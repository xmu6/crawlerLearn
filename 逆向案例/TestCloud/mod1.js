(self.webpackChunkvms = self.webpackChunkvms || []).push([[7872, 8708], {
    86500: function(t, e, i) {
        "use strict";
        i.d(e, {
            GC: function() {
                return d
            },
            T6: function() {
                return p
            },
            VD: function() {
                return m
            },
            WE: function() {
                return c
            },
            Wl: function() {
                return f
            },
            Yt: function() {
                return g
            },
            lC: function() {
                return o
            },
            py: function() {
                return l
            },
            rW: function() {
                return r
            },
            s: function() {
                return u
            },
            ve: function() {
                return a
            },
            vq: function() {
                return h
            }
        });
        var n = i(90279);
        function r(t, e, i) {
            return {
                r: 255 * (0,
                n.sh)(t, 255),
                g: 255 * (0,
                n.sh)(e, 255),
                b: 255 * (0,
                n.sh)(i, 255)
            }
        }
        function o(t, e, i) {
            t = (0,
            n.sh)(t, 255),
            e = (0,
            n.sh)(e, 255),
            i = (0,
            n.sh)(i, 255);
            var r = Math.max(t, e, i)
              , o = Math.min(t, e, i)
              , s = 0
              , a = 0
              , l = (r + o) / 2;
            if (r === o)
                a = 0,
                s = 0;
            else {
                var c = r - o;
                switch (a = l > .5 ? c / (2 - r - o) : c / (r + o),
                r) {
                case t:
                    s = (e - i) / c + (e < i ? 6 : 0);
                    break;
                case e:
                    s = (i - t) / c + 2;
                    break;
                case i:
                    s = (t - e) / c + 4
                }
                s /= 6
            }
            return {
                h: s,
                s: a,
                l: l
            }
        }
        function s(t, e, i) {
            return i < 0 && (i += 1),
            i > 1 && (i -= 1),
            i < 1 / 6 ? t + 6 * i * (e - t) : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
        }
        function a(t, e, i) {
            var r, o, a;
            if (t = (0,
            n.sh)(t, 360),
            e = (0,
            n.sh)(e, 100),
            i = (0,
            n.sh)(i, 100),
            0 === e)
                o = i,
                a = i,
                r = i;
            else {
                var l = i < .5 ? i * (1 + e) : i + e - i * e
                  , c = 2 * i - l;
                r = s(c, l, t + 1 / 3),
                o = s(c, l, t),
                a = s(c, l, t - 1 / 3)
            }
            return {
                r: 255 * r,
                g: 255 * o,
                b: 255 * a
            }
        }
        function l(t, e, i) {
            t = (0,
            n.sh)(t, 255),
            e = (0,
            n.sh)(e, 255),
            i = (0,
            n.sh)(i, 255);
            var r = Math.max(t, e, i)
              , o = Math.min(t, e, i)
              , s = 0
              , a = r
              , l = r - o
              , c = 0 === r ? 0 : l / r;
            if (r === o)
                s = 0;
            else {
                switch (r) {
                case t:
                    s = (e - i) / l + (e < i ? 6 : 0);
                    break;
                case e:
                    s = (i - t) / l + 2;
                    break;
                case i:
                    s = (t - e) / l + 4
                }
                s /= 6
            }
            return {
                h: s,
                s: c,
                v: a
            }
        }
        function c(t, e, i) {
            t = 6 * (0,
            n.sh)(t, 360),
            e = (0,
            n.sh)(e, 100),
            i = (0,
            n.sh)(i, 100);
            var r = Math.floor(t)
              , o = t - r
              , s = i * (1 - e)
              , a = i * (1 - o * e)
              , l = i * (1 - (1 - o) * e)
              , c = r % 6;
            return {
                r: 255 * [i, a, s, s, l, i][c],
                g: 255 * [l, i, i, a, s, s][c],
                b: 255 * [s, s, l, i, i, a][c]
            }
        }
        function h(t, e, i, r) {
            var o = [(0,
            n.FZ)(Math.round(t).toString(16)), (0,
            n.FZ)(Math.round(e).toString(16)), (0,
            n.FZ)(Math.round(i).toString(16))];
            return r && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) : o.join("")
        }
        function u(t, e, i, r, o) {
            var s = [(0,
            n.FZ)(Math.round(t).toString(16)), (0,
            n.FZ)(Math.round(e).toString(16)), (0,
            n.FZ)(Math.round(i).toString(16)), (0,
            n.FZ)(f(r))];
            return o && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) && s[3].startsWith(s[3].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("")
        }
        function d(t, e, i, r) {
            return [(0,
            n.FZ)(f(r)), (0,
            n.FZ)(Math.round(t).toString(16)), (0,
            n.FZ)(Math.round(e).toString(16)), (0,
            n.FZ)(Math.round(i).toString(16))].join("")
        }
        function f(t) {
            return Math.round(255 * parseFloat(t)).toString(16)
        }
        function p(t) {
            return m(t) / 255
        }
        function m(t) {
            return parseInt(t, 16)
        }
        function g(t) {
            return {
                r: t >> 16,
                g: (65280 & t) >> 8,
                b: 255 & t
            }
        }
    },
    48701: function(t, e, i) {
        "use strict";
        i.d(e, {
            R: function() {
                return n
            }
        });
        var n = {
            aliceblue: "#f0f8ff",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            aquamarine: "#7fffd4",
            azure: "#f0ffff",
            beige: "#f5f5dc",
            bisque: "#ffe4c4",
            black: "#000000",
            blanchedalmond: "#ffebcd",
            blue: "#0000ff",
            blueviolet: "#8a2be2",
            brown: "#a52a2a",
            burlywood: "#deb887",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            cornflowerblue: "#6495ed",
            cornsilk: "#fff8dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            darkkhaki: "#bdb76b",
            darkmagenta: "#8b008b",
            darkolivegreen: "#556b2f",
            darkorange: "#ff8c00",
            darkorchid: "#9932cc",
            darkred: "#8b0000",
            darksalmon: "#e9967a",
            darkseagreen: "#8fbc8f",
            darkslateblue: "#483d8b",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            darkturquoise: "#00ced1",
            darkviolet: "#9400d3",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1e90ff",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            forestgreen: "#228b22",
            fuchsia: "#ff00ff",
            gainsboro: "#dcdcdc",
            ghostwhite: "#f8f8ff",
            goldenrod: "#daa520",
            gold: "#ffd700",
            gray: "#808080",
            green: "#008000",
            greenyellow: "#adff2f",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            ivory: "#fffff0",
            khaki: "#f0e68c",
            lavenderblush: "#fff0f5",
            lavender: "#e6e6fa",
            lawngreen: "#7cfc00",
            lemonchiffon: "#fffacd",
            lightblue: "#add8e6",
            lightcoral: "#f08080",
            lightcyan: "#e0ffff",
            lightgoldenrodyellow: "#fafad2",
            lightgray: "#d3d3d3",
            lightgreen: "#90ee90",
            lightgrey: "#d3d3d3",
            lightpink: "#ffb6c1",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            lightskyblue: "#87cefa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#b0c4de",
            lightyellow: "#ffffe0",
            lime: "#00ff00",
            limegreen: "#32cd32",
            linen: "#faf0e6",
            magenta: "#ff00ff",
            maroon: "#800000",
            mediumaquamarine: "#66cdaa",
            mediumblue: "#0000cd",
            mediumorchid: "#ba55d3",
            mediumpurple: "#9370db",
            mediumseagreen: "#3cb371",
            mediumslateblue: "#7b68ee",
            mediumspringgreen: "#00fa9a",
            mediumturquoise: "#48d1cc",
            mediumvioletred: "#c71585",
            midnightblue: "#191970",
            mintcream: "#f5fffa",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            navajowhite: "#ffdead",
            navy: "#000080",
            oldlace: "#fdf5e6",
            olive: "#808000",
            olivedrab: "#6b8e23",
            orange: "#ffa500",
            orangered: "#ff4500",
            orchid: "#da70d6",
            palegoldenrod: "#eee8aa",
            palegreen: "#98fb98",
            paleturquoise: "#afeeee",
            palevioletred: "#db7093",
            papayawhip: "#ffefd5",
            peachpuff: "#ffdab9",
            peru: "#cd853f",
            pink: "#ffc0cb",
            plum: "#dda0dd",
            powderblue: "#b0e0e6",
            purple: "#800080",
            rebeccapurple: "#663399",
            red: "#ff0000",
            rosybrown: "#bc8f8f",
            royalblue: "#4169e1",
            saddlebrown: "#8b4513",
            salmon: "#fa8072",
            sandybrown: "#f4a460",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            sienna: "#a0522d",
            silver: "#c0c0c0",
            skyblue: "#87ceeb",
            slateblue: "#6a5acd",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#fffafa",
            springgreen: "#00ff7f",
            steelblue: "#4682b4",
            tan: "#d2b48c",
            teal: "#008080",
            thistle: "#d8bfd8",
            tomato: "#ff6347",
            turquoise: "#40e0d0",
            violet: "#ee82ee",
            wheat: "#f5deb3",
            white: "#ffffff",
            whitesmoke: "#f5f5f5",
            yellow: "#ffff00",
            yellowgreen: "#9acd32"
        }
    },
    1350: function(t, e, i) {
        "use strict";
        i.d(e, {
            ky: function() {
                return d
            },
            uA: function() {
                return s
            },
            uz: function() {
                return u
            }
        });
        var n = i(86500)
          , r = i(48701)
          , o = i(90279);
        function s(t) {
            var e = {
                r: 0,
                g: 0,
                b: 0
            }
              , i = 1
              , r = null
              , s = null
              , a = null
              , l = !1
              , c = !1;
            return "string" == typeof t && (t = u(t)),
            "object" == typeof t && (d(t.r) && d(t.g) && d(t.b) ? (e = (0,
            n.rW)(t.r, t.g, t.b),
            l = !0,
            c = "%" === String(t.r).substr(-1) ? "prgb" : "rgb") : d(t.h) && d(t.s) && d(t.v) ? (r = (0,
            o.JX)(t.s),
            s = (0,
            o.JX)(t.v),
            e = (0,
            n.WE)(t.h, r, s),
            l = !0,
            c = "hsv") : d(t.h) && d(t.s) && d(t.l) && (r = (0,
            o.JX)(t.s),
            a = (0,
            o.JX)(t.l),
            e = (0,
            n.ve)(t.h, r, a),
            l = !0,
            c = "hsl"),
            Object.prototype.hasOwnProperty.call(t, "a") && (i = t.a)),
            i = (0,
            o.Yq)(i),
            {
                ok: l,
                format: t.format || c,
                r: Math.min(255, Math.max(e.r, 0)),
                g: Math.min(255, Math.max(e.g, 0)),
                b: Math.min(255, Math.max(e.b, 0)),
                a: i
            }
        }
        var a = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")")
          , l = "[\\s|\\(]+(".concat(a, ")[,|\\s]+(").concat(a, ")[,|\\s]+(").concat(a, ")\\s*\\)?")
          , c = "[\\s|\\(]+(".concat(a, ")[,|\\s]+(").concat(a, ")[,|\\s]+(").concat(a, ")[,|\\s]+(").concat(a, ")\\s*\\)?")
          , h = {
            CSS_UNIT: new RegExp(a),
            rgb: new RegExp("rgb" + l),
            rgba: new RegExp("rgba" + c),
            hsl: new RegExp("hsl" + l),
            hsla: new RegExp("hsla" + c),
            hsv: new RegExp("hsv" + l),
            hsva: new RegExp("hsva" + c),
            hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
        function u(t) {
            if (0 === (t = t.trim().toLowerCase()).length)
                return !1;
            var e = !1;
            if (r.R[t])
                t = r.R[t],
                e = !0;
            else if ("transparent" === t)
                return {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    format: "name"
                };
            var i = h.rgb.exec(t);
            return i ? {
                r: i[1],
                g: i[2],
                b: i[3]
            } : (i = h.rgba.exec(t)) ? {
                r: i[1],
                g: i[2],
                b: i[3],
                a: i[4]
            } : (i = h.hsl.exec(t)) ? {
                h: i[1],
                s: i[2],
                l: i[3]
            } : (i = h.hsla.exec(t)) ? {
                h: i[1],
                s: i[2],
                l: i[3],
                a: i[4]
            } : (i = h.hsv.exec(t)) ? {
                h: i[1],
                s: i[2],
                v: i[3]
            } : (i = h.hsva.exec(t)) ? {
                h: i[1],
                s: i[2],
                v: i[3],
                a: i[4]
            } : (i = h.hex8.exec(t)) ? {
                r: (0,
                n.VD)(i[1]),
                g: (0,
                n.VD)(i[2]),
                b: (0,
                n.VD)(i[3]),
                a: (0,
                n.T6)(i[4]),
                format: e ? "name" : "hex8"
            } : (i = h.hex6.exec(t)) ? {
                r: (0,
                n.VD)(i[1]),
                g: (0,
                n.VD)(i[2]),
                b: (0,
                n.VD)(i[3]),
                format: e ? "name" : "hex"
            } : (i = h.hex4.exec(t)) ? {
                r: (0,
                n.VD)(i[1] + i[1]),
                g: (0,
                n.VD)(i[2] + i[2]),
                b: (0,
                n.VD)(i[3] + i[3]),
                a: (0,
                n.T6)(i[4] + i[4]),
                format: e ? "name" : "hex8"
            } : !!(i = h.hex3.exec(t)) && {
                r: (0,
                n.VD)(i[1] + i[1]),
                g: (0,
                n.VD)(i[2] + i[2]),
                b: (0,
                n.VD)(i[3] + i[3]),
                format: e ? "name" : "hex"
            }
        }
        function d(t) {
            return Boolean(h.CSS_UNIT.exec(String(t)))
        }
    },
    10274: function(t, e, i) {
        "use strict";
        i.d(e, {
            C: function() {
                return a
            },
            H: function() {
                return l
            }
        });
        var n = i(86500)
          , r = i(48701)
          , o = i(1350)
          , s = i(90279)
          , a = function() {
            function t(e, i) {
                var r;
                if (void 0 === e && (e = ""),
                void 0 === i && (i = {}),
                e instanceof t)
                    return e;
                "number" == typeof e && (e = (0,
                n.Yt)(e)),
                this.originalInput = e;
                var s = (0,
                o.uA)(e);
                this.originalInput = e,
                this.r = s.r,
                this.g = s.g,
                this.b = s.b,
                this.a = s.a,
                this.roundA = Math.round(100 * this.a) / 100,
                this.format = null !== (r = i.format) && void 0 !== r ? r : s.format,
                this.gradientType = i.gradientType,
                this.r < 1 && (this.r = Math.round(this.r)),
                this.g < 1 && (this.g = Math.round(this.g)),
                this.b < 1 && (this.b = Math.round(this.b)),
                this.isValid = s.ok
            }
            return t.prototype.isDark = function() {
                return this.getBrightness() < 128
            }
            ,
            t.prototype.isLight = function() {
                return !this.isDark()
            }
            ,
            t.prototype.getBrightness = function() {
                var t = this.toRgb();
                return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3
            }
            ,
            t.prototype.getLuminance = function() {
                var t = this.toRgb()
                  , e = t.r / 255
                  , i = t.g / 255
                  , n = t.b / 255;
                return .2126 * (e <= .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)) + .7152 * (i <= .03928 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4)) + .0722 * (n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4))
            }
            ,
            t.prototype.getAlpha = function() {
                return this.a
            }
            ,
            t.prototype.setAlpha = function(t) {
                return this.a = (0,
                s.Yq)(t),
                this.roundA = Math.round(100 * this.a) / 100,
                this
            }
            ,
            t.prototype.isMonochrome = function() {
                return 0 === this.toHsl().s
            }
            ,
            t.prototype.toHsv = function() {
                var t = (0,
                n.py)(this.r, this.g, this.b);
                return {
                    h: 360 * t.h,
                    s: t.s,
                    v: t.v,
                    a: this.a
                }
            }
            ,
            t.prototype.toHsvString = function() {
                var t = (0,
                n.py)(this.r, this.g, this.b)
                  , e = Math.round(360 * t.h)
                  , i = Math.round(100 * t.s)
                  , r = Math.round(100 * t.v);
                return 1 === this.a ? "hsv(".concat(e, ", ").concat(i, "%, ").concat(r, "%)") : "hsva(".concat(e, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
            }
            ,
            t.prototype.toHsl = function() {
                var t = (0,
                n.lC)(this.r, this.g, this.b);
                return {
                    h: 360 * t.h,
                    s: t.s,
                    l: t.l,
                    a: this.a
                }
            }
            ,
            t.prototype.toHslString = function() {
                var t = (0,
                n.lC)(this.r, this.g, this.b)
                  , e = Math.round(360 * t.h)
                  , i = Math.round(100 * t.s)
                  , r = Math.round(100 * t.l);
                return 1 === this.a ? "hsl(".concat(e, ", ").concat(i, "%, ").concat(r, "%)") : "hsla(".concat(e, ", ").concat(i, "%, ").concat(r, "%, ").concat(this.roundA, ")")
            }
            ,
            t.prototype.toHex = function(t) {
                return void 0 === t && (t = !1),
                (0,
                n.vq)(this.r, this.g, this.b, t)
            }
            ,
            t.prototype.toHexString = function(t) {
                return void 0 === t && (t = !1),
                "#" + this.toHex(t)
            }
            ,
            t.prototype.toHex8 = function(t) {
                return void 0 === t && (t = !1),
                (0,
                n.s)(this.r, this.g, this.b, this.a, t)
            }
            ,
            t.prototype.toHex8String = function(t) {
                return void 0 === t && (t = !1),
                "#" + this.toHex8(t)
            }
            ,
            t.prototype.toHexShortString = function(t) {
                return void 0 === t && (t = !1),
                1 === this.a ? this.toHexString(t) : this.toHex8String(t)
            }
            ,
            t.prototype.toRgb = function() {
                return {
                    r: Math.round(this.r),
                    g: Math.round(this.g),
                    b: Math.round(this.b),
                    a: this.a
                }
            }
            ,
            t.prototype.toRgbString = function() {
                var t = Math.round(this.r)
                  , e = Math.round(this.g)
                  , i = Math.round(this.b);
                return 1 === this.a ? "rgb(".concat(t, ", ").concat(e, ", ").concat(i, ")") : "rgba(".concat(t, ", ").concat(e, ", ").concat(i, ", ").concat(this.roundA, ")")
            }
            ,
            t.prototype.toPercentageRgb = function() {
                var t = function(t) {
                    return "".concat(Math.round(100 * (0,
                    s.sh)(t, 255)), "%")
                };
                return {
                    r: t(this.r),
                    g: t(this.g),
                    b: t(this.b),
                    a: this.a
                }
            }
            ,
            t.prototype.toPercentageRgbString = function() {
                var t = function(t) {
                    return Math.round(100 * (0,
                    s.sh)(t, 255))
                };
                return 1 === this.a ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")")
            }
            ,
            t.prototype.toName = function() {
                if (0 === this.a)
                    return "transparent";
                if (this.a < 1)
                    return !1;
                for (var t = "#" + (0,
                n.vq)(this.r, this.g, this.b, !1), e = 0, i = Object.entries(r.R); e < i.length; e++) {
                    var o = i[e]
                      , s = o[0];
                    if (t === o[1])
                        return s
                }
                return !1
            }
            ,
            t.prototype.toString = function(t) {
                var e = Boolean(t);
                t = null != t ? t : this.format;
                var i = !1
                  , n = this.a < 1 && this.a >= 0;
                return e || !n || !t.startsWith("hex") && "name" !== t ? ("rgb" === t && (i = this.toRgbString()),
                "prgb" === t && (i = this.toPercentageRgbString()),
                "hex" !== t && "hex6" !== t || (i = this.toHexString()),
                "hex3" === t && (i = this.toHexString(!0)),
                "hex4" === t && (i = this.toHex8String(!0)),
                "hex8" === t && (i = this.toHex8String()),
                "name" === t && (i = this.toName()),
                "hsl" === t && (i = this.toHslString()),
                "hsv" === t && (i = this.toHsvString()),
                i || this.toHexString()) : "name" === t && 0 === this.a ? this.toName() : this.toRgbString()
            }
            ,
            t.prototype.toNumber = function() {
                return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
            }
            ,
            t.prototype.clone = function() {
                return new t(this.toString())
            }
            ,
            t.prototype.lighten = function(e) {
                void 0 === e && (e = 10);
                var i = this.toHsl();
                return i.l += e / 100,
                i.l = (0,
                s.V2)(i.l),
                new t(i)
            }
            ,
            t.prototype.brighten = function(e) {
                void 0 === e && (e = 10);
                var i = this.toRgb();
                return i.r = Math.max(0, Math.min(255, i.r - Math.round(-e / 100 * 255))),
                i.g = Math.max(0, Math.min(255, i.g - Math.round(-e / 100 * 255))),
                i.b = Math.max(0, Math.min(255, i.b - Math.round(-e / 100 * 255))),
                new t(i)
            }
            ,
            t.prototype.darken = function(e) {
                void 0 === e && (e = 10);
                var i = this.toHsl();
                return i.l -= e / 100,
                i.l = (0,
                s.V2)(i.l),
                new t(i)
            }
            ,
            t.prototype.tint = function(t) {
                return void 0 === t && (t = 10),
                this.mix("white", t)
            }
            ,
            t.prototype.shade = function(t) {
                return void 0 === t && (t = 10),
                this.mix("black", t)
            }
            ,
            t.prototype.desaturate = function(e) {
                void 0 === e && (e = 10);
                var i = this.toHsl();
                return i.s -= e / 100,
                i.s = (0,
                s.V2)(i.s),
                new t(i)
            }
            ,
            t.prototype.saturate = function(e) {
                void 0 === e && (e = 10);
                var i = this.toHsl();
                return i.s += e / 100,
                i.s = (0,
                s.V2)(i.s),
                new t(i)
            }
            ,
            t.prototype.greyscale = function() {
                return this.desaturate(100)
            }
            ,
            t.prototype.spin = function(e) {
                var i = this.toHsl()
                  , n = (i.h + e) % 360;
                return i.h = n < 0 ? 360 + n : n,
                new t(i)
            }
            ,
            t.prototype.mix = function(e, i) {
                void 0 === i && (i = 50);
                var n = this.toRgb()
                  , r = new t(e).toRgb()
                  , o = i / 100;
                return new t({
                    r: (r.r - n.r) * o + n.r,
                    g: (r.g - n.g) * o + n.g,
                    b: (r.b - n.b) * o + n.b,
                    a: (r.a - n.a) * o + n.a
                })
            }
            ,
            t.prototype.analogous = function(e, i) {
                void 0 === e && (e = 6),
                void 0 === i && (i = 30);
                var n = this.toHsl()
                  , r = 360 / i
                  , o = [this];
                for (n.h = (n.h - (r * e >> 1) + 720) % 360; --e; )
                    n.h = (n.h + r) % 360,
                    o.push(new t(n));
                return o
            }
            ,
            t.prototype.complement = function() {
                var e = this.toHsl();
                return e.h = (e.h + 180) % 360,
                new t(e)
            }
            ,
            t.prototype.monochromatic = function(e) {
                void 0 === e && (e = 6);
                for (var i = this.toHsv(), n = i.h, r = i.s, o = i.v, s = [], a = 1 / e; e--; )
                    s.push(new t({
                        h: n,
                        s: r,
                        v: o
                    })),
                    o = (o + a) % 1;
                return s
            }
            ,
            t.prototype.splitcomplement = function() {
                var e = this.toHsl()
                  , i = e.h;
                return [this, new t({
                    h: (i + 72) % 360,
                    s: e.s,
                    l: e.l
                }), new t({
                    h: (i + 216) % 360,
                    s: e.s,
                    l: e.l
                })]
            }
            ,
            t.prototype.onBackground = function(e) {
                var i = this.toRgb()
                  , n = new t(e).toRgb()
                  , r = i.a + n.a * (1 - i.a);
                return new t({
                    r: (i.r * i.a + n.r * n.a * (1 - i.a)) / r,
                    g: (i.g * i.a + n.g * n.a * (1 - i.a)) / r,
                    b: (i.b * i.a + n.b * n.a * (1 - i.a)) / r,
                    a: r
                })
            }
            ,
            t.prototype.triad = function() {
                return this.polyad(3)
            }
            ,
            t.prototype.tetrad = function() {
                return this.polyad(4)
            }
            ,
            t.prototype.polyad = function(e) {
                for (var i = this.toHsl(), n = i.h, r = [this], o = 360 / e, s = 1; s < e; s++)
                    r.push(new t({
                        h: (n + s * o) % 360,
                        s: i.s,
                        l: i.l
                    }));
                return r
            }
            ,
            t.prototype.equals = function(e) {
                return this.toRgbString() === new t(e).toRgbString()
            }
            ,
            t
        }();
        function l(t, e) {
            return void 0 === t && (t = ""),
            void 0 === e && (e = {}),
            new a(t,e)
        }
    },
    90279: function(t, e, i) {
        "use strict";
        function n(t, e) {
            (function(t) {
                return "string" == typeof t && -1 !== t.indexOf(".") && 1 === parseFloat(t)
            }
            )(t) && (t = "100%");
            var i = function(t) {
                return "string" == typeof t && -1 !== t.indexOf("%")
            }(t);
            return t = 360 === e ? t : Math.min(e, Math.max(0, parseFloat(t))),
            i && (t = parseInt(String(t * e), 10) / 100),
            Math.abs(t - e) < 1e-6 ? 1 : t = 360 === e ? (t < 0 ? t % e + e : t % e) / parseFloat(String(e)) : t % e / parseFloat(String(e))
        }
        function r(t) {
            return Math.min(1, Math.max(0, t))
        }
        function o(t) {
            return t = parseFloat(t),
            (isNaN(t) || t < 0 || t > 1) && (t = 1),
            t
        }
        function s(t) {
            return t <= 1 ? "".concat(100 * Number(t), "%") : t
        }
        function a(t) {
            return 1 === t.length ? "0" + t : String(t)
        }
        i.d(e, {
            FZ: function() {
                return a
            },
            JX: function() {
                return s
            },
            V2: function() {
                return r
            },
            Yq: function() {
                return o
            },
            sh: function() {
                return n
            }
        })
    },
    17600: function(t, e, i) {
        "use strict";
        i.r(e),
        i.d(e, {
            DEFAULT_MESSAGE_DATA_TYPE: function() {
                return _
            },
            MISSING_RESOLVE_VALUE: function() {
                return it
            },
            NOT_REOSLVED: function() {
                return et
            },
            VERSION: function() {
                return tt
            },
            clearCompileCache: function() {
                return xt
            },
            clearDateTimeFormat: function() {
                return kt
            },
            clearNumberFormat: function() {
                return Dt
            },
            compileToFunction: function() {
                return bt
            },
            createCompileError: function() {
                return w
            },
            createCoreContext: function() {
                return ct
            },
            createCoreError: function() {
                return wt
            },
            createMessageContext: function() {
                return b
            },
            datetime: function() {
                return Mt
            },
            getAdditionalMeta: function() {
                return at
            },
            getDevToolsHook: function() {
                return $
            },
            getLocaleChain: function() {
                return ft
            },
            getWarnMessage: function() {
                return Q
            },
            handleFlatJson: function() {
                return p
            },
            handleMissing: function() {
                return dt
            },
            initI18nDevTools: function() {
                return X
            },
            isMessageFunction: function() {
                return Tt
            },
            isTranslateFallbackWarn: function() {
                return ht
            },
            isTranslateMissingWarn: function() {
                return ut
            },
            number: function() {
                return Ot
            },
            parse: function() {
                return u
            },
            parseDateTimeArgs: function() {
                return Pt
            },
            parseNumberArgs: function() {
                return Rt
            },
            parseTranslateArgs: function() {
                return At
            },
            registerMessageCompiler: function() {
                return rt
            },
            resolveValue: function() {
                return f
            },
            setAdditionalMeta: function() {
                return st
            },
            setDevToolsHook: function() {
                return H
            },
            translate: function() {
                return St
            },
            translateDevTools: function() {
                return Y
            },
            updateFallbackLocale: function() {
                return _t
            }
        });
        var n = i(87175);
        const r = Object.prototype.hasOwnProperty;
        function o(t, e) {
            return r.call(t, e)
        }
        const s = t => null !== t && "object" == typeof t
          , a = [];
        a[0] = {
            w: [0],
            i: [3, 0],
            "[": [4],
            o: [7]
        },
        a[1] = {
            w: [1],
            ".": [2],
            "[": [4],
            o: [7]
        },
        a[2] = {
            w: [2],
            i: [3, 0],
            0: [3, 0]
        },
        a[3] = {
            i: [3, 0],
            0: [3, 0],
            w: [1, 1],
            ".": [2, 1],
            "[": [4, 1],
            o: [7, 1]
        },
        a[4] = {
            "'": [5, 0],
            '"': [6, 0],
            "[": [4, 2],
            "]": [1, 3],
            o: 8,
            l: [4, 0]
        },
        a[5] = {
            "'": [4, 0],
            o: 8,
            l: [5, 0]
        },
        a[6] = {
            '"': [4, 0],
            o: 8,
            l: [6, 0]
        };
        const l = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
        function c(t) {
            if (null == t)
                return "o";
            switch (t.charCodeAt(0)) {
            case 91:
            case 93:
            case 46:
            case 34:
            case 39:
                return t;
            case 95:
            case 36:
            case 45:
                return "i";
            case 9:
            case 10:
            case 13:
            case 160:
            case 65279:
            case 8232:
            case 8233:
                return "w"
            }
            return "i"
        }
        function h(t) {
            const e = t.trim();
            return ("0" !== t.charAt(0) || !isNaN(parseInt(t))) && (i = e,
            l.test(i) ? function(t) {
                const e = t.charCodeAt(0);
                return e !== t.charCodeAt(t.length - 1) || 34 !== e && 39 !== e ? t : t.slice(1, -1)
            }(e) : "*" + e);
            var i
        }
        function u(t) {
            const e = [];
            let i, n, r, o, s, l, u, d = -1, f = 0, p = 0;
            const m = [];
            function g() {
                const e = t[d + 1];
                if (5 === f && "'" === e || 6 === f && '"' === e)
                    return d++,
                    r = "\\" + e,
                    m[0](),
                    !0
            }
            for (m[0] = () => {
                void 0 === n ? n = r : n += r
            }
            ,
            m[1] = () => {
                void 0 !== n && (e.push(n),
                n = void 0)
            }
            ,
            m[2] = () => {
                m[0](),
                p++
            }
            ,
            m[3] = () => {
                if (p > 0)
                    p--,
                    f = 4,
                    m[0]();
                else {
                    if (p = 0,
                    void 0 === n)
                        return !1;
                    if (n = h(n),
                    !1 === n)
                        return !1;
                    m[1]()
                }
            }
            ; null !== f; )
                if (d++,
                i = t[d],
                "\\" !== i || !g()) {
                    if (o = c(i),
                    u = a[f],
                    s = u[o] || u.l || 8,
                    8 === s)
                        return;
                    if (f = s[0],
                    void 0 !== s[1] && (l = m[s[1]],
                    l && (r = i,
                    !1 === l())))
                        return;
                    if (7 === f)
                        return e
                }
        }
        const d = new Map;
        function f(t, e) {
            if (!s(t))
                return null;
            let i = d.get(e);
            if (i || (i = u(e),
            i && d.set(e, i)),
            !i)
                return null;
            const n = i.length;
            let r = t
              , o = 0;
            for (; o < n; ) {
                const t = r[i[o]];
                if (void 0 === t)
                    return null;
                r = t,
                o++
            }
            return r
        }
        function p(t) {
            if (!s(t))
                return t;
            for (const e in t)
                if (o(t, e))
                    if (e.includes(".")) {
                        const i = e.split(".")
                          , n = i.length - 1;
                        let r = t;
                        for (let t = 0; t < n; t++)
                            i[t]in r || (r[i[t]] = {}),
                            r = r[i[t]];
                        r[i[n]] = t[e],
                        delete t[e],
                        s(r[i[n]]) && p(r[i[n]])
                    } else
                        s(t[e]) && p(t[e]);
            return t
        }
        const m = t => t
          , g = t => ""
          , _ = "text"
          , y = t => 0 === t.length ? "" : t.join("")
          , v = n.toDisplayString;
        function x(t, e) {
            return t = Math.abs(t),
            2 === e ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
        }
        function b(t={}) {
            const e = t.locale
              , i = function(t) {
                const e = (0,
                n.isNumber)(t.pluralIndex) ? t.pluralIndex : -1;
                return t.named && ((0,
                n.isNumber)(t.named.count) || (0,
                n.isNumber)(t.named.n)) ? (0,
                n.isNumber)(t.named.count) ? t.named.count : (0,
                n.isNumber)(t.named.n) ? t.named.n : e : e
            }(t)
              , r = (0,
            n.isObject)(t.pluralRules) && (0,
            n.isString)(e) && (0,
            n.isFunction)(t.pluralRules[e]) ? t.pluralRules[e] : x
              , o = (0,
            n.isObject)(t.pluralRules) && (0,
            n.isString)(e) && (0,
            n.isFunction)(t.pluralRules[e]) ? x : void 0
              , s = t.list || []
              , a = t.named || {};
            (0,
            n.isNumber)(t.pluralIndex) && function(t, e) {
                e.count || (e.count = t),
                e.n || (e.n = t)
            }(i, a);
            function l(e) {
                const i = (0,
                n.isFunction)(t.messages) ? t.messages(e) : !!(0,
                n.isObject)(t.messages) && t.messages[e];
                return i || (t.parent ? t.parent.message(e) : g)
            }
            const c = (0,
            n.isPlainObject)(t.processor) && (0,
            n.isFunction)(t.processor.normalize) ? t.processor.normalize : y
              , h = (0,
            n.isPlainObject)(t.processor) && (0,
            n.isFunction)(t.processor.interpolate) ? t.processor.interpolate : v
              , u = {
                list: t => s[t],
                named: t => a[t],
                plural: t => t[r(i, t.length, o)],
                linked: (e, i) => {
                    const r = l(e)(u);
                    return (0,
                    n.isString)(i) ? (o = i,
                    t.modifiers ? t.modifiers[o] : m)(r) : r;
                    var o
                }
                ,
                message: l,
                type: (0,
                n.isPlainObject)(t.processor) && (0,
                n.isString)(t.processor.type) ? t.processor.type : _,
                interpolate: h,
                normalize: c
            };
            return u
        }
        function w(t, e, i={}) {
            const {domain: n, messages: r, args: o} = i
              , s = new SyntaxError(String(t));
            return s.code = t,
            e && (s.location = e),
            s.domain = n,
            s
        }
        function E(t) {
            throw t
        }
        function T(t, e, i) {
            const n = {
                start: t,
                end: e
            };
            return null != i && (n.source = i),
            n
        }
        const S = " "
          , C = "\r"
          , A = "\n"
          , I = String.fromCharCode(8232)
          , M = String.fromCharCode(8233);
        function P(t) {
            const e = t;
            let i = 0
              , n = 1
              , r = 1
              , o = 0;
            const s = t => e[t] === C && e[t + 1] === A
              , a = t => e[t] === M
              , l = t => e[t] === I
              , c = t => s(t) || (t => e[t] === A)(t) || a(t) || l(t)
              , h = t => s(t) || a(t) || l(t) ? A : e[t];
            function u() {
                return o = 0,
                c(i) && (n++,
                r = 0),
                s(i) && i++,
                i++,
                r++,
                e[i]
            }
            return {
                index: () => i,
                line: () => n,
                column: () => r,
                peekOffset: () => o,
                charAt: h,
                currentChar: () => h(i),
                currentPeek: () => h(i + o),
                next: u,
                peek: function() {
                    return s(i + o) && o++,
                    o++,
                    e[i + o]
                },
                reset: function() {
                    i = 0,
                    n = 1,
                    r = 1,
                    o = 0
                },
                resetPeek: function(t=0) {
                    o = t
                },
                skipToPeek: function() {
                    const t = i + o;
                    for (; t !== i; )
                        u();
                    o = 0
                }
            }
        }
        const k = void 0
          , O = "'"
          , R = "tokenizer";
        function D(t, e={}) {
            const i = !1 !== e.location
              , n = P(t)
              , r = () => n.index()
              , o = () => {
                return t = n.line(),
                e = n.column(),
                i = n.index(),
                {
                    line: t,
                    column: e,
                    offset: i
                };
                var t, e, i
            }
              , s = o()
              , a = r()
              , l = {
                currentType: 14,
                offset: a,
                startLoc: s,
                endLoc: s,
                lastType: 14,
                lastOffset: a,
                lastStartLoc: s,
                lastEndLoc: s,
                braceNest: 0,
                inLinked: !1,
                text: ""
            }
              , c = () => l
              , {onError: h} = e;
            function u(t, e, i, ...n) {
                const r = c();
                if (e.column += i,
                e.offset += i,
                h) {
                    const i = w(t, T(r.startLoc, e), {
                        domain: R,
                        args: n
                    });
                    h(i)
                }
            }
            function d(t, e, n) {
                t.endLoc = o(),
                t.currentType = e;
                const r = {
                    type: e
                };
                return i && (r.loc = T(t.startLoc, t.endLoc)),
                null != n && (r.value = n),
                r
            }
            const f = t => d(t, 14);
            function p(t, e) {
                return t.currentChar() === e ? (t.next(),
                e) : (u(0, o(), 0, e),
                "")
            }
            function m(t) {
                let e = "";
                for (; t.currentPeek() === S || t.currentPeek() === A; )
                    e += t.currentPeek(),
                    t.peek();
                return e
            }
            function g(t) {
                const e = m(t);
                return t.skipToPeek(),
                e
            }
            function _(t) {
                if (t === k)
                    return !1;
                const e = t.charCodeAt(0);
                return e >= 97 && e <= 122 || e >= 65 && e <= 90 || 95 === e
            }
            function y(t, e) {
                const {currentType: i} = e;
                if (2 !== i)
                    return !1;
                m(t);
                const n = function(t) {
                    if (t === k)
                        return !1;
                    const e = t.charCodeAt(0);
                    return e >= 48 && e <= 57
                }("-" === t.currentPeek() ? t.peek() : t.currentPeek());
                return t.resetPeek(),
                n
            }
            function v(t) {
                m(t);
                const e = "|" === t.currentPeek();
                return t.resetPeek(),
                e
            }
            function x(t, e=!0) {
                const i = (e=!1, n="", r=!1) => {
                    const o = t.currentPeek();
                    return "{" === o ? "%" !== n && e : "@" !== o && o ? "%" === o ? (t.peek(),
                    i(e, "%", !0)) : "|" === o ? !("%" !== n && !r) || !(n === S || n === A) : o === S ? (t.peek(),
                    i(!0, S, r)) : o !== A || (t.peek(),
                    i(!0, A, r)) : "%" === n || e
                }
                  , n = i();
                return e && t.resetPeek(),
                n
            }
            function b(t, e) {
                const i = t.currentChar();
                return i === k ? k : e(i) ? (t.next(),
                i) : null
            }
            function E(t) {
                return b(t, (t => {
                    const e = t.charCodeAt(0);
                    return e >= 97 && e <= 122 || e >= 65 && e <= 90 || e >= 48 && e <= 57 || 95 === e || 36 === e
                }
                ))
            }
            function C(t) {
                return b(t, (t => {
                    const e = t.charCodeAt(0);
                    return e >= 48 && e <= 57
                }
                ))
            }
            function I(t) {
                return b(t, (t => {
                    const e = t.charCodeAt(0);
                    return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102
                }
                ))
            }
            function M(t) {
                let e = ""
                  , i = "";
                for (; e = C(t); )
                    i += e;
                return i
            }
            function D(t) {
                const e = t.currentChar();
                switch (e) {
                case "\\":
                case "'":
                    return t.next(),
                    `\\${e}`;
                case "u":
                    return L(t, e, 4);
                case "U":
                    return L(t, e, 6);
                default:
                    return u(3, o(), 0, e),
                    ""
                }
            }
            function L(t, e, i) {
                p(t, e);
                let n = "";
                for (let r = 0; r < i; r++) {
                    const i = I(t);
                    if (!i) {
                        u(4, o(), 0, `\\${e}${n}${t.currentChar()}`);
                        break
                    }
                    n += i
                }
                return `\\${e}${n}`
            }
            function B(t) {
                g(t);
                const e = p(t, "|");
                return g(t),
                e
            }
            function z(t, e) {
                let i = null;
                switch (t.currentChar()) {
                case "{":
                    return e.braceNest >= 1 && u(8, o(), 0),
                    t.next(),
                    i = d(e, 2, "{"),
                    g(t),
                    e.braceNest++,
                    i;
                case "}":
                    return e.braceNest > 0 && 2 === e.currentType && u(7, o(), 0),
                    t.next(),
                    i = d(e, 3, "}"),
                    e.braceNest--,
                    e.braceNest > 0 && g(t),
                    e.inLinked && 0 === e.braceNest && (e.inLinked = !1),
                    i;
                case "@":
                    return e.braceNest > 0 && u(6, o(), 0),
                    i = F(t, e) || f(e),
                    e.braceNest = 0,
                    i;
                default:
                    let n = !0
                      , r = !0
                      , s = !0;
                    if (v(t))
                        return e.braceNest > 0 && u(6, o(), 0),
                        i = d(e, 1, B(t)),
                        e.braceNest = 0,
                        e.inLinked = !1,
                        i;
                    if (e.braceNest > 0 && (5 === e.currentType || 6 === e.currentType || 7 === e.currentType))
                        return u(6, o(), 0),
                        e.braceNest = 0,
                        N(t, e);
                    if (n = function(t, e) {
                        const {currentType: i} = e;
                        if (2 !== i)
                            return !1;
                        m(t);
                        const n = _(t.currentPeek());
                        return t.resetPeek(),
                        n
                    }(t, e))
                        return i = d(e, 5, function(t) {
                            g(t);
                            let e = ""
                              , i = "";
                            for (; e = E(t); )
                                i += e;
                            return t.currentChar() === k && u(6, o(), 0),
                            i
                        }(t)),
                        g(t),
                        i;
                    if (r = y(t, e))
                        return i = d(e, 6, function(t) {
                            g(t);
                            let e = "";
                            return "-" === t.currentChar() ? (t.next(),
                            e += `-${M(t)}`) : e += M(t),
                            t.currentChar() === k && u(6, o(), 0),
                            e
                        }(t)),
                        g(t),
                        i;
                    if (s = function(t, e) {
                        const {currentType: i} = e;
                        if (2 !== i)
                            return !1;
                        m(t);
                        const n = t.currentPeek() === O;
                        return t.resetPeek(),
                        n
                    }(t, e))
                        return i = d(e, 7, function(t) {
                            g(t),
                            p(t, "'");
                            let e = ""
                              , i = "";
                            const n = t => t !== O && t !== A;
                            for (; e = b(t, n); )
                                i += "\\" === e ? D(t) : e;
                            const r = t.currentChar();
                            return r === A || r === k ? (u(2, o(), 0),
                            r === A && (t.next(),
                            p(t, "'")),
                            i) : (p(t, "'"),
                            i)
                        }(t)),
                        g(t),
                        i;
                    if (!n && !r && !s)
                        return i = d(e, 13, function(t) {
                            g(t);
                            let e = ""
                              , i = "";
                            const n = t => "{" !== t && "}" !== t && t !== S && t !== A;
                            for (; e = b(t, n); )
                                i += e;
                            return i
                        }(t)),
                        u(1, o(), 0, i.value),
                        g(t),
                        i
                }
                return i
            }
            function F(t, e) {
                const {currentType: i} = e;
                let n = null;
                const r = t.currentChar();
                switch (8 !== i && 9 !== i && 12 !== i && 10 !== i || r !== A && r !== S || u(9, o(), 0),
                r) {
                case "@":
                    return t.next(),
                    n = d(e, 8, "@"),
                    e.inLinked = !0,
                    n;
                case ".":
                    return g(t),
                    t.next(),
                    d(e, 9, ".");
                case ":":
                    return g(t),
                    t.next(),
                    d(e, 10, ":");
                default:
                    return v(t) ? (n = d(e, 1, B(t)),
                    e.braceNest = 0,
                    e.inLinked = !1,
                    n) : function(t, e) {
                        const {currentType: i} = e;
                        if (8 !== i)
                            return !1;
                        m(t);
                        const n = "." === t.currentPeek();
                        return t.resetPeek(),
                        n
                    }(t, e) || function(t, e) {
                        const {currentType: i} = e;
                        if (8 !== i && 12 !== i)
                            return !1;
                        m(t);
                        const n = ":" === t.currentPeek();
                        return t.resetPeek(),
                        n
                    }(t, e) ? (g(t),
                    F(t, e)) : function(t, e) {
                        const {currentType: i} = e;
                        if (9 !== i)
                            return !1;
                        m(t);
                        const n = _(t.currentPeek());
                        return t.resetPeek(),
                        n
                    }(t, e) ? (g(t),
                    d(e, 12, function(t) {
                        let e = ""
                          , i = "";
                        for (; e = E(t); )
                            i += e;
                        return i
                    }(t))) : function(t, e) {
                        const {currentType: i} = e;
                        if (10 !== i)
                            return !1;
                        const n = () => {
                            const e = t.currentPeek();
                            return "{" === e ? _(t.peek()) : !("@" === e || "%" === e || "|" === e || ":" === e || "." === e || e === S || !e) && (e === A ? (t.peek(),
                            n()) : _(e))
                        }
                          , r = n();
                        return t.resetPeek(),
                        r
                    }(t, e) ? (g(t),
                    "{" === r ? z(t, e) || n : d(e, 11, function(t) {
                        const e = (i=!1, n) => {
                            const r = t.currentChar();
                            return "{" !== r && "%" !== r && "@" !== r && "|" !== r && r ? r === S ? n : r === A ? (n += r,
                            t.next(),
                            e(i, n)) : (n += r,
                            t.next(),
                            e(!0, n)) : n
                        }
                        ;
                        return e(!1, "")
                    }(t))) : (8 === i && u(9, o(), 0),
                    e.braceNest = 0,
                    e.inLinked = !1,
                    N(t, e))
                }
            }
            function N(t, e) {
                let i = {
                    type: 14
                };
                if (e.braceNest > 0)
                    return z(t, e) || f(e);
                if (e.inLinked)
                    return F(t, e) || f(e);
                const n = t.currentChar();
                switch (n) {
                case "{":
                    return z(t, e) || f(e);
                case "}":
                    return u(5, o(), 0),
                    t.next(),
                    d(e, 3, "}");
                case "@":
                    return F(t, e) || f(e);
                default:
                    if (v(t))
                        return i = d(e, 1, B(t)),
                        e.braceNest = 0,
                        e.inLinked = !1,
                        i;
                    if (x(t))
                        return d(e, 0, function(t) {
                            let e = "";
                            for (; ; ) {
                                const i = t.currentChar();
                                if ("{" === i || "}" === i || "@" === i || "|" === i || !i)
                                    break;
                                if ("%" === i) {
                                    if (!x(t))
                                        break;
                                    e += i,
                                    t.next()
                                } else if (i === S || i === A)
                                    if (x(t))
                                        e += i,
                                        t.next();
                                    else {
                                        if (v(t))
                                            break;
                                        e += i,
                                        t.next()
                                    }
                                else
                                    e += i,
                                    t.next()
                            }
                            return e
                        }(t));
                    if ("%" === n)
                        return t.next(),
                        d(e, 4, "%")
                }
                return i
            }
            return {
                nextToken: function() {
                    const {currentType: t, offset: e, startLoc: i, endLoc: s} = l;
                    return l.lastType = t,
                    l.lastOffset = e,
                    l.lastStartLoc = i,
                    l.lastEndLoc = s,
                    l.offset = r(),
                    l.startLoc = o(),
                    n.currentChar() === k ? d(l, 14) : N(n, l)
                },
                currentOffset: r,
                currentPosition: o,
                context: c
            }
        }
        const L = "parser"
          , B = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
        function z(t, e, i) {
            switch (t) {
            case "\\\\":
                return "\\";
            case "\\'":
                return "'";
            default:
                {
                    const t = parseInt(e || i, 16);
                    return t <= 55295 || t >= 57344 ? String.fromCodePoint(t) : ""
                }
            }
        }
        function F(t={}) {
            const e = !1 !== t.location
              , {onError: i} = t;
            function r(t, e, n, r, ...o) {
                const s = t.currentPosition();
                if (s.offset += r,
                s.column += r,
                i) {
                    const t = w(e, T(n, s), {
                        domain: L,
                        args: o
                    });
                    i(t)
                }
            }
            function o(t, i, n) {
                const r = {
                    type: t,
                    start: i,
                    end: i
                };
                return e && (r.loc = {
                    start: n,
                    end: n
                }),
                r
            }
            function s(t, i, n, r) {
                t.end = i,
                r && (t.type = r),
                e && t.loc && (t.loc.end = n)
            }
            function a(t, e) {
                const i = t.context()
                  , n = o(3, i.offset, i.startLoc);
                return n.value = e,
                s(n, t.currentOffset(), t.currentPosition()),
                n
            }
            function l(t, e) {
                const i = t.context()
                  , {lastOffset: n, lastStartLoc: r} = i
                  , a = o(5, n, r);
                return a.index = parseInt(e, 10),
                t.nextToken(),
                s(a, t.currentOffset(), t.currentPosition()),
                a
            }
            function c(t, e) {
                const i = t.context()
                  , {lastOffset: n, lastStartLoc: r} = i
                  , a = o(4, n, r);
                return a.key = e,
                t.nextToken(),
                s(a, t.currentOffset(), t.currentPosition()),
                a
            }
            function h(t, e) {
                const i = t.context()
                  , {lastOffset: n, lastStartLoc: r} = i
                  , a = o(9, n, r);
                return a.value = e.replace(B, z),
                t.nextToken(),
                s(a, t.currentOffset(), t.currentPosition()),
                a
            }
            function u(t) {
                const e = t.context()
                  , i = o(6, e.offset, e.startLoc);
                let n = t.nextToken();
                if (9 === n.type) {
                    const e = function(t) {
                        const e = t.nextToken()
                          , i = t.context()
                          , {lastOffset: n, lastStartLoc: a} = i
                          , l = o(8, n, a);
                        return 12 !== e.type ? (r(t, 11, i.lastStartLoc, 0),
                        l.value = "",
                        s(l, n, a),
                        {
                            nextConsumeToken: e,
                            node: l
                        }) : (null == e.value && r(t, 13, i.lastStartLoc, 0, N(e)),
                        l.value = e.value || "",
                        s(l, t.currentOffset(), t.currentPosition()),
                        {
                            node: l
                        })
                    }(t);
                    i.modifier = e.node,
                    n = e.nextConsumeToken || t.nextToken()
                }
                switch (10 !== n.type && r(t, 13, e.lastStartLoc, 0, N(n)),
                n = t.nextToken(),
                2 === n.type && (n = t.nextToken()),
                n.type) {
                case 11:
                    null == n.value && r(t, 13, e.lastStartLoc, 0, N(n)),
                    i.key = function(t, e) {
                        const i = t.context()
                          , n = o(7, i.offset, i.startLoc);
                        return n.value = e,
                        s(n, t.currentOffset(), t.currentPosition()),
                        n
                    }(t, n.value || "");
                    break;
                case 5:
                    null == n.value && r(t, 13, e.lastStartLoc, 0, N(n)),
                    i.key = c(t, n.value || "");
                    break;
                case 6:
                    null == n.value && r(t, 13, e.lastStartLoc, 0, N(n)),
                    i.key = l(t, n.value || "");
                    break;
                case 7:
                    null == n.value && r(t, 13, e.lastStartLoc, 0, N(n)),
                    i.key = h(t, n.value || "");
                    break;
                default:
                    r(t, 12, e.lastStartLoc, 0);
                    const a = t.context()
                      , u = o(7, a.offset, a.startLoc);
                    return u.value = "",
                    s(u, a.offset, a.startLoc),
                    i.key = u,
                    s(i, a.offset, a.startLoc),
                    {
                        nextConsumeToken: n,
                        node: i
                    }
                }
                return s(i, t.currentOffset(), t.currentPosition()),
                {
                    node: i
                }
            }
            function d(t) {
                const e = t.context()
                  , i = o(2, 1 === e.currentType ? t.currentOffset() : e.offset, 1 === e.currentType ? e.endLoc : e.startLoc);
                i.items = [];
                let n = null;
                do {
                    const o = n || t.nextToken();
                    switch (n = null,
                    o.type) {
                    case 0:
                        null == o.value && r(t, 13, e.lastStartLoc, 0, N(o)),
                        i.items.push(a(t, o.value || ""));
                        break;
                    case 6:
                        null == o.value && r(t, 13, e.lastStartLoc, 0, N(o)),
                        i.items.push(l(t, o.value || ""));
                        break;
                    case 5:
                        null == o.value && r(t, 13, e.lastStartLoc, 0, N(o)),
                        i.items.push(c(t, o.value || ""));
                        break;
                    case 7:
                        null == o.value && r(t, 13, e.lastStartLoc, 0, N(o)),
                        i.items.push(h(t, o.value || ""));
                        break;
                    case 8:
                        const s = u(t);
                        i.items.push(s.node),
                        n = s.nextConsumeToken || null
                    }
                } while (14 !== e.currentType && 1 !== e.currentType);
                return s(i, 1 === e.currentType ? e.lastOffset : t.currentOffset(), 1 === e.currentType ? e.lastEndLoc : t.currentPosition()),
                i
            }
            function f(t) {
                const e = t.context()
                  , {offset: i, startLoc: n} = e
                  , a = d(t);
                return 14 === e.currentType ? a : function(t, e, i, n) {
                    const a = t.context();
                    let l = 0 === n.items.length;
                    const c = o(1, e, i);
                    c.cases = [],
                    c.cases.push(n);
                    do {
                        const e = d(t);
                        l || (l = 0 === e.items.length),
                        c.cases.push(e)
                    } while (14 !== a.currentType);
                    return l && r(t, 10, i, 0),
                    s(c, t.currentOffset(), t.currentPosition()),
                    c
                }(t, i, n, a)
            }
            return {
                parse: function(i) {
                    const a = D(i, (0,
                    n.assign)({}, t))
                      , l = a.context()
                      , c = o(0, l.offset, l.startLoc);
                    return e && c.loc && (c.loc.source = i),
                    c.body = f(a),
                    14 !== l.currentType && r(a, 13, l.lastStartLoc, 0, i[l.offset] || ""),
                    s(c, a.currentOffset(), a.currentPosition()),
                    c
                }
            }
        }
        function N(t) {
            if (14 === t.type)
                return "EOF";
            const e = (t.value || "").replace(/\r?\n/gu, "\\n");
            return e.length > 10 ? e.slice(0, 9) + "" : e
        }
        function j(t, e) {
            for (let i = 0; i < t.length; i++)
                U(t[i], e)
        }
        function U(t, e) {
            switch (t.type) {
            case 1:
                j(t.cases, e),
                e.helper("plural");
                break;
            case 2:
                j(t.items, e);
                break;
            case 6:
                U(t.key, e),
                e.helper("linked");
                break;
            case 5:
                e.helper("interpolate"),
                e.helper("list");
                break;
            case 4:
                e.helper("interpolate"),
                e.helper("named")
            }
        }
        function V(t, e={}) {
            const i = function(t, e={}) {
                const i = {
                    ast: t,
                    helpers: new Set
                };
                return {
                    context: () => i,
                    helper: t => (i.helpers.add(t),
                    t)
                }
            }(t);
            i.helper("normalize"),
            t.body && U(t.body, i);
            const n = i.context();
            t.helpers = Array.from(n.helpers)
        }
        function G(t, e) {
            const {helper: i} = t;
            switch (e.type) {
            case 0:
                !function(t, e) {
                    e.body ? G(t, e.body) : t.push("null")
                }(t, e);
                break;
            case 1:
                !function(t, e) {
                    const {helper: i, needIndent: n} = t;
                    if (e.cases.length > 1) {
                        t.push(`${i("plural")}([`),
                        t.indent(n());
                        const r = e.cases.length;
                        for (let i = 0; i < r && (G(t, e.cases[i]),
                        i !== r - 1); i++)
                            t.push(", ");
                        t.deindent(n()),
                        t.push("])")
                    }
                }(t, e);
                break;
            case 2:
                !function(t, e) {
                    const {helper: i, needIndent: n} = t;
                    t.push(`${i("normalize")}([`),
                    t.indent(n());
                    const r = e.items.length;
                    for (let i = 0; i < r && (G(t, e.items[i]),
                    i !== r - 1); i++)
                        t.push(", ");
                    t.deindent(n()),
                    t.push("])")
                }(t, e);
                break;
            case 6:
                !function(t, e) {
                    const {helper: i} = t;
                    t.push(`${i("linked")}(`),
                    G(t, e.key),
                    e.modifier && (t.push(", "),
                    G(t, e.modifier)),
                    t.push(")")
                }(t, e);
                break;
            case 8:
            case 7:
            case 9:
            case 3:
                t.push(JSON.stringify(e.value), e);
                break;
            case 5:
                t.push(`${i("interpolate")}(${i("list")}(${e.index}))`, e);
                break;
            case 4:
                t.push(`${i("interpolate")}(${i("named")}(${JSON.stringify(e.key)}))`, e)
            }
        }
        const Z = (t, e={}) => {
            const i = (0,
            n.isString)(e.mode) ? e.mode : "normal"
              , r = (0,
            n.isString)(e.filename) ? e.filename : "message.intl"
              , o = !!e.sourceMap
              , s = null != e.breakLineCode ? e.breakLineCode : "arrow" === i ? ";" : "\n"
              , a = e.needIndent ? e.needIndent : "arrow" !== i
              , l = t.helpers || []
              , c = function(t, e) {
                const {sourceMap: i, filename: n, breakLineCode: r, needIndent: o} = e
                  , s = {
                    source: t.loc.source,
                    filename: n,
                    code: "",
                    column: 1,
                    line: 1,
                    offset: 0,
                    map: void 0,
                    breakLineCode: r,
                    needIndent: o,
                    indentLevel: 0
                };
                function a(t, e) {
                    s.code += t
                }
                function l(t, e=!0) {
                    const i = e ? r : "";
                    a(o ? i + "  ".repeat(t) : i)
                }
                return {
                    context: () => s,
                    push: a,
                    indent: function(t=!0) {
                        const e = ++s.indentLevel;
                        t && l(e)
                    },
                    deindent: function(t=!0) {
                        const e = --s.indentLevel;
                        t && l(e)
                    },
                    newline: function() {
                        l(s.indentLevel)
                    },
                    helper: t => `_${t}`,
                    needIndent: () => s.needIndent
                }
            }(t, {
                mode: i,
                filename: r,
                sourceMap: o,
                breakLineCode: s,
                needIndent: a
            });
            c.push("normal" === i ? "function __msg__ (ctx) {" : "(ctx) => {"),
            c.indent(a),
            l.length > 0 && (c.push(`const { ${l.map((t => `${t}: _${t}`)).join(", ")} } = ctx`),
            c.newline()),
            c.push("return "),
            G(c, t),
            c.deindent(a),
            c.push("}");
            const {code: h, map: u} = c.context();
            return {
                ast: t,
                code: h,
                map: u ? u.toJSON() : void 0
            }
        }
        ;
        const q = {
            I18nInit: "i18n:init",
            FunctionTranslate: "function:translate"
        };
        let W = null;
        function H(t) {
            W = t
        }
        function $() {
            return W
        }
        function X(t, e, i) {
            W && W.emit(q.I18nInit, {
                timestamp: Date.now(),
                i18n: t,
                version: e,
                meta: i
            })
        }
        const Y = K(q.FunctionTranslate);
        function K(t) {
            return e => W && W.emit(t, e)
        }
        const J = {
            0: "Not found '{key}' key in '{locale}' locale messages.",
            1: "Fall back to translate '{key}' key with '{target}' locale.",
            2: "Cannot format a number value due to not supported Intl.NumberFormat.",
            3: "Fall back to number format '{key}' key with '{target}' locale.",
            4: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
            5: "Fall back to datetime format '{key}' key with '{target}' locale."
        };
        function Q(t, ...e) {
            return (0,
            n.format)(J[t], ...e)
        }
        const tt = "9.1.10"
          , et = -1
          , it = "";
        let nt;
        function rt(t) {
            nt = t
        }
        let ot = null;
        const st = t => {
            ot = t
        }
          , at = () => ot;
        let lt = 0;
        function ct(t={}) {
            const e = (0,
            n.isString)(t.version) ? t.version : tt
              , i = (0,
            n.isString)(t.locale) ? t.locale : "en-US"
              , r = (0,
            n.isArray)(t.fallbackLocale) || (0,
            n.isPlainObject)(t.fallbackLocale) || (0,
            n.isString)(t.fallbackLocale) || !1 === t.fallbackLocale ? t.fallbackLocale : i
              , o = (0,
            n.isPlainObject)(t.messages) ? t.messages : {
                [i]: {}
            }
              , s = (0,
            n.isPlainObject)(t.datetimeFormats) ? t.datetimeFormats : {
                [i]: {}
            }
              , a = (0,
            n.isPlainObject)(t.numberFormats) ? t.numberFormats : {
                [i]: {}
            }
              , l = (0,
            n.assign)({}, t.modifiers || {}, {
                upper: t => (0,
                n.isString)(t) ? t.toUpperCase() : t,
                lower: t => (0,
                n.isString)(t) ? t.toLowerCase() : t,
                capitalize: t => (0,
                n.isString)(t) ? `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}` : t
            })
              , c = t.pluralRules || {}
              , h = (0,
            n.isFunction)(t.missing) ? t.missing : null
              , u = !(0,
            n.isBoolean)(t.missingWarn) && !(0,
            n.isRegExp)(t.missingWarn) || t.missingWarn
              , d = !(0,
            n.isBoolean)(t.fallbackWarn) && !(0,
            n.isRegExp)(t.fallbackWarn) || t.fallbackWarn
              , f = !!t.fallbackFormat
              , p = !!t.unresolving
              , m = (0,
            n.isFunction)(t.postTranslation) ? t.postTranslation : null
              , g = (0,
            n.isPlainObject)(t.processor) ? t.processor : null
              , _ = !(0,
            n.isBoolean)(t.warnHtmlMessage) || t.warnHtmlMessage
              , y = !!t.escapeParameter
              , v = (0,
            n.isFunction)(t.messageCompiler) ? t.messageCompiler : nt
              , x = (0,
            n.isFunction)(t.onWarn) ? t.onWarn : n.warn
              , b = t
              , w = (0,
            n.isObject)(b.__datetimeFormatters) ? b.__datetimeFormatters : new Map
              , E = (0,
            n.isObject)(b.__numberFormatters) ? b.__numberFormatters : new Map
              , T = (0,
            n.isObject)(b.__meta) ? b.__meta : {};
            lt++;
            const S = {
                version: e,
                cid: lt,
                locale: i,
                fallbackLocale: r,
                messages: o,
                datetimeFormats: s,
                numberFormats: a,
                modifiers: l,
                pluralRules: c,
                missing: h,
                missingWarn: u,
                fallbackWarn: d,
                fallbackFormat: f,
                unresolving: p,
                postTranslation: m,
                processor: g,
                warnHtmlMessage: _,
                escapeParameter: y,
                messageCompiler: v,
                onWarn: x,
                __datetimeFormatters: w,
                __numberFormatters: E,
                __meta: T
            };
            return __INTLIFY_PROD_DEVTOOLS__ && X(S, e, T),
            S
        }
        function ht(t, e) {
            return t instanceof RegExp ? t.test(e) : t
        }
        function ut(t, e) {
            return t instanceof RegExp ? t.test(e) : t
        }
        function dt(t, e, i, r, o) {
            const {missing: s, onWarn: a} = t;
            if (null !== s) {
                const r = s(t, i, e, o);
                return (0,
                n.isString)(r) ? r : e
            }
            return e
        }
        function ft(t, e, i) {
            const r = t;
            r.__localeChainCache || (r.__localeChainCache = new Map);
            let o = r.__localeChainCache.get(i);
            if (!o) {
                o = [];
                let t = [i];
                for (; (0,
                n.isArray)(t); )
                    t = pt(o, t, e);
                const s = (0,
                n.isArray)(e) ? e : (0,
                n.isPlainObject)(e) ? e.default ? e.default : null : e;
                t = (0,
                n.isString)(s) ? [s] : s,
                (0,
                n.isArray)(t) && pt(o, t, !1),
                r.__localeChainCache.set(i, o)
            }
            return o
        }
        function pt(t, e, i) {
            let r = !0;
            for (let o = 0; o < e.length && (0,
            n.isBoolean)(r); o++) {
                const s = e[o];
                (0,
                n.isString)(s) && (r = mt(t, e[o], i))
            }
            return r
        }
        function mt(t, e, i) {
            let n;
            const r = e.split("-");
            do {
                n = gt(t, r.join("-"), i),
                r.splice(-1, 1)
            } while (r.length && !0 === n);
            return n
        }
        function gt(t, e, i) {
            let r = !1;
            if (!t.includes(e) && (r = !0,
            e)) {
                r = "!" !== e[e.length - 1];
                const o = e.replace(/!/g, "");
                t.push(o),
                ((0,
                n.isArray)(i) || (0,
                n.isPlainObject)(i)) && i[o] && (r = i[o])
            }
            return r
        }
        function _t(t, e, i) {
            t.__localeChainCache = new Map,
            ft(t, i, e)
        }
        const yt = t => t;
        let vt = Object.create(null);
        function xt() {
            vt = Object.create(null)
        }
        function bt(t, e={}) {
            {
                const i = (e.onCacheKey || yt)(t)
                  , r = vt[i];
                if (r)
                    return r;
                let o = !1;
                const s = e.onError || E;
                e.onError = t => {
                    o = !0,
                    s(t)
                }
                ;
                const {code: a} = function(t, e={}) {
                    const i = (0,
                    n.assign)({}, e)
                      , r = F(i).parse(t);
                    return V(r, i),
                    Z(r, i)
                }(t, e)
                  , l = new Function(`return ${a}`)();
                return o ? l : vt[i] = l
            }
        }
        function wt(t) {
            return w(t, null, void 0)
        }
        const Et = () => ""
          , Tt = t => (0,
        n.isFunction)(t);
        function St(t, ...e) {
            const {fallbackFormat: i, postTranslation: r, unresolving: o, fallbackLocale: s, messages: a} = t
              , [l,c] = At(...e)
              , h = ((0,
            n.isBoolean)(c.missingWarn) ? c.missingWarn : t.missingWarn,
            (0,
            n.isBoolean)(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn,
            (0,
            n.isBoolean)(c.escapeParameter) ? c.escapeParameter : t.escapeParameter)
              , u = !!c.resolvedMessage
              , d = (0,
            n.isString)(c.default) || (0,
            n.isBoolean)(c.default) ? (0,
            n.isBoolean)(c.default) ? l : c.default : i ? l : ""
              , p = i || "" !== d
              , m = (0,
            n.isString)(c.locale) ? c.locale : t.locale;
            h && function(t) {
                (0,
                n.isArray)(t.list) ? t.list = t.list.map((t => (0,
                n.isString)(t) ? (0,
                n.escapeHtml)(t) : t)) : (0,
                n.isObject)(t.named) && Object.keys(t.named).forEach((e => {
                    (0,
                    n.isString)(t.named[e]) && (t.named[e] = (0,
                    n.escapeHtml)(t.named[e]))
                }
                ))
            }(c);
            let[g,_,y] = u ? [l, m, a[m] || {}] : function(t, e, i, r, o, s) {
                const {messages: a, onWarn: l} = t
                  , c = ft(t, r, i);
                let h, u = {}, d = null, p = i, m = null;
                const g = "translate";
                for (let i = 0; i < c.length; i++) {
                    h = m = c[i],
                    u = a[h] || {};
                    if (null === (d = f(u, e)) && (d = u[e]),
                    (0,
                    n.isString)(d) || (0,
                    n.isFunction)(d))
                        break;
                    const r = dt(t, e, h, 0, g);
                    r !== e && (d = r),
                    p = m
                }
                return [d, h, u]
            }(t, l, m, s)
              , v = l;
            if (u || (0,
            n.isString)(g) || Tt(g) || p && (g = d,
            v = g),
            !(u || ((0,
            n.isString)(g) || Tt(g)) && (0,
            n.isString)(_)))
                return o ? et : l;
            let x = !1;
            const w = Tt(g) ? g : Ct(t, l, _, g, v, ( () => {
                x = !0
            }
            ));
            if (x)
                return g;
            const E = function(t, e, i, r) {
                const {modifiers: o, pluralRules: s} = t
                  , a = r => {
                    const o = f(i, r);
                    if ((0,
                    n.isString)(o)) {
                        let i = !1;
                        const n = Ct(t, r, e, o, r, ( () => {
                            i = !0
                        }
                        ));
                        return i ? Et : n
                    }
                    return Tt(o) ? o : Et
                }
                  , l = {
                    locale: e,
                    modifiers: o,
                    pluralRules: s,
                    messages: a
                };
                t.processor && (l.processor = t.processor);
                r.list && (l.list = r.list);
                r.named && (l.named = r.named);
                (0,
                n.isNumber)(r.plural) && (l.pluralIndex = r.plural);
                return l
            }(t, _, y, c)
              , T = function(t, e, i) {
                0;
                const n = e(i);
                0;
                return n
            }(0, w, b(E))
              , S = r ? r(T) : T;
            if (__INTLIFY_PROD_DEVTOOLS__) {
                const e = {
                    timestamp: Date.now(),
                    key: (0,
                    n.isString)(l) ? l : Tt(g) ? g.key : "",
                    locale: _ || (Tt(g) ? g.locale : ""),
                    format: (0,
                    n.isString)(g) ? g : Tt(g) ? g.source : "",
                    message: S
                };
                e.meta = (0,
                n.assign)({}, t.__meta, at() || {}),
                Y(e)
            }
            return S
        }
        function Ct(t, e, i, r, o, s) {
            const {messageCompiler: a, warnHtmlMessage: l} = t;
            if (Tt(r)) {
                const t = r;
                return t.locale = t.locale || i,
                t.key = t.key || e,
                t
            }
            const c = a(r, function(t, e, i, r, o, s) {
                return {
                    warnHtmlMessage: o,
                    onError: t => {
                        throw s && s(t),
                        t
                    }
                    ,
                    onCacheKey: t => (0,
                    n.generateFormatCacheKey)(e, i, t)
                }
            }(0, i, o, 0, l, s));
            return c.locale = i,
            c.key = e,
            c.source = r,
            c
        }
        function At(...t) {
            const [e,i,r] = t
              , o = {};
            if (!(0,
            n.isString)(e) && !(0,
            n.isNumber)(e) && !Tt(e))
                throw wt(14);
            const s = (0,
            n.isNumber)(e) ? String(e) : (Tt(e),
            e);
            return (0,
            n.isNumber)(i) ? o.plural = i : (0,
            n.isString)(i) ? o.default = i : (0,
            n.isPlainObject)(i) && !(0,
            n.isEmptyObject)(i) ? o.named = i : (0,
            n.isArray)(i) && (o.list = i),
            (0,
            n.isNumber)(r) ? o.plural = r : (0,
            n.isString)(r) ? o.default = r : (0,
            n.isPlainObject)(r) && (0,
            n.assign)(o, r),
            [s, o]
        }
        const It = "undefined" != typeof Intl;
        It && Intl.DateTimeFormat,
        It && Intl.NumberFormat;
        function Mt(t, ...e) {
            const {datetimeFormats: i, unresolving: r, fallbackLocale: o, onWarn: s} = t
              , {__datetimeFormatters: a} = t;
            const [l,c,h,u] = Pt(...e)
              , d = ((0,
            n.isBoolean)(h.missingWarn) ? h.missingWarn : t.missingWarn,
            (0,
            n.isBoolean)(h.fallbackWarn) ? h.fallbackWarn : t.fallbackWarn,
            !!h.part)
              , f = (0,
            n.isString)(h.locale) ? h.locale : t.locale
              , p = ft(t, o, f);
            if (!(0,
            n.isString)(l) || "" === l)
                return new Intl.DateTimeFormat(f).format(c);
            let m, g = {}, _ = null, y = f, v = null;
            for (let e = 0; e < p.length && (m = v = p[e],
            g = i[m] || {},
            _ = g[l],
            !(0,
            n.isPlainObject)(_)); e++)
                dt(t, l, m, 0, "datetime format"),
                y = v;
            if (!(0,
            n.isPlainObject)(_) || !(0,
            n.isString)(m))
                return r ? et : l;
            let x = `${m}__${l}`;
            (0,
            n.isEmptyObject)(u) || (x = `${x}__${JSON.stringify(u)}`);
            let b = a.get(x);
            return b || (b = new Intl.DateTimeFormat(m,(0,
            n.assign)({}, _, u)),
            a.set(x, b)),
            d ? b.formatToParts(c) : b.format(c)
        }
        function Pt(...t) {
            const [e,i,r,o] = t;
            let s, a = {}, l = {};
            if ((0,
            n.isString)(e)) {
                if (!/\d{4}-\d{2}-\d{2}(T.*)?/.test(e))
                    throw wt(16);
                s = new Date(e);
                try {
                    s.toISOString()
                } catch (t) {
                    throw wt(16)
                }
            } else if ((0,
            n.isDate)(e)) {
                if (isNaN(e.getTime()))
                    throw wt(15);
                s = e
            } else {
                if (!(0,
                n.isNumber)(e))
                    throw wt(14);
                s = e
            }
            return (0,
            n.isString)(i) ? a.key = i : (0,
            n.isPlainObject)(i) && (a = i),
            (0,
            n.isString)(r) ? a.locale = r : (0,
            n.isPlainObject)(r) && (l = r),
            (0,
            n.isPlainObject)(o) && (l = o),
            [a.key || "", s, a, l]
        }
        function kt(t, e, i) {
            const n = t;
            for (const t in i) {
                const i = `${e}__${t}`;
                n.__datetimeFormatters.has(i) && n.__datetimeFormatters.delete(i)
            }
        }
        function Ot(t, ...e) {
            const {numberFormats: i, unresolving: r, fallbackLocale: o, onWarn: s} = t
              , {__numberFormatters: a} = t;
            const [l,c,h,u] = Rt(...e)
              , d = ((0,
            n.isBoolean)(h.missingWarn) ? h.missingWarn : t.missingWarn,
            (0,
            n.isBoolean)(h.fallbackWarn) ? h.fallbackWarn : t.fallbackWarn,
            !!h.part)
              , f = (0,
            n.isString)(h.locale) ? h.locale : t.locale
              , p = ft(t, o, f);
            if (!(0,
            n.isString)(l) || "" === l)
                return new Intl.NumberFormat(f).format(c);
            let m, g = {}, _ = null, y = f, v = null;
            for (let e = 0; e < p.length && (m = v = p[e],
            g = i[m] || {},
            _ = g[l],
            !(0,
            n.isPlainObject)(_)); e++)
                dt(t, l, m, 0, "number format"),
                y = v;
            if (!(0,
            n.isPlainObject)(_) || !(0,
            n.isString)(m))
                return r ? et : l;
            let x = `${m}__${l}`;
            (0,
            n.isEmptyObject)(u) || (x = `${x}__${JSON.stringify(u)}`);
            let b = a.get(x);
            return b || (b = new Intl.NumberFormat(m,(0,
            n.assign)({}, _, u)),
            a.set(x, b)),
            d ? b.formatToParts(c) : b.format(c)
        }
        function Rt(...t) {
            const [e,i,r,o] = t;
            let s = {}
              , a = {};
            if (!(0,
            n.isNumber)(e))
                throw wt(14);
            const l = e;
            return (0,
            n.isString)(i) ? s.key = i : (0,
            n.isPlainObject)(i) && (s = i),
            (0,
            n.isString)(r) ? s.locale = r : (0,
            n.isPlainObject)(r) && (a = r),
            (0,
            n.isPlainObject)(o) && (a = o),
            [s.key || "", l, s, a]
        }
        function Dt(t, e, i) {
            const n = t;
            for (const t in i) {
                const i = `${e}__${t}`;
                n.__numberFormatters.has(i) && n.__numberFormatters.delete(i)
            }
        }
        "boolean" != typeof __INTLIFY_PROD_DEVTOOLS__ && ((0,
        n.getGlobalThis)().__INTLIFY_PROD_DEVTOOLS__ = !1)
    },
    87175: function(t, e, i) {
        "use strict";
        i.r(e),
        i.d(e, {
            assign: function() {
                return g
            },
            createEmitter: function() {
                return L
            },
            escapeHtml: function() {
                return v
            },
            format: function() {
                return s
            },
            friendlyJSONstringify: function() {
                return h
            },
            generateCodeFrame: function() {
                return D
            },
            generateFormatCacheKey: function() {
                return c
            },
            getGlobalThis: function() {
                return y
            },
            hasOwn: function() {
                return b
            },
            inBrowser: function() {
                return r
            },
            isArray: function() {
                return w
            },
            isBoolean: function() {
                return S
            },
            isDate: function() {
                return d
            },
            isEmptyObject: function() {
                return p
            },
            isFunction: function() {
                return E
            },
            isNumber: function() {
                return u
            },
            isObject: function() {
                return A
            },
            isPlainObject: function() {
                return k
            },
            isPromise: function() {
                return I
            },
            isRegExp: function() {
                return f
            },
            isString: function() {
                return T
            },
            isSymbol: function() {
                return C
            },
            makeSymbol: function() {
                return l
            },
            mark: function() {},
            measure: function() {},
            objectToString: function() {
                return M
            },
            toDisplayString: function() {
                return O
            },
            toTypeString: function() {
                return P
            },
            warn: function() {
                return m
            }
        });
        var n = i(25108);
        const r = "undefined" != typeof window;
        const o = /\{([0-9a-zA-Z]+)\}/g;
        function s(t, ...e) {
            return 1 === e.length && A(e[0]) && (e = e[0]),
            e && e.hasOwnProperty || (e = {}),
            t.replace(o, ( (t, i) => e.hasOwnProperty(i) ? e[i] : ""))
        }
        const a = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag
          , l = t => a ? Symbol(t) : t
          , c = (t, e, i) => h({
            l: t,
            k: e,
            s: i
        })
          , h = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027")
          , u = t => "number" == typeof t && isFinite(t)
          , d = t => "[object Date]" === P(t)
          , f = t => "[object RegExp]" === P(t)
          , p = t => k(t) && 0 === Object.keys(t).length;
        function m(t, e) {
            void 0 !== n && (n.warn("[intlify] " + t),
            e && n.warn(e.stack))
        }
        const g = Object.assign;
        let _;
        const y = () => _ || (_ = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== i.g ? i.g : {});
        function v(t) {
            return t.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
        }
        const x = Object.prototype.hasOwnProperty;
        function b(t, e) {
            return x.call(t, e)
        }
        const w = Array.isArray
          , E = t => "function" == typeof t
          , T = t => "string" == typeof t
          , S = t => "boolean" == typeof t
          , C = t => "symbol" == typeof t
          , A = t => null !== t && "object" == typeof t
          , I = t => A(t) && E(t.then) && E(t.catch)
          , M = Object.prototype.toString
          , P = t => M.call(t)
          , k = t => "[object Object]" === P(t)
          , O = t => null == t ? "" : w(t) || k(t) && t.toString === M ? JSON.stringify(t, null, 2) : String(t)
          , R = 2;
        function D(t, e=0, i=t.length) {
            const n = t.split(/\r?\n/);
            let r = 0;
            const o = [];
            for (let t = 0; t < n.length; t++)
                if (r += n[t].length + 1,
                r >= e) {
                    for (let s = t - R; s <= t + R || i > r; s++) {
                        if (s < 0 || s >= n.length)
                            continue;
                        const a = s + 1;
                        o.push(`${a}${" ".repeat(3 - String(a).length)}|  ${n[s]}`);
                        const l = n[s].length;
                        if (s === t) {
                            const t = e - (r - l) + 1
                              , n = Math.max(1, i > r ? l - t : i - e);
                            o.push("   |  " + " ".repeat(t) + "^".repeat(n))
                        } else if (s > t) {
                            if (i > r) {
                                const t = Math.max(Math.min(i - r, l), 1);
                                o.push("   |  " + "^".repeat(t))
                            }
                            r += l + 1
                        }
                    }
                    break
                }
            return o.join("\n")
        }
        function L() {
            const t = new Map;
            return {
                events: t,
                on(e, i) {
                    const n = t.get(e);
                    n && n.push(i) || t.set(e, [i])
                },
                off(e, i) {
                    const n = t.get(e);
                    n && n.splice(n.indexOf(i) >>> 0, 1)
                },
                emit(e, i) {
                    (t.get(e) || []).slice().map((t => t(i))),
                    (t.get("*") || []).slice().map((t => t(e, i)))
                }
            }
        }
    },
    24532: function(t, e, i) {
        "use strict";
        var n = i(33310)
          , r = i(47529)
          , o = "value"
          , s = "\n  "
          , a = {};
        function l(t) {
            var e = Array.isArray(t);
            return function(i) {
                var n, r = c(a.plainArray, i);
                if (r)
                    return r;
                if (e && i.length !== t.length)
                    return "an array with " + t.length + " items";
                for (var o = 0; o < i.length; o++)
                    if (r = c((n = o,
                    e ? t[n] : t), i[o]))
                        return [o].concat(r)
            }
        }
        function c(t, e) {
            if (null != e || t.hasOwnProperty("__required")) {
                var i = t(e);
                return i ? Array.isArray(i) ? i : [i] : void 0
            }
        }
        function h(t, e) {
            var i = t.length
              , n = t[i - 1]
              , s = t.slice(0, i - 1);
            return 0 === s.length && (s = [o]),
            e = r(e, {
                path: s
            }),
            "function" == typeof n ? n(e) : u(e, function(t) {
                return "must be " + function(t) {
                    if (/^an? /.test(t))
                        return t;
                    if (/^[aeiou]/i.test(t))
                        return "an " + t;
                    if (/^[a-z]/i.test(t))
                        return "a " + t;
                    return t
                }(t) + "."
            }(n))
        }
        function u(t, e) {
            return (d(t.path) ? "Item at position " : "") + (t.path.join(".") + " " + e)
        }
        function d(t) {
            return "number" == typeof t[t.length - 1] || "number" == typeof t[0]
        }
        a.assert = function(t, e) {
            return e = e || {},
            function(i) {
                var n = c(t, i);
                if (n) {
                    var r = h(n, e);
                    throw e.apiName && (r = e.apiName + ": " + r),
                    new Error(r)
                }
            }
        }
        ,
        a.shape = function(t) {
            var e, i = (e = t,
            Object.keys(e || {}).map((function(t) {
                return {
                    key: t,
                    value: e[t]
                }
            }
            )));
            return function(t) {
                var e, n = c(a.plainObject, t);
                if (n)
                    return n;
                for (var r = [], l = 0; l < i.length; l++)
                    e = i[l].key,
                    (n = c(i[l].value, t[e])) && r.push([e].concat(n));
                return r.length < 2 ? r[0] : function(t) {
                    r = r.map((function(e) {
                        return "- " + e[0] + ": " + h(e, t).split("\n").join(s)
                    }
                    ));
                    var e = t.path.join(".");
                    return "The following properties" + (e === o ? "" : " of " + e) + " have invalid values:" + s + r.join(s)
                }
            }
        }
        ,
        a.strictShape = function(t) {
            var e = a.shape(t);
            return function(i) {
                var n = e(i);
                if (n)
                    return n;
                var r = Object.keys(i).reduce((function(e, i) {
                    return void 0 === t[i] && e.push(i),
                    e
                }
                ), []);
                return 0 !== r.length ? function() {
                    return "The following keys are invalid: " + r.join(", ")
                }
                : void 0
            }
        }
        ,
        a.arrayOf = function(t) {
            return l(t)
        }
        ,
        a.tuple = function() {
            return l(Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments))
        }
        ,
        a.required = function(t) {
            function e(e) {
                return null == e ? function(t) {
                    return u(t, d(t.path) ? "cannot be undefined/null." : "is required.")
                }
                : t.apply(this, arguments)
            }
            return e.__required = !0,
            e
        }
        ,
        a.oneOfType = function() {
            var t = Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments);
            return function(e) {
                var i = t.map((function(t) {
                    return c(t, e)
                }
                )).filter(Boolean);
                if (i.length === t.length)
                    return i.every((function(t) {
                        return 1 === t.length && "string" == typeof t[0]
                    }
                    )) ? function(t) {
                        if (t.length < 2)
                            return t[0];
                        if (2 === t.length)
                            return t.join(" or ");
                        return t.slice(0, -1).join(", ") + ", or " + t.slice(-1)
                    }(i.map((function(t) {
                        return t[0]
                    }
                    ))) : i.reduce((function(t, e) {
                        return e.length > t.length ? e : t
                    }
                    ))
            }
        }
        ,
        a.equal = function(t) {
            return function(e) {
                if (e !== t)
                    return JSON.stringify(t)
            }
        }
        ,
        a.oneOf = function() {
            var t = (Array.isArray(arguments[0]) ? arguments[0] : Array.prototype.slice.call(arguments)).map((function(t) {
                return a.equal(t)
            }
            ));
            return a.oneOfType.apply(this, t)
        }
        ,
        a.range = function(t) {
            var e = t[0]
              , i = t[1];
            return function(t) {
                if (c(a.number, t) || t < e || t > i)
                    return "number between " + e + " & " + i + " (inclusive)"
            }
        }
        ,
        a.any = function() {}
        ,
        a.boolean = function(t) {
            if ("boolean" != typeof t)
                return "boolean"
        }
        ,
        a.number = function(t) {
            if ("number" != typeof t)
                return "number"
        }
        ,
        a.plainArray = function(t) {
            if (!Array.isArray(t))
                return "array"
        }
        ,
        a.plainObject = function(t) {
            if (!n(t))
                return "object"
        }
        ,
        a.string = function(t) {
            if ("string" != typeof t)
                return "string"
        }
        ,
        a.func = function(t) {
            if ("function" != typeof t)
                return "function"
        }
        ,
        a.validate = c,
        a.processMessage = h,
        t.exports = a
    },
    4010: function(t, e, i) {
        "use strict";
        var n = i(72543);
        t.exports = n
    },
    72543: function(t, e, i) {
        "use strict";
        var n = i(89366)
          , r = i(58503);
        function o(t) {
            r.call(this, t)
        }
        o.prototype = Object.create(r.prototype),
        o.prototype.constructor = o,
        o.prototype.sendRequest = n.browserSend,
        o.prototype.abortRequest = n.browserAbort,
        t.exports = function(t) {
            return new o(t)
        }
    },
    89366: function(t, e, i) {
        "use strict";
        var n = i(56293)
          , r = i(74404)
          , o = i(1835)
          , s = i(19614)
          , a = {};
        function l(t) {
            var e = t.total
              , i = t.loaded;
            return {
                total: e,
                transferred: i,
                percent: 100 * i / e
            }
        }
        function c(t, e) {
            return new Promise((function(i, n) {
                e.onprogress = function(e) {
                    t.emitter.emit(o.EVENT_PROGRESS_DOWNLOAD, l(e))
                }
                ;
                var s = t.file;
                s && (e.upload.onprogress = function(e) {
                    t.emitter.emit(o.EVENT_PROGRESS_UPLOAD, l(e))
                }
                ),
                e.onerror = function(t) {
                    n(t)
                }
                ,
                e.onabort = function() {
                    var e = new r({
                        request: t,
                        type: o.ERROR_REQUEST_ABORTED
                    });
                    n(e)
                }
                ,
                e.onload = function() {
                    if (delete a[t.id],
                    e.status < 200 || e.status >= 400) {
                        var o = new r({
                            request: t,
                            body: e.response,
                            statusCode: e.status
                        });
                        n(o)
                    } else
                        i(e)
                }
                ;
                var c = t.body;
                "string" == typeof c ? e.send(c) : c ? e.send(JSON.stringify(c)) : s ? e.send(s) : e.send(),
                a[t.id] = e
            }
            )).then((function(e) {
                return function(t, e) {
                    return new n(t,{
                        body: e.response,
                        headers: s(e.getAllResponseHeaders()),
                        statusCode: e.status
                    })
                }(t, e)
            }
            ))
        }
        function h(t, e) {
            var i = t.url(e)
              , n = new window.XMLHttpRequest;
            return n.open(t.method, i),
            Object.keys(t.headers).forEach((function(e) {
                n.setRequestHeader(e, t.headers[e])
            }
            )),
            n
        }
        t.exports = {
            browserAbort: function(t) {
                var e = a[t.id];
                e && (e.abort(),
                delete a[t.id])
            },
            sendRequestXhr: c,
            browserSend: function(t) {
                return Promise.resolve().then((function() {
                    var e = h(t, t.client.accessToken);
                    return c(t, e)
                }
                ))
            },
            createRequestXhr: h
        }
    },
    58503: function(t, e, i) {
        "use strict";
        var n = i(24713)
          , r = i(75225)
          , o = i(1835);
        function s(t) {
            if (!t || !t.accessToken)
                throw new Error("Cannot create a client without an access token");
            n(t.accessToken),
            this.accessToken = t.accessToken,
            this.origin = t.origin || o.API_ORIGIN
        }
        s.prototype.createRequest = function(t) {
            return new r(this,t)
        }
        ,
        t.exports = s
    },
    74404: function(t, e, i) {
        "use strict";
        var n = i(1835);
        t.exports = function(t) {
            var e, i = t.type || n.ERROR_HTTP;
            if (t.body)
                try {
                    e = JSON.parse(t.body)
                } catch (i) {
                    e = t.body
                }
            else
                e = null;
            var r = t.message || null;
            r || ("string" == typeof e ? r = e : e && "string" == typeof e.message ? r = e.message : i === n.ERROR_REQUEST_ABORTED && (r = "Request aborted")),
            this.message = r,
            this.type = i,
            this.statusCode = t.statusCode || null,
            this.request = t.request,
            this.body = e
        }
    },
    75225: function(t, e, i) {
        "use strict";
        var n = i(24713)
          , r = i(47529)
          , o = i(26729)
          , s = i(25959)
          , a = i(1835)
          , l = 1;
        function c(t, e) {
            if (!t)
                throw new Error("MapiRequest requires a client");
            if (!e || !e.path || !e.method)
                throw new Error("MapiRequest requires an options object with path and method properties");
            var i = {};
            e.body && (i["content-type"] = "application/json");
            var n = r(i, e.headers)
              , s = Object.keys(n).reduce((function(t, e) {
                return t[e.toLowerCase()] = n[e],
                t
            }
            ), {});
            this.id = l++,
            this._options = e,
            this.emitter = new o,
            this.client = t,
            this.response = null,
            this.error = null,
            this.sent = !1,
            this.aborted = !1,
            this.path = e.path,
            this.method = e.method,
            this.origin = e.origin || t.origin,
            this.query = e.query || {},
            this.params = e.params || {},
            this.body = e.body || null,
            this.file = e.file || null,
            this.encoding = e.encoding || "utf8",
            this.sendFileAs = e.sendFileAs || null,
            this.headers = s
        }
        c.prototype.url = function(t) {
            var e = s.prependOrigin(this.path, this.origin);
            e = s.appendQueryObject(e, this.query);
            var i = this.params
              , o = null == t ? this.client.accessToken : t;
            if (o) {
                e = s.appendQueryParam(e, "access_token", o);
                var a = n(o).user;
                i = r({
                    ownerId: a
                }, i)
            }
            return e = s.interpolateRouteParams(e, i),
            e
        }
        ,
        c.prototype.send = function() {
            var t = this;
            if (t.sent)
                throw new Error("This request has already been sent. Check the response and error properties. Create a new request with clone().");
            return t.sent = !0,
            t.client.sendRequest(t).then((function(e) {
                return t.response = e,
                t.emitter.emit(a.EVENT_RESPONSE, e),
                e
            }
            ), (function(e) {
                throw t.error = e,
                t.emitter.emit(a.EVENT_ERROR, e),
                e
            }
            ))
        }
        ,
        c.prototype.abort = function() {
            this._nextPageRequest && (this._nextPageRequest.abort(),
            delete this._nextPageRequest),
            this.response || this.error || this.aborted || (this.aborted = !0,
            this.client.abortRequest(this))
        }
        ,
        c.prototype.eachPage = function(t) {
            var e = this;
            function i(i) {
                t(null, i, (function() {
                    delete e._nextPageRequest;
                    var t = i.nextPage();
                    t && (e._nextPageRequest = t,
                    r(t))
                }
                ))
            }
            function n(e) {
                t(e, null, (function() {}
                ))
            }
            function r(t) {
                t.send().then(i, n)
            }
            r(this)
        }
        ,
        c.prototype.clone = function() {
            return this._extend()
        }
        ,
        c.prototype._extend = function(t) {
            var e = r(this._options, t);
            return new c(this.client,e)
        }
        ,
        t.exports = c
    },
    56293: function(t, e, i) {
        "use strict";
        var n = i(94626);
        function r(t, e) {
            this.request = t,
            this.headers = e.headers,
            this.rawBody = e.body,
            this.statusCode = e.statusCode;
            try {
                this.body = JSON.parse(e.body || "{}")
            } catch (t) {
                this.body = e.body
            }
            this.links = n(this.headers.link)
        }
        r.prototype.hasNextPage = function() {
            return !!this.links.next
        }
        ,
        r.prototype.nextPage = function() {
            return this.hasNextPage() ? this.request._extend({
                path: this.links.next.url
            }) : null
        }
        ,
        t.exports = r
    },
    1835: function(t) {
        "use strict";
        t.exports = {
            API_ORIGIN: "https://api.mapbox.com",
            EVENT_PROGRESS_DOWNLOAD: "downloadProgress",
            EVENT_PROGRESS_UPLOAD: "uploadProgress",
            EVENT_ERROR: "error",
            EVENT_RESPONSE: "response",
            ERROR_HTTP: "HttpError",
            ERROR_REQUEST_ABORTED: "RequestAbortedError"
        }
    },
    19614: function(t) {
        "use strict";
        t.exports = function(t) {
            var e = {};
            return t ? (t.trim().split(/[\r|\n]+/).forEach((function(t) {
                var i = function(t) {
                    var e = t.indexOf(":");
                    return {
                        name: t.substring(0, e).trim().toLowerCase(),
                        value: t.substring(e + 1).trim()
                    }
                }(t);
                e[i.name] = i.value
            }
            )),
            e) : e
        }
    },
    94626: function(t) {
        "use strict";
        t.exports = function(t) {
            return t ? t.split(/,\s*</).reduce((function(t, e) {
                var i = function(t) {
                    var e = t.match(/<?([^>]*)>(.*)/);
                    if (!e)
                        return null;
                    var i = e[1]
                      , n = e[2].split(";")
                      , r = null
                      , o = n.reduce((function(t, e) {
                        var i = function(t) {
                            var e = t.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
                            return e ? {
                                key: e[1],
                                value: e[2]
                            } : null
                        }(e);
                        return i ? "rel" === i.key ? (r || (r = i.value),
                        t) : (t[i.key] = i.value,
                        t) : t
                    }
                    ), {});
                    return r ? {
                        url: i,
                        rel: r,
                        params: o
                    } : null
                }(e);
                return i ? (i.rel.split(/\s+/).forEach((function(e) {
                    t[e] || (t[e] = {
                        url: i.url,
                        params: i.params
                    })
                }
                )),
                t) : t
            }
            ), {}) : {}
        }
    },
    25959: function(t) {
        "use strict";
        function e(t) {
            return Array.isArray(t) ? t.map(encodeURIComponent).join(",") : encodeURIComponent(String(t))
        }
        function i(t, i, n) {
            if (!1 === n || null === n)
                return t;
            var r = /\?/.test(t) ? "&" : "?"
              , o = encodeURIComponent(i);
            return void 0 !== n && "" !== n && !0 !== n && (o += "=" + e(n)),
            "" + t + r + o
        }
        t.exports = {
            appendQueryObject: function(t, e) {
                if (!e)
                    return t;
                var n = t;
                return Object.keys(e).forEach((function(t) {
                    var r = e[t];
                    void 0 !== r && (Array.isArray(r) && (r = r.filter((function(t) {
                        return null != t
                    }
                    )).join(",")),
                    n = i(n, t, r))
                }
                )),
                n
            },
            appendQueryParam: i,
            prependOrigin: function(t, e) {
                if (!e)
                    return t;
                if ("http" === t.slice(0, 4))
                    return t;
                var i = "/" === t[0] ? "" : "/";
                return "" + e.replace(/\/$/, "") + i + t
            },
            interpolateRouteParams: function(t, i) {
                return i ? t.replace(/\/:([a-zA-Z0-9]+)/g, (function(t, n) {
                    var r = i[n];
                    if (void 0 === r)
                        throw new Error("Unspecified route parameter " + n);
                    return "/" + e(r)
                }
                )) : t
            }
        }
    },
    52081: function(t, e, i) {
        "use strict";
        var n = i(47529)
          , r = i(61222)
          , o = i(92497)
          , s = i(33886)
          , a = i(93222)
          , l = {}
          , c = ["country", "region", "postcode", "district", "place", "locality", "neighborhood", "address", "poi", "poi.landmark"];
        l.forwardGeocode = function(t) {
            r.assertShape({
                query: r.required(r.string),
                mode: r.oneOf("mapbox.places", "mapbox.places-permanent"),
                countries: r.arrayOf(r.string),
                proximity: r.oneOf(r.coordinates, "ip"),
                types: r.arrayOf(r.oneOf(c)),
                autocomplete: r.boolean,
                bbox: r.arrayOf(r.number),
                limit: r.number,
                language: r.arrayOf(r.string),
                routing: r.boolean,
                fuzzyMatch: r.boolean,
                worldview: r.string
            })(t),
            t.mode = t.mode || "mapbox.places";
            var e = s(n({
                country: t.countries
            }, o(t, ["proximity", "types", "autocomplete", "bbox", "limit", "language", "routing", "fuzzyMatch", "worldview"])));
            return this.client.createRequest({
                method: "GET",
                path: "/geocoding/v5/:mode/:query.json",
                params: o(t, ["mode", "query"]),
                query: e
            })
        }
        ,
        l.reverseGeocode = function(t) {
            r.assertShape({
                query: r.required(r.coordinates),
                mode: r.oneOf("mapbox.places", "mapbox.places-permanent"),
                countries: r.arrayOf(r.string),
                types: r.arrayOf(r.oneOf(c)),
                bbox: r.arrayOf(r.number),
                limit: r.number,
                language: r.arrayOf(r.string),
                reverseMode: r.oneOf("distance", "score"),
                routing: r.boolean,
                worldview: r.string
            })(t),
            t.mode = t.mode || "mapbox.places";
            var e = s(n({
                country: t.countries
            }, o(t, ["country", "types", "bbox", "limit", "language", "reverseMode", "routing", "worldview"])));
            return this.client.createRequest({
                method: "GET",
                path: "/geocoding/v5/:mode/:query.json",
                params: o(t, ["mode", "query"]),
                query: e
            })
        }
        ,
        t.exports = a(l)
    },
    93222: function(t, e, i) {
        "use strict";
        var n = i(58503)
          , r = i(72543);
        t.exports = function(t) {
            return function(e) {
                var i;
                i = n.prototype.isPrototypeOf(e) ? e : r(e);
                var o = Object.create(t);
                return o.client = i,
                o
            }
        }
    },
    14436: function(t) {
        "use strict";
        t.exports = function(t, e) {
            return Object.keys(t).reduce((function(i, n) {
                return i[n] = e(n, t[n]),
                i
            }
            ), {})
        }
    },
    92497: function(t) {
        "use strict";
        t.exports = function(t, e) {
            var i = function(t, i) {
                return -1 !== e.indexOf(t) && void 0 !== i
            };
            return "function" == typeof e && (i = e),
            Object.keys(t).filter((function(e) {
                return i(e, t[e])
            }
            )).reduce((function(e, i) {
                return e[i] = t[i],
                e
            }
            ), {})
        }
    },
    33886: function(t, e, i) {
        "use strict";
        var n = i(14436);
        t.exports = function(t) {
            return n(t, (function(t, e) {
                return "boolean" == typeof e ? JSON.stringify(e) : e
            }
            ))
        }
    },
    61222: function(t, e, i) {
        "use strict";
        var n = i(47529)
          , r = i(24532);
        t.exports = n(r, {
            file: function(t) {
                if ("undefined" != typeof window) {
                    if (t instanceof i.g.Blob || t instanceof i.g.ArrayBuffer)
                        return;
                    return "Blob or ArrayBuffer"
                }
                if ("string" != typeof t && void 0 === t.pipe)
                    return "Filename or Readable stream"
            },
            date: function(t) {
                var e = "date";
                if ("boolean" == typeof t)
                    return e;
                try {
                    var i = new Date(t);
                    if (i.getTime && isNaN(i.getTime()))
                        return e
                } catch (t) {
                    return e
                }
            },
            coordinates: function(t) {
                return r.tuple(r.number, r.number)(t)
            },
            assertShape: function(t, e) {
                return r.assert(r.strictShape(t), e)
            }
        })
    },
    24713: function(t, e, i) {
        "use strict";
        var n = i(97501)
          , r = {};
        function o(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }
        t.exports = function(t) {
            if (r[t])
                return r[t];
            var e = t.split(".")
              , i = e[0]
              , s = e[1];
            if (!s)
                throw new Error("Invalid token");
            var a = function(t) {
                try {
                    return JSON.parse(n.decode(t))
                } catch (t) {
                    throw new Error("Invalid token")
                }
            }(s)
              , l = {
                usage: i,
                user: a.u
            };
            return o(a, "a") && (l.authorization = a.a),
            o(a, "exp") && (l.expires = 1e3 * a.exp),
            o(a, "iat") && (l.created = 1e3 * a.iat),
            o(a, "scopes") && (l.scopes = a.scopes),
            o(a, "client") && (l.client = a.client),
            o(a, "ll") && (l.lastLogin = a.ll),
            o(a, "iu") && (l.impersonator = a.iu),
            r[t] = l,
            l
        }
    },
    25715: function(t, e, i) {
        "use strict";
        i.r(e),
        i.d(e, {
            default: function() {
                return M
            }
        });
        i(34155);
        var n = i(25108);
        function r() {
            return r = Object.assign ? Object.assign.bind() : function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var n in i)
                        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                }
                return t
            }
            ,
            r.apply(this, arguments)
        }
        function o(t) {
            return o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t)
            }
            ,
            o(t)
        }
        function s(t, e) {
            return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e,
                t
            }
            ,
            s(t, e)
        }
        function a(t, e, i) {
            return a = function() {
                if ("undefined" == typeof Reflect || !Reflect.construct)
                    return !1;
                if (Reflect.construct.sham)
                    return !1;
                if ("function" == typeof Proxy)
                    return !0;
                try {
                    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                    ))),
                    !0
                } catch (t) {
                    return !1
                }
            }() ? Reflect.construct.bind() : function(t, e, i) {
                var n = [null];
                n.push.apply(n, e);
                var r = new (Function.bind.apply(t, n));
                return i && s(r, i.prototype),
                r
            }
            ,
            a.apply(null, arguments)
        }
        function l(t) {
            var e = "function" == typeof Map ? new Map : void 0;
            return l = function(t) {
                if (null === t || (i = t,
                -1 === Function.toString.call(i).indexOf("[native code]")))
                    return t;
                var i;
                if ("function" != typeof t)
                    throw new TypeError("Super expression must either be null or a function");
                if (void 0 !== e) {
                    if (e.has(t))
                        return e.get(t);
                    e.set(t, n)
                }
                function n() {
                    return a(t, arguments, o(this).constructor)
                }
                return n.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: n,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }),
                s(n, t)
            }
            ,
            l(t)
        }
        var c = /%[sdj%]/g;
        function h(t) {
            if (!t || !t.length)
                return null;
            var e = {};
            return t.forEach((function(t) {
                var i = t.field;
                e[i] = e[i] || [],
                e[i].push(t)
            }
            )),
            e
        }
        function u(t) {
            for (var e = arguments.length, i = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
                i[n - 1] = arguments[n];
            var r = 0
              , o = i.length;
            return "function" == typeof t ? t.apply(null, i) : "string" == typeof t ? t.replace(c, (function(t) {
                if ("%%" === t)
                    return "%";
                if (r >= o)
                    return t;
                switch (t) {
                case "%s":
                    return String(i[r++]);
                case "%d":
                    return Number(i[r++]);
                case "%j":
                    try {
                        return JSON.stringify(i[r++])
                    } catch (t) {
                        return "[Circular]"
                    }
                    break;
                default:
                    return t
                }
            }
            )) : t
        }
        function d(t, e) {
            return null == t || (!("array" !== e || !Array.isArray(t) || t.length) || !(!function(t) {
                return "string" === t || "url" === t || "hex" === t || "email" === t || "date" === t || "pattern" === t
            }(e) || "string" != typeof t || t))
        }
        function f(t, e, i) {
            var n = 0
              , r = t.length;
            !function o(s) {
                if (s && s.length)
                    i(s);
                else {
                    var a = n;
                    n += 1,
                    a < r ? e(t[a], o) : i([])
                }
            }([])
        }
        var p = function(t) {
            var e, i;
            function n(e, i) {
                var n;
                return (n = t.call(this, "Async Validation Error") || this).errors = e,
                n.fields = i,
                n
            }
            return i = t,
            (e = n).prototype = Object.create(i.prototype),
            e.prototype.constructor = e,
            s(e, i),
            n
        }(l(Error));
        function m(t, e, i, n, r) {
            if (e.first) {
                var o = new Promise((function(e, o) {
                    var s = function(t) {
                        var e = [];
                        return Object.keys(t).forEach((function(i) {
                            e.push.apply(e, t[i] || [])
                        }
                        )),
                        e
                    }(t);
                    f(s, i, (function(t) {
                        return n(t),
                        t.length ? o(new p(t,h(t))) : e(r)
                    }
                    ))
                }
                ));
                return o.catch((function(t) {
                    return t
                }
                )),
                o
            }
            var s = !0 === e.firstFields ? Object.keys(t) : e.firstFields || []
              , a = Object.keys(t)
              , l = a.length
              , c = 0
              , u = []
              , d = new Promise((function(e, o) {
                var d = function(t) {
                    if (u.push.apply(u, t),
                    ++c === l)
                        return n(u),
                        u.length ? o(new p(u,h(u))) : e(r)
                };
                a.length || (n(u),
                e(r)),
                a.forEach((function(e) {
                    var n = t[e];
                    -1 !== s.indexOf(e) ? f(n, i, d) : function(t, e, i) {
                        var n = []
                          , r = 0
                          , o = t.length;
                        function s(t) {
                            n.push.apply(n, t || []),
                            ++r === o && i(n)
                        }
                        t.forEach((function(t) {
                            e(t, s)
                        }
                        ))
                    }(n, i, d)
                }
                ))
            }
            ));
            return d.catch((function(t) {
                return t
            }
            )),
            d
        }
        function g(t, e) {
            return function(i) {
                var n, r;
                return n = t.fullFields ? function(t, e) {
                    for (var i = t, n = 0; n < e.length; n++) {
                        if (null == i)
                            return i;
                        i = i[e[n]]
                    }
                    return i
                }(e, t.fullFields) : e[i.field || t.fullField],
                (r = i) && void 0 !== r.message ? (i.field = i.field || t.fullField,
                i.fieldValue = n,
                i) : {
                    message: "function" == typeof i ? i() : i,
                    fieldValue: n,
                    field: i.field || t.fullField
                }
            }
        }
        function _(t, e) {
            if (e)
                for (var i in e)
                    if (e.hasOwnProperty(i)) {
                        var n = e[i];
                        "object" == typeof n && "object" == typeof t[i] ? t[i] = r({}, t[i], n) : t[i] = n
                    }
            return t
        }
        var y, v = function(t, e, i, n, r, o) {
            !t.required || i.hasOwnProperty(t.field) && !d(e, o || t.type) || n.push(u(r.messages.required, t.fullField))
        }, x = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/, b = /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i, w = {
            integer: function(t) {
                return w.number(t) && parseInt(t, 10) === t
            },
            float: function(t) {
                return w.number(t) && !w.integer(t)
            },
            array: function(t) {
                return Array.isArray(t)
            },
            regexp: function(t) {
                if (t instanceof RegExp)
                    return !0;
                try {
                    return !!new RegExp(t)
                } catch (t) {
                    return !1
                }
            },
            date: function(t) {
                return "function" == typeof t.getTime && "function" == typeof t.getMonth && "function" == typeof t.getYear && !isNaN(t.getTime())
            },
            number: function(t) {
                return !isNaN(t) && "number" == typeof t
            },
            object: function(t) {
                return "object" == typeof t && !w.array(t)
            },
            method: function(t) {
                return "function" == typeof t
            },
            email: function(t) {
                return "string" == typeof t && t.length <= 320 && !!t.match(x)
            },
            url: function(t) {
                return "string" == typeof t && t.length <= 2048 && !!t.match(function() {
                    if (y)
                        return y;
                    var t = "[a-fA-F\\d:]"
                      , e = function(e) {
                        return e && e.includeBoundaries ? "(?:(?<=\\s|^)(?=" + t + ")|(?<=" + t + ")(?=\\s|$))" : ""
                    }
                      , i = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}"
                      , n = "[a-fA-F\\d]{1,4}"
                      , r = ("\n(?:\n(?:" + n + ":){7}(?:" + n + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + n + ":){6}(?:" + i + "|:" + n + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + n + ":){5}(?::" + i + "|(?::" + n + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + n + ":){4}(?:(?::" + n + "){0,1}:" + i + "|(?::" + n + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + n + ":){3}(?:(?::" + n + "){0,2}:" + i + "|(?::" + n + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + n + ":){2}(?:(?::" + n + "){0,3}:" + i + "|(?::" + n + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + n + ":){1}(?:(?::" + n + "){0,4}:" + i + "|(?::" + n + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + n + "){0,5}:" + i + "|(?::" + n + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim()
                      , o = new RegExp("(?:^" + i + "$)|(?:^" + r + "$)")
                      , s = new RegExp("^" + i + "$")
                      , a = new RegExp("^" + r + "$")
                      , l = function(t) {
                        return t && t.exact ? o : new RegExp("(?:" + e(t) + i + e(t) + ")|(?:" + e(t) + r + e(t) + ")","g")
                    };
                    l.v4 = function(t) {
                        return t && t.exact ? s : new RegExp("" + e(t) + i + e(t),"g")
                    }
                    ,
                    l.v6 = function(t) {
                        return t && t.exact ? a : new RegExp("" + e(t) + r + e(t),"g")
                    }
                    ;
                    var c = l.v4().source
                      , h = l.v6().source;
                    return y = new RegExp("(?:^(?:(?:(?:[a-z]+:)?//)|www\\.)(?:\\S+(?::\\S*)?@)?(?:localhost|" + c + "|" + h + '|(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#][^\\s"]*)?$)',"i")
                }())
            },
            hex: function(t) {
                return "string" == typeof t && !!t.match(b)
            }
        }, E = "enum", T = {
            required: v,
            whitespace: function(t, e, i, n, r) {
                (/^\s+$/.test(e) || "" === e) && n.push(u(r.messages.whitespace, t.fullField))
            },
            type: function(t, e, i, n, r) {
                if (t.required && void 0 === e)
                    v(t, e, i, n, r);
                else {
                    var o = t.type;
                    ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"].indexOf(o) > -1 ? w[o](e) || n.push(u(r.messages.types[o], t.fullField, t.type)) : o && typeof e !== t.type && n.push(u(r.messages.types[o], t.fullField, t.type))
                }
            },
            range: function(t, e, i, n, r) {
                var o = "number" == typeof t.len
                  , s = "number" == typeof t.min
                  , a = "number" == typeof t.max
                  , l = e
                  , c = null
                  , h = "number" == typeof e
                  , d = "string" == typeof e
                  , f = Array.isArray(e);
                if (h ? c = "number" : d ? c = "string" : f && (c = "array"),
                !c)
                    return !1;
                f && (l = e.length),
                d && (l = e.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "_").length),
                o ? l !== t.len && n.push(u(r.messages[c].len, t.fullField, t.len)) : s && !a && l < t.min ? n.push(u(r.messages[c].min, t.fullField, t.min)) : a && !s && l > t.max ? n.push(u(r.messages[c].max, t.fullField, t.max)) : s && a && (l < t.min || l > t.max) && n.push(u(r.messages[c].range, t.fullField, t.min, t.max))
            },
            enum: function(t, e, i, n, r) {
                t[E] = Array.isArray(t[E]) ? t[E] : [],
                -1 === t[E].indexOf(e) && n.push(u(r.messages[E], t.fullField, t[E].join(", ")))
            },
            pattern: function(t, e, i, n, r) {
                if (t.pattern)
                    if (t.pattern instanceof RegExp)
                        t.pattern.lastIndex = 0,
                        t.pattern.test(e) || n.push(u(r.messages.pattern.mismatch, t.fullField, e, t.pattern));
                    else if ("string" == typeof t.pattern) {
                        new RegExp(t.pattern).test(e) || n.push(u(r.messages.pattern.mismatch, t.fullField, e, t.pattern))
                    }
            }
        }, S = function(t, e, i, n, r) {
            var o = t.type
              , s = [];
            if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                if (d(e, o) && !t.required)
                    return i();
                T.required(t, e, n, s, r, o),
                d(e, o) || T.type(t, e, n, s, r)
            }
            i(s)
        }, C = {
            string: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e, "string") && !t.required)
                        return i();
                    T.required(t, e, n, o, r, "string"),
                    d(e, "string") || (T.type(t, e, n, o, r),
                    T.range(t, e, n, o, r),
                    T.pattern(t, e, n, o, r),
                    !0 === t.whitespace && T.whitespace(t, e, n, o, r))
                }
                i(o)
            },
            method: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && T.type(t, e, n, o, r)
                }
                i(o)
            },
            number: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if ("" === e && (e = void 0),
                    d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && (T.type(t, e, n, o, r),
                    T.range(t, e, n, o, r))
                }
                i(o)
            },
            boolean: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && T.type(t, e, n, o, r)
                }
                i(o)
            },
            regexp: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    d(e) || T.type(t, e, n, o, r)
                }
                i(o)
            },
            integer: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && (T.type(t, e, n, o, r),
                    T.range(t, e, n, o, r))
                }
                i(o)
            },
            float: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && (T.type(t, e, n, o, r),
                    T.range(t, e, n, o, r))
                }
                i(o)
            },
            array: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (null == e && !t.required)
                        return i();
                    T.required(t, e, n, o, r, "array"),
                    null != e && (T.type(t, e, n, o, r),
                    T.range(t, e, n, o, r))
                }
                i(o)
            },
            object: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && T.type(t, e, n, o, r)
                }
                i(o)
            },
            enum: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    void 0 !== e && T.enum(t, e, n, o, r)
                }
                i(o)
            },
            pattern: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e, "string") && !t.required)
                        return i();
                    T.required(t, e, n, o, r),
                    d(e, "string") || T.pattern(t, e, n, o, r)
                }
                i(o)
            },
            date: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e, "date") && !t.required)
                        return i();
                    var s;
                    if (T.required(t, e, n, o, r),
                    !d(e, "date"))
                        s = e instanceof Date ? e : new Date(e),
                        T.type(t, s, n, o, r),
                        s && T.range(t, s.getTime(), n, o, r)
                }
                i(o)
            },
            url: S,
            hex: S,
            email: S,
            required: function(t, e, i, n, r) {
                var o = []
                  , s = Array.isArray(e) ? "array" : typeof e;
                T.required(t, e, n, o, r, s),
                i(o)
            },
            any: function(t, e, i, n, r) {
                var o = [];
                if (t.required || !t.required && n.hasOwnProperty(t.field)) {
                    if (d(e) && !t.required)
                        return i();
                    T.required(t, e, n, o, r)
                }
                i(o)
            }
        };
        function A() {
            return {
                default: "Validation error on field %s",
                required: "%s is required",
                enum: "%s must be one of %s",
                whitespace: "%s cannot be empty",
                date: {
                    format: "%s date %s is invalid for format %s",
                    parse: "%s date could not be parsed, %s is invalid ",
                    invalid: "%s date %s is invalid"
                },
                types: {
                    string: "%s is not a %s",
                    method: "%s is not a %s (function)",
                    array: "%s is not an %s",
                    object: "%s is not an %s",
                    number: "%s is not a %s",
                    date: "%s is not a %s",
                    boolean: "%s is not a %s",
                    integer: "%s is not an %s",
                    float: "%s is not a %s",
                    regexp: "%s is not a valid %s",
                    email: "%s is not a valid %s",
                    url: "%s is not a valid %s",
                    hex: "%s is not a valid %s"
                },
                string: {
                    len: "%s must be exactly %s characters",
                    min: "%s must be at least %s characters",
                    max: "%s cannot be longer than %s characters",
                    range: "%s must be between %s and %s characters"
                },
                number: {
                    len: "%s must equal %s",
                    min: "%s cannot be less than %s",
                    max: "%s cannot be greater than %s",
                    range: "%s must be between %s and %s"
                },
                array: {
                    len: "%s must be exactly %s in length",
                    min: "%s cannot be less than %s in length",
                    max: "%s cannot be greater than %s in length",
                    range: "%s must be between %s and %s in length"
                },
                pattern: {
                    mismatch: "%s value %s does not match pattern %s"
                },
                clone: function() {
                    var t = JSON.parse(JSON.stringify(this));
                    return t.clone = this.clone,
                    t
                }
            }
        }
        var I = A()
          , M = function() {
            function t(t) {
                this.rules = null,
                this._messages = I,
                this.define(t)
            }
            var e = t.prototype;
            return e.define = function(t) {
                var e = this;
                if (!t)
                    throw new Error("Cannot configure a schema with no rules");
                if ("object" != typeof t || Array.isArray(t))
                    throw new Error("Rules must be an object");
                this.rules = {},
                Object.keys(t).forEach((function(i) {
                    var n = t[i];
                    e.rules[i] = Array.isArray(n) ? n : [n]
                }
                ))
            }
            ,
            e.messages = function(t) {
                return t && (this._messages = _(A(), t)),
                this._messages
            }
            ,
            e.validate = function(e, i, o) {
                var s = this;
                void 0 === i && (i = {}),
                void 0 === o && (o = function() {}
                );
                var a = e
                  , l = i
                  , c = o;
                if ("function" == typeof l && (c = l,
                l = {}),
                !this.rules || 0 === Object.keys(this.rules).length)
                    return c && c(null, a),
                    Promise.resolve(a);
                if (l.messages) {
                    var d = this.messages();
                    d === I && (d = A()),
                    _(d, l.messages),
                    l.messages = d
                } else
                    l.messages = this.messages();
                var f = {};
                (l.keys || Object.keys(this.rules)).forEach((function(t) {
                    var i = s.rules[t]
                      , n = a[t];
                    i.forEach((function(i) {
                        var o = i;
                        "function" == typeof o.transform && (a === e && (a = r({}, a)),
                        n = a[t] = o.transform(n)),
                        (o = "function" == typeof o ? {
                            validator: o
                        } : r({}, o)).validator = s.getValidationMethod(o),
                        o.validator && (o.field = t,
                        o.fullField = o.fullField || t,
                        o.type = s.getType(o),
                        f[t] = f[t] || [],
                        f[t].push({
                            rule: o,
                            value: n,
                            source: a,
                            field: t
                        }))
                    }
                    ))
                }
                ));
                var p = {};
                return m(f, l, (function(e, i) {
                    var o, s = e.rule, c = !("object" !== s.type && "array" !== s.type || "object" != typeof s.fields && "object" != typeof s.defaultField);
                    function h(t, e) {
                        return r({}, e, {
                            fullField: s.fullField + "." + t,
                            fullFields: s.fullFields ? [].concat(s.fullFields, [t]) : [t]
                        })
                    }
                    function d(n) {
                        void 0 === n && (n = []);
                        var o = Array.isArray(n) ? n : [n];
                        !l.suppressWarning && o.length && t.warning("async-validator:", o),
                        o.length && void 0 !== s.message && (o = [].concat(s.message));
                        var d = o.map(g(s, a));
                        if (l.first && d.length)
                            return p[s.field] = 1,
                            i(d);
                        if (c) {
                            if (s.required && !e.value)
                                return void 0 !== s.message ? d = [].concat(s.message).map(g(s, a)) : l.error && (d = [l.error(s, u(l.messages.required, s.field))]),
                                i(d);
                            var f = {};
                            s.defaultField && Object.keys(e.value).map((function(t) {
                                f[t] = s.defaultField
                            }
                            )),
                            f = r({}, f, e.rule.fields);
                            var m = {};
                            Object.keys(f).forEach((function(t) {
                                var e = f[t]
                                  , i = Array.isArray(e) ? e : [e];
                                m[t] = i.map(h.bind(null, t))
                            }
                            ));
                            var _ = new t(m);
                            _.messages(l.messages),
                            e.rule.options && (e.rule.options.messages = l.messages,
                            e.rule.options.error = l.error),
                            _.validate(e.value, e.rule.options || l, (function(t) {
                                var e = [];
                                d && d.length && e.push.apply(e, d),
                                t && t.length && e.push.apply(e, t),
                                i(e.length ? e : null)
                            }
                            ))
                        } else
                            i(d)
                    }
                    if (c = c && (s.required || !s.required && e.value),
                    s.field = e.field,
                    s.asyncValidator)
                        o = s.asyncValidator(s, e.value, d, e.source, l);
                    else if (s.validator) {
                        try {
                            o = s.validator(s, e.value, d, e.source, l)
                        } catch (t) {
                            null == n.error || n.error(t),
                            l.suppressValidatorError || setTimeout((function() {
                                throw t
                            }
                            ), 0),
                            d(t.message)
                        }
                        !0 === o ? d() : !1 === o ? d("function" == typeof s.message ? s.message(s.fullField || s.field) : s.message || (s.fullField || s.field) + " fails") : o instanceof Array ? d(o) : o instanceof Error && d(o.message)
                    }
                    o && o.then && o.then((function() {
                        return d()
                    }
                    ), (function(t) {
                        return d(t)
                    }
                    ))
                }
                ), (function(t) {
                    !function(t) {
                        for (var e, i, n = [], r = {}, o = 0; o < t.length; o++)
                            e = t[o],
                            i = void 0,
                            Array.isArray(e) ? n = (i = n).concat.apply(i, e) : n.push(e);
                        n.length ? (r = h(n),
                        c(n, r)) : c(null, a)
                    }(t)
                }
                ), a)
            }
            ,
            e.getType = function(t) {
                if (void 0 === t.type && t.pattern instanceof RegExp && (t.type = "pattern"),
                "function" != typeof t.validator && t.type && !C.hasOwnProperty(t.type))
                    throw new Error(u("Unknown rule type %s", t.type));
                return t.type || "string"
            }
            ,
            e.getValidationMethod = function(t) {
                if ("function" == typeof t.validator)
                    return t.validator;
                var e = Object.keys(t)
                  , i = e.indexOf("message");
                return -1 !== i && e.splice(i, 1),
                1 === e.length && "required" === e[0] ? C.required : C[this.getType(t)] || void 0
            }
            ,
            t
        }();
        M.register = function(t, e) {
            if ("function" != typeof e)
                throw new Error("Cannot register a validator by type, validator is not a function");
            C[t] = e
        }
        ,
        M.warning = function() {}
        ,
        M.messages = I,
        M.validators = C
    },
    41800: function(t, e, i) {
        "use strict";
        function n(t, e) {
            return t.then((function(t) {
                return [null, t]
            }
            )).catch((function(t) {
                return e && Object.assign(t, e),
                [t, void 0]
            }
            ))
        }
        i.d(e, {
            to: function() {
                return n
            }
        }),
        e.Z = n
    },
    97501: function(t, e, i) {
        var n;
        t = i.nmd(t),
        function(r) {
            var o = e
              , s = (t && t.exports,
            "object" == typeof i.g && i.g);
            s.global !== s && s.window;
            var a = function(t) {
                this.message = t
            };
            (a.prototype = new Error).name = "InvalidCharacterError";
            var l = function(t) {
                throw new a(t)
            }
              , c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
              , h = /[\t\n\f\r ]/g
              , u = {
                encode: function(t) {
                    t = String(t),
                    /[^\0-\xFF]/.test(t) && l("The string to be encoded contains characters outside of the Latin1 range.");
                    for (var e, i, n, r, o = t.length % 3, s = "", a = -1, h = t.length - o; ++a < h; )
                        e = t.charCodeAt(a) << 16,
                        i = t.charCodeAt(++a) << 8,
                        n = t.charCodeAt(++a),
                        s += c.charAt((r = e + i + n) >> 18 & 63) + c.charAt(r >> 12 & 63) + c.charAt(r >> 6 & 63) + c.charAt(63 & r);
                    return 2 == o ? (e = t.charCodeAt(a) << 8,
                    i = t.charCodeAt(++a),
                    s += c.charAt((r = e + i) >> 10) + c.charAt(r >> 4 & 63) + c.charAt(r << 2 & 63) + "=") : 1 == o && (r = t.charCodeAt(a),
                    s += c.charAt(r >> 2) + c.charAt(r << 4 & 63) + "=="),
                    s
                },
                decode: function(t) {
                    var e = (t = String(t).replace(h, "")).length;
                    e % 4 == 0 && (e = (t = t.replace(/==?$/, "")).length),
                    (e % 4 == 1 || /[^+a-zA-Z0-9/]/.test(t)) && l("Invalid character: the string to be decoded is not correctly encoded.");
                    for (var i, n, r = 0, o = "", s = -1; ++s < e; )
                        n = c.indexOf(t.charAt(s)),
                        i = r % 4 ? 64 * i + n : n,
                        r++ % 4 && (o += String.fromCharCode(255 & i >> (-2 * r & 6)));
                    return o
                },
                version: "0.1.0"
            };
            void 0 === (n = function() {
                return u
            }
            .call(e, i, e, t)) || (t.exports = n)
        }()
    },
    79742: function(t, e) {
        "use strict";
        e.byteLength = function(t) {
            var e = a(t)
              , i = e[0]
              , n = e[1];
            return 3 * (i + n) / 4 - n
        }
        ,
        e.toByteArray = function(t) {
            var e, i, o = a(t), s = o[0], l = o[1], c = new r(function(t, e, i) {
                return 3 * (e + i) / 4 - i
            }(0, s, l)), h = 0, u = l > 0 ? s - 4 : s;
            for (i = 0; i < u; i += 4)
                e = n[t.charCodeAt(i)] << 18 | n[t.charCodeAt(i + 1)] << 12 | n[t.charCodeAt(i + 2)] << 6 | n[t.charCodeAt(i + 3)],
                c[h++] = e >> 16 & 255,
                c[h++] = e >> 8 & 255,
                c[h++] = 255 & e;
            2 === l && (e = n[t.charCodeAt(i)] << 2 | n[t.charCodeAt(i + 1)] >> 4,
            c[h++] = 255 & e);
            1 === l && (e = n[t.charCodeAt(i)] << 10 | n[t.charCodeAt(i + 1)] << 4 | n[t.charCodeAt(i + 2)] >> 2,
            c[h++] = e >> 8 & 255,
            c[h++] = 255 & e);
            return c
        }
        ,
        e.fromByteArray = function(t) {
            for (var e, n = t.length, r = n % 3, o = [], s = 16383, a = 0, c = n - r; a < c; a += s)
                o.push(l(t, a, a + s > c ? c : a + s));
            1 === r ? (e = t[n - 1],
            o.push(i[e >> 2] + i[e << 4 & 63] + "==")) : 2 === r && (e = (t[n - 2] << 8) + t[n - 1],
            o.push(i[e >> 10] + i[e >> 4 & 63] + i[e << 2 & 63] + "="));
            return o.join("")
        }
        ;
        for (var i = [], n = [], r = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s)
            i[s] = o[s],
            n[o.charCodeAt(s)] = s;
        function a(t) {
            var e = t.length;
            if (e % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
            var i = t.indexOf("=");
            return -1 === i && (i = e),
            [i, i === e ? 0 : 4 - i % 4]
        }
        function l(t, e, n) {
            for (var r, o, s = [], a = e; a < n; a += 3)
                r = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]),
                s.push(i[(o = r) >> 18 & 63] + i[o >> 12 & 63] + i[o >> 6 & 63] + i[63 & o]);
            return s.join("")
        }
        n["-".charCodeAt(0)] = 62,
        n["_".charCodeAt(0)] = 63
    },
    48764: function(t, e, i) {
        "use strict";
        var n = i(25108);
        const r = i(79742)
          , o = i(80645)
          , s = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        e.lW = c,
        e.h2 = 50;
        const a = 2147483647;
        function l(t) {
            if (t > a)
                throw new RangeError('The value "' + t + '" is invalid for option "size"');
            const e = new Uint8Array(t);
            return Object.setPrototypeOf(e, c.prototype),
            e
        }
        function c(t, e, i) {
            if ("number" == typeof t) {
                if ("string" == typeof e)
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                return d(t)
            }
            return h(t, e, i)
        }
        function h(t, e, i) {
            if ("string" == typeof t)
                return function(t, e) {
                    "string" == typeof e && "" !== e || (e = "utf8");
                    if (!c.isEncoding(e))
                        throw new TypeError("Unknown encoding: " + e);
                    const i = 0 | g(t, e);
                    let n = l(i);
                    const r = n.write(t, e);
                    r !== i && (n = n.slice(0, r));
                    return n
                }(t, e);
            if (ArrayBuffer.isView(t))
                return function(t) {
                    if (Y(t, Uint8Array)) {
                        const e = new Uint8Array(t);
                        return p(e.buffer, e.byteOffset, e.byteLength)
                    }
                    return f(t)
                }(t);
            if (null == t)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
            if (Y(t, ArrayBuffer) || t && Y(t.buffer, ArrayBuffer))
                return p(t, e, i);
            if ("undefined" != typeof SharedArrayBuffer && (Y(t, SharedArrayBuffer) || t && Y(t.buffer, SharedArrayBuffer)))
                return p(t, e, i);
            if ("number" == typeof t)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            const n = t.valueOf && t.valueOf();
            if (null != n && n !== t)
                return c.from(n, e, i);
            const r = function(t) {
                if (c.isBuffer(t)) {
                    const e = 0 | m(t.length)
                      , i = l(e);
                    return 0 === i.length || t.copy(i, 0, 0, e),
                    i
                }
                if (void 0 !== t.length)
                    return "number" != typeof t.length || K(t.length) ? l(0) : f(t);
                if ("Buffer" === t.type && Array.isArray(t.data))
                    return f(t.data)
            }(t);
            if (r)
                return r;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive])
                return c.from(t[Symbol.toPrimitive]("string"), e, i);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
        }
        function u(t) {
            if ("number" != typeof t)
                throw new TypeError('"size" argument must be of type number');
            if (t < 0)
                throw new RangeError('The value "' + t + '" is invalid for option "size"')
        }
        function d(t) {
            return u(t),
            l(t < 0 ? 0 : 0 | m(t))
        }
        function f(t) {
            const e = t.length < 0 ? 0 : 0 | m(t.length)
              , i = l(e);
            for (let n = 0; n < e; n += 1)
                i[n] = 255 & t[n];
            return i
        }
        function p(t, e, i) {
            if (e < 0 || t.byteLength < e)
                throw new RangeError('"offset" is outside of buffer bounds');
            if (t.byteLength < e + (i || 0))
                throw new RangeError('"length" is outside of buffer bounds');
            let n;
            return n = void 0 === e && void 0 === i ? new Uint8Array(t) : void 0 === i ? new Uint8Array(t,e) : new Uint8Array(t,e,i),
            Object.setPrototypeOf(n, c.prototype),
            n
        }
        function m(t) {
            if (t >= a)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
            return 0 | t
        }
        function g(t, e) {
            if (c.isBuffer(t))
                return t.length;
            if (ArrayBuffer.isView(t) || Y(t, ArrayBuffer))
                return t.byteLength;
            if ("string" != typeof t)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
            const i = t.length
              , n = arguments.length > 2 && !0 === arguments[2];
            if (!n && 0 === i)
                return 0;
            let r = !1;
            for (; ; )
                switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                    return i;
                case "utf8":
                case "utf-8":
                    return H(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return 2 * i;
                case "hex":
                    return i >>> 1;
                case "base64":
                    return $(t).length;
                default:
                    if (r)
                        return n ? -1 : H(t).length;
                    e = ("" + e).toLowerCase(),
                    r = !0
                }
        }
        function _(t, e, i) {
            let n = !1;
            if ((void 0 === e || e < 0) && (e = 0),
            e > this.length)
                return "";
            if ((void 0 === i || i > this.length) && (i = this.length),
            i <= 0)
                return "";
            if ((i >>>= 0) <= (e >>>= 0))
                return "";
            for (t || (t = "utf8"); ; )
                switch (t) {
                case "hex":
                    return k(this, e, i);
                case "utf8":
                case "utf-8":
                    return A(this, e, i);
                case "ascii":
                    return M(this, e, i);
                case "latin1":
                case "binary":
                    return P(this, e, i);
                case "base64":
                    return C(this, e, i);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return O(this, e, i);
                default:
                    if (n)
                        throw new TypeError("Unknown encoding: " + t);
                    t = (t + "").toLowerCase(),
                    n = !0
                }
        }
        function y(t, e, i) {
            const n = t[e];
            t[e] = t[i],
            t[i] = n
        }
        function v(t, e, i, n, r) {
            if (0 === t.length)
                return -1;
            if ("string" == typeof i ? (n = i,
            i = 0) : i > 2147483647 ? i = 2147483647 : i < -2147483648 && (i = -2147483648),
            K(i = +i) && (i = r ? 0 : t.length - 1),
            i < 0 && (i = t.length + i),
            i >= t.length) {
                if (r)
                    return -1;
                i = t.length - 1
            } else if (i < 0) {
                if (!r)
                    return -1;
                i = 0
            }
            if ("string" == typeof e && (e = c.from(e, n)),
            c.isBuffer(e))
                return 0 === e.length ? -1 : x(t, e, i, n, r);
            if ("number" == typeof e)
                return e &= 255,
                "function" == typeof Uint8Array.prototype.indexOf ? r ? Uint8Array.prototype.indexOf.call(t, e, i) : Uint8Array.prototype.lastIndexOf.call(t, e, i) : x(t, [e], i, n, r);
            throw new TypeError("val must be string, number or Buffer")
        }
        function x(t, e, i, n, r) {
            let o, s = 1, a = t.length, l = e.length;
            if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                if (t.length < 2 || e.length < 2)
                    return -1;
                s = 2,
                a /= 2,
                l /= 2,
                i /= 2
            }
            function c(t, e) {
                return 1 === s ? t[e] : t.readUInt16BE(e * s)
            }
            if (r) {
                let n = -1;
                for (o = i; o < a; o++)
                    if (c(t, o) === c(e, -1 === n ? 0 : o - n)) {
                        if (-1 === n && (n = o),
                        o - n + 1 === l)
                            return n * s
                    } else
                        -1 !== n && (o -= o - n),
                        n = -1
            } else
                for (i + l > a && (i = a - l),
                o = i; o >= 0; o--) {
                    let i = !0;
                    for (let n = 0; n < l; n++)
                        if (c(t, o + n) !== c(e, n)) {
                            i = !1;
                            break
                        }
                    if (i)
                        return o
                }
            return -1
        }
        function b(t, e, i, n) {
            i = Number(i) || 0;
            const r = t.length - i;
            n ? (n = Number(n)) > r && (n = r) : n = r;
            const o = e.length;
            let s;
            for (n > o / 2 && (n = o / 2),
            s = 0; s < n; ++s) {
                const n = parseInt(e.substr(2 * s, 2), 16);
                if (K(n))
                    return s;
                t[i + s] = n
            }
            return s
        }
        function w(t, e, i, n) {
            return X(H(e, t.length - i), t, i, n)
        }
        function E(t, e, i, n) {
            return X(function(t) {
                const e = [];
                for (let i = 0; i < t.length; ++i)
                    e.push(255 & t.charCodeAt(i));
                return e
            }(e), t, i, n)
        }
        function T(t, e, i, n) {
            return X($(e), t, i, n)
        }
        function S(t, e, i, n) {
            return X(function(t, e) {
                let i, n, r;
                const o = [];
                for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
                    i = t.charCodeAt(s),
                    n = i >> 8,
                    r = i % 256,
                    o.push(r),
                    o.push(n);
                return o
            }(e, t.length - i), t, i, n)
        }
        function C(t, e, i) {
            return 0 === e && i === t.length ? r.fromByteArray(t) : r.fromByteArray(t.slice(e, i))
        }
        function A(t, e, i) {
            i = Math.min(t.length, i);
            const n = [];
            let r = e;
            for (; r < i; ) {
                const e = t[r];
                let o = null
                  , s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
                if (r + s <= i) {
                    let i, n, a, l;
                    switch (s) {
                    case 1:
                        e < 128 && (o = e);
                        break;
                    case 2:
                        i = t[r + 1],
                        128 == (192 & i) && (l = (31 & e) << 6 | 63 & i,
                        l > 127 && (o = l));
                        break;
                    case 3:
                        i = t[r + 1],
                        n = t[r + 2],
                        128 == (192 & i) && 128 == (192 & n) && (l = (15 & e) << 12 | (63 & i) << 6 | 63 & n,
                        l > 2047 && (l < 55296 || l > 57343) && (o = l));
                        break;
                    case 4:
                        i = t[r + 1],
                        n = t[r + 2],
                        a = t[r + 3],
                        128 == (192 & i) && 128 == (192 & n) && 128 == (192 & a) && (l = (15 & e) << 18 | (63 & i) << 12 | (63 & n) << 6 | 63 & a,
                        l > 65535 && l < 1114112 && (o = l))
                    }
                }
                null === o ? (o = 65533,
                s = 1) : o > 65535 && (o -= 65536,
                n.push(o >>> 10 & 1023 | 55296),
                o = 56320 | 1023 & o),
                n.push(o),
                r += s
            }
            return function(t) {
                const e = t.length;
                if (e <= I)
                    return String.fromCharCode.apply(String, t);
                let i = ""
                  , n = 0;
                for (; n < e; )
                    i += String.fromCharCode.apply(String, t.slice(n, n += I));
                return i
            }(n)
        }
        c.TYPED_ARRAY_SUPPORT = function() {
            try {
                const t = new Uint8Array(1)
                  , e = {
                    foo: function() {
                        return 42
                    }
                };
                return Object.setPrototypeOf(e, Uint8Array.prototype),
                Object.setPrototypeOf(t, e),
                42 === t.foo()
            } catch (t) {
                return !1
            }
        }(),
        c.TYPED_ARRAY_SUPPORT || void 0 === n || "function" != typeof n.error || n.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),
        Object.defineProperty(c.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (c.isBuffer(this))
                    return this.buffer
            }
        }),
        Object.defineProperty(c.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (c.isBuffer(this))
                    return this.byteOffset
            }
        }),
        c.poolSize = 8192,
        c.from = function(t, e, i) {
            return h(t, e, i)
        }
        ,
        Object.setPrototypeOf(c.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(c, Uint8Array),
        c.alloc = function(t, e, i) {
            return function(t, e, i) {
                return u(t),
                t <= 0 ? l(t) : void 0 !== e ? "string" == typeof i ? l(t).fill(e, i) : l(t).fill(e) : l(t)
            }(t, e, i)
        }
        ,
        c.allocUnsafe = function(t) {
            return d(t)
        }
        ,
        c.allocUnsafeSlow = function(t) {
            return d(t)
        }
        ,
        c.isBuffer = function(t) {
            return null != t && !0 === t._isBuffer && t !== c.prototype
        }
        ,
        c.compare = function(t, e) {
            if (Y(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)),
            Y(e, Uint8Array) && (e = c.from(e, e.offset, e.byteLength)),
            !c.isBuffer(t) || !c.isBuffer(e))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (t === e)
                return 0;
            let i = t.length
              , n = e.length;
            for (let r = 0, o = Math.min(i, n); r < o; ++r)
                if (t[r] !== e[r]) {
                    i = t[r],
                    n = e[r];
                    break
                }
            return i < n ? -1 : n < i ? 1 : 0
        }
        ,
        c.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        c.concat = function(t, e) {
            if (!Array.isArray(t))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === t.length)
                return c.alloc(0);
            let i;
            if (void 0 === e)
                for (e = 0,
                i = 0; i < t.length; ++i)
                    e += t[i].length;
            const n = c.allocUnsafe(e);
            let r = 0;
            for (i = 0; i < t.length; ++i) {
                let e = t[i];
                if (Y(e, Uint8Array))
                    r + e.length > n.length ? (c.isBuffer(e) || (e = c.from(e)),
                    e.copy(n, r)) : Uint8Array.prototype.set.call(n, e, r);
                else {
                    if (!c.isBuffer(e))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    e.copy(n, r)
                }
                r += e.length
            }
            return n
        }
        ,
        c.byteLength = g,
        c.prototype._isBuffer = !0,
        c.prototype.swap16 = function() {
            const t = this.length;
            if (t % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let e = 0; e < t; e += 2)
                y(this, e, e + 1);
            return this
        }
        ,
        c.prototype.swap32 = function() {
            const t = this.length;
            if (t % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let e = 0; e < t; e += 4)
                y(this, e, e + 3),
                y(this, e + 1, e + 2);
            return this
        }
        ,
        c.prototype.swap64 = function() {
            const t = this.length;
            if (t % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let e = 0; e < t; e += 8)
                y(this, e, e + 7),
                y(this, e + 1, e + 6),
                y(this, e + 2, e + 5),
                y(this, e + 3, e + 4);
            return this
        }
        ,
        c.prototype.toString = function() {
            const t = this.length;
            return 0 === t ? "" : 0 === arguments.length ? A(this, 0, t) : _.apply(this, arguments)
        }
        ,
        c.prototype.toLocaleString = c.prototype.toString,
        c.prototype.equals = function(t) {
            if (!c.isBuffer(t))
                throw new TypeError("Argument must be a Buffer");
            return this === t || 0 === c.compare(this, t)
        }
        ,
        c.prototype.inspect = function() {
            let t = "";
            const i = e.h2;
            return t = this.toString("hex", 0, i).replace(/(.{2})/g, "$1 ").trim(),
            this.length > i && (t += " ... "),
            "<Buffer " + t + ">"
        }
        ,
        s && (c.prototype[s] = c.prototype.inspect),
        c.prototype.compare = function(t, e, i, n, r) {
            if (Y(t, Uint8Array) && (t = c.from(t, t.offset, t.byteLength)),
            !c.isBuffer(t))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
            if (void 0 === e && (e = 0),
            void 0 === i && (i = t ? t.length : 0),
            void 0 === n && (n = 0),
            void 0 === r && (r = this.length),
            e < 0 || i > t.length || n < 0 || r > this.length)
                throw new RangeError("out of range index");
            if (n >= r && e >= i)
                return 0;
            if (n >= r)
                return -1;
            if (e >= i)
                return 1;
            if (this === t)
                return 0;
            let o = (r >>>= 0) - (n >>>= 0)
              , s = (i >>>= 0) - (e >>>= 0);
            const a = Math.min(o, s)
              , l = this.slice(n, r)
              , h = t.slice(e, i);
            for (let t = 0; t < a; ++t)
                if (l[t] !== h[t]) {
                    o = l[t],
                    s = h[t];
                    break
                }
            return o < s ? -1 : s < o ? 1 : 0
        }
        ,
        c.prototype.includes = function(t, e, i) {
            return -1 !== this.indexOf(t, e, i)
        }
        ,
        c.prototype.indexOf = function(t, e, i) {
            return v(this, t, e, i, !0)
        }
        ,
        c.prototype.lastIndexOf = function(t, e, i) {
            return v(this, t, e, i, !1)
        }
        ,
        c.prototype.write = function(t, e, i, n) {
            if (void 0 === e)
                n = "utf8",
                i = this.length,
                e = 0;
            else if (void 0 === i && "string" == typeof e)
                n = e,
                i = this.length,
                e = 0;
            else {
                if (!isFinite(e))
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                e >>>= 0,
                isFinite(i) ? (i >>>= 0,
                void 0 === n && (n = "utf8")) : (n = i,
                i = void 0)
            }
            const r = this.length - e;
            if ((void 0 === i || i > r) && (i = r),
            t.length > 0 && (i < 0 || e < 0) || e > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            let o = !1;
            for (; ; )
                switch (n) {
                case "hex":
                    return b(this, t, e, i);
                case "utf8":
                case "utf-8":
                    return w(this, t, e, i);
                case "ascii":
                case "latin1":
                case "binary":
                    return E(this, t, e, i);
                case "base64":
                    return T(this, t, e, i);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return S(this, t, e, i);
                default:
                    if (o)
                        throw new TypeError("Unknown encoding: " + n);
                    n = ("" + n).toLowerCase(),
                    o = !0
                }
        }
        ,
        c.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        const I = 4096;
        function M(t, e, i) {
            let n = "";
            i = Math.min(t.length, i);
            for (let r = e; r < i; ++r)
                n += String.fromCharCode(127 & t[r]);
            return n
        }
        function P(t, e, i) {
            let n = "";
            i = Math.min(t.length, i);
            for (let r = e; r < i; ++r)
                n += String.fromCharCode(t[r]);
            return n
        }
        function k(t, e, i) {
            const n = t.length;
            (!e || e < 0) && (e = 0),
            (!i || i < 0 || i > n) && (i = n);
            let r = "";
            for (let n = e; n < i; ++n)
                r += J[t[n]];
            return r
        }
        function O(t, e, i) {
            const n = t.slice(e, i);
            let r = "";
            for (let t = 0; t < n.length - 1; t += 2)
                r += String.fromCharCode(n[t] + 256 * n[t + 1]);
            return r
        }
        function R(t, e, i) {
            if (t % 1 != 0 || t < 0)
                throw new RangeError("offset is not uint");
            if (t + e > i)
                throw new RangeError("Trying to access beyond buffer length")
        }
        function D(t, e, i, n, r, o) {
            if (!c.isBuffer(t))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > r || e < o)
                throw new RangeError('"value" argument is out of bounds');
            if (i + n > t.length)
                throw new RangeError("Index out of range")
        }
        function L(t, e, i, n, r) {
            G(e, n, r, t, i, 7);
            let o = Number(e & BigInt(4294967295));
            t[i++] = o,
            o >>= 8,
            t[i++] = o,
            o >>= 8,
            t[i++] = o,
            o >>= 8,
            t[i++] = o;
            let s = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[i++] = s,
            s >>= 8,
            t[i++] = s,
            s >>= 8,
            t[i++] = s,
            s >>= 8,
            t[i++] = s,
            i
        }
        function B(t, e, i, n, r) {
            G(e, n, r, t, i, 7);
            let o = Number(e & BigInt(4294967295));
            t[i + 7] = o,
            o >>= 8,
            t[i + 6] = o,
            o >>= 8,
            t[i + 5] = o,
            o >>= 8,
            t[i + 4] = o;
            let s = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[i + 3] = s,
            s >>= 8,
            t[i + 2] = s,
            s >>= 8,
            t[i + 1] = s,
            s >>= 8,
            t[i] = s,
            i + 8
        }
        function z(t, e, i, n, r, o) {
            if (i + n > t.length)
                throw new RangeError("Index out of range");
            if (i < 0)
                throw new RangeError("Index out of range")
        }
        function F(t, e, i, n, r) {
            return e = +e,
            i >>>= 0,
            r || z(t, 0, i, 4),
            o.write(t, e, i, n, 23, 4),
            i + 4
        }
        function N(t, e, i, n, r) {
            return e = +e,
            i >>>= 0,
            r || z(t, 0, i, 8),
            o.write(t, e, i, n, 52, 8),
            i + 8
        }
        c.prototype.slice = function(t, e) {
            const i = this.length;
            (t = ~~t) < 0 ? (t += i) < 0 && (t = 0) : t > i && (t = i),
            (e = void 0 === e ? i : ~~e) < 0 ? (e += i) < 0 && (e = 0) : e > i && (e = i),
            e < t && (e = t);
            const n = this.subarray(t, e);
            return Object.setPrototypeOf(n, c.prototype),
            n
        }
        ,
        c.prototype.readUintLE = c.prototype.readUIntLE = function(t, e, i) {
            t >>>= 0,
            e >>>= 0,
            i || R(t, e, this.length);
            let n = this[t]
              , r = 1
              , o = 0;
            for (; ++o < e && (r *= 256); )
                n += this[t + o] * r;
            return n
        }
        ,
        c.prototype.readUintBE = c.prototype.readUIntBE = function(t, e, i) {
            t >>>= 0,
            e >>>= 0,
            i || R(t, e, this.length);
            let n = this[t + --e]
              , r = 1;
            for (; e > 0 && (r *= 256); )
                n += this[t + --e] * r;
            return n
        }
        ,
        c.prototype.readUint8 = c.prototype.readUInt8 = function(t, e) {
            return t >>>= 0,
            e || R(t, 1, this.length),
            this[t]
        }
        ,
        c.prototype.readUint16LE = c.prototype.readUInt16LE = function(t, e) {
            return t >>>= 0,
            e || R(t, 2, this.length),
            this[t] | this[t + 1] << 8
        }
        ,
        c.prototype.readUint16BE = c.prototype.readUInt16BE = function(t, e) {
            return t >>>= 0,
            e || R(t, 2, this.length),
            this[t] << 8 | this[t + 1]
        }
        ,
        c.prototype.readUint32LE = c.prototype.readUInt32LE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }
        ,
        c.prototype.readUint32BE = c.prototype.readUInt32BE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }
        ,
        c.prototype.readBigUInt64LE = Q((function(t) {
            Z(t >>>= 0, "offset");
            const e = this[t]
              , i = this[t + 7];
            void 0 !== e && void 0 !== i || q(t, this.length - 8);
            const n = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24
              , r = this[++t] + 256 * this[++t] + 65536 * this[++t] + i * 2 ** 24;
            return BigInt(n) + (BigInt(r) << BigInt(32))
        }
        )),
        c.prototype.readBigUInt64BE = Q((function(t) {
            Z(t >>>= 0, "offset");
            const e = this[t]
              , i = this[t + 7];
            void 0 !== e && void 0 !== i || q(t, this.length - 8);
            const n = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t]
              , r = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + i;
            return (BigInt(n) << BigInt(32)) + BigInt(r)
        }
        )),
        c.prototype.readIntLE = function(t, e, i) {
            t >>>= 0,
            e >>>= 0,
            i || R(t, e, this.length);
            let n = this[t]
              , r = 1
              , o = 0;
            for (; ++o < e && (r *= 256); )
                n += this[t + o] * r;
            return r *= 128,
            n >= r && (n -= Math.pow(2, 8 * e)),
            n
        }
        ,
        c.prototype.readIntBE = function(t, e, i) {
            t >>>= 0,
            e >>>= 0,
            i || R(t, e, this.length);
            let n = e
              , r = 1
              , o = this[t + --n];
            for (; n > 0 && (r *= 256); )
                o += this[t + --n] * r;
            return r *= 128,
            o >= r && (o -= Math.pow(2, 8 * e)),
            o
        }
        ,
        c.prototype.readInt8 = function(t, e) {
            return t >>>= 0,
            e || R(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }
        ,
        c.prototype.readInt16LE = function(t, e) {
            t >>>= 0,
            e || R(t, 2, this.length);
            const i = this[t] | this[t + 1] << 8;
            return 32768 & i ? 4294901760 | i : i
        }
        ,
        c.prototype.readInt16BE = function(t, e) {
            t >>>= 0,
            e || R(t, 2, this.length);
            const i = this[t + 1] | this[t] << 8;
            return 32768 & i ? 4294901760 | i : i
        }
        ,
        c.prototype.readInt32LE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }
        ,
        c.prototype.readInt32BE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }
        ,
        c.prototype.readBigInt64LE = Q((function(t) {
            Z(t >>>= 0, "offset");
            const e = this[t]
              , i = this[t + 7];
            void 0 !== e && void 0 !== i || q(t, this.length - 8);
            const n = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (i << 24);
            return (BigInt(n) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24)
        }
        )),
        c.prototype.readBigInt64BE = Q((function(t) {
            Z(t >>>= 0, "offset");
            const e = this[t]
              , i = this[t + 7];
            void 0 !== e && void 0 !== i || q(t, this.length - 8);
            const n = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
            return (BigInt(n) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + i)
        }
        )),
        c.prototype.readFloatLE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            o.read(this, t, !0, 23, 4)
        }
        ,
        c.prototype.readFloatBE = function(t, e) {
            return t >>>= 0,
            e || R(t, 4, this.length),
            o.read(this, t, !1, 23, 4)
        }
        ,
        c.prototype.readDoubleLE = function(t, e) {
            return t >>>= 0,
            e || R(t, 8, this.length),
            o.read(this, t, !0, 52, 8)
        }
        ,
        c.prototype.readDoubleBE = function(t, e) {
            return t >>>= 0,
            e || R(t, 8, this.length),
            o.read(this, t, !1, 52, 8)
        }
        ,
        c.prototype.writeUintLE = c.prototype.writeUIntLE = function(t, e, i, n) {
            if (t = +t,
            e >>>= 0,
            i >>>= 0,
            !n) {
                D(this, t, e, i, Math.pow(2, 8 * i) - 1, 0)
            }
            let r = 1
              , o = 0;
            for (this[e] = 255 & t; ++o < i && (r *= 256); )
                this[e + o] = t / r & 255;
            return e + i
        }
        ,
        c.prototype.writeUintBE = c.prototype.writeUIntBE = function(t, e, i, n) {
            if (t = +t,
            e >>>= 0,
            i >>>= 0,
            !n) {
                D(this, t, e, i, Math.pow(2, 8 * i) - 1, 0)
            }
            let r = i - 1
              , o = 1;
            for (this[e + r] = 255 & t; --r >= 0 && (o *= 256); )
                this[e + r] = t / o & 255;
            return e + i
        }
        ,
        c.prototype.writeUint8 = c.prototype.writeUInt8 = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 1, 255, 0),
            this[e] = 255 & t,
            e + 1
        }
        ,
        c.prototype.writeUint16LE = c.prototype.writeUInt16LE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 2, 65535, 0),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            e + 2
        }
        ,
        c.prototype.writeUint16BE = c.prototype.writeUInt16BE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 2, 65535, 0),
            this[e] = t >>> 8,
            this[e + 1] = 255 & t,
            e + 2
        }
        ,
        c.prototype.writeUint32LE = c.prototype.writeUInt32LE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 4, 4294967295, 0),
            this[e + 3] = t >>> 24,
            this[e + 2] = t >>> 16,
            this[e + 1] = t >>> 8,
            this[e] = 255 & t,
            e + 4
        }
        ,
        c.prototype.writeUint32BE = c.prototype.writeUInt32BE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 4, 4294967295, 0),
            this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t,
            e + 4
        }
        ,
        c.prototype.writeBigUInt64LE = Q((function(t, e=0) {
            return L(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }
        )),
        c.prototype.writeBigUInt64BE = Q((function(t, e=0) {
            return B(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }
        )),
        c.prototype.writeIntLE = function(t, e, i, n) {
            if (t = +t,
            e >>>= 0,
            !n) {
                const n = Math.pow(2, 8 * i - 1);
                D(this, t, e, i, n - 1, -n)
            }
            let r = 0
              , o = 1
              , s = 0;
            for (this[e] = 255 & t; ++r < i && (o *= 256); )
                t < 0 && 0 === s && 0 !== this[e + r - 1] && (s = 1),
                this[e + r] = (t / o >> 0) - s & 255;
            return e + i
        }
        ,
        c.prototype.writeIntBE = function(t, e, i, n) {
            if (t = +t,
            e >>>= 0,
            !n) {
                const n = Math.pow(2, 8 * i - 1);
                D(this, t, e, i, n - 1, -n)
            }
            let r = i - 1
              , o = 1
              , s = 0;
            for (this[e + r] = 255 & t; --r >= 0 && (o *= 256); )
                t < 0 && 0 === s && 0 !== this[e + r + 1] && (s = 1),
                this[e + r] = (t / o >> 0) - s & 255;
            return e + i
        }
        ,
        c.prototype.writeInt8 = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 1, 127, -128),
            t < 0 && (t = 255 + t + 1),
            this[e] = 255 & t,
            e + 1
        }
        ,
        c.prototype.writeInt16LE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 2, 32767, -32768),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            e + 2
        }
        ,
        c.prototype.writeInt16BE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 2, 32767, -32768),
            this[e] = t >>> 8,
            this[e + 1] = 255 & t,
            e + 2
        }
        ,
        c.prototype.writeInt32LE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 4, 2147483647, -2147483648),
            this[e] = 255 & t,
            this[e + 1] = t >>> 8,
            this[e + 2] = t >>> 16,
            this[e + 3] = t >>> 24,
            e + 4
        }
        ,
        c.prototype.writeInt32BE = function(t, e, i) {
            return t = +t,
            e >>>= 0,
            i || D(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            this[e] = t >>> 24,
            this[e + 1] = t >>> 16,
            this[e + 2] = t >>> 8,
            this[e + 3] = 255 & t,
            e + 4
        }
        ,
        c.prototype.writeBigInt64LE = Q((function(t, e=0) {
            return L(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }
        )),
        c.prototype.writeBigInt64BE = Q((function(t, e=0) {
            return B(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }
        )),
        c.prototype.writeFloatLE = function(t, e, i) {
            return F(this, t, e, !0, i)
        }
        ,
        c.prototype.writeFloatBE = function(t, e, i) {
            return F(this, t, e, !1, i)
        }
        ,
        c.prototype.writeDoubleLE = function(t, e, i) {
            return N(this, t, e, !0, i)
        }
        ,
        c.prototype.writeDoubleBE = function(t, e, i) {
            return N(this, t, e, !1, i)
        }
        ,
        c.prototype.copy = function(t, e, i, n) {
            if (!c.isBuffer(t))
                throw new TypeError("argument should be a Buffer");
            if (i || (i = 0),
            n || 0 === n || (n = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            n > 0 && n < i && (n = i),
            n === i)
                return 0;
            if (0 === t.length || 0 === this.length)
                return 0;
            if (e < 0)
                throw new RangeError("targetStart out of bounds");
            if (i < 0 || i >= this.length)
                throw new RangeError("Index out of range");
            if (n < 0)
                throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length),
            t.length - e < n - i && (n = t.length - e + i);
            const r = n - i;
            return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, i, n) : Uint8Array.prototype.set.call(t, this.subarray(i, n), e),
            r
        }
        ,
        c.prototype.fill = function(t, e, i, n) {
            if ("string" == typeof t) {
                if ("string" == typeof e ? (n = e,
                e = 0,
                i = this.length) : "string" == typeof i && (n = i,
                i = this.length),
                void 0 !== n && "string" != typeof n)
                    throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !c.isEncoding(n))
                    throw new TypeError("Unknown encoding: " + n);
                if (1 === t.length) {
                    const e = t.charCodeAt(0);
                    ("utf8" === n && e < 128 || "latin1" === n) && (t = e)
                }
            } else
                "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = Number(t));
            if (e < 0 || this.length < e || this.length < i)
                throw new RangeError("Out of range index");
            if (i <= e)
                return this;
            let r;
            if (e >>>= 0,
            i = void 0 === i ? this.length : i >>> 0,
            t || (t = 0),
            "number" == typeof t)
                for (r = e; r < i; ++r)
                    this[r] = t;
            else {
                const o = c.isBuffer(t) ? t : c.from(t, n)
                  , s = o.length;
                if (0 === s)
                    throw new TypeError('The value "' + t + '" is invalid for argument "value"');
                for (r = 0; r < i - e; ++r)
                    this[r + e] = o[r % s]
            }
            return this
        }
        ;
        const j = {};
        function U(t, e, i) {
            j[t] = class extends i {
                constructor() {
                    super(),
                    Object.defineProperty(this, "message", {
                        value: e.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }),
                    this.name = `${this.name} [${t}]`,
                    this.stack,
                    delete this.name
                }
                get code() {
                    return t
                }
                set code(t) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: t,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${t}]: ${this.message}`
                }
            }
        }
        function V(t) {
            let e = ""
              , i = t.length;
            const n = "-" === t[0] ? 1 : 0;
            for (; i >= n + 4; i -= 3)
                e = `_${t.slice(i - 3, i)}${e}`;
            return `${t.slice(0, i)}${e}`
        }
        function G(t, e, i, n, r, o) {
            if (t > i || t < e) {
                const n = "bigint" == typeof e ? "n" : "";
                let r;
                throw r = o > 3 ? 0 === e || e === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8 * (o + 1)}${n}` : `>= -(2${n} ** ${8 * (o + 1) - 1}${n}) and < 2 ** ${8 * (o + 1) - 1}${n}` : `>= ${e}${n} and <= ${i}${n}`,
                new j.ERR_OUT_OF_RANGE("value",r,t)
            }
            !function(t, e, i) {
                Z(e, "offset"),
                void 0 !== t[e] && void 0 !== t[e + i] || q(e, t.length - (i + 1))
            }(n, r, o)
        }
        function Z(t, e) {
            if ("number" != typeof t)
                throw new j.ERR_INVALID_ARG_TYPE(e,"number",t)
        }
        function q(t, e, i) {
            if (Math.floor(t) !== t)
                throw Z(t, i),
                new j.ERR_OUT_OF_RANGE(i || "offset","an integer",t);
            if (e < 0)
                throw new j.ERR_BUFFER_OUT_OF_BOUNDS;
            throw new j.ERR_OUT_OF_RANGE(i || "offset",`>= ${i ? 1 : 0} and <= ${e}`,t)
        }
        U("ERR_BUFFER_OUT_OF_BOUNDS", (function(t) {
            return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }
        ), RangeError),
        U("ERR_INVALID_ARG_TYPE", (function(t, e) {
            return `The "${t}" argument must be of type number. Received type ${typeof e}`
        }
        ), TypeError),
        U("ERR_OUT_OF_RANGE", (function(t, e, i) {
            let n = `The value of "${t}" is out of range.`
              , r = i;
            return Number.isInteger(i) && Math.abs(i) > 2 ** 32 ? r = V(String(i)) : "bigint" == typeof i && (r = String(i),
            (i > BigInt(2) ** BigInt(32) || i < -(BigInt(2) ** BigInt(32))) && (r = V(r)),
            r += "n"),
            n += ` It must be ${e}. Received ${r}`,
            n
        }
        ), RangeError);
        const W = /[^+/0-9A-Za-z-_]/g;
        function H(t, e) {
            let i;
            e = e || 1 / 0;
            const n = t.length;
            let r = null;
            const o = [];
            for (let s = 0; s < n; ++s) {
                if (i = t.charCodeAt(s),
                i > 55295 && i < 57344) {
                    if (!r) {
                        if (i > 56319) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (s + 1 === n) {
                            (e -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        r = i;
                        continue
                    }
                    if (i < 56320) {
                        (e -= 3) > -1 && o.push(239, 191, 189),
                        r = i;
                        continue
                    }
                    i = 65536 + (r - 55296 << 10 | i - 56320)
                } else
                    r && (e -= 3) > -1 && o.push(239, 191, 189);
                if (r = null,
                i < 128) {
                    if ((e -= 1) < 0)
                        break;
                    o.push(i)
                } else if (i < 2048) {
                    if ((e -= 2) < 0)
                        break;
                    o.push(i >> 6 | 192, 63 & i | 128)
                } else if (i < 65536) {
                    if ((e -= 3) < 0)
                        break;
                    o.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128)
                } else {
                    if (!(i < 1114112))
                        throw new Error("Invalid code point");
                    if ((e -= 4) < 0)
                        break;
                    o.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128)
                }
            }
            return o
        }
        function $(t) {
            return r.toByteArray(function(t) {
                if ((t = (t = t.split("=")[0]).trim().replace(W, "")).length < 2)
                    return "";
                for (; t.length % 4 != 0; )
                    t += "=";
                return t
            }(t))
        }
        function X(t, e, i, n) {
            let r;
            for (r = 0; r < n && !(r + i >= e.length || r >= t.length); ++r)
                e[r + i] = t[r];
            return r
        }
        function Y(t, e) {
            return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name
        }
        function K(t) {
            return t != t
        }
        const J = function() {
            const t = "0123456789abcdef"
              , e = new Array(256);
            for (let i = 0; i < 16; ++i) {
                const n = 16 * i;
                for (let r = 0; r < 16; ++r)
                    e[n + r] = t[i] + t[r]
            }
            return e
        }();
        function Q(t) {
            return "undefined" == typeof BigInt ? tt : t
        }
        function tt() {
            throw new Error("BigInt not supported")
        }
    },
    19662: function(t, e, i) {
        "use strict";
        var n = i(60614)
          , r = i(66330)
          , o = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw o(r(t) + " is not a function")
        }
    },
    96077: function(t, e, i) {
        "use strict";
        var n = i(60614)
          , r = String
          , o = TypeError;
        t.exports = function(t) {
            if ("object" == typeof t || n(t))
                return t;
            throw o("Can't set " + r(t) + " as a prototype")
        }
    },
    25787: function(t, e, i) {
        "use strict";
        var n = i(47976)
          , r = TypeError;
        t.exports = function(t, e) {
            if (n(e, t))
                return t;
            throw r("Incorrect invocation")
        }
    },
    19670: function(t, e, i) {
        "use strict";
        var n = i(70111)
          , r = String
          , o = TypeError;
        t.exports = function(t) {
            if (n(t))
                return t;
            throw o(r(t) + " is not an object")
        }
    },
    41318: function(t, e, i) {
        "use strict";
        var n = i(45656)
          , r = i(51400)
          , o = i(26244)
          , s = function(t) {
            return function(e, i, s) {
                var a, l = n(e), c = o(l), h = r(s, c);
                if (t && i != i) {
                    for (; c > h; )
                        if ((a = l[h++]) != a)
                            return !0
                } else
                    for (; c > h; h++)
                        if ((t || h in l) && l[h] === i)
                            return t || h || 0;
                return !t && -1
            }
        };
        t.exports = {
            includes: s(!0),
            indexOf: s(!1)
        }
    },
    83658: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(43157)
          , o = TypeError
          , s = Object.getOwnPropertyDescriptor
          , a = n && !function() {
            if (void 0 !== this)
                return !0;
            try {
                Object.defineProperty([], "length", {
                    writable: !1
                }).length = 1
            } catch (t) {
                return t instanceof TypeError
            }
        }();
        t.exports = a ? function(t, e) {
            if (r(t) && !s(t, "length").writable)
                throw o("Cannot set read only .length");
            return t.length = e
        }
        : function(t, e) {
            return t.length = e
        }
    },
    84326: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = n({}.toString)
          , o = n("".slice);
        t.exports = function(t) {
            return o(r(t), 8, -1)
        }
    },
    70648: function(t, e, i) {
        "use strict";
        var n = i(51694)
          , r = i(60614)
          , o = i(84326)
          , s = i(5112)("toStringTag")
          , a = Object
          , l = "Arguments" == o(function() {
            return arguments
        }());
        t.exports = n ? o : function(t) {
            var e, i, n;
            return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (i = function(t, e) {
                try {
                    return t[e]
                } catch (t) {}
            }(e = a(t), s)) ? i : l ? o(e) : "Object" == (n = o(e)) && r(e.callee) ? "Arguments" : n
        }
    },
    99920: function(t, e, i) {
        "use strict";
        var n = i(92597)
          , r = i(53887)
          , o = i(31236)
          , s = i(3070);
        t.exports = function(t, e, i) {
            for (var a = r(e), l = s.f, c = o.f, h = 0; h < a.length; h++) {
                var u = a[h];
                n(t, u) || i && n(i, u) || l(t, u, c(e, u))
            }
        }
    },
    68880: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(3070)
          , o = i(79114);
        t.exports = n ? function(t, e, i) {
            return r.f(t, e, o(1, i))
        }
        : function(t, e, i) {
            return t[e] = i,
            t
        }
    },
    79114: function(t) {
        "use strict";
        t.exports = function(t, e) {
            return {
                enumerable: !(1 & t),
                configurable: !(2 & t),
                writable: !(4 & t),
                value: e
            }
        }
    },
    47045: function(t, e, i) {
        "use strict";
        var n = i(56339)
          , r = i(3070);
        t.exports = function(t, e, i) {
            return i.get && n(i.get, e, {
                getter: !0
            }),
            i.set && n(i.set, e, {
                setter: !0
            }),
            r.f(t, e, i)
        }
    },
    98052: function(t, e, i) {
        "use strict";
        var n = i(60614)
          , r = i(3070)
          , o = i(56339)
          , s = i(13072);
        t.exports = function(t, e, i, a) {
            a || (a = {});
            var l = a.enumerable
              , c = void 0 !== a.name ? a.name : e;
            if (n(i) && o(i, c, a),
            a.global)
                l ? t[e] = i : s(e, i);
            else {
                try {
                    a.unsafe ? t[e] && (l = !0) : delete t[e]
                } catch (t) {}
                l ? t[e] = i : r.f(t, e, {
                    value: i,
                    enumerable: !1,
                    configurable: !a.nonConfigurable,
                    writable: !a.nonWritable
                })
            }
            return t
        }
    },
    13072: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = Object.defineProperty;
        t.exports = function(t, e) {
            try {
                r(n, t, {
                    value: e,
                    configurable: !0,
                    writable: !0
                })
            } catch (i) {
                n[t] = e
            }
            return e
        }
    },
    19781: function(t, e, i) {
        "use strict";
        var n = i(47293);
        t.exports = !n((function() {
            return 7 != Object.defineProperty({}, 1, {
                get: function() {
                    return 7
                }
            })[1]
        }
        ))
    },
    4154: function(t) {
        "use strict";
        var e = "object" == typeof document && document.all
          , i = void 0 === e && void 0 !== e;
        t.exports = {
            all: e,
            IS_HTMLDDA: i
        }
    },
    80317: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(70111)
          , o = n.document
          , s = r(o) && r(o.createElement);
        t.exports = function(t) {
            return s ? o.createElement(t) : {}
        }
    },
    7207: function(t) {
        "use strict";
        var e = TypeError;
        t.exports = function(t) {
            if (t > 9007199254740991)
                throw e("Maximum allowed index exceeded");
            return t
        }
    },
    93678: function(t) {
        "use strict";
        t.exports = {
            IndexSizeError: {
                s: "INDEX_SIZE_ERR",
                c: 1,
                m: 1
            },
            DOMStringSizeError: {
                s: "DOMSTRING_SIZE_ERR",
                c: 2,
                m: 0
            },
            HierarchyRequestError: {
                s: "HIERARCHY_REQUEST_ERR",
                c: 3,
                m: 1
            },
            WrongDocumentError: {
                s: "WRONG_DOCUMENT_ERR",
                c: 4,
                m: 1
            },
            InvalidCharacterError: {
                s: "INVALID_CHARACTER_ERR",
                c: 5,
                m: 1
            },
            NoDataAllowedError: {
                s: "NO_DATA_ALLOWED_ERR",
                c: 6,
                m: 0
            },
            NoModificationAllowedError: {
                s: "NO_MODIFICATION_ALLOWED_ERR",
                c: 7,
                m: 1
            },
            NotFoundError: {
                s: "NOT_FOUND_ERR",
                c: 8,
                m: 1
            },
            NotSupportedError: {
                s: "NOT_SUPPORTED_ERR",
                c: 9,
                m: 1
            },
            InUseAttributeError: {
                s: "INUSE_ATTRIBUTE_ERR",
                c: 10,
                m: 1
            },
            InvalidStateError: {
                s: "INVALID_STATE_ERR",
                c: 11,
                m: 1
            },
            SyntaxError: {
                s: "SYNTAX_ERR",
                c: 12,
                m: 1
            },
            InvalidModificationError: {
                s: "INVALID_MODIFICATION_ERR",
                c: 13,
                m: 1
            },
            NamespaceError: {
                s: "NAMESPACE_ERR",
                c: 14,
                m: 1
            },
            InvalidAccessError: {
                s: "INVALID_ACCESS_ERR",
                c: 15,
                m: 1
            },
            ValidationError: {
                s: "VALIDATION_ERR",
                c: 16,
                m: 0
            },
            TypeMismatchError: {
                s: "TYPE_MISMATCH_ERR",
                c: 17,
                m: 1
            },
            SecurityError: {
                s: "SECURITY_ERR",
                c: 18,
                m: 1
            },
            NetworkError: {
                s: "NETWORK_ERR",
                c: 19,
                m: 1
            },
            AbortError: {
                s: "ABORT_ERR",
                c: 20,
                m: 1
            },
            URLMismatchError: {
                s: "URL_MISMATCH_ERR",
                c: 21,
                m: 1
            },
            QuotaExceededError: {
                s: "QUOTA_EXCEEDED_ERR",
                c: 22,
                m: 1
            },
            TimeoutError: {
                s: "TIMEOUT_ERR",
                c: 23,
                m: 1
            },
            InvalidNodeTypeError: {
                s: "INVALID_NODE_TYPE_ERR",
                c: 24,
                m: 1
            },
            DataCloneError: {
                s: "DATA_CLONE_ERR",
                c: 25,
                m: 1
            }
        }
    },
    88113: function(t) {
        "use strict";
        t.exports = "undefined" != typeof navigator && String(navigator.userAgent) || ""
    },
    7392: function(t, e, i) {
        "use strict";
        var n, r, o = i(17854), s = i(88113), a = o.process, l = o.Deno, c = a && a.versions || l && l.version, h = c && c.v8;
        h && (r = (n = h.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])),
        !r && s && (!(n = s.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = s.match(/Chrome\/(\d+)/)) && (r = +n[1]),
        t.exports = r
    },
    80748: function(t) {
        "use strict";
        t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
    },
    11060: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = Error
          , o = n("".replace)
          , s = String(r("zxcasd").stack)
          , a = /\n\s*at [^:]*:[^\n]*/
          , l = a.test(s);
        t.exports = function(t, e) {
            if (l && "string" == typeof t && !r.prepareStackTrace)
                for (; e--; )
                    t = o(t, a, "");
            return t
        }
    },
    82109: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(31236).f
          , o = i(68880)
          , s = i(98052)
          , a = i(13072)
          , l = i(99920)
          , c = i(54705);
        t.exports = function(t, e) {
            var i, h, u, d, f, p = t.target, m = t.global, g = t.stat;
            if (i = m ? n : g ? n[p] || a(p, {}) : (n[p] || {}).prototype)
                for (h in e) {
                    if (d = e[h],
                    u = t.dontCallGetSet ? (f = r(i, h)) && f.value : i[h],
                    !c(m ? h : p + (g ? "." : "#") + h, t.forced) && void 0 !== u) {
                        if (typeof d == typeof u)
                            continue;
                        l(d, u)
                    }
                    (t.sham || u && u.sham) && o(d, "sham", !0),
                    s(i, h, d, t)
                }
        }
    },
    47293: function(t) {
        "use strict";
        t.exports = function(t) {
            try {
                return !!t()
            } catch (t) {
                return !0
            }
        }
    },
    34374: function(t, e, i) {
        "use strict";
        var n = i(47293);
        t.exports = !n((function() {
            var t = function() {}
            .bind();
            return "function" != typeof t || t.hasOwnProperty("prototype")
        }
        ))
    },
    46916: function(t, e, i) {
        "use strict";
        var n = i(34374)
          , r = Function.prototype.call;
        t.exports = n ? r.bind(r) : function() {
            return r.apply(r, arguments)
        }
    },
    76530: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(92597)
          , o = Function.prototype
          , s = n && Object.getOwnPropertyDescriptor
          , a = r(o, "name")
          , l = a && "something" === function() {}
        .name
          , c = a && (!n || n && s(o, "name").configurable);
        t.exports = {
            EXISTS: a,
            PROPER: l,
            CONFIGURABLE: c
        }
    },
    75668: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(19662);
        t.exports = function(t, e, i) {
            try {
                return n(r(Object.getOwnPropertyDescriptor(t, e)[i]))
            } catch (t) {}
        }
    },
    1702: function(t, e, i) {
        "use strict";
        var n = i(34374)
          , r = Function.prototype
          , o = r.call
          , s = n && r.bind.bind(o, o);
        t.exports = n ? s : function(t) {
            return function() {
                return o.apply(t, arguments)
            }
        }
    },
    35005: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(60614);
        t.exports = function(t, e) {
            return arguments.length < 2 ? (i = n[t],
            r(i) ? i : void 0) : n[t] && n[t][e];
            var i
        }
    },
    58173: function(t, e, i) {
        "use strict";
        var n = i(19662)
          , r = i(68554);
        t.exports = function(t, e) {
            var i = t[e];
            return r(i) ? void 0 : n(i)
        }
    },
    17854: function(t, e, i) {
        "use strict";
        var n = function(t) {
            return t && t.Math == Math && t
        };
        t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof i.g && i.g) || function() {
            return this
        }() || this || Function("return this")()
    },
    92597: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(47908)
          , o = n({}.hasOwnProperty);
        t.exports = Object.hasOwn || function(t, e) {
            return o(r(t), e)
        }
    },
    3501: function(t) {
        "use strict";
        t.exports = {}
    },
    64664: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(47293)
          , o = i(80317);
        t.exports = !n && !r((function() {
            return 7 != Object.defineProperty(o("div"), "a", {
                get: function() {
                    return 7
                }
            }).a
        }
        ))
    },
    68361: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(47293)
          , o = i(84326)
          , s = Object
          , a = n("".split);
        t.exports = r((function() {
            return !s("z").propertyIsEnumerable(0)
        }
        )) ? function(t) {
            return "String" == o(t) ? a(t, "") : s(t)
        }
        : s
    },
    79587: function(t, e, i) {
        "use strict";
        var n = i(60614)
          , r = i(70111)
          , o = i(27674);
        t.exports = function(t, e, i) {
            var s, a;
            return o && n(s = e.constructor) && s !== i && r(a = s.prototype) && a !== i.prototype && o(t, a),
            t
        }
    },
    42788: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(60614)
          , o = i(5465)
          , s = n(Function.toString);
        r(o.inspectSource) || (o.inspectSource = function(t) {
            return s(t)
        }
        ),
        t.exports = o.inspectSource
    },
    29909: function(t, e, i) {
        "use strict";
        var n, r, o, s = i(94811), a = i(17854), l = i(70111), c = i(68880), h = i(92597), u = i(5465), d = i(6200), f = i(3501), p = "Object already initialized", m = a.TypeError, g = a.WeakMap;
        if (s || u.state) {
            var _ = u.state || (u.state = new g);
            _.get = _.get,
            _.has = _.has,
            _.set = _.set,
            n = function(t, e) {
                if (_.has(t))
                    throw m(p);
                return e.facade = t,
                _.set(t, e),
                e
            }
            ,
            r = function(t) {
                return _.get(t) || {}
            }
            ,
            o = function(t) {
                return _.has(t)
            }
        } else {
            var y = d("state");
            f[y] = !0,
            n = function(t, e) {
                if (h(t, y))
                    throw m(p);
                return e.facade = t,
                c(t, y, e),
                e
            }
            ,
            r = function(t) {
                return h(t, y) ? t[y] : {}
            }
            ,
            o = function(t) {
                return h(t, y)
            }
        }
        t.exports = {
            set: n,
            get: r,
            has: o,
            enforce: function(t) {
                return o(t) ? r(t) : n(t, {})
            },
            getterFor: function(t) {
                return function(e) {
                    var i;
                    if (!l(e) || (i = r(e)).type !== t)
                        throw m("Incompatible receiver, " + t + " required");
                    return i
                }
            }
        }
    },
    43157: function(t, e, i) {
        "use strict";
        var n = i(84326);
        t.exports = Array.isArray || function(t) {
            return "Array" == n(t)
        }
    },
    60614: function(t, e, i) {
        "use strict";
        var n = i(4154)
          , r = n.all;
        t.exports = n.IS_HTMLDDA ? function(t) {
            return "function" == typeof t || t === r
        }
        : function(t) {
            return "function" == typeof t
        }
    },
    54705: function(t, e, i) {
        "use strict";
        var n = i(47293)
          , r = i(60614)
          , o = /#|\.prototype\./
          , s = function(t, e) {
            var i = l[a(t)];
            return i == h || i != c && (r(e) ? n(e) : !!e)
        }
          , a = s.normalize = function(t) {
            return String(t).replace(o, ".").toLowerCase()
        }
          , l = s.data = {}
          , c = s.NATIVE = "N"
          , h = s.POLYFILL = "P";
        t.exports = s
    },
    68554: function(t) {
        "use strict";
        t.exports = function(t) {
            return null == t
        }
    },
    70111: function(t, e, i) {
        "use strict";
        var n = i(60614)
          , r = i(4154)
          , o = r.all;
        t.exports = r.IS_HTMLDDA ? function(t) {
            return "object" == typeof t ? null !== t : n(t) || t === o
        }
        : function(t) {
            return "object" == typeof t ? null !== t : n(t)
        }
    },
    31913: function(t) {
        "use strict";
        t.exports = !1
    },
    52190: function(t, e, i) {
        "use strict";
        var n = i(35005)
          , r = i(60614)
          , o = i(47976)
          , s = i(43307)
          , a = Object;
        t.exports = s ? function(t) {
            return "symbol" == typeof t
        }
        : function(t) {
            var e = n("Symbol");
            return r(e) && o(e.prototype, a(t))
        }
    },
    26244: function(t, e, i) {
        "use strict";
        var n = i(17466);
        t.exports = function(t) {
            return n(t.length)
        }
    },
    56339: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(47293)
          , o = i(60614)
          , s = i(92597)
          , a = i(19781)
          , l = i(76530).CONFIGURABLE
          , c = i(42788)
          , h = i(29909)
          , u = h.enforce
          , d = h.get
          , f = String
          , p = Object.defineProperty
          , m = n("".slice)
          , g = n("".replace)
          , _ = n([].join)
          , y = a && !r((function() {
            return 8 !== p((function() {}
            ), "length", {
                value: 8
            }).length
        }
        ))
          , v = String(String).split("String")
          , x = t.exports = function(t, e, i) {
            "Symbol(" === m(f(e), 0, 7) && (e = "[" + g(f(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
            i && i.getter && (e = "get " + e),
            i && i.setter && (e = "set " + e),
            (!s(t, "name") || l && t.name !== e) && (a ? p(t, "name", {
                value: e,
                configurable: !0
            }) : t.name = e),
            y && i && s(i, "arity") && t.length !== i.arity && p(t, "length", {
                value: i.arity
            });
            try {
                i && s(i, "constructor") && i.constructor ? a && p(t, "prototype", {
                    writable: !1
                }) : t.prototype && (t.prototype = void 0)
            } catch (t) {}
            var n = u(t);
            return s(n, "source") || (n.source = _(v, "string" == typeof e ? e : "")),
            t
        }
        ;
        Function.prototype.toString = x((function() {
            return o(this) && d(this).source || c(this)
        }
        ), "toString")
    },
    74758: function(t) {
        "use strict";
        var e = Math.ceil
          , i = Math.floor;
        t.exports = Math.trunc || function(t) {
            var n = +t;
            return (n > 0 ? i : e)(n)
        }
    },
    56277: function(t, e, i) {
        "use strict";
        var n = i(41340);
        t.exports = function(t, e) {
            return void 0 === t ? arguments.length < 2 ? "" : e : n(t)
        }
    },
    3070: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(64664)
          , o = i(3353)
          , s = i(19670)
          , a = i(34948)
          , l = TypeError
          , c = Object.defineProperty
          , h = Object.getOwnPropertyDescriptor
          , u = "enumerable"
          , d = "configurable"
          , f = "writable";
        e.f = n ? o ? function(t, e, i) {
            if (s(t),
            e = a(e),
            s(i),
            "function" == typeof t && "prototype" === e && "value"in i && f in i && !i[f]) {
                var n = h(t, e);
                n && n[f] && (t[e] = i.value,
                i = {
                    configurable: d in i ? i[d] : n[d],
                    enumerable: u in i ? i[u] : n[u],
                    writable: !1
                })
            }
            return c(t, e, i)
        }
        : c : function(t, e, i) {
            if (s(t),
            e = a(e),
            s(i),
            r)
                try {
                    return c(t, e, i)
                } catch (t) {}
            if ("get"in i || "set"in i)
                throw l("Accessors not supported");
            return "value"in i && (t[e] = i.value),
            t
        }
    },
    31236: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(46916)
          , o = i(55296)
          , s = i(79114)
          , a = i(45656)
          , l = i(34948)
          , c = i(92597)
          , h = i(64664)
          , u = Object.getOwnPropertyDescriptor;
        e.f = n ? u : function(t, e) {
            if (t = a(t),
            e = l(e),
            h)
                try {
                    return u(t, e)
                } catch (t) {}
            if (c(t, e))
                return s(!r(o.f, t, e), t[e])
        }
    },
    8006: function(t, e, i) {
        "use strict";
        var n = i(16324)
          , r = i(80748).concat("length", "prototype");
        e.f = Object.getOwnPropertyNames || function(t) {
            return n(t, r)
        }
    },
    25181: function(t, e) {
        "use strict";
        e.f = Object.getOwnPropertySymbols
    },
    47976: function(t, e, i) {
        "use strict";
        var n = i(1702);
        t.exports = n({}.isPrototypeOf)
    },
    16324: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = i(92597)
          , o = i(45656)
          , s = i(41318).indexOf
          , a = i(3501)
          , l = n([].push);
        t.exports = function(t, e) {
            var i, n = o(t), c = 0, h = [];
            for (i in n)
                !r(a, i) && r(n, i) && l(h, i);
            for (; e.length > c; )
                r(n, i = e[c++]) && (~s(h, i) || l(h, i));
            return h
        }
    },
    55296: function(t, e) {
        "use strict";
        var i = {}.propertyIsEnumerable
          , n = Object.getOwnPropertyDescriptor
          , r = n && !i.call({
            1: 2
        }, 1);
        e.f = r ? function(t) {
            var e = n(this, t);
            return !!e && e.enumerable
        }
        : i
    },
    27674: function(t, e, i) {
        "use strict";
        var n = i(75668)
          , r = i(19670)
          , o = i(96077);
        t.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
            var t, e = !1, i = {};
            try {
                (t = n(Object.prototype, "__proto__", "set"))(i, []),
                e = i instanceof Array
            } catch (t) {}
            return function(i, n) {
                return r(i),
                o(n),
                e ? t(i, n) : i.__proto__ = n,
                i
            }
        }() : void 0)
    },
    92140: function(t, e, i) {
        "use strict";
        var n = i(46916)
          , r = i(60614)
          , o = i(70111)
          , s = TypeError;
        t.exports = function(t, e) {
            var i, a;
            if ("string" === e && r(i = t.toString) && !o(a = n(i, t)))
                return a;
            if (r(i = t.valueOf) && !o(a = n(i, t)))
                return a;
            if ("string" !== e && r(i = t.toString) && !o(a = n(i, t)))
                return a;
            throw s("Can't convert object to primitive value")
        }
    },
    53887: function(t, e, i) {
        "use strict";
        var n = i(35005)
          , r = i(1702)
          , o = i(8006)
          , s = i(25181)
          , a = i(19670)
          , l = r([].concat);
        t.exports = n("Reflect", "ownKeys") || function(t) {
            var e = o.f(a(t))
              , i = s.f;
            return i ? l(e, i(t)) : e
        }
    },
    84488: function(t, e, i) {
        "use strict";
        var n = i(68554)
          , r = TypeError;
        t.exports = function(t) {
            if (n(t))
                throw r("Can't call method on " + t);
            return t
        }
    },
    6200: function(t, e, i) {
        "use strict";
        var n = i(72309)
          , r = i(69711)
          , o = n("keys");
        t.exports = function(t) {
            return o[t] || (o[t] = r(t))
        }
    },
    5465: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(13072)
          , o = "__core-js_shared__"
          , s = n[o] || r(o, {});
        t.exports = s
    },
    72309: function(t, e, i) {
        "use strict";
        var n = i(31913)
          , r = i(5465);
        (t.exports = function(t, e) {
            return r[t] || (r[t] = void 0 !== e ? e : {})
        }
        )("versions", []).push({
            version: "3.32.0",
            mode: n ? "pure" : "global",
            copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE",
            source: "https://github.com/zloirock/core-js"
        })
    },
    36293: function(t, e, i) {
        "use strict";
        var n = i(7392)
          , r = i(47293)
          , o = i(17854).String;
        t.exports = !!Object.getOwnPropertySymbols && !r((function() {
            var t = Symbol();
            return !o(t) || !(Object(t)instanceof Symbol) || !Symbol.sham && n && n < 41
        }
        ))
    },
    51400: function(t, e, i) {
        "use strict";
        var n = i(19303)
          , r = Math.max
          , o = Math.min;
        t.exports = function(t, e) {
            var i = n(t);
            return i < 0 ? r(i + e, 0) : o(i, e)
        }
    },
    45656: function(t, e, i) {
        "use strict";
        var n = i(68361)
          , r = i(84488);
        t.exports = function(t) {
            return n(r(t))
        }
    },
    19303: function(t, e, i) {
        "use strict";
        var n = i(74758);
        t.exports = function(t) {
            var e = +t;
            return e != e || 0 === e ? 0 : n(e)
        }
    },
    17466: function(t, e, i) {
        "use strict";
        var n = i(19303)
          , r = Math.min;
        t.exports = function(t) {
            return t > 0 ? r(n(t), 9007199254740991) : 0
        }
    },
    47908: function(t, e, i) {
        "use strict";
        var n = i(84488)
          , r = Object;
        t.exports = function(t) {
            return r(n(t))
        }
    },
    57593: function(t, e, i) {
        "use strict";
        var n = i(46916)
          , r = i(70111)
          , o = i(52190)
          , s = i(58173)
          , a = i(92140)
          , l = i(5112)
          , c = TypeError
          , h = l("toPrimitive");
        t.exports = function(t, e) {
            if (!r(t) || o(t))
                return t;
            var i, l = s(t, h);
            if (l) {
                if (void 0 === e && (e = "default"),
                i = n(l, t, e),
                !r(i) || o(i))
                    return i;
                throw c("Can't convert object to primitive value")
            }
            return void 0 === e && (e = "number"),
            a(t, e)
        }
    },
    34948: function(t, e, i) {
        "use strict";
        var n = i(57593)
          , r = i(52190);
        t.exports = function(t) {
            var e = n(t, "string");
            return r(e) ? e : e + ""
        }
    },
    51694: function(t, e, i) {
        "use strict";
        var n = {};
        n[i(5112)("toStringTag")] = "z",
        t.exports = "[object z]" === String(n)
    },
    41340: function(t, e, i) {
        "use strict";
        var n = i(70648)
          , r = String;
        t.exports = function(t) {
            if ("Symbol" === n(t))
                throw TypeError("Cannot convert a Symbol value to a string");
            return r(t)
        }
    },
    66330: function(t) {
        "use strict";
        var e = String;
        t.exports = function(t) {
            try {
                return e(t)
            } catch (t) {
                return "Object"
            }
        }
    },
    69711: function(t, e, i) {
        "use strict";
        var n = i(1702)
          , r = 0
          , o = Math.random()
          , s = n(1..toString);
        t.exports = function(t) {
            return "Symbol(" + (void 0 === t ? "" : t) + ")_" + s(++r + o, 36)
        }
    },
    43307: function(t, e, i) {
        "use strict";
        var n = i(36293);
        t.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator
    },
    3353: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(47293);
        t.exports = n && r((function() {
            return 42 != Object.defineProperty((function() {}
            ), "prototype", {
                value: 42,
                writable: !1
            }).prototype
        }
        ))
    },
    48053: function(t) {
        "use strict";
        var e = TypeError;
        t.exports = function(t, i) {
            if (t < i)
                throw e("Not enough arguments");
            return t
        }
    },
    94811: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(60614)
          , o = n.WeakMap;
        t.exports = r(o) && /native code/.test(String(o))
    },
    5112: function(t, e, i) {
        "use strict";
        var n = i(17854)
          , r = i(72309)
          , o = i(92597)
          , s = i(69711)
          , a = i(36293)
          , l = i(43307)
          , c = n.Symbol
          , h = r("wks")
          , u = l ? c.for || c : c && c.withoutSetter || s;
        t.exports = function(t) {
            return o(h, t) || (h[t] = a && o(c, t) ? c[t] : u("Symbol." + t)),
            h[t]
        }
    },
    57658: function(t, e, i) {
        "use strict";
        var n = i(82109)
          , r = i(47908)
          , o = i(26244)
          , s = i(83658)
          , a = i(7207);
        n({
            target: "Array",
            proto: !0,
            arity: 1,
            forced: i(47293)((function() {
                return 4294967297 !== [].push.call({
                    length: 4294967296
                }, 1)
            }
            )) || !function() {
                try {
                    Object.defineProperty([], "length", {
                        writable: !1
                    }).push()
                } catch (t) {
                    return t instanceof TypeError
                }
            }()
        }, {
            push: function(t) {
                var e = r(this)
                  , i = o(e)
                  , n = arguments.length;
                a(i + n);
                for (var l = 0; l < n; l++)
                    e[i] = arguments[l],
                    i++;
                return s(e, i),
                i
            }
        })
    },
    82801: function(t, e, i) {
        "use strict";
        var n = i(82109)
          , r = i(17854)
          , o = i(35005)
          , s = i(79114)
          , a = i(3070).f
          , l = i(92597)
          , c = i(25787)
          , h = i(79587)
          , u = i(56277)
          , d = i(93678)
          , f = i(11060)
          , p = i(19781)
          , m = i(31913)
          , g = "DOMException"
          , _ = o("Error")
          , y = o(g)
          , v = function() {
            c(this, x);
            var t = arguments.length
              , e = u(t < 1 ? void 0 : arguments[0])
              , i = u(t < 2 ? void 0 : arguments[1], "Error")
              , n = new y(e,i)
              , r = _(e);
            return r.name = g,
            a(n, "stack", s(1, f(r.stack, 1))),
            h(n, this, v),
            n
        }
          , x = v.prototype = y.prototype
          , b = "stack"in _(g)
          , w = "stack"in new y(1,2)
          , E = y && p && Object.getOwnPropertyDescriptor(r, g)
          , T = !(!E || E.writable && E.configurable)
          , S = b && !T && !w;
        n({
            global: !0,
            constructor: !0,
            forced: m || S
        }, {
            DOMException: S ? v : y
        });
        var C = o(g)
          , A = C.prototype;
        if (A.constructor !== C)
            for (var I in m || a(A, "constructor", s(1, C)),
            d)
                if (l(d, I)) {
                    var M = d[I]
                      , P = M.s;
                    l(C, P) || a(C, P, s(6, M.c))
                }
    },
    46229: function(t, e, i) {
        "use strict";
        var n = i(98052)
          , r = i(1702)
          , o = i(41340)
          , s = i(48053)
          , a = URLSearchParams
          , l = a.prototype
          , c = r(l.append)
          , h = r(l.delete)
          , u = r(l.forEach)
          , d = r([].push)
          , f = new a("a=1&a=2&b=3");
        f.delete("a", 1),
        f.delete("b", void 0),
        f + "" != "a=2" && n(l, "delete", (function(t) {
            var e = arguments.length
              , i = e < 2 ? void 0 : arguments[1];
            if (e && void 0 === i)
                return h(this, t);
            var n = [];
            u(this, (function(t, e) {
                d(n, {
                    key: e,
                    value: t
                })
            }
            )),
            s(e, 1);
            for (var r, a = o(t), l = o(i), f = 0, p = 0, m = !1, g = n.length; f < g; )
                r = n[f++],
                m || r.key === a ? (m = !0,
                h(this, r.key)) : p++;
            for (; p < g; )
                (r = n[p++]).key === a && r.value === l || c(this, r.key, r.value)
        }
        ), {
            enumerable: !0,
            unsafe: !0
        })
    },
    17330: function(t, e, i) {
        "use strict";
        var n = i(98052)
          , r = i(1702)
          , o = i(41340)
          , s = i(48053)
          , a = URLSearchParams
          , l = a.prototype
          , c = r(l.getAll)
          , h = r(l.has)
          , u = new a("a=1");
        !u.has("a", 2) && u.has("a", void 0) || n(l, "has", (function(t) {
            var e = arguments.length
              , i = e < 2 ? void 0 : arguments[1];
            if (e && void 0 === i)
                return h(this, t);
            var n = c(this, t);
            s(e, 1);
            for (var r = o(i), a = 0; a < n.length; )
                if (n[a++] === r)
                    return !0;
            return !1
        }
        ), {
            enumerable: !0,
            unsafe: !0
        })
    },
    62062: function(t, e, i) {
        "use strict";
        var n = i(19781)
          , r = i(1702)
          , o = i(47045)
          , s = URLSearchParams.prototype
          , a = r(s.forEach);
        n && !("size"in s) && o(s, "size", {
            get: function() {
                var t = 0;
                return a(this, (function() {
                    t++
                }
                )),
                t
            },
            configurable: !0,
            enumerable: !0
        })
    },
    40452: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(98269),
        i(68214),
        i(90888),
        i(75109),
        function() {
            var t = n
              , e = t.lib.BlockCipher
              , i = t.algo
              , r = []
              , o = []
              , s = []
              , a = []
              , l = []
              , c = []
              , h = []
              , u = []
              , d = []
              , f = [];
            !function() {
                for (var t = [], e = 0; e < 256; e++)
                    t[e] = e < 128 ? e << 1 : e << 1 ^ 283;
                var i = 0
                  , n = 0;
                for (e = 0; e < 256; e++) {
                    var p = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4;
                    p = p >>> 8 ^ 255 & p ^ 99,
                    r[i] = p,
                    o[p] = i;
                    var m = t[i]
                      , g = t[m]
                      , _ = t[g]
                      , y = 257 * t[p] ^ 16843008 * p;
                    s[i] = y << 24 | y >>> 8,
                    a[i] = y << 16 | y >>> 16,
                    l[i] = y << 8 | y >>> 24,
                    c[i] = y,
                    y = 16843009 * _ ^ 65537 * g ^ 257 * m ^ 16843008 * i,
                    h[p] = y << 24 | y >>> 8,
                    u[p] = y << 16 | y >>> 16,
                    d[p] = y << 8 | y >>> 24,
                    f[p] = y,
                    i ? (i = m ^ t[t[t[_ ^ m]]],
                    n ^= t[t[n]]) : i = n = 1
                }
            }();
            var p = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]
              , m = i.AES = e.extend({
                _doReset: function() {
                    if (!this._nRounds || this._keyPriorReset !== this._key) {
                        for (var t = this._keyPriorReset = this._key, e = t.words, i = t.sigBytes / 4, n = 4 * ((this._nRounds = i + 6) + 1), o = this._keySchedule = [], s = 0; s < n; s++)
                            s < i ? o[s] = e[s] : (c = o[s - 1],
                            s % i ? i > 6 && s % i == 4 && (c = r[c >>> 24] << 24 | r[c >>> 16 & 255] << 16 | r[c >>> 8 & 255] << 8 | r[255 & c]) : (c = r[(c = c << 8 | c >>> 24) >>> 24] << 24 | r[c >>> 16 & 255] << 16 | r[c >>> 8 & 255] << 8 | r[255 & c],
                            c ^= p[s / i | 0] << 24),
                            o[s] = o[s - i] ^ c);
                        for (var a = this._invKeySchedule = [], l = 0; l < n; l++) {
                            if (s = n - l,
                            l % 4)
                                var c = o[s];
                            else
                                c = o[s - 4];
                            a[l] = l < 4 || s <= 4 ? c : h[r[c >>> 24]] ^ u[r[c >>> 16 & 255]] ^ d[r[c >>> 8 & 255]] ^ f[r[255 & c]]
                        }
                    }
                },
                encryptBlock: function(t, e) {
                    this._doCryptBlock(t, e, this._keySchedule, s, a, l, c, r)
                },
                decryptBlock: function(t, e) {
                    var i = t[e + 1];
                    t[e + 1] = t[e + 3],
                    t[e + 3] = i,
                    this._doCryptBlock(t, e, this._invKeySchedule, h, u, d, f, o),
                    i = t[e + 1],
                    t[e + 1] = t[e + 3],
                    t[e + 3] = i
                },
                _doCryptBlock: function(t, e, i, n, r, o, s, a) {
                    for (var l = this._nRounds, c = t[e] ^ i[0], h = t[e + 1] ^ i[1], u = t[e + 2] ^ i[2], d = t[e + 3] ^ i[3], f = 4, p = 1; p < l; p++) {
                        var m = n[c >>> 24] ^ r[h >>> 16 & 255] ^ o[u >>> 8 & 255] ^ s[255 & d] ^ i[f++]
                          , g = n[h >>> 24] ^ r[u >>> 16 & 255] ^ o[d >>> 8 & 255] ^ s[255 & c] ^ i[f++]
                          , _ = n[u >>> 24] ^ r[d >>> 16 & 255] ^ o[c >>> 8 & 255] ^ s[255 & h] ^ i[f++]
                          , y = n[d >>> 24] ^ r[c >>> 16 & 255] ^ o[h >>> 8 & 255] ^ s[255 & u] ^ i[f++];
                        c = m,
                        h = g,
                        u = _,
                        d = y
                    }
                    m = (a[c >>> 24] << 24 | a[h >>> 16 & 255] << 16 | a[u >>> 8 & 255] << 8 | a[255 & d]) ^ i[f++],
                    g = (a[h >>> 24] << 24 | a[u >>> 16 & 255] << 16 | a[d >>> 8 & 255] << 8 | a[255 & c]) ^ i[f++],
                    _ = (a[u >>> 24] << 24 | a[d >>> 16 & 255] << 16 | a[c >>> 8 & 255] << 8 | a[255 & h]) ^ i[f++],
                    y = (a[d >>> 24] << 24 | a[c >>> 16 & 255] << 16 | a[h >>> 8 & 255] << 8 | a[255 & u]) ^ i[f++],
                    t[e] = m,
                    t[e + 1] = g,
                    t[e + 2] = _,
                    t[e + 3] = y
                },
                keySize: 8
            });
            t.AES = e._createHelper(m)
        }(),
        n.AES)
    },
    75109: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(90888),
        void (n.lib.Cipher || function(t) {
            var e = n
              , i = e.lib
              , r = i.Base
              , o = i.WordArray
              , s = i.BufferedBlockAlgorithm
              , a = e.enc
              , l = (a.Utf8,
            a.Base64)
              , c = e.algo.EvpKDF
              , h = i.Cipher = s.extend({
                cfg: r.extend(),
                createEncryptor: function(t, e) {
                    return this.create(this._ENC_XFORM_MODE, t, e)
                },
                createDecryptor: function(t, e) {
                    return this.create(this._DEC_XFORM_MODE, t, e)
                },
                init: function(t, e, i) {
                    this.cfg = this.cfg.extend(i),
                    this._xformMode = t,
                    this._key = e,
                    this.reset()
                },
                reset: function() {
                    s.reset.call(this),
                    this._doReset()
                },
                process: function(t) {
                    return this._append(t),
                    this._process()
                },
                finalize: function(t) {
                    return t && this._append(t),
                    this._doFinalize()
                },
                keySize: 4,
                ivSize: 4,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function() {
                    function t(t) {
                        return "string" == typeof t ? v : _
                    }
                    return function(e) {
                        return {
                            encrypt: function(i, n, r) {
                                return t(n).encrypt(e, i, n, r)
                            },
                            decrypt: function(i, n, r) {
                                return t(n).decrypt(e, i, n, r)
                            }
                        }
                    }
                }()
            })
              , u = (i.StreamCipher = h.extend({
                _doFinalize: function() {
                    return this._process(!0)
                },
                blockSize: 1
            }),
            e.mode = {})
              , d = i.BlockCipherMode = r.extend({
                createEncryptor: function(t, e) {
                    return this.Encryptor.create(t, e)
                },
                createDecryptor: function(t, e) {
                    return this.Decryptor.create(t, e)
                },
                init: function(t, e) {
                    this._cipher = t,
                    this._iv = e
                }
            })
              , f = u.CBC = function() {
                var e = d.extend();
                function i(e, i, n) {
                    var r, o = this._iv;
                    o ? (r = o,
                    this._iv = t) : r = this._prevBlock;
                    for (var s = 0; s < n; s++)
                        e[i + s] ^= r[s]
                }
                return e.Encryptor = e.extend({
                    processBlock: function(t, e) {
                        var n = this._cipher
                          , r = n.blockSize;
                        i.call(this, t, e, r),
                        n.encryptBlock(t, e),
                        this._prevBlock = t.slice(e, e + r)
                    }
                }),
                e.Decryptor = e.extend({
                    processBlock: function(t, e) {
                        var n = this._cipher
                          , r = n.blockSize
                          , o = t.slice(e, e + r);
                        n.decryptBlock(t, e),
                        i.call(this, t, e, r),
                        this._prevBlock = o
                    }
                }),
                e
            }()
              , p = (e.pad = {}).Pkcs7 = {
                pad: function(t, e) {
                    for (var i = 4 * e, n = i - t.sigBytes % i, r = n << 24 | n << 16 | n << 8 | n, s = [], a = 0; a < n; a += 4)
                        s.push(r);
                    var l = o.create(s, n);
                    t.concat(l)
                },
                unpad: function(t) {
                    var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                    t.sigBytes -= e
                }
            }
              , m = (i.BlockCipher = h.extend({
                cfg: h.cfg.extend({
                    mode: f,
                    padding: p
                }),
                reset: function() {
                    var t;
                    h.reset.call(this);
                    var e = this.cfg
                      , i = e.iv
                      , n = e.mode;
                    this._xformMode == this._ENC_XFORM_MODE ? t = n.createEncryptor : (t = n.createDecryptor,
                    this._minBufferSize = 1),
                    this._mode && this._mode.__creator == t ? this._mode.init(this, i && i.words) : (this._mode = t.call(n, this, i && i.words),
                    this._mode.__creator = t)
                },
                _doProcessBlock: function(t, e) {
                    this._mode.processBlock(t, e)
                },
                _doFinalize: function() {
                    var t, e = this.cfg.padding;
                    return this._xformMode == this._ENC_XFORM_MODE ? (e.pad(this._data, this.blockSize),
                    t = this._process(!0)) : (t = this._process(!0),
                    e.unpad(t)),
                    t
                },
                blockSize: 4
            }),
            i.CipherParams = r.extend({
                init: function(t) {
                    this.mixIn(t)
                },
                toString: function(t) {
                    return (t || this.formatter).stringify(this)
                }
            }))
              , g = (e.format = {}).OpenSSL = {
                stringify: function(t) {
                    var e = t.ciphertext
                      , i = t.salt;
                    return (i ? o.create([1398893684, 1701076831]).concat(i).concat(e) : e).toString(l)
                },
                parse: function(t) {
                    var e, i = l.parse(t), n = i.words;
                    return 1398893684 == n[0] && 1701076831 == n[1] && (e = o.create(n.slice(2, 4)),
                    n.splice(0, 4),
                    i.sigBytes -= 16),
                    m.create({
                        ciphertext: i,
                        salt: e
                    })
                }
            }
              , _ = i.SerializableCipher = r.extend({
                cfg: r.extend({
                    format: g
                }),
                encrypt: function(t, e, i, n) {
                    n = this.cfg.extend(n);
                    var r = t.createEncryptor(i, n)
                      , o = r.finalize(e)
                      , s = r.cfg;
                    return m.create({
                        ciphertext: o,
                        key: i,
                        iv: s.iv,
                        algorithm: t,
                        mode: s.mode,
                        padding: s.padding,
                        blockSize: t.blockSize,
                        formatter: n.format
                    })
                },
                decrypt: function(t, e, i, n) {
                    return n = this.cfg.extend(n),
                    e = this._parse(e, n.format),
                    t.createDecryptor(i, n).finalize(e.ciphertext)
                },
                _parse: function(t, e) {
                    return "string" == typeof t ? e.parse(t, this) : t
                }
            })
              , y = (e.kdf = {}).OpenSSL = {
                execute: function(t, e, i, n) {
                    n || (n = o.random(8));
                    var r = c.create({
                        keySize: e + i
                    }).compute(t, n)
                      , s = o.create(r.words.slice(e), 4 * i);
                    return r.sigBytes = 4 * e,
                    m.create({
                        key: r,
                        iv: s,
                        salt: n
                    })
                }
            }
              , v = i.PasswordBasedCipher = _.extend({
                cfg: _.cfg.extend({
                    kdf: y
                }),
                encrypt: function(t, e, i, n) {
                    var r = (n = this.cfg.extend(n)).kdf.execute(i, t.keySize, t.ivSize);
                    n.iv = r.iv;
                    var o = _.encrypt.call(this, t, e, r.key, n);
                    return o.mixIn(r),
                    o
                },
                decrypt: function(t, e, i, n) {
                    n = this.cfg.extend(n),
                    e = this._parse(e, n.format);
                    var r = n.kdf.execute(i, t.keySize, t.ivSize, e.salt);
                    return n.iv = r.iv,
                    _.decrypt.call(this, t, e, r.key, n)
                }
            })
        }()))
    },
    78249: function(t, e, i) {
        var n;
        t.exports = (n = n || function(t, e) {
            var n;
            if ("undefined" != typeof window && window.crypto && (n = window.crypto),
            "undefined" != typeof self && self.crypto && (n = self.crypto),
            "undefined" != typeof globalThis && globalThis.crypto && (n = globalThis.crypto),
            !n && "undefined" != typeof window && window.msCrypto && (n = window.msCrypto),
            !n && void 0 !== i.g && i.g.crypto && (n = i.g.crypto),
            !n)
                try {
                    n = i(42480)
                } catch (t) {}
            var r = function() {
                if (n) {
                    if ("function" == typeof n.getRandomValues)
                        try {
                            return n.getRandomValues(new Uint32Array(1))[0]
                        } catch (t) {}
                    if ("function" == typeof n.randomBytes)
                        try {
                            return n.randomBytes(4).readInt32LE()
                        } catch (t) {}
                }
                throw new Error("Native crypto module could not be used to get secure random number.")
            }
              , o = Object.create || function() {
                function t() {}
                return function(e) {
                    var i;
                    return t.prototype = e,
                    i = new t,
                    t.prototype = null,
                    i
                }
            }()
              , s = {}
              , a = s.lib = {}
              , l = a.Base = {
                extend: function(t) {
                    var e = o(this);
                    return t && e.mixIn(t),
                    e.hasOwnProperty("init") && this.init !== e.init || (e.init = function() {
                        e.$super.init.apply(this, arguments)
                    }
                    ),
                    e.init.prototype = e,
                    e.$super = this,
                    e
                },
                create: function() {
                    var t = this.extend();
                    return t.init.apply(t, arguments),
                    t
                },
                init: function() {},
                mixIn: function(t) {
                    for (var e in t)
                        t.hasOwnProperty(e) && (this[e] = t[e]);
                    t.hasOwnProperty("toString") && (this.toString = t.toString)
                },
                clone: function() {
                    return this.init.prototype.extend(this)
                }
            }
              , c = a.WordArray = l.extend({
                init: function(t, i) {
                    t = this.words = t || [],
                    this.sigBytes = i != e ? i : 4 * t.length
                },
                toString: function(t) {
                    return (t || u).stringify(this)
                },
                concat: function(t) {
                    var e = this.words
                      , i = t.words
                      , n = this.sigBytes
                      , r = t.sigBytes;
                    if (this.clamp(),
                    n % 4)
                        for (var o = 0; o < r; o++) {
                            var s = i[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                            e[n + o >>> 2] |= s << 24 - (n + o) % 4 * 8
                        }
                    else
                        for (var a = 0; a < r; a += 4)
                            e[n + a >>> 2] = i[a >>> 2];
                    return this.sigBytes += r,
                    this
                },
                clamp: function() {
                    var e = this.words
                      , i = this.sigBytes;
                    e[i >>> 2] &= 4294967295 << 32 - i % 4 * 8,
                    e.length = t.ceil(i / 4)
                },
                clone: function() {
                    var t = l.clone.call(this);
                    return t.words = this.words.slice(0),
                    t
                },
                random: function(t) {
                    for (var e = [], i = 0; i < t; i += 4)
                        e.push(r());
                    return new c.init(e,t)
                }
            })
              , h = s.enc = {}
              , u = h.Hex = {
                stringify: function(t) {
                    for (var e = t.words, i = t.sigBytes, n = [], r = 0; r < i; r++) {
                        var o = e[r >>> 2] >>> 24 - r % 4 * 8 & 255;
                        n.push((o >>> 4).toString(16)),
                        n.push((15 & o).toString(16))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var e = t.length, i = [], n = 0; n < e; n += 2)
                        i[n >>> 3] |= parseInt(t.substr(n, 2), 16) << 24 - n % 8 * 4;
                    return new c.init(i,e / 2)
                }
            }
              , d = h.Latin1 = {
                stringify: function(t) {
                    for (var e = t.words, i = t.sigBytes, n = [], r = 0; r < i; r++) {
                        var o = e[r >>> 2] >>> 24 - r % 4 * 8 & 255;
                        n.push(String.fromCharCode(o))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var e = t.length, i = [], n = 0; n < e; n++)
                        i[n >>> 2] |= (255 & t.charCodeAt(n)) << 24 - n % 4 * 8;
                    return new c.init(i,e)
                }
            }
              , f = h.Utf8 = {
                stringify: function(t) {
                    try {
                        return decodeURIComponent(escape(d.stringify(t)))
                    } catch (t) {
                        throw new Error("Malformed UTF-8 data")
                    }
                },
                parse: function(t) {
                    return d.parse(unescape(encodeURIComponent(t)))
                }
            }
              , p = a.BufferedBlockAlgorithm = l.extend({
                reset: function() {
                    this._data = new c.init,
                    this._nDataBytes = 0
                },
                _append: function(t) {
                    "string" == typeof t && (t = f.parse(t)),
                    this._data.concat(t),
                    this._nDataBytes += t.sigBytes
                },
                _process: function(e) {
                    var i, n = this._data, r = n.words, o = n.sigBytes, s = this.blockSize, a = o / (4 * s), l = (a = e ? t.ceil(a) : t.max((0 | a) - this._minBufferSize, 0)) * s, h = t.min(4 * l, o);
                    if (l) {
                        for (var u = 0; u < l; u += s)
                            this._doProcessBlock(r, u);
                        i = r.splice(0, l),
                        n.sigBytes -= h
                    }
                    return new c.init(i,h)
                },
                clone: function() {
                    var t = l.clone.call(this);
                    return t._data = this._data.clone(),
                    t
                },
                _minBufferSize: 0
            })
              , m = (a.Hasher = p.extend({
                cfg: l.extend(),
                init: function(t) {
                    this.cfg = this.cfg.extend(t),
                    this.reset()
                },
                reset: function() {
                    p.reset.call(this),
                    this._doReset()
                },
                update: function(t) {
                    return this._append(t),
                    this._process(),
                    this
                },
                finalize: function(t) {
                    return t && this._append(t),
                    this._doFinalize()
                },
                blockSize: 16,
                _createHelper: function(t) {
                    return function(e, i) {
                        return new t.init(i).finalize(e)
                    }
                },
                _createHmacHelper: function(t) {
                    return function(e, i) {
                        return new m.HMAC.init(t,i).finalize(e)
                    }
                }
            }),
            s.algo = {});
            return s
        }(Math),
        n)
    },
    98269: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function() {
            var t = n
              , e = t.lib.WordArray;
            function i(t, i, n) {
                for (var r = [], o = 0, s = 0; s < i; s++)
                    if (s % 4) {
                        var a = n[t.charCodeAt(s - 1)] << s % 4 * 2 | n[t.charCodeAt(s)] >>> 6 - s % 4 * 2;
                        r[o >>> 2] |= a << 24 - o % 4 * 8,
                        o++
                    }
                return e.create(r, o)
            }
            t.enc.Base64 = {
                stringify: function(t) {
                    var e = t.words
                      , i = t.sigBytes
                      , n = this._map;
                    t.clamp();
                    for (var r = [], o = 0; o < i; o += 3)
                        for (var s = (e[o >>> 2] >>> 24 - o % 4 * 8 & 255) << 16 | (e[o + 1 >>> 2] >>> 24 - (o + 1) % 4 * 8 & 255) << 8 | e[o + 2 >>> 2] >>> 24 - (o + 2) % 4 * 8 & 255, a = 0; a < 4 && o + .75 * a < i; a++)
                            r.push(n.charAt(s >>> 6 * (3 - a) & 63));
                    var l = n.charAt(64);
                    if (l)
                        for (; r.length % 4; )
                            r.push(l);
                    return r.join("")
                },
                parse: function(t) {
                    var e = t.length
                      , n = this._map
                      , r = this._reverseMap;
                    if (!r) {
                        r = this._reverseMap = [];
                        for (var o = 0; o < n.length; o++)
                            r[n.charCodeAt(o)] = o
                    }
                    var s = n.charAt(64);
                    if (s) {
                        var a = t.indexOf(s);
                        -1 !== a && (e = a)
                    }
                    return i(t, e, r)
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            }
        }(),
        n.enc.Base64)
    },
    43786: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function() {
            var t = n
              , e = t.lib.WordArray;
            function i(t, i, n) {
                for (var r = [], o = 0, s = 0; s < i; s++)
                    if (s % 4) {
                        var a = n[t.charCodeAt(s - 1)] << s % 4 * 2 | n[t.charCodeAt(s)] >>> 6 - s % 4 * 2;
                        r[o >>> 2] |= a << 24 - o % 4 * 8,
                        o++
                    }
                return e.create(r, o)
            }
            t.enc.Base64url = {
                stringify: function(t, e=!0) {
                    var i = t.words
                      , n = t.sigBytes
                      , r = e ? this._safe_map : this._map;
                    t.clamp();
                    for (var o = [], s = 0; s < n; s += 3)
                        for (var a = (i[s >>> 2] >>> 24 - s % 4 * 8 & 255) << 16 | (i[s + 1 >>> 2] >>> 24 - (s + 1) % 4 * 8 & 255) << 8 | i[s + 2 >>> 2] >>> 24 - (s + 2) % 4 * 8 & 255, l = 0; l < 4 && s + .75 * l < n; l++)
                            o.push(r.charAt(a >>> 6 * (3 - l) & 63));
                    var c = r.charAt(64);
                    if (c)
                        for (; o.length % 4; )
                            o.push(c);
                    return o.join("")
                },
                parse: function(t, e=!0) {
                    var n = t.length
                      , r = e ? this._safe_map : this._map
                      , o = this._reverseMap;
                    if (!o) {
                        o = this._reverseMap = [];
                        for (var s = 0; s < r.length; s++)
                            o[r.charCodeAt(s)] = s
                    }
                    var a = r.charAt(64);
                    if (a) {
                        var l = t.indexOf(a);
                        -1 !== l && (n = l)
                    }
                    return i(t, n, o)
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
                _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
            }
        }(),
        n.enc.Base64url)
    },
    50298: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function() {
            var t = n
              , e = t.lib.WordArray
              , i = t.enc;
            function r(t) {
                return t << 8 & 4278255360 | t >>> 8 & 16711935
            }
            i.Utf16 = i.Utf16BE = {
                stringify: function(t) {
                    for (var e = t.words, i = t.sigBytes, n = [], r = 0; r < i; r += 2) {
                        var o = e[r >>> 2] >>> 16 - r % 4 * 8 & 65535;
                        n.push(String.fromCharCode(o))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var i = t.length, n = [], r = 0; r < i; r++)
                        n[r >>> 1] |= t.charCodeAt(r) << 16 - r % 2 * 16;
                    return e.create(n, 2 * i)
                }
            },
            i.Utf16LE = {
                stringify: function(t) {
                    for (var e = t.words, i = t.sigBytes, n = [], o = 0; o < i; o += 2) {
                        var s = r(e[o >>> 2] >>> 16 - o % 4 * 8 & 65535);
                        n.push(String.fromCharCode(s))
                    }
                    return n.join("")
                },
                parse: function(t) {
                    for (var i = t.length, n = [], o = 0; o < i; o++)
                        n[o >>> 1] |= r(t.charCodeAt(o) << 16 - o % 2 * 16);
                    return e.create(n, 2 * i)
                }
            }
        }(),
        n.enc.Utf16)
    },
    90888: function(t, e, i) {
        var n, r, o, s, a, l, c, h;
        t.exports = (h = i(78249),
        i(62783),
        i(89824),
        r = (n = h).lib,
        o = r.Base,
        s = r.WordArray,
        a = n.algo,
        l = a.MD5,
        c = a.EvpKDF = o.extend({
            cfg: o.extend({
                keySize: 4,
                hasher: l,
                iterations: 1
            }),
            init: function(t) {
                this.cfg = this.cfg.extend(t)
            },
            compute: function(t, e) {
                for (var i, n = this.cfg, r = n.hasher.create(), o = s.create(), a = o.words, l = n.keySize, c = n.iterations; a.length < l; ) {
                    i && r.update(i),
                    i = r.update(t).finalize(e),
                    r.reset();
                    for (var h = 1; h < c; h++)
                        i = r.finalize(i),
                        r.reset();
                    o.concat(i)
                }
                return o.sigBytes = 4 * l,
                o
            }
        }),
        n.EvpKDF = function(t, e, i) {
            return c.create(i).compute(t, e)
        }
        ,
        h.EvpKDF)
    },
    42209: function(t, e, i) {
        var n, r, o, s;
        t.exports = (s = i(78249),
        i(75109),
        r = (n = s).lib.CipherParams,
        o = n.enc.Hex,
        n.format.Hex = {
            stringify: function(t) {
                return t.ciphertext.toString(o)
            },
            parse: function(t) {
                var e = o.parse(t);
                return r.create({
                    ciphertext: e
                })
            }
        },
        s.format.Hex)
    },
    89824: function(t, e, i) {
        var n, r, o, s;
        t.exports = (n = i(78249),
        o = (r = n).lib.Base,
        s = r.enc.Utf8,
        void (r.algo.HMAC = o.extend({
            init: function(t, e) {
                t = this._hasher = new t.init,
                "string" == typeof e && (e = s.parse(e));
                var i = t.blockSize
                  , n = 4 * i;
                e.sigBytes > n && (e = t.finalize(e)),
                e.clamp();
                for (var r = this._oKey = e.clone(), o = this._iKey = e.clone(), a = r.words, l = o.words, c = 0; c < i; c++)
                    a[c] ^= 1549556828,
                    l[c] ^= 909522486;
                r.sigBytes = o.sigBytes = n,
                this.reset()
            },
            reset: function() {
                var t = this._hasher;
                t.reset(),
                t.update(this._iKey)
            },
            update: function(t) {
                return this._hasher.update(t),
                this
            },
            finalize: function(t) {
                var e = this._hasher
                  , i = e.finalize(t);
                return e.reset(),
                e.finalize(this._oKey.clone().concat(i))
            }
        })))
    },
    81354: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(64938),
        i(4433),
        i(50298),
        i(98269),
        i(43786),
        i(68214),
        i(62783),
        i(52153),
        i(87792),
        i(70034),
        i(17460),
        i(13327),
        i(30706),
        i(89824),
        i(2112),
        i(90888),
        i(75109),
        i(8568),
        i(74242),
        i(59968),
        i(27660),
        i(31148),
        i(43615),
        i(92807),
        i(71077),
        i(56475),
        i(16991),
        i(42209),
        i(40452),
        i(94253),
        i(51857),
        i(84454),
        i(93974),
        n)
    },
    4433: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function() {
            if ("function" == typeof ArrayBuffer) {
                var t = n.lib.WordArray
                  , e = t.init
                  , i = t.init = function(t) {
                    if (t instanceof ArrayBuffer && (t = new Uint8Array(t)),
                    (t instanceof Int8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array) && (t = new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),
                    t instanceof Uint8Array) {
                        for (var i = t.byteLength, n = [], r = 0; r < i; r++)
                            n[r >>> 2] |= t[r] << 24 - r % 4 * 8;
                        e.call(this, n, i)
                    } else
                        e.apply(this, arguments)
                }
                ;
                i.prototype = t
            }
        }(),
        n.lib.WordArray)
    },
    68214: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function(t) {
            var e = n
              , i = e.lib
              , r = i.WordArray
              , o = i.Hasher
              , s = e.algo
              , a = [];
            !function() {
                for (var e = 0; e < 64; e++)
                    a[e] = 4294967296 * t.abs(t.sin(e + 1)) | 0
            }();
            var l = s.MD5 = o.extend({
                _doReset: function() {
                    this._hash = new r.init([1732584193, 4023233417, 2562383102, 271733878])
                },
                _doProcessBlock: function(t, e) {
                    for (var i = 0; i < 16; i++) {
                        var n = e + i
                          , r = t[n];
                        t[n] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8)
                    }
                    var o = this._hash.words
                      , s = t[e + 0]
                      , l = t[e + 1]
                      , f = t[e + 2]
                      , p = t[e + 3]
                      , m = t[e + 4]
                      , g = t[e + 5]
                      , _ = t[e + 6]
                      , y = t[e + 7]
                      , v = t[e + 8]
                      , x = t[e + 9]
                      , b = t[e + 10]
                      , w = t[e + 11]
                      , E = t[e + 12]
                      , T = t[e + 13]
                      , S = t[e + 14]
                      , C = t[e + 15]
                      , A = o[0]
                      , I = o[1]
                      , M = o[2]
                      , P = o[3];
                    A = c(A, I, M, P, s, 7, a[0]),
                    P = c(P, A, I, M, l, 12, a[1]),
                    M = c(M, P, A, I, f, 17, a[2]),
                    I = c(I, M, P, A, p, 22, a[3]),
                    A = c(A, I, M, P, m, 7, a[4]),
                    P = c(P, A, I, M, g, 12, a[5]),
                    M = c(M, P, A, I, _, 17, a[6]),
                    I = c(I, M, P, A, y, 22, a[7]),
                    A = c(A, I, M, P, v, 7, a[8]),
                    P = c(P, A, I, M, x, 12, a[9]),
                    M = c(M, P, A, I, b, 17, a[10]),
                    I = c(I, M, P, A, w, 22, a[11]),
                    A = c(A, I, M, P, E, 7, a[12]),
                    P = c(P, A, I, M, T, 12, a[13]),
                    M = c(M, P, A, I, S, 17, a[14]),
                    A = h(A, I = c(I, M, P, A, C, 22, a[15]), M, P, l, 5, a[16]),
                    P = h(P, A, I, M, _, 9, a[17]),
                    M = h(M, P, A, I, w, 14, a[18]),
                    I = h(I, M, P, A, s, 20, a[19]),
                    A = h(A, I, M, P, g, 5, a[20]),
                    P = h(P, A, I, M, b, 9, a[21]),
                    M = h(M, P, A, I, C, 14, a[22]),
                    I = h(I, M, P, A, m, 20, a[23]),
                    A = h(A, I, M, P, x, 5, a[24]),
                    P = h(P, A, I, M, S, 9, a[25]),
                    M = h(M, P, A, I, p, 14, a[26]),
                    I = h(I, M, P, A, v, 20, a[27]),
                    A = h(A, I, M, P, T, 5, a[28]),
                    P = h(P, A, I, M, f, 9, a[29]),
                    M = h(M, P, A, I, y, 14, a[30]),
                    A = u(A, I = h(I, M, P, A, E, 20, a[31]), M, P, g, 4, a[32]),
                    P = u(P, A, I, M, v, 11, a[33]),
                    M = u(M, P, A, I, w, 16, a[34]),
                    I = u(I, M, P, A, S, 23, a[35]),
                    A = u(A, I, M, P, l, 4, a[36]),
                    P = u(P, A, I, M, m, 11, a[37]),
                    M = u(M, P, A, I, y, 16, a[38]),
                    I = u(I, M, P, A, b, 23, a[39]),
                    A = u(A, I, M, P, T, 4, a[40]),
                    P = u(P, A, I, M, s, 11, a[41]),
                    M = u(M, P, A, I, p, 16, a[42]),
                    I = u(I, M, P, A, _, 23, a[43]),
                    A = u(A, I, M, P, x, 4, a[44]),
                    P = u(P, A, I, M, E, 11, a[45]),
                    M = u(M, P, A, I, C, 16, a[46]),
                    A = d(A, I = u(I, M, P, A, f, 23, a[47]), M, P, s, 6, a[48]),
                    P = d(P, A, I, M, y, 10, a[49]),
                    M = d(M, P, A, I, S, 15, a[50]),
                    I = d(I, M, P, A, g, 21, a[51]),
                    A = d(A, I, M, P, E, 6, a[52]),
                    P = d(P, A, I, M, p, 10, a[53]),
                    M = d(M, P, A, I, b, 15, a[54]),
                    I = d(I, M, P, A, l, 21, a[55]),
                    A = d(A, I, M, P, v, 6, a[56]),
                    P = d(P, A, I, M, C, 10, a[57]),
                    M = d(M, P, A, I, _, 15, a[58]),
                    I = d(I, M, P, A, T, 21, a[59]),
                    A = d(A, I, M, P, m, 6, a[60]),
                    P = d(P, A, I, M, w, 10, a[61]),
                    M = d(M, P, A, I, f, 15, a[62]),
                    I = d(I, M, P, A, x, 21, a[63]),
                    o[0] = o[0] + A | 0,
                    o[1] = o[1] + I | 0,
                    o[2] = o[2] + M | 0,
                    o[3] = o[3] + P | 0
                },
                _doFinalize: function() {
                    var e = this._data
                      , i = e.words
                      , n = 8 * this._nDataBytes
                      , r = 8 * e.sigBytes;
                    i[r >>> 5] |= 128 << 24 - r % 32;
                    var o = t.floor(n / 4294967296)
                      , s = n;
                    i[15 + (r + 64 >>> 9 << 4)] = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                    i[14 + (r + 64 >>> 9 << 4)] = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                    e.sigBytes = 4 * (i.length + 1),
                    this._process();
                    for (var a = this._hash, l = a.words, c = 0; c < 4; c++) {
                        var h = l[c];
                        l[c] = 16711935 & (h << 8 | h >>> 24) | 4278255360 & (h << 24 | h >>> 8)
                    }
                    return a
                },
                clone: function() {
                    var t = o.clone.call(this);
                    return t._hash = this._hash.clone(),
                    t
                }
            });
            function c(t, e, i, n, r, o, s) {
                var a = t + (e & i | ~e & n) + r + s;
                return (a << o | a >>> 32 - o) + e
            }
            function h(t, e, i, n, r, o, s) {
                var a = t + (e & n | i & ~n) + r + s;
                return (a << o | a >>> 32 - o) + e
            }
            function u(t, e, i, n, r, o, s) {
                var a = t + (e ^ i ^ n) + r + s;
                return (a << o | a >>> 32 - o) + e
            }
            function d(t, e, i, n, r, o, s) {
                var a = t + (i ^ (e | ~n)) + r + s;
                return (a << o | a >>> 32 - o) + e
            }
            e.MD5 = o._createHelper(l),
            e.HmacMD5 = o._createHmacHelper(l)
        }(Math),
        n.MD5)
    },
    8568: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.mode.CFB = function() {
            var t = n.lib.BlockCipherMode.extend();
            function e(t, e, i, n) {
                var r, o = this._iv;
                o ? (r = o.slice(0),
                this._iv = void 0) : r = this._prevBlock,
                n.encryptBlock(r, 0);
                for (var s = 0; s < i; s++)
                    t[e + s] ^= r[s]
            }
            return t.Encryptor = t.extend({
                processBlock: function(t, i) {
                    var n = this._cipher
                      , r = n.blockSize;
                    e.call(this, t, i, r, n),
                    this._prevBlock = t.slice(i, i + r)
                }
            }),
            t.Decryptor = t.extend({
                processBlock: function(t, i) {
                    var n = this._cipher
                      , r = n.blockSize
                      , o = t.slice(i, i + r);
                    e.call(this, t, i, r, n),
                    this._prevBlock = o
                }
            }),
            t
        }(),
        n.mode.CFB)
    },
    59968: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.mode.CTRGladman = function() {
            var t = n.lib.BlockCipherMode.extend();
            function e(t) {
                if (255 == (t >> 24 & 255)) {
                    var e = t >> 16 & 255
                      , i = t >> 8 & 255
                      , n = 255 & t;
                    255 === e ? (e = 0,
                    255 === i ? (i = 0,
                    255 === n ? n = 0 : ++n) : ++i) : ++e,
                    t = 0,
                    t += e << 16,
                    t += i << 8,
                    t += n
                } else
                    t += 1 << 24;
                return t
            }
            function i(t) {
                return 0 === (t[0] = e(t[0])) && (t[1] = e(t[1])),
                t
            }
            var r = t.Encryptor = t.extend({
                processBlock: function(t, e) {
                    var n = this._cipher
                      , r = n.blockSize
                      , o = this._iv
                      , s = this._counter;
                    o && (s = this._counter = o.slice(0),
                    this._iv = void 0),
                    i(s);
                    var a = s.slice(0);
                    n.encryptBlock(a, 0);
                    for (var l = 0; l < r; l++)
                        t[e + l] ^= a[l]
                }
            });
            return t.Decryptor = r,
            t
        }(),
        n.mode.CTRGladman)
    },
    74242: function(t, e, i) {
        var n, r, o;
        t.exports = (o = i(78249),
        i(75109),
        o.mode.CTR = (n = o.lib.BlockCipherMode.extend(),
        r = n.Encryptor = n.extend({
            processBlock: function(t, e) {
                var i = this._cipher
                  , n = i.blockSize
                  , r = this._iv
                  , o = this._counter;
                r && (o = this._counter = r.slice(0),
                this._iv = void 0);
                var s = o.slice(0);
                i.encryptBlock(s, 0),
                o[n - 1] = o[n - 1] + 1 | 0;
                for (var a = 0; a < n; a++)
                    t[e + a] ^= s[a]
            }
        }),
        n.Decryptor = r,
        n),
        o.mode.CTR)
    },
    31148: function(t, e, i) {
        var n, r;
        t.exports = (r = i(78249),
        i(75109),
        r.mode.ECB = ((n = r.lib.BlockCipherMode.extend()).Encryptor = n.extend({
            processBlock: function(t, e) {
                this._cipher.encryptBlock(t, e)
            }
        }),
        n.Decryptor = n.extend({
            processBlock: function(t, e) {
                this._cipher.decryptBlock(t, e)
            }
        }),
        n),
        r.mode.ECB)
    },
    27660: function(t, e, i) {
        var n, r, o;
        t.exports = (o = i(78249),
        i(75109),
        o.mode.OFB = (n = o.lib.BlockCipherMode.extend(),
        r = n.Encryptor = n.extend({
            processBlock: function(t, e) {
                var i = this._cipher
                  , n = i.blockSize
                  , r = this._iv
                  , o = this._keystream;
                r && (o = this._keystream = r.slice(0),
                this._iv = void 0),
                i.encryptBlock(o, 0);
                for (var s = 0; s < n; s++)
                    t[e + s] ^= o[s]
            }
        }),
        n.Decryptor = r,
        n),
        o.mode.OFB)
    },
    43615: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.pad.AnsiX923 = {
            pad: function(t, e) {
                var i = t.sigBytes
                  , n = 4 * e
                  , r = n - i % n
                  , o = i + r - 1;
                t.clamp(),
                t.words[o >>> 2] |= r << 24 - o % 4 * 8,
                t.sigBytes += r
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        },
        n.pad.Ansix923)
    },
    92807: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.pad.Iso10126 = {
            pad: function(t, e) {
                var i = 4 * e
                  , r = i - t.sigBytes % i;
                t.concat(n.lib.WordArray.random(r - 1)).concat(n.lib.WordArray.create([r << 24], 1))
            },
            unpad: function(t) {
                var e = 255 & t.words[t.sigBytes - 1 >>> 2];
                t.sigBytes -= e
            }
        },
        n.pad.Iso10126)
    },
    71077: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.pad.Iso97971 = {
            pad: function(t, e) {
                t.concat(n.lib.WordArray.create([2147483648], 1)),
                n.pad.ZeroPadding.pad(t, e)
            },
            unpad: function(t) {
                n.pad.ZeroPadding.unpad(t),
                t.sigBytes--
            }
        },
        n.pad.Iso97971)
    },
    16991: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.pad.NoPadding = {
            pad: function() {},
            unpad: function() {}
        },
        n.pad.NoPadding)
    },
    56475: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(75109),
        n.pad.ZeroPadding = {
            pad: function(t, e) {
                var i = 4 * e;
                t.clamp(),
                t.sigBytes += i - (t.sigBytes % i || i)
            },
            unpad: function(t) {
                var e = t.words
                  , i = t.sigBytes - 1;
                for (i = t.sigBytes - 1; i >= 0; i--)
                    if (e[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
                        t.sigBytes = i + 1;
                        break
                    }
            }
        },
        n.pad.ZeroPadding)
    },
    2112: function(t, e, i) {
        var n, r, o, s, a, l, c, h, u;
        t.exports = (u = i(78249),
        i(62783),
        i(89824),
        r = (n = u).lib,
        o = r.Base,
        s = r.WordArray,
        a = n.algo,
        l = a.SHA1,
        c = a.HMAC,
        h = a.PBKDF2 = o.extend({
            cfg: o.extend({
                keySize: 4,
                hasher: l,
                iterations: 1
            }),
            init: function(t) {
                this.cfg = this.cfg.extend(t)
            },
            compute: function(t, e) {
                for (var i = this.cfg, n = c.create(i.hasher, t), r = s.create(), o = s.create([1]), a = r.words, l = o.words, h = i.keySize, u = i.iterations; a.length < h; ) {
                    var d = n.update(e).finalize(o);
                    n.reset();
                    for (var f = d.words, p = f.length, m = d, g = 1; g < u; g++) {
                        m = n.finalize(m),
                        n.reset();
                        for (var _ = m.words, y = 0; y < p; y++)
                            f[y] ^= _[y]
                    }
                    r.concat(d),
                    l[0]++
                }
                return r.sigBytes = 4 * h,
                r
            }
        }),
        n.PBKDF2 = function(t, e, i) {
            return h.create(i).compute(t, e)
        }
        ,
        u.PBKDF2)
    },
    93974: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(98269),
        i(68214),
        i(90888),
        i(75109),
        function() {
            var t = n
              , e = t.lib.StreamCipher
              , i = t.algo
              , r = []
              , o = []
              , s = []
              , a = i.RabbitLegacy = e.extend({
                _doReset: function() {
                    var t = this._key.words
                      , e = this.cfg.iv
                      , i = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                      , n = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                    this._b = 0;
                    for (var r = 0; r < 4; r++)
                        l.call(this);
                    for (r = 0; r < 8; r++)
                        n[r] ^= i[r + 4 & 7];
                    if (e) {
                        var o = e.words
                          , s = o[0]
                          , a = o[1]
                          , c = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                          , h = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                          , u = c >>> 16 | 4294901760 & h
                          , d = h << 16 | 65535 & c;
                        for (n[0] ^= c,
                        n[1] ^= u,
                        n[2] ^= h,
                        n[3] ^= d,
                        n[4] ^= c,
                        n[5] ^= u,
                        n[6] ^= h,
                        n[7] ^= d,
                        r = 0; r < 4; r++)
                            l.call(this)
                    }
                },
                _doProcessBlock: function(t, e) {
                    var i = this._X;
                    l.call(this),
                    r[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                    r[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                    r[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                    r[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                    for (var n = 0; n < 4; n++)
                        r[n] = 16711935 & (r[n] << 8 | r[n] >>> 24) | 4278255360 & (r[n] << 24 | r[n] >>> 8),
                        t[e + n] ^= r[n]
                },
                blockSize: 4,
                ivSize: 2
            });
            function l() {
                for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                    o[i] = e[i];
                for (e[0] = e[0] + 1295307597 + this._b | 0,
                e[1] = e[1] + 3545052371 + (e[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0,
                e[2] = e[2] + 886263092 + (e[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0,
                e[3] = e[3] + 1295307597 + (e[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0,
                e[4] = e[4] + 3545052371 + (e[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0,
                e[5] = e[5] + 886263092 + (e[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0,
                e[6] = e[6] + 1295307597 + (e[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0,
                e[7] = e[7] + 3545052371 + (e[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0,
                this._b = e[7] >>> 0 < o[7] >>> 0 ? 1 : 0,
                i = 0; i < 8; i++) {
                    var n = t[i] + e[i]
                      , r = 65535 & n
                      , a = n >>> 16
                      , l = ((r * r >>> 17) + r * a >>> 15) + a * a
                      , c = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                    s[i] = l ^ c
                }
                t[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0,
                t[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0,
                t[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0,
                t[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0,
                t[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0,
                t[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0,
                t[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0,
                t[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0
            }
            t.RabbitLegacy = e._createHelper(a)
        }(),
        n.RabbitLegacy)
    },
    84454: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(98269),
        i(68214),
        i(90888),
        i(75109),
        function() {
            var t = n
              , e = t.lib.StreamCipher
              , i = t.algo
              , r = []
              , o = []
              , s = []
              , a = i.Rabbit = e.extend({
                _doReset: function() {
                    for (var t = this._key.words, e = this.cfg.iv, i = 0; i < 4; i++)
                        t[i] = 16711935 & (t[i] << 8 | t[i] >>> 24) | 4278255360 & (t[i] << 24 | t[i] >>> 8);
                    var n = this._X = [t[0], t[3] << 16 | t[2] >>> 16, t[1], t[0] << 16 | t[3] >>> 16, t[2], t[1] << 16 | t[0] >>> 16, t[3], t[2] << 16 | t[1] >>> 16]
                      , r = this._C = [t[2] << 16 | t[2] >>> 16, 4294901760 & t[0] | 65535 & t[1], t[3] << 16 | t[3] >>> 16, 4294901760 & t[1] | 65535 & t[2], t[0] << 16 | t[0] >>> 16, 4294901760 & t[2] | 65535 & t[3], t[1] << 16 | t[1] >>> 16, 4294901760 & t[3] | 65535 & t[0]];
                    for (this._b = 0,
                    i = 0; i < 4; i++)
                        l.call(this);
                    for (i = 0; i < 8; i++)
                        r[i] ^= n[i + 4 & 7];
                    if (e) {
                        var o = e.words
                          , s = o[0]
                          , a = o[1]
                          , c = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8)
                          , h = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                          , u = c >>> 16 | 4294901760 & h
                          , d = h << 16 | 65535 & c;
                        for (r[0] ^= c,
                        r[1] ^= u,
                        r[2] ^= h,
                        r[3] ^= d,
                        r[4] ^= c,
                        r[5] ^= u,
                        r[6] ^= h,
                        r[7] ^= d,
                        i = 0; i < 4; i++)
                            l.call(this)
                    }
                },
                _doProcessBlock: function(t, e) {
                    var i = this._X;
                    l.call(this),
                    r[0] = i[0] ^ i[5] >>> 16 ^ i[3] << 16,
                    r[1] = i[2] ^ i[7] >>> 16 ^ i[5] << 16,
                    r[2] = i[4] ^ i[1] >>> 16 ^ i[7] << 16,
                    r[3] = i[6] ^ i[3] >>> 16 ^ i[1] << 16;
                    for (var n = 0; n < 4; n++)
                        r[n] = 16711935 & (r[n] << 8 | r[n] >>> 24) | 4278255360 & (r[n] << 24 | r[n] >>> 8),
                        t[e + n] ^= r[n]
                },
                blockSize: 4,
                ivSize: 2
            });
            function l() {
                for (var t = this._X, e = this._C, i = 0; i < 8; i++)
                    o[i] = e[i];
                for (e[0] = e[0] + 1295307597 + this._b | 0,
                e[1] = e[1] + 3545052371 + (e[0] >>> 0 < o[0] >>> 0 ? 1 : 0) | 0,
                e[2] = e[2] + 886263092 + (e[1] >>> 0 < o[1] >>> 0 ? 1 : 0) | 0,
                e[3] = e[3] + 1295307597 + (e[2] >>> 0 < o[2] >>> 0 ? 1 : 0) | 0,
                e[4] = e[4] + 3545052371 + (e[3] >>> 0 < o[3] >>> 0 ? 1 : 0) | 0,
                e[5] = e[5] + 886263092 + (e[4] >>> 0 < o[4] >>> 0 ? 1 : 0) | 0,
                e[6] = e[6] + 1295307597 + (e[5] >>> 0 < o[5] >>> 0 ? 1 : 0) | 0,
                e[7] = e[7] + 3545052371 + (e[6] >>> 0 < o[6] >>> 0 ? 1 : 0) | 0,
                this._b = e[7] >>> 0 < o[7] >>> 0 ? 1 : 0,
                i = 0; i < 8; i++) {
                    var n = t[i] + e[i]
                      , r = 65535 & n
                      , a = n >>> 16
                      , l = ((r * r >>> 17) + r * a >>> 15) + a * a
                      , c = ((4294901760 & n) * n | 0) + ((65535 & n) * n | 0);
                    s[i] = l ^ c
                }
                t[0] = s[0] + (s[7] << 16 | s[7] >>> 16) + (s[6] << 16 | s[6] >>> 16) | 0,
                t[1] = s[1] + (s[0] << 8 | s[0] >>> 24) + s[7] | 0,
                t[2] = s[2] + (s[1] << 16 | s[1] >>> 16) + (s[0] << 16 | s[0] >>> 16) | 0,
                t[3] = s[3] + (s[2] << 8 | s[2] >>> 24) + s[1] | 0,
                t[4] = s[4] + (s[3] << 16 | s[3] >>> 16) + (s[2] << 16 | s[2] >>> 16) | 0,
                t[5] = s[5] + (s[4] << 8 | s[4] >>> 24) + s[3] | 0,
                t[6] = s[6] + (s[5] << 16 | s[5] >>> 16) + (s[4] << 16 | s[4] >>> 16) | 0,
                t[7] = s[7] + (s[6] << 8 | s[6] >>> 24) + s[5] | 0
            }
            t.Rabbit = e._createHelper(a)
        }(),
        n.Rabbit)
    },
    51857: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(98269),
        i(68214),
        i(90888),
        i(75109),
        function() {
            var t = n
              , e = t.lib.StreamCipher
              , i = t.algo
              , r = i.RC4 = e.extend({
                _doReset: function() {
                    for (var t = this._key, e = t.words, i = t.sigBytes, n = this._S = [], r = 0; r < 256; r++)
                        n[r] = r;
                    r = 0;
                    for (var o = 0; r < 256; r++) {
                        var s = r % i
                          , a = e[s >>> 2] >>> 24 - s % 4 * 8 & 255;
                        o = (o + n[r] + a) % 256;
                        var l = n[r];
                        n[r] = n[o],
                        n[o] = l
                    }
                    this._i = this._j = 0
                },
                _doProcessBlock: function(t, e) {
                    t[e] ^= o.call(this)
                },
                keySize: 8,
                ivSize: 0
            });
            function o() {
                for (var t = this._S, e = this._i, i = this._j, n = 0, r = 0; r < 4; r++) {
                    i = (i + t[e = (e + 1) % 256]) % 256;
                    var o = t[e];
                    t[e] = t[i],
                    t[i] = o,
                    n |= t[(t[e] + t[i]) % 256] << 24 - 8 * r
                }
                return this._i = e,
                this._j = i,
                n
            }
            t.RC4 = e._createHelper(r);
            var s = i.RC4Drop = r.extend({
                cfg: r.cfg.extend({
                    drop: 192
                }),
                _doReset: function() {
                    r._doReset.call(this);
                    for (var t = this.cfg.drop; t > 0; t--)
                        o.call(this)
                }
            });
            t.RC4Drop = e._createHelper(s)
        }(),
        n.RC4)
    },
    30706: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function(t) {
            var e = n
              , i = e.lib
              , r = i.WordArray
              , o = i.Hasher
              , s = e.algo
              , a = r.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13])
              , l = r.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11])
              , c = r.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6])
              , h = r.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11])
              , u = r.create([0, 1518500249, 1859775393, 2400959708, 2840853838])
              , d = r.create([1352829926, 1548603684, 1836072691, 2053994217, 0])
              , f = s.RIPEMD160 = o.extend({
                _doReset: function() {
                    this._hash = r.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
                },
                _doProcessBlock: function(t, e) {
                    for (var i = 0; i < 16; i++) {
                        var n = e + i
                          , r = t[n];
                        t[n] = 16711935 & (r << 8 | r >>> 24) | 4278255360 & (r << 24 | r >>> 8)
                    }
                    var o, s, f, x, b, w, E, T, S, C, A, I = this._hash.words, M = u.words, P = d.words, k = a.words, O = l.words, R = c.words, D = h.words;
                    for (w = o = I[0],
                    E = s = I[1],
                    T = f = I[2],
                    S = x = I[3],
                    C = b = I[4],
                    i = 0; i < 80; i += 1)
                        A = o + t[e + k[i]] | 0,
                        A += i < 16 ? p(s, f, x) + M[0] : i < 32 ? m(s, f, x) + M[1] : i < 48 ? g(s, f, x) + M[2] : i < 64 ? _(s, f, x) + M[3] : y(s, f, x) + M[4],
                        A = (A = v(A |= 0, R[i])) + b | 0,
                        o = b,
                        b = x,
                        x = v(f, 10),
                        f = s,
                        s = A,
                        A = w + t[e + O[i]] | 0,
                        A += i < 16 ? y(E, T, S) + P[0] : i < 32 ? _(E, T, S) + P[1] : i < 48 ? g(E, T, S) + P[2] : i < 64 ? m(E, T, S) + P[3] : p(E, T, S) + P[4],
                        A = (A = v(A |= 0, D[i])) + C | 0,
                        w = C,
                        C = S,
                        S = v(T, 10),
                        T = E,
                        E = A;
                    A = I[1] + f + S | 0,
                    I[1] = I[2] + x + C | 0,
                    I[2] = I[3] + b + w | 0,
                    I[3] = I[4] + o + E | 0,
                    I[4] = I[0] + s + T | 0,
                    I[0] = A
                },
                _doFinalize: function() {
                    var t = this._data
                      , e = t.words
                      , i = 8 * this._nDataBytes
                      , n = 8 * t.sigBytes;
                    e[n >>> 5] |= 128 << 24 - n % 32,
                    e[14 + (n + 64 >>> 9 << 4)] = 16711935 & (i << 8 | i >>> 24) | 4278255360 & (i << 24 | i >>> 8),
                    t.sigBytes = 4 * (e.length + 1),
                    this._process();
                    for (var r = this._hash, o = r.words, s = 0; s < 5; s++) {
                        var a = o[s];
                        o[s] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8)
                    }
                    return r
                },
                clone: function() {
                    var t = o.clone.call(this);
                    return t._hash = this._hash.clone(),
                    t
                }
            });
            function p(t, e, i) {
                return t ^ e ^ i
            }
            function m(t, e, i) {
                return t & e | ~t & i
            }
            function g(t, e, i) {
                return (t | ~e) ^ i
            }
            function _(t, e, i) {
                return t & i | e & ~i
            }
            function y(t, e, i) {
                return t ^ (e | ~i)
            }
            function v(t, e) {
                return t << e | t >>> 32 - e
            }
            e.RIPEMD160 = o._createHelper(f),
            e.HmacRIPEMD160 = o._createHmacHelper(f)
        }(Math),
        n.RIPEMD160)
    },
    62783: function(t, e, i) {
        var n, r, o, s, a, l, c, h;
        t.exports = (h = i(78249),
        r = (n = h).lib,
        o = r.WordArray,
        s = r.Hasher,
        a = n.algo,
        l = [],
        c = a.SHA1 = s.extend({
            _doReset: function() {
                this._hash = new o.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520])
            },
            _doProcessBlock: function(t, e) {
                for (var i = this._hash.words, n = i[0], r = i[1], o = i[2], s = i[3], a = i[4], c = 0; c < 80; c++) {
                    if (c < 16)
                        l[c] = 0 | t[e + c];
                    else {
                        var h = l[c - 3] ^ l[c - 8] ^ l[c - 14] ^ l[c - 16];
                        l[c] = h << 1 | h >>> 31
                    }
                    var u = (n << 5 | n >>> 27) + a + l[c];
                    u += c < 20 ? 1518500249 + (r & o | ~r & s) : c < 40 ? 1859775393 + (r ^ o ^ s) : c < 60 ? (r & o | r & s | o & s) - 1894007588 : (r ^ o ^ s) - 899497514,
                    a = s,
                    s = o,
                    o = r << 30 | r >>> 2,
                    r = n,
                    n = u
                }
                i[0] = i[0] + n | 0,
                i[1] = i[1] + r | 0,
                i[2] = i[2] + o | 0,
                i[3] = i[3] + s | 0,
                i[4] = i[4] + a | 0
            },
            _doFinalize: function() {
                var t = this._data
                  , e = t.words
                  , i = 8 * this._nDataBytes
                  , n = 8 * t.sigBytes;
                return e[n >>> 5] |= 128 << 24 - n % 32,
                e[14 + (n + 64 >>> 9 << 4)] = Math.floor(i / 4294967296),
                e[15 + (n + 64 >>> 9 << 4)] = i,
                t.sigBytes = 4 * e.length,
                this._process(),
                this._hash
            },
            clone: function() {
                var t = s.clone.call(this);
                return t._hash = this._hash.clone(),
                t
            }
        }),
        n.SHA1 = s._createHelper(c),
        n.HmacSHA1 = s._createHmacHelper(c),
        h.SHA1)
    },
    87792: function(t, e, i) {
        var n, r, o, s, a, l;
        t.exports = (l = i(78249),
        i(52153),
        r = (n = l).lib.WordArray,
        o = n.algo,
        s = o.SHA256,
        a = o.SHA224 = s.extend({
            _doReset: function() {
                this._hash = new r.init([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
            },
            _doFinalize: function() {
                var t = s._doFinalize.call(this);
                return t.sigBytes -= 4,
                t
            }
        }),
        n.SHA224 = s._createHelper(a),
        n.HmacSHA224 = s._createHmacHelper(a),
        l.SHA224)
    },
    52153: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function(t) {
            var e = n
              , i = e.lib
              , r = i.WordArray
              , o = i.Hasher
              , s = e.algo
              , a = []
              , l = [];
            !function() {
                function e(e) {
                    for (var i = t.sqrt(e), n = 2; n <= i; n++)
                        if (!(e % n))
                            return !1;
                    return !0
                }
                function i(t) {
                    return 4294967296 * (t - (0 | t)) | 0
                }
                for (var n = 2, r = 0; r < 64; )
                    e(n) && (r < 8 && (a[r] = i(t.pow(n, .5))),
                    l[r] = i(t.pow(n, 1 / 3)),
                    r++),
                    n++
            }();
            var c = []
              , h = s.SHA256 = o.extend({
                _doReset: function() {
                    this._hash = new r.init(a.slice(0))
                },
                _doProcessBlock: function(t, e) {
                    for (var i = this._hash.words, n = i[0], r = i[1], o = i[2], s = i[3], a = i[4], h = i[5], u = i[6], d = i[7], f = 0; f < 64; f++) {
                        if (f < 16)
                            c[f] = 0 | t[e + f];
                        else {
                            var p = c[f - 15]
                              , m = (p << 25 | p >>> 7) ^ (p << 14 | p >>> 18) ^ p >>> 3
                              , g = c[f - 2]
                              , _ = (g << 15 | g >>> 17) ^ (g << 13 | g >>> 19) ^ g >>> 10;
                            c[f] = m + c[f - 7] + _ + c[f - 16]
                        }
                        var y = n & r ^ n & o ^ r & o
                          , v = (n << 30 | n >>> 2) ^ (n << 19 | n >>> 13) ^ (n << 10 | n >>> 22)
                          , x = d + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & h ^ ~a & u) + l[f] + c[f];
                        d = u,
                        u = h,
                        h = a,
                        a = s + x | 0,
                        s = o,
                        o = r,
                        r = n,
                        n = x + (v + y) | 0
                    }
                    i[0] = i[0] + n | 0,
                    i[1] = i[1] + r | 0,
                    i[2] = i[2] + o | 0,
                    i[3] = i[3] + s | 0,
                    i[4] = i[4] + a | 0,
                    i[5] = i[5] + h | 0,
                    i[6] = i[6] + u | 0,
                    i[7] = i[7] + d | 0
                },
                _doFinalize: function() {
                    var e = this._data
                      , i = e.words
                      , n = 8 * this._nDataBytes
                      , r = 8 * e.sigBytes;
                    return i[r >>> 5] |= 128 << 24 - r % 32,
                    i[14 + (r + 64 >>> 9 << 4)] = t.floor(n / 4294967296),
                    i[15 + (r + 64 >>> 9 << 4)] = n,
                    e.sigBytes = 4 * i.length,
                    this._process(),
                    this._hash
                },
                clone: function() {
                    var t = o.clone.call(this);
                    return t._hash = this._hash.clone(),
                    t
                }
            });
            e.SHA256 = o._createHelper(h),
            e.HmacSHA256 = o._createHmacHelper(h)
        }(Math),
        n.SHA256)
    },
    13327: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(64938),
        function(t) {
            var e = n
              , i = e.lib
              , r = i.WordArray
              , o = i.Hasher
              , s = e.x64.Word
              , a = e.algo
              , l = []
              , c = []
              , h = [];
            !function() {
                for (var t = 1, e = 0, i = 0; i < 24; i++) {
                    l[t + 5 * e] = (i + 1) * (i + 2) / 2 % 64;
                    var n = (2 * t + 3 * e) % 5;
                    t = e % 5,
                    e = n
                }
                for (t = 0; t < 5; t++)
                    for (e = 0; e < 5; e++)
                        c[t + 5 * e] = e + (2 * t + 3 * e) % 5 * 5;
                for (var r = 1, o = 0; o < 24; o++) {
                    for (var a = 0, u = 0, d = 0; d < 7; d++) {
                        if (1 & r) {
                            var f = (1 << d) - 1;
                            f < 32 ? u ^= 1 << f : a ^= 1 << f - 32
                        }
                        128 & r ? r = r << 1 ^ 113 : r <<= 1
                    }
                    h[o] = s.create(a, u)
                }
            }();
            var u = [];
            !function() {
                for (var t = 0; t < 25; t++)
                    u[t] = s.create()
            }();
            var d = a.SHA3 = o.extend({
                cfg: o.cfg.extend({
                    outputLength: 512
                }),
                _doReset: function() {
                    for (var t = this._state = [], e = 0; e < 25; e++)
                        t[e] = new s.init;
                    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32
                },
                _doProcessBlock: function(t, e) {
                    for (var i = this._state, n = this.blockSize / 2, r = 0; r < n; r++) {
                        var o = t[e + 2 * r]
                          , s = t[e + 2 * r + 1];
                        o = 16711935 & (o << 8 | o >>> 24) | 4278255360 & (o << 24 | o >>> 8),
                        s = 16711935 & (s << 8 | s >>> 24) | 4278255360 & (s << 24 | s >>> 8),
                        (I = i[r]).high ^= s,
                        I.low ^= o
                    }
                    for (var a = 0; a < 24; a++) {
                        for (var d = 0; d < 5; d++) {
                            for (var f = 0, p = 0, m = 0; m < 5; m++)
                                f ^= (I = i[d + 5 * m]).high,
                                p ^= I.low;
                            var g = u[d];
                            g.high = f,
                            g.low = p
                        }
                        for (d = 0; d < 5; d++) {
                            var _ = u[(d + 4) % 5]
                              , y = u[(d + 1) % 5]
                              , v = y.high
                              , x = y.low;
                            for (f = _.high ^ (v << 1 | x >>> 31),
                            p = _.low ^ (x << 1 | v >>> 31),
                            m = 0; m < 5; m++)
                                (I = i[d + 5 * m]).high ^= f,
                                I.low ^= p
                        }
                        for (var b = 1; b < 25; b++) {
                            var w = (I = i[b]).high
                              , E = I.low
                              , T = l[b];
                            T < 32 ? (f = w << T | E >>> 32 - T,
                            p = E << T | w >>> 32 - T) : (f = E << T - 32 | w >>> 64 - T,
                            p = w << T - 32 | E >>> 64 - T);
                            var S = u[c[b]];
                            S.high = f,
                            S.low = p
                        }
                        var C = u[0]
                          , A = i[0];
                        for (C.high = A.high,
                        C.low = A.low,
                        d = 0; d < 5; d++)
                            for (m = 0; m < 5; m++) {
                                var I = i[b = d + 5 * m]
                                  , M = u[b]
                                  , P = u[(d + 1) % 5 + 5 * m]
                                  , k = u[(d + 2) % 5 + 5 * m];
                                I.high = M.high ^ ~P.high & k.high,
                                I.low = M.low ^ ~P.low & k.low
                            }
                        I = i[0];
                        var O = h[a];
                        I.high ^= O.high,
                        I.low ^= O.low
                    }
                },
                _doFinalize: function() {
                    var e = this._data
                      , i = e.words
                      , n = (this._nDataBytes,
                    8 * e.sigBytes)
                      , o = 32 * this.blockSize;
                    i[n >>> 5] |= 1 << 24 - n % 32,
                    i[(t.ceil((n + 1) / o) * o >>> 5) - 1] |= 128,
                    e.sigBytes = 4 * i.length,
                    this._process();
                    for (var s = this._state, a = this.cfg.outputLength / 8, l = a / 8, c = [], h = 0; h < l; h++) {
                        var u = s[h]
                          , d = u.high
                          , f = u.low;
                        d = 16711935 & (d << 8 | d >>> 24) | 4278255360 & (d << 24 | d >>> 8),
                        f = 16711935 & (f << 8 | f >>> 24) | 4278255360 & (f << 24 | f >>> 8),
                        c.push(f),
                        c.push(d)
                    }
                    return new r.init(c,a)
                },
                clone: function() {
                    for (var t = o.clone.call(this), e = t._state = this._state.slice(0), i = 0; i < 25; i++)
                        e[i] = e[i].clone();
                    return t
                }
            });
            e.SHA3 = o._createHelper(d),
            e.HmacSHA3 = o._createHmacHelper(d)
        }(Math),
        n.SHA3)
    },
    17460: function(t, e, i) {
        var n, r, o, s, a, l, c, h;
        t.exports = (h = i(78249),
        i(64938),
        i(70034),
        r = (n = h).x64,
        o = r.Word,
        s = r.WordArray,
        a = n.algo,
        l = a.SHA512,
        c = a.SHA384 = l.extend({
            _doReset: function() {
                this._hash = new s.init([new o.init(3418070365,3238371032), new o.init(1654270250,914150663), new o.init(2438529370,812702999), new o.init(355462360,4144912697), new o.init(1731405415,4290775857), new o.init(2394180231,1750603025), new o.init(3675008525,1694076839), new o.init(1203062813,3204075428)])
            },
            _doFinalize: function() {
                var t = l._doFinalize.call(this);
                return t.sigBytes -= 16,
                t
            }
        }),
        n.SHA384 = l._createHelper(c),
        n.HmacSHA384 = l._createHmacHelper(c),
        h.SHA384)
    },
    70034: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(64938),
        function() {
            var t = n
              , e = t.lib.Hasher
              , i = t.x64
              , r = i.Word
              , o = i.WordArray
              , s = t.algo;
            function a() {
                return r.create.apply(r, arguments)
            }
            var l = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317), a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291, 2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899), a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470, 3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)]
              , c = [];
            !function() {
                for (var t = 0; t < 80; t++)
                    c[t] = a()
            }();
            var h = s.SHA512 = e.extend({
                _doReset: function() {
                    this._hash = new o.init([new r.init(1779033703,4089235720), new r.init(3144134277,2227873595), new r.init(1013904242,4271175723), new r.init(2773480762,1595750129), new r.init(1359893119,2917565137), new r.init(2600822924,725511199), new r.init(528734635,4215389547), new r.init(1541459225,327033209)])
                },
                _doProcessBlock: function(t, e) {
                    for (var i = this._hash.words, n = i[0], r = i[1], o = i[2], s = i[3], a = i[4], h = i[5], u = i[6], d = i[7], f = n.high, p = n.low, m = r.high, g = r.low, _ = o.high, y = o.low, v = s.high, x = s.low, b = a.high, w = a.low, E = h.high, T = h.low, S = u.high, C = u.low, A = d.high, I = d.low, M = f, P = p, k = m, O = g, R = _, D = y, L = v, B = x, z = b, F = w, N = E, j = T, U = S, V = C, G = A, Z = I, q = 0; q < 80; q++) {
                        var W, H, $ = c[q];
                        if (q < 16)
                            H = $.high = 0 | t[e + 2 * q],
                            W = $.low = 0 | t[e + 2 * q + 1];
                        else {
                            var X = c[q - 15]
                              , Y = X.high
                              , K = X.low
                              , J = (Y >>> 1 | K << 31) ^ (Y >>> 8 | K << 24) ^ Y >>> 7
                              , Q = (K >>> 1 | Y << 31) ^ (K >>> 8 | Y << 24) ^ (K >>> 7 | Y << 25)
                              , tt = c[q - 2]
                              , et = tt.high
                              , it = tt.low
                              , nt = (et >>> 19 | it << 13) ^ (et << 3 | it >>> 29) ^ et >>> 6
                              , rt = (it >>> 19 | et << 13) ^ (it << 3 | et >>> 29) ^ (it >>> 6 | et << 26)
                              , ot = c[q - 7]
                              , st = ot.high
                              , at = ot.low
                              , lt = c[q - 16]
                              , ct = lt.high
                              , ht = lt.low;
                            H = (H = (H = J + st + ((W = Q + at) >>> 0 < Q >>> 0 ? 1 : 0)) + nt + ((W += rt) >>> 0 < rt >>> 0 ? 1 : 0)) + ct + ((W += ht) >>> 0 < ht >>> 0 ? 1 : 0),
                            $.high = H,
                            $.low = W
                        }
                        var ut, dt = z & N ^ ~z & U, ft = F & j ^ ~F & V, pt = M & k ^ M & R ^ k & R, mt = P & O ^ P & D ^ O & D, gt = (M >>> 28 | P << 4) ^ (M << 30 | P >>> 2) ^ (M << 25 | P >>> 7), _t = (P >>> 28 | M << 4) ^ (P << 30 | M >>> 2) ^ (P << 25 | M >>> 7), yt = (z >>> 14 | F << 18) ^ (z >>> 18 | F << 14) ^ (z << 23 | F >>> 9), vt = (F >>> 14 | z << 18) ^ (F >>> 18 | z << 14) ^ (F << 23 | z >>> 9), xt = l[q], bt = xt.high, wt = xt.low, Et = G + yt + ((ut = Z + vt) >>> 0 < Z >>> 0 ? 1 : 0), Tt = _t + mt;
                        G = U,
                        Z = V,
                        U = N,
                        V = j,
                        N = z,
                        j = F,
                        z = L + (Et = (Et = (Et = Et + dt + ((ut += ft) >>> 0 < ft >>> 0 ? 1 : 0)) + bt + ((ut += wt) >>> 0 < wt >>> 0 ? 1 : 0)) + H + ((ut += W) >>> 0 < W >>> 0 ? 1 : 0)) + ((F = B + ut | 0) >>> 0 < B >>> 0 ? 1 : 0) | 0,
                        L = R,
                        B = D,
                        R = k,
                        D = O,
                        k = M,
                        O = P,
                        M = Et + (gt + pt + (Tt >>> 0 < _t >>> 0 ? 1 : 0)) + ((P = ut + Tt | 0) >>> 0 < ut >>> 0 ? 1 : 0) | 0
                    }
                    p = n.low = p + P,
                    n.high = f + M + (p >>> 0 < P >>> 0 ? 1 : 0),
                    g = r.low = g + O,
                    r.high = m + k + (g >>> 0 < O >>> 0 ? 1 : 0),
                    y = o.low = y + D,
                    o.high = _ + R + (y >>> 0 < D >>> 0 ? 1 : 0),
                    x = s.low = x + B,
                    s.high = v + L + (x >>> 0 < B >>> 0 ? 1 : 0),
                    w = a.low = w + F,
                    a.high = b + z + (w >>> 0 < F >>> 0 ? 1 : 0),
                    T = h.low = T + j,
                    h.high = E + N + (T >>> 0 < j >>> 0 ? 1 : 0),
                    C = u.low = C + V,
                    u.high = S + U + (C >>> 0 < V >>> 0 ? 1 : 0),
                    I = d.low = I + Z,
                    d.high = A + G + (I >>> 0 < Z >>> 0 ? 1 : 0)
                },
                _doFinalize: function() {
                    var t = this._data
                      , e = t.words
                      , i = 8 * this._nDataBytes
                      , n = 8 * t.sigBytes;
                    return e[n >>> 5] |= 128 << 24 - n % 32,
                    e[30 + (n + 128 >>> 10 << 5)] = Math.floor(i / 4294967296),
                    e[31 + (n + 128 >>> 10 << 5)] = i,
                    t.sigBytes = 4 * e.length,
                    this._process(),
                    this._hash.toX32()
                },
                clone: function() {
                    var t = e.clone.call(this);
                    return t._hash = this._hash.clone(),
                    t
                },
                blockSize: 32
            });
            t.SHA512 = e._createHelper(h),
            t.HmacSHA512 = e._createHmacHelper(h)
        }(),
        n.SHA512)
    },
    94253: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        i(98269),
        i(68214),
        i(90888),
        i(75109),
        function() {
            var t = n
              , e = t.lib
              , i = e.WordArray
              , r = e.BlockCipher
              , o = t.algo
              , s = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]
              , a = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]
              , l = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]
              , c = [{
                0: 8421888,
                268435456: 32768,
                536870912: 8421378,
                805306368: 2,
                1073741824: 512,
                1342177280: 8421890,
                1610612736: 8389122,
                1879048192: 8388608,
                2147483648: 514,
                2415919104: 8389120,
                2684354560: 33280,
                2952790016: 8421376,
                3221225472: 32770,
                3489660928: 8388610,
                3758096384: 0,
                4026531840: 33282,
                134217728: 0,
                402653184: 8421890,
                671088640: 33282,
                939524096: 32768,
                1207959552: 8421888,
                1476395008: 512,
                1744830464: 8421378,
                2013265920: 2,
                2281701376: 8389120,
                2550136832: 33280,
                2818572288: 8421376,
                3087007744: 8389122,
                3355443200: 8388610,
                3623878656: 32770,
                3892314112: 514,
                4160749568: 8388608,
                1: 32768,
                268435457: 2,
                536870913: 8421888,
                805306369: 8388608,
                1073741825: 8421378,
                1342177281: 33280,
                1610612737: 512,
                1879048193: 8389122,
                2147483649: 8421890,
                2415919105: 8421376,
                2684354561: 8388610,
                2952790017: 33282,
                3221225473: 514,
                3489660929: 8389120,
                3758096385: 32770,
                4026531841: 0,
                134217729: 8421890,
                402653185: 8421376,
                671088641: 8388608,
                939524097: 512,
                1207959553: 32768,
                1476395009: 8388610,
                1744830465: 2,
                2013265921: 33282,
                2281701377: 32770,
                2550136833: 8389122,
                2818572289: 514,
                3087007745: 8421888,
                3355443201: 8389120,
                3623878657: 0,
                3892314113: 33280,
                4160749569: 8421378
            }, {
                0: 1074282512,
                16777216: 16384,
                33554432: 524288,
                50331648: 1074266128,
                67108864: 1073741840,
                83886080: 1074282496,
                100663296: 1073758208,
                117440512: 16,
                134217728: 540672,
                150994944: 1073758224,
                167772160: 1073741824,
                184549376: 540688,
                201326592: 524304,
                218103808: 0,
                234881024: 16400,
                251658240: 1074266112,
                8388608: 1073758208,
                25165824: 540688,
                41943040: 16,
                58720256: 1073758224,
                75497472: 1074282512,
                92274688: 1073741824,
                109051904: 524288,
                125829120: 1074266128,
                142606336: 524304,
                159383552: 0,
                176160768: 16384,
                192937984: 1074266112,
                209715200: 1073741840,
                226492416: 540672,
                243269632: 1074282496,
                260046848: 16400,
                268435456: 0,
                285212672: 1074266128,
                301989888: 1073758224,
                318767104: 1074282496,
                335544320: 1074266112,
                352321536: 16,
                369098752: 540688,
                385875968: 16384,
                402653184: 16400,
                419430400: 524288,
                436207616: 524304,
                452984832: 1073741840,
                469762048: 540672,
                486539264: 1073758208,
                503316480: 1073741824,
                520093696: 1074282512,
                276824064: 540688,
                293601280: 524288,
                310378496: 1074266112,
                327155712: 16384,
                343932928: 1073758208,
                360710144: 1074282512,
                377487360: 16,
                394264576: 1073741824,
                411041792: 1074282496,
                427819008: 1073741840,
                444596224: 1073758224,
                461373440: 524304,
                478150656: 0,
                494927872: 16400,
                511705088: 1074266128,
                528482304: 540672
            }, {
                0: 260,
                1048576: 0,
                2097152: 67109120,
                3145728: 65796,
                4194304: 65540,
                5242880: 67108868,
                6291456: 67174660,
                7340032: 67174400,
                8388608: 67108864,
                9437184: 67174656,
                10485760: 65792,
                11534336: 67174404,
                12582912: 67109124,
                13631488: 65536,
                14680064: 4,
                15728640: 256,
                524288: 67174656,
                1572864: 67174404,
                2621440: 0,
                3670016: 67109120,
                4718592: 67108868,
                5767168: 65536,
                6815744: 65540,
                7864320: 260,
                8912896: 4,
                9961472: 256,
                11010048: 67174400,
                12058624: 65796,
                13107200: 65792,
                14155776: 67109124,
                15204352: 67174660,
                16252928: 67108864,
                16777216: 67174656,
                17825792: 65540,
                18874368: 65536,
                19922944: 67109120,
                20971520: 256,
                22020096: 67174660,
                23068672: 67108868,
                24117248: 0,
                25165824: 67109124,
                26214400: 67108864,
                27262976: 4,
                28311552: 65792,
                29360128: 67174400,
                30408704: 260,
                31457280: 65796,
                32505856: 67174404,
                17301504: 67108864,
                18350080: 260,
                19398656: 67174656,
                20447232: 0,
                21495808: 65540,
                22544384: 67109120,
                23592960: 256,
                24641536: 67174404,
                25690112: 65536,
                26738688: 67174660,
                27787264: 65796,
                28835840: 67108868,
                29884416: 67109124,
                30932992: 67174400,
                31981568: 4,
                33030144: 65792
            }, {
                0: 2151682048,
                65536: 2147487808,
                131072: 4198464,
                196608: 2151677952,
                262144: 0,
                327680: 4198400,
                393216: 2147483712,
                458752: 4194368,
                524288: 2147483648,
                589824: 4194304,
                655360: 64,
                720896: 2147487744,
                786432: 2151678016,
                851968: 4160,
                917504: 4096,
                983040: 2151682112,
                32768: 2147487808,
                98304: 64,
                163840: 2151678016,
                229376: 2147487744,
                294912: 4198400,
                360448: 2151682112,
                425984: 0,
                491520: 2151677952,
                557056: 4096,
                622592: 2151682048,
                688128: 4194304,
                753664: 4160,
                819200: 2147483648,
                884736: 4194368,
                950272: 4198464,
                1015808: 2147483712,
                1048576: 4194368,
                1114112: 4198400,
                1179648: 2147483712,
                1245184: 0,
                1310720: 4160,
                1376256: 2151678016,
                1441792: 2151682048,
                1507328: 2147487808,
                1572864: 2151682112,
                1638400: 2147483648,
                1703936: 2151677952,
                1769472: 4198464,
                1835008: 2147487744,
                1900544: 4194304,
                1966080: 64,
                2031616: 4096,
                1081344: 2151677952,
                1146880: 2151682112,
                1212416: 0,
                1277952: 4198400,
                1343488: 4194368,
                1409024: 2147483648,
                1474560: 2147487808,
                1540096: 64,
                1605632: 2147483712,
                1671168: 4096,
                1736704: 2147487744,
                1802240: 2151678016,
                1867776: 4160,
                1933312: 2151682048,
                1998848: 4194304,
                2064384: 4198464
            }, {
                0: 128,
                4096: 17039360,
                8192: 262144,
                12288: 536870912,
                16384: 537133184,
                20480: 16777344,
                24576: 553648256,
                28672: 262272,
                32768: 16777216,
                36864: 537133056,
                40960: 536871040,
                45056: 553910400,
                49152: 553910272,
                53248: 0,
                57344: 17039488,
                61440: 553648128,
                2048: 17039488,
                6144: 553648256,
                10240: 128,
                14336: 17039360,
                18432: 262144,
                22528: 537133184,
                26624: 553910272,
                30720: 536870912,
                34816: 537133056,
                38912: 0,
                43008: 553910400,
                47104: 16777344,
                51200: 536871040,
                55296: 553648128,
                59392: 16777216,
                63488: 262272,
                65536: 262144,
                69632: 128,
                73728: 536870912,
                77824: 553648256,
                81920: 16777344,
                86016: 553910272,
                90112: 537133184,
                94208: 16777216,
                98304: 553910400,
                102400: 553648128,
                106496: 17039360,
                110592: 537133056,
                114688: 262272,
                118784: 536871040,
                122880: 0,
                126976: 17039488,
                67584: 553648256,
                71680: 16777216,
                75776: 17039360,
                79872: 537133184,
                83968: 536870912,
                88064: 17039488,
                92160: 128,
                96256: 553910272,
                100352: 262272,
                104448: 553910400,
                108544: 0,
                112640: 553648128,
                116736: 16777344,
                120832: 262144,
                124928: 537133056,
                129024: 536871040
            }, {
                0: 268435464,
                256: 8192,
                512: 270532608,
                768: 270540808,
                1024: 268443648,
                1280: 2097152,
                1536: 2097160,
                1792: 268435456,
                2048: 0,
                2304: 268443656,
                2560: 2105344,
                2816: 8,
                3072: 270532616,
                3328: 2105352,
                3584: 8200,
                3840: 270540800,
                128: 270532608,
                384: 270540808,
                640: 8,
                896: 2097152,
                1152: 2105352,
                1408: 268435464,
                1664: 268443648,
                1920: 8200,
                2176: 2097160,
                2432: 8192,
                2688: 268443656,
                2944: 270532616,
                3200: 0,
                3456: 270540800,
                3712: 2105344,
                3968: 268435456,
                4096: 268443648,
                4352: 270532616,
                4608: 270540808,
                4864: 8200,
                5120: 2097152,
                5376: 268435456,
                5632: 268435464,
                5888: 2105344,
                6144: 2105352,
                6400: 0,
                6656: 8,
                6912: 270532608,
                7168: 8192,
                7424: 268443656,
                7680: 270540800,
                7936: 2097160,
                4224: 8,
                4480: 2105344,
                4736: 2097152,
                4992: 268435464,
                5248: 268443648,
                5504: 8200,
                5760: 270540808,
                6016: 270532608,
                6272: 270540800,
                6528: 270532616,
                6784: 8192,
                7040: 2105352,
                7296: 2097160,
                7552: 0,
                7808: 268435456,
                8064: 268443656
            }, {
                0: 1048576,
                16: 33555457,
                32: 1024,
                48: 1049601,
                64: 34604033,
                80: 0,
                96: 1,
                112: 34603009,
                128: 33555456,
                144: 1048577,
                160: 33554433,
                176: 34604032,
                192: 34603008,
                208: 1025,
                224: 1049600,
                240: 33554432,
                8: 34603009,
                24: 0,
                40: 33555457,
                56: 34604032,
                72: 1048576,
                88: 33554433,
                104: 33554432,
                120: 1025,
                136: 1049601,
                152: 33555456,
                168: 34603008,
                184: 1048577,
                200: 1024,
                216: 34604033,
                232: 1,
                248: 1049600,
                256: 33554432,
                272: 1048576,
                288: 33555457,
                304: 34603009,
                320: 1048577,
                336: 33555456,
                352: 34604032,
                368: 1049601,
                384: 1025,
                400: 34604033,
                416: 1049600,
                432: 1,
                448: 0,
                464: 34603008,
                480: 33554433,
                496: 1024,
                264: 1049600,
                280: 33555457,
                296: 34603009,
                312: 1,
                328: 33554432,
                344: 1048576,
                360: 1025,
                376: 34604032,
                392: 33554433,
                408: 34603008,
                424: 0,
                440: 34604033,
                456: 1049601,
                472: 1024,
                488: 33555456,
                504: 1048577
            }, {
                0: 134219808,
                1: 131072,
                2: 134217728,
                3: 32,
                4: 131104,
                5: 134350880,
                6: 134350848,
                7: 2048,
                8: 134348800,
                9: 134219776,
                10: 133120,
                11: 134348832,
                12: 2080,
                13: 0,
                14: 134217760,
                15: 133152,
                2147483648: 2048,
                2147483649: 134350880,
                2147483650: 134219808,
                2147483651: 134217728,
                2147483652: 134348800,
                2147483653: 133120,
                2147483654: 133152,
                2147483655: 32,
                2147483656: 134217760,
                2147483657: 2080,
                2147483658: 131104,
                2147483659: 134350848,
                2147483660: 0,
                2147483661: 134348832,
                2147483662: 134219776,
                2147483663: 131072,
                16: 133152,
                17: 134350848,
                18: 32,
                19: 2048,
                20: 134219776,
                21: 134217760,
                22: 134348832,
                23: 131072,
                24: 0,
                25: 131104,
                26: 134348800,
                27: 134219808,
                28: 134350880,
                29: 133120,
                30: 2080,
                31: 134217728,
                2147483664: 131072,
                2147483665: 2048,
                2147483666: 134348832,
                2147483667: 133152,
                2147483668: 32,
                2147483669: 134348800,
                2147483670: 134217728,
                2147483671: 134219808,
                2147483672: 134350880,
                2147483673: 134217760,
                2147483674: 134219776,
                2147483675: 0,
                2147483676: 133120,
                2147483677: 2080,
                2147483678: 131104,
                2147483679: 134350848
            }]
              , h = [4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679]
              , u = o.DES = r.extend({
                _doReset: function() {
                    for (var t = this._key.words, e = [], i = 0; i < 56; i++) {
                        var n = s[i] - 1;
                        e[i] = t[n >>> 5] >>> 31 - n % 32 & 1
                    }
                    for (var r = this._subKeys = [], o = 0; o < 16; o++) {
                        var c = r[o] = []
                          , h = l[o];
                        for (i = 0; i < 24; i++)
                            c[i / 6 | 0] |= e[(a[i] - 1 + h) % 28] << 31 - i % 6,
                            c[4 + (i / 6 | 0)] |= e[28 + (a[i + 24] - 1 + h) % 28] << 31 - i % 6;
                        for (c[0] = c[0] << 1 | c[0] >>> 31,
                        i = 1; i < 7; i++)
                            c[i] = c[i] >>> 4 * (i - 1) + 3;
                        c[7] = c[7] << 5 | c[7] >>> 27
                    }
                    var u = this._invSubKeys = [];
                    for (i = 0; i < 16; i++)
                        u[i] = r[15 - i]
                },
                encryptBlock: function(t, e) {
                    this._doCryptBlock(t, e, this._subKeys)
                },
                decryptBlock: function(t, e) {
                    this._doCryptBlock(t, e, this._invSubKeys)
                },
                _doCryptBlock: function(t, e, i) {
                    this._lBlock = t[e],
                    this._rBlock = t[e + 1],
                    d.call(this, 4, 252645135),
                    d.call(this, 16, 65535),
                    f.call(this, 2, 858993459),
                    f.call(this, 8, 16711935),
                    d.call(this, 1, 1431655765);
                    for (var n = 0; n < 16; n++) {
                        for (var r = i[n], o = this._lBlock, s = this._rBlock, a = 0, l = 0; l < 8; l++)
                            a |= c[l][((s ^ r[l]) & h[l]) >>> 0];
                        this._lBlock = s,
                        this._rBlock = o ^ a
                    }
                    var u = this._lBlock;
                    this._lBlock = this._rBlock,
                    this._rBlock = u,
                    d.call(this, 1, 1431655765),
                    f.call(this, 8, 16711935),
                    f.call(this, 2, 858993459),
                    d.call(this, 16, 65535),
                    d.call(this, 4, 252645135),
                    t[e] = this._lBlock,
                    t[e + 1] = this._rBlock
                },
                keySize: 2,
                ivSize: 2,
                blockSize: 2
            });
            function d(t, e) {
                var i = (this._lBlock >>> t ^ this._rBlock) & e;
                this._rBlock ^= i,
                this._lBlock ^= i << t
            }
            function f(t, e) {
                var i = (this._rBlock >>> t ^ this._lBlock) & e;
                this._lBlock ^= i,
                this._rBlock ^= i << t
            }
            t.DES = r._createHelper(u);
            var p = o.TripleDES = r.extend({
                _doReset: function() {
                    var t = this._key.words;
                    if (2 !== t.length && 4 !== t.length && t.length < 6)
                        throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
                    var e = t.slice(0, 2)
                      , n = t.length < 4 ? t.slice(0, 2) : t.slice(2, 4)
                      , r = t.length < 6 ? t.slice(0, 2) : t.slice(4, 6);
                    this._des1 = u.createEncryptor(i.create(e)),
                    this._des2 = u.createEncryptor(i.create(n)),
                    this._des3 = u.createEncryptor(i.create(r))
                },
                encryptBlock: function(t, e) {
                    this._des1.encryptBlock(t, e),
                    this._des2.decryptBlock(t, e),
                    this._des3.encryptBlock(t, e)
                },
                decryptBlock: function(t, e) {
                    this._des3.decryptBlock(t, e),
                    this._des2.encryptBlock(t, e),
                    this._des1.decryptBlock(t, e)
                },
                keySize: 6,
                ivSize: 2,
                blockSize: 2
            });
            t.TripleDES = r._createHelper(p)
        }(),
        n.TripleDES)
    },
    64938: function(t, e, i) {
        var n;
        t.exports = (n = i(78249),
        function(t) {
            var e = n
              , i = e.lib
              , r = i.Base
              , o = i.WordArray
              , s = e.x64 = {};
            s.Word = r.extend({
                init: function(t, e) {
                    this.high = t,
                    this.low = e
                }
            }),
            s.WordArray = r.extend({
                init: function(e, i) {
                    e = this.words = e || [],
                    this.sigBytes = i != t ? i : 8 * e.length
                },
                toX32: function() {
                    for (var t = this.words, e = t.length, i = [], n = 0; n < e; n++) {
                        var r = t[n];
                        i.push(r.high),
                        i.push(r.low)
                    }
                    return o.create(i, this.sigBytes)
                },
                clone: function() {
                    for (var t = r.clone.call(this), e = t.words = this.words.slice(0), i = e.length, n = 0; n < i; n++)
                        e[n] = e[n].clone();
                    return t
                }
            })
        }(),
        n)
    },
    73382: function(t, e, i) {
        "use strict";
        function n(t, e) {
            var i = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }
                ))),
                i.push.apply(i, n)
            }
            return i
        }
        function r(t) {
            for (var e = 1; e < arguments.length; e++) {
                var i = null != arguments[e] ? arguments[e] : {};
                e % 2 ? n(Object(i), !0).forEach((function(e) {
                    s(t, e, i[e])
                }
                )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : n(Object(i)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }
                ))
            }
            return t
        }
        function o(t) {
            return o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            }
            : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }
            ,
            o(t)
        }
        function s(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i,
            t
        }
        var a;
        i.r(e),
        i.d(e, {
            alignElement: function() {
                return at
            },
            alignPoint: function() {
                return lt
            }
        });
        var l = {
            Webkit: "-webkit-",
            Moz: "-moz-",
            ms: "-ms-",
            O: "-o-"
        };
        function c() {
            if (void 0 !== a)
                return a;
            a = "";
            var t = document.createElement("p").style;
            for (var e in l)
                e + "Transform"in t && (a = e);
            return a
        }
        function h() {
            return c() ? "".concat(c(), "TransitionProperty") : "transitionProperty"
        }
        function u() {
            return c() ? "".concat(c(), "Transform") : "transform"
        }
        function d(t, e) {
            var i = h();
            i && (t.style[i] = e,
            "transitionProperty" !== i && (t.style.transitionProperty = e))
        }
        function f(t, e) {
            var i = u();
            i && (t.style[i] = e,
            "transform" !== i && (t.style.transform = e))
        }
        var p, m = /matrix\((.*)\)/, g = /matrix3d\((.*)\)/;
        function _(t) {
            var e = t.style.display;
            t.style.display = "none",
            t.offsetHeight,
            t.style.display = e
        }
        function y(t, e, i) {
            var n = i;
            if ("object" !== o(e))
                return void 0 !== n ? ("number" == typeof n && (n = "".concat(n, "px")),
                void (t.style[e] = n)) : p(t, e);
            for (var r in e)
                e.hasOwnProperty(r) && y(t, r, e[r])
        }
        function v(t, e) {
            var i = t["page".concat(e ? "Y" : "X", "Offset")]
              , n = "scroll".concat(e ? "Top" : "Left");
            if ("number" != typeof i) {
                var r = t.document;
                "number" != typeof (i = r.documentElement[n]) && (i = r.body[n])
            }
            return i
        }
        function x(t) {
            return v(t)
        }
        function b(t) {
            return v(t, !0)
        }
        function w(t) {
            var e = function(t) {
                var e, i, n, r = t.ownerDocument, o = r.body, s = r && r.documentElement;
                return e = t.getBoundingClientRect(),
                i = Math.floor(e.left),
                n = Math.floor(e.top),
                {
                    left: i -= s.clientLeft || o.clientLeft || 0,
                    top: n -= s.clientTop || o.clientTop || 0
                }
            }(t)
              , i = t.ownerDocument
              , n = i.defaultView || i.parentWindow;
            return e.left += x(n),
            e.top += b(n),
            e
        }
        function E(t) {
            return null != t && t == t.window
        }
        function T(t) {
            return E(t) ? t.document : 9 === t.nodeType ? t : t.ownerDocument
        }
        var S = new RegExp("^(".concat(/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, ")(?!px)[a-z%]+$"),"i")
          , C = /^(top|right|bottom|left)$/
          , A = "currentStyle"
          , I = "runtimeStyle"
          , M = "left";
        function P(t, e) {
            return "left" === t ? e.useCssRight ? "right" : t : e.useCssBottom ? "bottom" : t
        }
        function k(t) {
            return "left" === t ? "right" : "right" === t ? "left" : "top" === t ? "bottom" : "bottom" === t ? "top" : void 0
        }
        function O(t, e, i) {
            "static" === y(t, "position") && (t.style.position = "relative");
            var n = -999
              , r = -999
              , o = P("left", i)
              , s = P("top", i)
              , a = k(o)
              , l = k(s);
            "left" !== o && (n = 999),
            "top" !== s && (r = 999);
            var c, u = "", f = w(t);
            ("left"in e || "top"in e) && (u = (c = t).style.transitionProperty || c.style[h()] || "",
            d(t, "none")),
            "left"in e && (t.style[a] = "",
            t.style[o] = "".concat(n, "px")),
            "top"in e && (t.style[l] = "",
            t.style[s] = "".concat(r, "px")),
            _(t);
            var p = w(t)
              , m = {};
            for (var g in e)
                if (e.hasOwnProperty(g)) {
                    var v = P(g, i)
                      , x = "left" === g ? n : r
                      , b = f[g] - p[g];
                    m[v] = v === g ? x + b : x - b
                }
            y(t, m),
            _(t),
            ("left"in e || "top"in e) && d(t, u);
            var E = {};
            for (var T in e)
                if (e.hasOwnProperty(T)) {
                    var S = P(T, i)
                      , C = e[T] - f[T];
                    E[S] = T === S ? m[S] + C : m[S] - C
                }
            y(t, E)
        }
        function R(t, e) {
            var i = w(t)
              , n = function(t) {
                var e = window.getComputedStyle(t, null)
                  , i = e.getPropertyValue("transform") || e.getPropertyValue(u());
                if (i && "none" !== i) {
                    var n = i.replace(/[^0-9\-.,]/g, "").split(",");
                    return {
                        x: parseFloat(n[12] || n[4], 0),
                        y: parseFloat(n[13] || n[5], 0)
                    }
                }
                return {
                    x: 0,
                    y: 0
                }
            }(t)
              , r = {
                x: n.x,
                y: n.y
            };
            "left"in e && (r.x = n.x + e.left - i.left),
            "top"in e && (r.y = n.y + e.top - i.top),
            function(t, e) {
                var i = window.getComputedStyle(t, null)
                  , n = i.getPropertyValue("transform") || i.getPropertyValue(u());
                if (n && "none" !== n) {
                    var r, o = n.match(m);
                    o ? ((r = (o = o[1]).split(",").map((function(t) {
                        return parseFloat(t, 10)
                    }
                    )))[4] = e.x,
                    r[5] = e.y,
                    f(t, "matrix(".concat(r.join(","), ")"))) : ((r = n.match(g)[1].split(",").map((function(t) {
                        return parseFloat(t, 10)
                    }
                    )))[12] = e.x,
                    r[13] = e.y,
                    f(t, "matrix3d(".concat(r.join(","), ")")))
                } else
                    f(t, "translateX(".concat(e.x, "px) translateY(").concat(e.y, "px) translateZ(0)"))
            }(t, r)
        }
        function D(t, e) {
            for (var i = 0; i < t.length; i++)
                e(t[i])
        }
        function L(t) {
            return "border-box" === p(t, "boxSizing")
        }
        "undefined" != typeof window && (p = window.getComputedStyle ? function(t, e, i) {
            var n = i
              , r = ""
              , o = T(t);
            return (n = n || o.defaultView.getComputedStyle(t, null)) && (r = n.getPropertyValue(e) || n[e]),
            r
        }
        : function(t, e) {
            var i = t[A] && t[A][e];
            if (S.test(i) && !C.test(e)) {
                var n = t.style
                  , r = n[M]
                  , o = t[I][M];
                t[I][M] = t[A][M],
                n[M] = "fontSize" === e ? "1em" : i || 0,
                i = n.pixelLeft + "px",
                n[M] = r,
                t[I][M] = o
            }
            return "" === i ? "auto" : i
        }
        );
        var B = ["margin", "border", "padding"]
          , z = -1
          , F = 2
          , N = 1;
        function j(t, e, i) {
            var n, r, o, s = 0;
            for (r = 0; r < e.length; r++)
                if (n = e[r])
                    for (o = 0; o < i.length; o++) {
                        var a = void 0;
                        a = "border" === n ? "".concat(n).concat(i[o], "Width") : n + i[o],
                        s += parseFloat(p(t, a)) || 0
                    }
            return s
        }
        var U = {
            getParent: function(t) {
                var e = t;
                do {
                    e = 11 === e.nodeType && e.host ? e.host : e.parentNode
                } while (e && 1 !== e.nodeType && 9 !== e.nodeType);
                return e
            }
        };
        function V(t, e, i) {
            var n = i;
            if (E(t))
                return "width" === e ? U.viewportWidth(t) : U.viewportHeight(t);
            if (9 === t.nodeType)
                return "width" === e ? U.docWidth(t) : U.docHeight(t);
            var r = "width" === e ? ["Left", "Right"] : ["Top", "Bottom"]
              , o = "width" === e ? Math.floor(t.getBoundingClientRect().width) : Math.floor(t.getBoundingClientRect().height)
              , s = L(t)
              , a = 0;
            (null == o || o <= 0) && (o = void 0,
            (null == (a = p(t, e)) || Number(a) < 0) && (a = t.style[e] || 0),
            a = Math.floor(parseFloat(a)) || 0),
            void 0 === n && (n = s ? N : z);
            var l = void 0 !== o || s
              , c = o || a;
            return n === z ? l ? c - j(t, ["border", "padding"], r) : a : l ? n === N ? c : c + (n === F ? -j(t, ["border"], r) : j(t, ["margin"], r)) : a + j(t, B.slice(n), r)
        }
        D(["Width", "Height"], (function(t) {
            U["doc".concat(t)] = function(e) {
                var i = e.document;
                return Math.max(i.documentElement["scroll".concat(t)], i.body["scroll".concat(t)], U["viewport".concat(t)](i))
            }
            ,
            U["viewport".concat(t)] = function(e) {
                var i = "client".concat(t)
                  , n = e.document
                  , r = n.body
                  , o = n.documentElement[i];
                return "CSS1Compat" === n.compatMode && o || r && r[i] || o
            }
        }
        ));
        var G = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        };
        function Z() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                e[i] = arguments[i];
            var n, r = e[0];
            return 0 !== r.offsetWidth ? n = V.apply(void 0, e) : function(t, e, i) {
                var n, r = {}, o = t.style;
                for (n in e)
                    e.hasOwnProperty(n) && (r[n] = o[n],
                    o[n] = e[n]);
                for (n in i.call(t),
                e)
                    e.hasOwnProperty(n) && (o[n] = r[n])
            }(r, G, (function() {
                n = V.apply(void 0, e)
            }
            )),
            n
        }
        function q(t, e) {
            for (var i in e)
                e.hasOwnProperty(i) && (t[i] = e[i]);
            return t
        }
        D(["width", "height"], (function(t) {
            var e = t.charAt(0).toUpperCase() + t.slice(1);
            U["outer".concat(e)] = function(e, i) {
                return e && Z(e, t, i ? 0 : N)
            }
            ;
            var i = "width" === t ? ["Left", "Right"] : ["Top", "Bottom"];
            U[t] = function(e, n) {
                var r = n;
                return void 0 !== r ? e ? (L(e) && (r += j(e, ["padding", "border"], i)),
                y(e, t, r)) : void 0 : e && Z(e, t, z)
            }
        }
        ));
        var W = {
            getWindow: function(t) {
                if (t && t.document && t.setTimeout)
                    return t;
                var e = t.ownerDocument || t;
                return e.defaultView || e.parentWindow
            },
            getDocument: T,
            offset: function(t, e, i) {
                if (void 0 === e)
                    return w(t);
                !function(t, e, i) {
                    if (i.ignoreShake) {
                        var n = w(t)
                          , r = n.left.toFixed(0)
                          , o = n.top.toFixed(0)
                          , s = e.left.toFixed(0)
                          , a = e.top.toFixed(0);
                        if (r === s && o === a)
                            return
                    }
                    i.useCssRight || i.useCssBottom ? O(t, e, i) : i.useCssTransform && u()in document.body.style ? R(t, e) : O(t, e, i)
                }(t, e, i || {})
            },
            isWindow: E,
            each: D,
            css: y,
            clone: function(t) {
                var e, i = {};
                for (e in t)
                    t.hasOwnProperty(e) && (i[e] = t[e]);
                if (t.overflow)
                    for (e in t)
                        t.hasOwnProperty(e) && (i.overflow[e] = t.overflow[e]);
                return i
            },
            mix: q,
            getWindowScrollLeft: function(t) {
                return x(t)
            },
            getWindowScrollTop: function(t) {
                return b(t)
            },
            merge: function() {
                for (var t = {}, e = 0; e < arguments.length; e++)
                    W.mix(t, e < 0 || arguments.length <= e ? void 0 : arguments[e]);
                return t
            },
            viewportWidth: 0,
            viewportHeight: 0
        };
        q(W, U);
        var H = W.getParent;
        function $(t) {
            if (W.isWindow(t) || 9 === t.nodeType)
                return null;
            var e, i = W.getDocument(t).body, n = W.css(t, "position");
            if (!("fixed" === n || "absolute" === n))
                return "html" === t.nodeName.toLowerCase() ? null : H(t);
            for (e = H(t); e && e !== i && 9 !== e.nodeType; e = H(e))
                if ("static" !== (n = W.css(e, "position")))
                    return e;
            return null
        }
        var X = W.getParent;
        function Y(t, e) {
            for (var i = {
                left: 0,
                right: 1 / 0,
                top: 0,
                bottom: 1 / 0
            }, n = $(t), r = W.getDocument(t), o = r.defaultView || r.parentWindow, s = r.body, a = r.documentElement; n; ) {
                if (-1 !== navigator.userAgent.indexOf("MSIE") && 0 === n.clientWidth || n === s || n === a || "visible" === W.css(n, "overflow")) {
                    if (n === s || n === a)
                        break
                } else {
                    var l = W.offset(n);
                    l.left += n.clientLeft,
                    l.top += n.clientTop,
                    i.top = Math.max(i.top, l.top),
                    i.right = Math.min(i.right, l.left + n.clientWidth),
                    i.bottom = Math.min(i.bottom, l.top + n.clientHeight),
                    i.left = Math.max(i.left, l.left)
                }
                n = $(n)
            }
            var c = null;
            W.isWindow(t) || 9 === t.nodeType || (c = t.style.position,
            "absolute" === W.css(t, "position") && (t.style.position = "fixed"));
            var h = W.getWindowScrollLeft(o)
              , u = W.getWindowScrollTop(o)
              , d = W.viewportWidth(o)
              , f = W.viewportHeight(o)
              , p = a.scrollWidth
              , m = a.scrollHeight
              , g = window.getComputedStyle(s);
            if ("hidden" === g.overflowX && (p = o.innerWidth),
            "hidden" === g.overflowY && (m = o.innerHeight),
            t.style && (t.style.position = c),
            e || function(t) {
                if (W.isWindow(t) || 9 === t.nodeType)
                    return !1;
                var e = W.getDocument(t)
                  , i = e.body
                  , n = null;
                for (n = X(t); n && n !== i && n !== e; n = X(n))
                    if ("fixed" === W.css(n, "position"))
                        return !0;
                return !1
            }(t))
                i.left = Math.max(i.left, h),
                i.top = Math.max(i.top, u),
                i.right = Math.min(i.right, h + d),
                i.bottom = Math.min(i.bottom, u + f);
            else {
                var _ = Math.max(p, h + d);
                i.right = Math.min(i.right, _);
                var y = Math.max(m, u + f);
                i.bottom = Math.min(i.bottom, y)
            }
            return i.top >= 0 && i.left >= 0 && i.bottom > i.top && i.right > i.left ? i : null
        }
        function K(t) {
            var e, i, n;
            if (W.isWindow(t) || 9 === t.nodeType) {
                var r = W.getWindow(t);
                e = {
                    left: W.getWindowScrollLeft(r),
                    top: W.getWindowScrollTop(r)
                },
                i = W.viewportWidth(r),
                n = W.viewportHeight(r)
            } else
                e = W.offset(t),
                i = W.outerWidth(t),
                n = W.outerHeight(t);
            return e.width = i,
            e.height = n,
            e
        }
        function J(t, e) {
            var i = e.charAt(0)
              , n = e.charAt(1)
              , r = t.width
              , o = t.height
              , s = t.left
              , a = t.top;
            return "c" === i ? a += o / 2 : "b" === i && (a += o),
            "c" === n ? s += r / 2 : "r" === n && (s += r),
            {
                left: s,
                top: a
            }
        }
        function Q(t, e, i, n, r) {
            var o = J(e, i[1])
              , s = J(t, i[0])
              , a = [s.left - o.left, s.top - o.top];
            return {
                left: Math.round(t.left - a[0] + n[0] - r[0]),
                top: Math.round(t.top - a[1] + n[1] - r[1])
            }
        }
        function tt(t, e, i) {
            return t.left < i.left || t.left + e.width > i.right
        }
        function et(t, e, i) {
            return t.top < i.top || t.top + e.height > i.bottom
        }
        function it(t, e, i) {
            var n = [];
            return W.each(t, (function(t) {
                n.push(t.replace(e, (function(t) {
                    return i[t]
                }
                )))
            }
            )),
            n
        }
        function nt(t, e) {
            return t[e] = -t[e],
            t
        }
        function rt(t, e) {
            return (/%$/.test(t) ? parseInt(t.substring(0, t.length - 1), 10) / 100 * e : parseInt(t, 10)) || 0
        }
        function ot(t, e) {
            t[0] = rt(t[0], e.width),
            t[1] = rt(t[1], e.height)
        }
        function st(t, e, i, n) {
            var r = i.points
              , o = i.offset || [0, 0]
              , s = i.targetOffset || [0, 0]
              , a = i.overflow
              , l = i.source || t;
            o = [].concat(o),
            s = [].concat(s);
            var c = {}
              , h = 0
              , u = Y(l, !(!(a = a || {}) || !a.alwaysByViewport))
              , d = K(l);
            ot(o, d),
            ot(s, e);
            var f = Q(d, e, r, o, s)
              , p = W.merge(d, f);
            if (u && (a.adjustX || a.adjustY) && n) {
                if (a.adjustX && tt(f, d, u)) {
                    var m = it(r, /[lr]/gi, {
                        l: "r",
                        r: "l"
                    })
                      , g = nt(o, 0)
                      , _ = nt(s, 0);
                    (function(t, e, i) {
                        return t.left > i.right || t.left + e.width < i.left
                    }
                    )(Q(d, e, m, g, _), d, u) || (h = 1,
                    r = m,
                    o = g,
                    s = _)
                }
                if (a.adjustY && et(f, d, u)) {
                    var y = it(r, /[tb]/gi, {
                        t: "b",
                        b: "t"
                    })
                      , v = nt(o, 1)
                      , x = nt(s, 1);
                    (function(t, e, i) {
                        return t.top > i.bottom || t.top + e.height < i.top
                    }
                    )(Q(d, e, y, v, x), d, u) || (h = 1,
                    r = y,
                    o = v,
                    s = x)
                }
                h && (f = Q(d, e, r, o, s),
                W.mix(p, f));
                var b = tt(f, d, u)
                  , w = et(f, d, u);
                if (b || w) {
                    var E = r;
                    b && (E = it(r, /[lr]/gi, {
                        l: "r",
                        r: "l"
                    })),
                    w && (E = it(r, /[tb]/gi, {
                        t: "b",
                        b: "t"
                    })),
                    r = E,
                    o = i.offset || [0, 0],
                    s = i.targetOffset || [0, 0]
                }
                c.adjustX = a.adjustX && b,
                c.adjustY = a.adjustY && w,
                (c.adjustX || c.adjustY) && (p = function(t, e, i, n) {
                    var r = W.clone(t)
                      , o = {
                        width: e.width,
                        height: e.height
                    };
                    return n.adjustX && r.left < i.left && (r.left = i.left),
                    n.resizeWidth && r.left >= i.left && r.left + o.width > i.right && (o.width -= r.left + o.width - i.right),
                    n.adjustX && r.left + o.width > i.right && (r.left = Math.max(i.right - o.width, i.left)),
                    n.adjustY && r.top < i.top && (r.top = i.top),
                    n.resizeHeight && r.top >= i.top && r.top + o.height > i.bottom && (o.height -= r.top + o.height - i.bottom),
                    n.adjustY && r.top + o.height > i.bottom && (r.top = Math.max(i.bottom - o.height, i.top)),
                    W.mix(r, o)
                }(f, d, u, c))
            }
            return p.width !== d.width && W.css(l, "width", W.width(l) + p.width - d.width),
            p.height !== d.height && W.css(l, "height", W.height(l) + p.height - d.height),
            W.offset(l, {
                left: p.left,
                top: p.top
            }, {
                useCssRight: i.useCssRight,
                useCssBottom: i.useCssBottom,
                useCssTransform: i.useCssTransform,
                ignoreShake: i.ignoreShake
            }),
            {
                points: r,
                offset: o,
                targetOffset: s,
                overflow: c
            }
        }
        function at(t, e, i) {
            var n = i.target || e
              , r = K(n)
              , o = !function(t, e) {
                var i = Y(t, e)
                  , n = K(t);
                return !i || n.left + n.width <= i.left || n.top + n.height <= i.top || n.left >= i.right || n.top >= i.bottom
            }(n, i.overflow && i.overflow.alwaysByViewport);
            return st(t, r, i, o)
        }
        function lt(t, e, i) {
            var n, o, s = W.getDocument(t), a = s.defaultView || s.parentWindow, l = W.getWindowScrollLeft(a), c = W.getWindowScrollTop(a), h = W.viewportWidth(a), u = W.viewportHeight(a), d = {
                left: n = "pageX"in e ? e.pageX : l + e.clientX,
                top: o = "pageY"in e ? e.pageY : c + e.clientY,
                width: 0,
                height: 0
            }, f = n >= 0 && n <= l + h && o >= 0 && o <= c + u, p = [i.points[0], "cc"];
            return st(t, d, r(r({}, i), {}, {
                points: p
            }), f)
        }
        at.__getOffsetParent = $,
        at.__getVisibleRectForElement = Y,
        e.default = at
    },
    26729: function(t) {
        "use strict";
        var e = Object.prototype.hasOwnProperty
          , i = "~";
        function n() {}
        function r(t, e, i) {
            this.fn = t,
            this.context = e,
            this.once = i || !1
        }
        function o(t, e, n, o, s) {
            if ("function" != typeof n)
                throw new TypeError("The listener must be a function");
            var a = new r(n,o || t,s)
              , l = i ? i + e : e;
            return t._events[l] ? t._events[l].fn ? t._events[l] = [t._events[l], a] : t._events[l].push(a) : (t._events[l] = a,
            t._eventsCount++),
            t
        }
        function s(t, e) {
            0 == --t._eventsCount ? t._events = new n : delete t._events[e]
        }
        function a() {
            this._events = new n,
            this._eventsCount = 0
        }
        Object.create && (n.prototype = Object.create(null),
        (new n).__proto__ || (i = !1)),
        a.prototype.eventNames = function() {
            var t, n, r = [];
            if (0 === this._eventsCount)
                return r;
            for (n in t = this._events)
                e.call(t, n) && r.push(i ? n.slice(1) : n);
            return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
        }
        ,
        a.prototype.listeners = function(t) {
            var e = i ? i + t : t
              , n = this._events[e];
            if (!n)
                return [];
            if (n.fn)
                return [n.fn];
            for (var r = 0, o = n.length, s = new Array(o); r < o; r++)
                s[r] = n[r].fn;
            return s
        }
        ,
        a.prototype.listenerCount = function(t) {
            var e = i ? i + t : t
              , n = this._events[e];
            return n ? n.fn ? 1 : n.length : 0
        }
        ,
        a.prototype.emit = function(t, e, n, r, o, s) {
            var a = i ? i + t : t;
            if (!this._events[a])
                return !1;
            var l, c, h = this._events[a], u = arguments.length;
            if (h.fn) {
                switch (h.once && this.removeListener(t, h.fn, void 0, !0),
                u) {
                case 1:
                    return h.fn.call(h.context),
                    !0;
                case 2:
                    return h.fn.call(h.context, e),
                    !0;
                case 3:
                    return h.fn.call(h.context, e, n),
                    !0;
                case 4:
                    return h.fn.call(h.context, e, n, r),
                    !0;
                case 5:
                    return h.fn.call(h.context, e, n, r, o),
                    !0;
                case 6:
                    return h.fn.call(h.context, e, n, r, o, s),
                    !0
                }
                for (c = 1,
                l = new Array(u - 1); c < u; c++)
                    l[c - 1] = arguments[c];
                h.fn.apply(h.context, l)
            } else {
                var d, f = h.length;
                for (c = 0; c < f; c++)
                    switch (h[c].once && this.removeListener(t, h[c].fn, void 0, !0),
                    u) {
                    case 1:
                        h[c].fn.call(h[c].context);
                        break;
                    case 2:
                        h[c].fn.call(h[c].context, e);
                        break;
                    case 3:
                        h[c].fn.call(h[c].context, e, n);
                        break;
                    case 4:
                        h[c].fn.call(h[c].context, e, n, r);
                        break;
                    default:
                        if (!l)
                            for (d = 1,
                            l = new Array(u - 1); d < u; d++)
                                l[d - 1] = arguments[d];
                        h[c].fn.apply(h[c].context, l)
                    }
            }
            return !0
        }
        ,
        a.prototype.on = function(t, e, i) {
            return o(this, t, e, i, !1)
        }
        ,
        a.prototype.once = function(t, e, i) {
            return o(this, t, e, i, !0)
        }
        ,
        a.prototype.removeListener = function(t, e, n, r) {
            var o = i ? i + t : t;
            if (!this._events[o])
                return this;
            if (!e)
                return s(this, o),
                this;
            var a = this._events[o];
            if (a.fn)
                a.fn !== e || r && !a.once || n && a.context !== n || s(this, o);
            else {
                for (var l = 0, c = [], h = a.length; l < h; l++)
                    (a[l].fn !== e || r && !a[l].once || n && a[l].context !== n) && c.push(a[l]);
                c.length ? this._events[o] = 1 === c.length ? c[0] : c : s(this, o)
            }
            return this
        }
        ,
        a.prototype.removeAllListeners = function(t) {
            var e;
            return t ? (e = i ? i + t : t,
            this._events[e] && s(this, e)) : (this._events = new n,
            this._eventsCount = 0),
            this
        }
        ,
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prefixed = i,
        a.EventEmitter = a,
        t.exports = a
    },
    80645: function(t, e) {
        e.read = function(t, e, i, n, r) {
            var o, s, a = 8 * r - n - 1, l = (1 << a) - 1, c = l >> 1, h = -7, u = i ? r - 1 : 0, d = i ? -1 : 1, f = t[e + u];
            for (u += d,
            o = f & (1 << -h) - 1,
            f >>= -h,
            h += a; h > 0; o = 256 * o + t[e + u],
            u += d,
            h -= 8)
                ;
            for (s = o & (1 << -h) - 1,
            o >>= -h,
            h += n; h > 0; s = 256 * s + t[e + u],
            u += d,
            h -= 8)
                ;
            if (0 === o)
                o = 1 - c;
            else {
                if (o === l)
                    return s ? NaN : 1 / 0 * (f ? -1 : 1);
                s += Math.pow(2, n),
                o -= c
            }
            return (f ? -1 : 1) * s * Math.pow(2, o - n)
        }
        ,
        e.write = function(t, e, i, n, r, o) {
            var s, a, l, c = 8 * o - r - 1, h = (1 << c) - 1, u = h >> 1, d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : o - 1, p = n ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e),
            isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
            s = h) : (s = Math.floor(Math.log(e) / Math.LN2),
            e * (l = Math.pow(2, -s)) < 1 && (s--,
            l *= 2),
            (e += s + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (s++,
            l /= 2),
            s + u >= h ? (a = 0,
            s = h) : s + u >= 1 ? (a = (e * l - 1) * Math.pow(2, r),
            s += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, r),
            s = 0)); r >= 8; t[i + f] = 255 & a,
            f += p,
            a /= 256,
            r -= 8)
                ;
            for (s = s << r | a,
            c += r; c > 0; t[i + f] = 255 & s,
            f += p,
            s /= 256,
            c -= 8)
                ;
            t[i + f - p] |= 128 * m
        }
    },
    33310: function(t) {
        "use strict";
        var e = Object.prototype.toString;
        t.exports = function(t) {
            var i;
            return "[object Object]" === e.call(t) && (null === (i = Object.getPrototypeOf(t)) || i === Object.getPrototypeOf({}))
        }
    },
    29291: function(t, e, i) {
        "use strict";
        i.d(e, {
            X: function() {
                return G
            },
            Z: function() {
                return Z
            }
        });
        var n, r = i(24829), o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = "=";
        function a(t) {
            var e, i, n = "";
            for (e = 0; e + 3 <= t.length; e += 3)
                i = parseInt(t.substring(e, e + 3), 16),
                n += o.charAt(i >> 6) + o.charAt(63 & i);
            for (e + 1 == t.length ? (i = parseInt(t.substring(e, e + 1), 16),
            n += o.charAt(i << 2)) : e + 2 == t.length && (i = parseInt(t.substring(e, e + 2), 16),
            n += o.charAt(i >> 2) + o.charAt((3 & i) << 4)); (3 & n.length) > 0; )
                n += s;
            return n
        }
        function l(t) {
            var e, i = "", n = 0, a = 0;
            for (e = 0; e < t.length && t.charAt(e) != s; ++e) {
                var l = o.indexOf(t.charAt(e));
                l < 0 || (0 == n ? (i += (0,
                r.vL)(l >> 2),
                a = 3 & l,
                n = 1) : 1 == n ? (i += (0,
                r.vL)(a << 2 | l >> 4),
                a = 15 & l,
                n = 2) : 2 == n ? (i += (0,
                r.vL)(a),
                i += (0,
                r.vL)(l >> 2),
                a = 3 & l,
                n = 3) : (i += (0,
                r.vL)(a << 2 | l >> 4),
                i += (0,
                r.vL)(15 & l),
                n = 0))
            }
            return 1 == n && (i += (0,
            r.vL)(a << 2)),
            i
        }
        var c, h = function(t) {
            var e;
            if (void 0 === n) {
                var i = "0123456789ABCDEF"
                  , r = " \f\n\r\t\u2028\u2029";
                for (n = {},
                e = 0; e < 16; ++e)
                    n[i.charAt(e)] = e;
                for (i = i.toLowerCase(),
                e = 10; e < 16; ++e)
                    n[i.charAt(e)] = e;
                for (e = 0; e < 8; ++e)
                    n[r.charAt(e)] = -1
            }
            var o = []
              , s = 0
              , a = 0;
            for (e = 0; e < t.length; ++e) {
                var l = t.charAt(e);
                if ("=" == l)
                    break;
                if (-1 != (l = n[l])) {
                    if (void 0 === l)
                        throw new Error("Illegal character at offset " + e);
                    s |= l,
                    ++a >= 2 ? (o[o.length] = s,
                    s = 0,
                    a = 0) : s <<= 4
                }
            }
            if (a)
                throw new Error("Hex encoding incomplete: 4 bits missing");
            return o
        }, u = {
            decode: function(t) {
                var e;
                if (void 0 === c) {
                    var i = "= \f\n\r\t\u2028\u2029";
                    for (c = Object.create(null),
                    e = 0; e < 64; ++e)
                        c["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e)] = e;
                    for (c["-"] = 62,
                    c._ = 63,
                    e = 0; e < 9; ++e)
                        c[i.charAt(e)] = -1
                }
                var n = []
                  , r = 0
                  , o = 0;
                for (e = 0; e < t.length; ++e) {
                    var s = t.charAt(e);
                    if ("=" == s)
                        break;
                    if (-1 != (s = c[s])) {
                        if (void 0 === s)
                            throw new Error("Illegal character at offset " + e);
                        r |= s,
                        ++o >= 4 ? (n[n.length] = r >> 16,
                        n[n.length] = r >> 8 & 255,
                        n[n.length] = 255 & r,
                        r = 0,
                        o = 0) : r <<= 6
                    }
                }
                switch (o) {
                case 1:
                    throw new Error("Base64 encoding incomplete: at least 2 bits missing");
                case 2:
                    n[n.length] = r >> 10;
                    break;
                case 3:
                    n[n.length] = r >> 16,
                    n[n.length] = r >> 8 & 255
                }
                return n
            },
            re: /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,
            unarmor: function(t) {
                var e = u.re.exec(t);
                if (e)
                    if (e[1])
                        t = e[1];
                    else {
                        if (!e[2])
                            throw new Error("RegExp out of sync");
                        t = e[2]
                    }
                return u.decode(t)
            }
        }, d = 1e13, f = function() {
            function t(t) {
                this.buf = [+t || 0]
            }
            return t.prototype.mulAdd = function(t, e) {
                var i, n, r = this.buf, o = r.length;
                for (i = 0; i < o; ++i)
                    (n = r[i] * t + e) < d ? e = 0 : n -= (e = 0 | n / d) * d,
                    r[i] = n;
                e > 0 && (r[i] = e)
            }
            ,
            t.prototype.sub = function(t) {
                var e, i, n = this.buf, r = n.length;
                for (e = 0; e < r; ++e)
                    (i = n[e] - t) < 0 ? (i += d,
                    t = 1) : t = 0,
                    n[e] = i;
                for (; 0 === n[n.length - 1]; )
                    n.pop()
            }
            ,
            t.prototype.toString = function(t) {
                if (10 != (t || 10))
                    throw new Error("only base 10 is supported");
                for (var e = this.buf, i = e[e.length - 1].toString(), n = e.length - 2; n >= 0; --n)
                    i += (d + e[n]).toString().substring(1);
                return i
            }
            ,
            t.prototype.valueOf = function() {
                for (var t = this.buf, e = 0, i = t.length - 1; i >= 0; --i)
                    e = e * d + t[i];
                return e
            }
            ,
            t.prototype.simplify = function() {
                var t = this.buf;
                return 1 == t.length ? t[0] : this
            }
            ,
            t
        }(), p = /^(\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/, m = /^(\d\d\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
        function g(t, e) {
            return t.length > e && (t = t.substring(0, e) + ""),
            t
        }
        var _ = function() {
            function t(e, i) {
                this.hexDigits = "0123456789ABCDEF",
                e instanceof t ? (this.enc = e.enc,
                this.pos = e.pos) : (this.enc = e,
                this.pos = i)
            }
            return t.prototype.get = function(t) {
                if (void 0 === t && (t = this.pos++),
                t >= this.enc.length)
                    throw new Error("Requesting byte offset ".concat(t, " on a stream of length ").concat(this.enc.length));
                return "string" == typeof this.enc ? this.enc.charCodeAt(t) : this.enc[t]
            }
            ,
            t.prototype.hexByte = function(t) {
                return this.hexDigits.charAt(t >> 4 & 15) + this.hexDigits.charAt(15 & t)
            }
            ,
            t.prototype.hexDump = function(t, e, i) {
                for (var n = "", r = t; r < e; ++r)
                    if (n += this.hexByte(this.get(r)),
                    !0 !== i)
                        switch (15 & r) {
                        case 7:
                            n += "  ";
                            break;
                        case 15:
                            n += "\n";
                            break;
                        default:
                            n += " "
                        }
                return n
            }
            ,
            t.prototype.isASCII = function(t, e) {
                for (var i = t; i < e; ++i) {
                    var n = this.get(i);
                    if (n < 32 || n > 176)
                        return !1
                }
                return !0
            }
            ,
            t.prototype.parseStringISO = function(t, e) {
                for (var i = "", n = t; n < e; ++n)
                    i += String.fromCharCode(this.get(n));
                return i
            }
            ,
            t.prototype.parseStringUTF = function(t, e) {
                for (var i = "", n = t; n < e; ) {
                    var r = this.get(n++);
                    i += r < 128 ? String.fromCharCode(r) : r > 191 && r < 224 ? String.fromCharCode((31 & r) << 6 | 63 & this.get(n++)) : String.fromCharCode((15 & r) << 12 | (63 & this.get(n++)) << 6 | 63 & this.get(n++))
                }
                return i
            }
            ,
            t.prototype.parseStringBMP = function(t, e) {
                for (var i, n, r = "", o = t; o < e; )
                    i = this.get(o++),
                    n = this.get(o++),
                    r += String.fromCharCode(i << 8 | n);
                return r
            }
            ,
            t.prototype.parseTime = function(t, e, i) {
                var n = this.parseStringISO(t, e)
                  , r = (i ? p : m).exec(n);
                return r ? (i && (r[1] = +r[1],
                r[1] += +r[1] < 70 ? 2e3 : 1900),
                n = r[1] + "-" + r[2] + "-" + r[3] + " " + r[4],
                r[5] && (n += ":" + r[5],
                r[6] && (n += ":" + r[6],
                r[7] && (n += "." + r[7]))),
                r[8] && (n += " UTC",
                "Z" != r[8] && (n += r[8],
                r[9] && (n += ":" + r[9]))),
                n) : "Unrecognized time: " + n
            }
            ,
            t.prototype.parseInteger = function(t, e) {
                for (var i, n = this.get(t), r = n > 127, o = r ? 255 : 0, s = ""; n == o && ++t < e; )
                    n = this.get(t);
                if (0 === (i = e - t))
                    return r ? -1 : 0;
                if (i > 4) {
                    for (s = n,
                    i <<= 3; 0 == (128 & (+s ^ o)); )
                        s = +s << 1,
                        --i;
                    s = "(" + i + " bit)\n"
                }
                r && (n -= 256);
                for (var a = new f(n), l = t + 1; l < e; ++l)
                    a.mulAdd(256, this.get(l));
                return s + a.toString()
            }
            ,
            t.prototype.parseBitString = function(t, e, i) {
                for (var n = this.get(t), r = "(" + ((e - t - 1 << 3) - n) + " bit)\n", o = "", s = t + 1; s < e; ++s) {
                    for (var a = this.get(s), l = s == e - 1 ? n : 0, c = 7; c >= l; --c)
                        o += a >> c & 1 ? "1" : "0";
                    if (o.length > i)
                        return r + g(o, i)
                }
                return r + o
            }
            ,
            t.prototype.parseOctetString = function(t, e, i) {
                if (this.isASCII(t, e))
                    return g(this.parseStringISO(t, e), i);
                var n = e - t
                  , r = "(" + n + " byte)\n";
                n > (i /= 2) && (e = t + i);
                for (var o = t; o < e; ++o)
                    r += this.hexByte(this.get(o));
                return n > i && (r += ""),
                r
            }
            ,
            t.prototype.parseOID = function(t, e, i) {
                for (var n = "", r = new f, o = 0, s = t; s < e; ++s) {
                    var a = this.get(s);
                    if (r.mulAdd(128, 127 & a),
                    o += 7,
                    !(128 & a)) {
                        if ("" === n)
                            if ((r = r.simplify())instanceof f)
                                r.sub(80),
                                n = "2." + r.toString();
                            else {
                                var l = r < 80 ? r < 40 ? 0 : 1 : 2;
                                n = l + "." + (r - 40 * l)
                            }
                        else
                            n += "." + r.toString();
                        if (n.length > i)
                            return g(n, i);
                        r = new f,
                        o = 0
                    }
                }
                return o > 0 && (n += ".incomplete"),
                n
            }
            ,
            t
        }()
          , y = function() {
            function t(t, e, i, n, r) {
                if (!(n instanceof v))
                    throw new Error("Invalid tag value.");
                this.stream = t,
                this.header = e,
                this.length = i,
                this.tag = n,
                this.sub = r
            }
            return t.prototype.typeName = function() {
                switch (this.tag.tagClass) {
                case 0:
                    switch (this.tag.tagNumber) {
                    case 0:
                        return "EOC";
                    case 1:
                        return "BOOLEAN";
                    case 2:
                        return "INTEGER";
                    case 3:
                        return "BIT_STRING";
                    case 4:
                        return "OCTET_STRING";
                    case 5:
                        return "NULL";
                    case 6:
                        return "OBJECT_IDENTIFIER";
                    case 7:
                        return "ObjectDescriptor";
                    case 8:
                        return "EXTERNAL";
                    case 9:
                        return "REAL";
                    case 10:
                        return "ENUMERATED";
                    case 11:
                        return "EMBEDDED_PDV";
                    case 12:
                        return "UTF8String";
                    case 16:
                        return "SEQUENCE";
                    case 17:
                        return "SET";
                    case 18:
                        return "NumericString";
                    case 19:
                        return "PrintableString";
                    case 20:
                        return "TeletexString";
                    case 21:
                        return "VideotexString";
                    case 22:
                        return "IA5String";
                    case 23:
                        return "UTCTime";
                    case 24:
                        return "GeneralizedTime";
                    case 25:
                        return "GraphicString";
                    case 26:
                        return "VisibleString";
                    case 27:
                        return "GeneralString";
                    case 28:
                        return "UniversalString";
                    case 30:
                        return "BMPString"
                    }
                    return "Universal_" + this.tag.tagNumber.toString();
                case 1:
                    return "Application_" + this.tag.tagNumber.toString();
                case 2:
                    return "[" + this.tag.tagNumber.toString() + "]";
                case 3:
                    return "Private_" + this.tag.tagNumber.toString()
                }
            }
            ,
            t.prototype.content = function(t) {
                if (void 0 === this.tag)
                    return null;
                void 0 === t && (t = 1 / 0);
                var e = this.posContent()
                  , i = Math.abs(this.length);
                if (!this.tag.isUniversal())
                    return null !== this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(e, e + i, t);
                switch (this.tag.tagNumber) {
                case 1:
                    return 0 === this.stream.get(e) ? "false" : "true";
                case 2:
                    return this.stream.parseInteger(e, e + i);
                case 3:
                    return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(e, e + i, t);
                case 4:
                    return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(e, e + i, t);
                case 6:
                    return this.stream.parseOID(e, e + i, t);
                case 16:
                case 17:
                    return null !== this.sub ? "(" + this.sub.length + " elem)" : "(no elem)";
                case 12:
                    return g(this.stream.parseStringUTF(e, e + i), t);
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 26:
                    return g(this.stream.parseStringISO(e, e + i), t);
                case 30:
                    return g(this.stream.parseStringBMP(e, e + i), t);
                case 23:
                case 24:
                    return this.stream.parseTime(e, e + i, 23 == this.tag.tagNumber)
                }
                return null
            }
            ,
            t.prototype.toString = function() {
                return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + (null === this.sub ? "null" : this.sub.length) + "]"
            }
            ,
            t.prototype.toPrettyString = function(t) {
                void 0 === t && (t = "");
                var e = t + this.typeName() + " @" + this.stream.pos;
                if (this.length >= 0 && (e += "+"),
                e += this.length,
                this.tag.tagConstructed ? e += " (constructed)" : !this.tag.isUniversal() || 3 != this.tag.tagNumber && 4 != this.tag.tagNumber || null === this.sub || (e += " (encapsulates)"),
                e += "\n",
                null !== this.sub) {
                    t += "  ";
                    for (var i = 0, n = this.sub.length; i < n; ++i)
                        e += this.sub[i].toPrettyString(t)
                }
                return e
            }
            ,
            t.prototype.posStart = function() {
                return this.stream.pos
            }
            ,
            t.prototype.posContent = function() {
                return this.stream.pos + this.header
            }
            ,
            t.prototype.posEnd = function() {
                return this.stream.pos + this.header + Math.abs(this.length)
            }
            ,
            t.prototype.toHexString = function() {
                return this.stream.hexDump(this.posStart(), this.posEnd(), !0)
            }
            ,
            t.decodeLength = function(t) {
                var e = t.get()
                  , i = 127 & e;
                if (i == e)
                    return i;
                if (i > 6)
                    throw new Error("Length over 48 bits not supported at position " + (t.pos - 1));
                if (0 === i)
                    return null;
                e = 0;
                for (var n = 0; n < i; ++n)
                    e = 256 * e + t.get();
                return e
            }
            ,
            t.prototype.getHexStringValue = function() {
                var t = this.toHexString()
                  , e = 2 * this.header
                  , i = 2 * this.length;
                return t.substr(e, i)
            }
            ,
            t.decode = function(e) {
                var i;
                i = e instanceof _ ? e : new _(e,0);
                var n = new _(i)
                  , r = new v(i)
                  , o = t.decodeLength(i)
                  , s = i.pos
                  , a = s - n.pos
                  , l = null
                  , c = function() {
                    var e = [];
                    if (null !== o) {
                        for (var n = s + o; i.pos < n; )
                            e[e.length] = t.decode(i);
                        if (i.pos != n)
                            throw new Error("Content size is not correct for container starting at offset " + s)
                    } else
                        try {
                            for (; ; ) {
                                var r = t.decode(i);
                                if (r.tag.isEOC())
                                    break;
                                e[e.length] = r
                            }
                            o = s - i.pos
                        } catch (t) {
                            throw new Error("Exception while decoding undefined length content: " + t)
                        }
                    return e
                };
                if (r.tagConstructed)
                    l = c();
                else if (r.isUniversal() && (3 == r.tagNumber || 4 == r.tagNumber))
                    try {
                        if (3 == r.tagNumber && 0 != i.get())
                            throw new Error("BIT STRINGs with unused bits cannot encapsulate.");
                        l = c();
                        for (var h = 0; h < l.length; ++h)
                            if (l[h].tag.isEOC())
                                throw new Error("EOC is not supposed to be actual content.")
                    } catch (t) {
                        l = null
                    }
                if (null === l) {
                    if (null === o)
                        throw new Error("We can't skip over an invalid tag with undefined length at offset " + s);
                    i.pos = s + Math.abs(o)
                }
                return new t(n,a,o,r,l)
            }
            ,
            t
        }()
          , v = function() {
            function t(t) {
                var e = t.get();
                if (this.tagClass = e >> 6,
                this.tagConstructed = 0 != (32 & e),
                this.tagNumber = 31 & e,
                31 == this.tagNumber) {
                    var i = new f;
                    do {
                        e = t.get(),
                        i.mulAdd(128, 127 & e)
                    } while (128 & e);
                    this.tagNumber = i.simplify()
                }
            }
            return t.prototype.isUniversal = function() {
                return 0 === this.tagClass
            }
            ,
            t.prototype.isEOC = function() {
                return 0 === this.tagClass && 0 === this.tagNumber
            }
            ,
            t
        }()
          , x = i(42529)
          , b = function() {
            function t() {
                this.i = 0,
                this.j = 0,
                this.S = []
            }
            return t.prototype.init = function(t) {
                var e, i, n;
                for (e = 0; e < 256; ++e)
                    this.S[e] = e;
                for (i = 0,
                e = 0; e < 256; ++e)
                    i = i + this.S[e] + t[e % t.length] & 255,
                    n = this.S[e],
                    this.S[e] = this.S[i],
                    this.S[i] = n;
                this.i = 0,
                this.j = 0
            }
            ,
            t.prototype.next = function() {
                var t;
                return this.i = this.i + 1 & 255,
                this.j = this.j + this.S[this.i] & 255,
                t = this.S[this.i],
                this.S[this.i] = this.S[this.j],
                this.S[this.j] = t,
                this.S[t + this.S[this.i] & 255]
            }
            ,
            t
        }();
        var w, E, T = null;
        if (null == T) {
            T = [],
            E = 0;
            var S = void 0;
            if ("undefined" != typeof window && window.crypto && window.crypto.getRandomValues) {
                var C = new Uint32Array(256);
                for (window.crypto.getRandomValues(C),
                S = 0; S < C.length; ++S)
                    T[E++] = 255 & C[S]
            }
            var A = 0
              , I = function(t) {
                if ((A = A || 0) >= 256 || E >= 256)
                    window.removeEventListener ? window.removeEventListener("mousemove", I, !1) : window.detachEvent && window.detachEvent("onmousemove", I);
                else
                    try {
                        var e = t.x + t.y;
                        T[E++] = 255 & e,
                        A += 1
                    } catch (t) {}
            };
            "undefined" != typeof window && (window.addEventListener ? window.addEventListener("mousemove", I, !1) : window.attachEvent && window.attachEvent("onmousemove", I))
        }
        function M() {
            if (null == w) {
                for (w = new b; E < 256; ) {
                    var t = Math.floor(65536 * Math.random());
                    T[E++] = 255 & t
                }
                for (w.init(T),
                E = 0; E < T.length; ++E)
                    T[E] = 0;
                E = 0
            }
            return w.next()
        }
        var P = function() {
            function t() {}
            return t.prototype.nextBytes = function(t) {
                for (var e = 0; e < t.length; ++e)
                    t[e] = M()
            }
            ,
            t
        }()
          , k = i(25108);
        var O = function() {
            function t() {
                this.n = null,
                this.e = 0,
                this.d = null,
                this.p = null,
                this.q = null,
                this.dmp1 = null,
                this.dmq1 = null,
                this.coeff = null
            }
            return t.prototype.doPublic = function(t) {
                return t.modPowInt(this.e, this.n)
            }
            ,
            t.prototype.doPrivate = function(t) {
                if (null == this.p || null == this.q)
                    return t.modPow(this.d, this.n);
                for (var e = t.mod(this.p).modPow(this.dmp1, this.p), i = t.mod(this.q).modPow(this.dmq1, this.q); e.compareTo(i) < 0; )
                    e = e.add(this.p);
                return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i)
            }
            ,
            t.prototype.setPublic = function(t, e) {
                null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = (0,
                x.BF)(t, 16),
                this.e = parseInt(e, 16)) : k.error("Invalid RSA public key")
            }
            ,
            t.prototype.encrypt = function(t) {
                var e = this.n.bitLength() + 7 >> 3
                  , i = function(t, e) {
                    if (e < t.length + 11)
                        return k.error("Message too long for RSA"),
                        null;
                    for (var i = [], n = t.length - 1; n >= 0 && e > 0; ) {
                        var r = t.charCodeAt(n--);
                        r < 128 ? i[--e] = r : r > 127 && r < 2048 ? (i[--e] = 63 & r | 128,
                        i[--e] = r >> 6 | 192) : (i[--e] = 63 & r | 128,
                        i[--e] = r >> 6 & 63 | 128,
                        i[--e] = r >> 12 | 224)
                    }
                    i[--e] = 0;
                    for (var o = new P, s = []; e > 2; ) {
                        for (s[0] = 0; 0 == s[0]; )
                            o.nextBytes(s);
                        i[--e] = s[0]
                    }
                    return i[--e] = 2,
                    i[--e] = 0,
                    new x.Jh(i)
                }(t, e);
                if (null == i)
                    return null;
                var n = this.doPublic(i);
                if (null == n)
                    return null;
                for (var r = n.toString(16), o = r.length, s = 0; s < 2 * e - o; s++)
                    r = "0" + r;
                return r
            }
            ,
            t.prototype.setPrivate = function(t, e, i) {
                null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = (0,
                x.BF)(t, 16),
                this.e = parseInt(e, 16),
                this.d = (0,
                x.BF)(i, 16)) : k.error("Invalid RSA private key")
            }
            ,
            t.prototype.setPrivateEx = function(t, e, i, n, r, o, s, a) {
                null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = (0,
                x.BF)(t, 16),
                this.e = parseInt(e, 16),
                this.d = (0,
                x.BF)(i, 16),
                this.p = (0,
                x.BF)(n, 16),
                this.q = (0,
                x.BF)(r, 16),
                this.dmp1 = (0,
                x.BF)(o, 16),
                this.dmq1 = (0,
                x.BF)(s, 16),
                this.coeff = (0,
                x.BF)(a, 16)) : k.error("Invalid RSA private key")
            }
            ,
            t.prototype.generate = function(t, e) {
                var i = new P
                  , n = t >> 1;
                this.e = parseInt(e, 16);
                for (var r = new x.Jh(e,16); ; ) {
                    for (; this.p = new x.Jh(t - n,1,i),
                    0 != this.p.subtract(x.Jh.ONE).gcd(r).compareTo(x.Jh.ONE) || !this.p.isProbablePrime(10); )
                        ;
                    for (; this.q = new x.Jh(n,1,i),
                    0 != this.q.subtract(x.Jh.ONE).gcd(r).compareTo(x.Jh.ONE) || !this.q.isProbablePrime(10); )
                        ;
                    if (this.p.compareTo(this.q) <= 0) {
                        var o = this.p;
                        this.p = this.q,
                        this.q = o
                    }
                    var s = this.p.subtract(x.Jh.ONE)
                      , a = this.q.subtract(x.Jh.ONE)
                      , l = s.multiply(a);
                    if (0 == l.gcd(r).compareTo(x.Jh.ONE)) {
                        this.n = this.p.multiply(this.q),
                        this.d = r.modInverse(l),
                        this.dmp1 = this.d.mod(s),
                        this.dmq1 = this.d.mod(a),
                        this.coeff = this.q.modInverse(this.p);
                        break
                    }
                }
            }
            ,
            t.prototype.decrypt = function(t) {
                var e = (0,
                x.BF)(t, 16)
                  , i = this.doPrivate(e);
                return null == i ? null : function(t, e) {
                    var i = t.toByteArray()
                      , n = 0;
                    for (; n < i.length && 0 == i[n]; )
                        ++n;
                    if (i.length - n != e - 1 || 2 != i[n])
                        return null;
                    ++n;
                    for (; 0 != i[n]; )
                        if (++n >= i.length)
                            return null;
                    var r = "";
                    for (; ++n < i.length; ) {
                        var o = 255 & i[n];
                        o < 128 ? r += String.fromCharCode(o) : o > 191 && o < 224 ? (r += String.fromCharCode((31 & o) << 6 | 63 & i[n + 1]),
                        ++n) : (r += String.fromCharCode((15 & o) << 12 | (63 & i[n + 1]) << 6 | 63 & i[n + 2]),
                        n += 2)
                    }
                    return r
                }(i, this.n.bitLength() + 7 >> 3)
            }
            ,
            t.prototype.generateAsync = function(t, e, i) {
                var n = new P
                  , r = t >> 1;
                this.e = parseInt(e, 16);
                var o = new x.Jh(e,16)
                  , s = this
                  , a = function() {
                    var e = function() {
                        if (s.p.compareTo(s.q) <= 0) {
                            var t = s.p;
                            s.p = s.q,
                            s.q = t
                        }
                        var e = s.p.subtract(x.Jh.ONE)
                          , n = s.q.subtract(x.Jh.ONE)
                          , r = e.multiply(n);
                        0 == r.gcd(o).compareTo(x.Jh.ONE) ? (s.n = s.p.multiply(s.q),
                        s.d = o.modInverse(r),
                        s.dmp1 = s.d.mod(e),
                        s.dmq1 = s.d.mod(n),
                        s.coeff = s.q.modInverse(s.p),
                        setTimeout((function() {
                            i()
                        }
                        ), 0)) : setTimeout(a, 0)
                    }
                      , l = function() {
                        s.q = (0,
                        x.cR)(),
                        s.q.fromNumberAsync(r, 1, n, (function() {
                            s.q.subtract(x.Jh.ONE).gcda(o, (function(t) {
                                0 == t.compareTo(x.Jh.ONE) && s.q.isProbablePrime(10) ? setTimeout(e, 0) : setTimeout(l, 0)
                            }
                            ))
                        }
                        ))
                    }
                      , c = function() {
                        s.p = (0,
                        x.cR)(),
                        s.p.fromNumberAsync(t - r, 1, n, (function() {
                            s.p.subtract(x.Jh.ONE).gcda(o, (function(t) {
                                0 == t.compareTo(x.Jh.ONE) && s.p.isProbablePrime(10) ? setTimeout(l, 0) : setTimeout(c, 0)
                            }
                            ))
                        }
                        ))
                    };
                    setTimeout(c, 0)
                };
                setTimeout(a, 0)
            }
            ,
            t.prototype.sign = function(t, e, i) {
                var n = function(t, e) {
                    if (e < t.length + 22)
                        return k.error("Message too long for RSA"),
                        null;
                    for (var i = e - t.length - 6, n = "", r = 0; r < i; r += 2)
                        n += "ff";
                    var o = "0001" + n + "00" + t;
                    return (0,
                    x.BF)(o, 16)
                }((R[i] || "") + e(t).toString(), this.n.bitLength() / 4);
                if (null == n)
                    return null;
                var r = this.doPrivate(n);
                if (null == r)
                    return null;
                var o = r.toString(16);
                return 0 == (1 & o.length) ? o : "0" + o
            }
            ,
            t.prototype.verify = function(t, e, i) {
                var n = (0,
                x.BF)(e, 16)
                  , r = this.doPublic(n);
                return null == r ? null : function(t) {
                    for (var e in R)
                        if (R.hasOwnProperty(e)) {
                            var i = R[e]
                              , n = i.length;
                            if (t.substr(0, n) == i)
                                return t.substr(n)
                        }
                    return t
                }(r.toString(16).replace(/^1f+00/, "")) == i(t).toString()
            }
            ,
            t
        }();
        var R = {
            md2: "3020300c06082a864886f70d020205000410",
            md5: "3020300c06082a864886f70d020505000410",
            sha1: "3021300906052b0e03021a05000414",
            sha224: "302d300d06096086480165030402040500041c",
            sha256: "3031300d060960864801650304020105000420",
            sha384: "3041300d060960864801650304020205000430",
            sha512: "3051300d060960864801650304020305000440",
            ripemd160: "3021300906052b2403020105000414"
        };
        var D = {};
        D.lang = {
            extend: function(t, e, i) {
                if (!e || !t)
                    throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");
                var n = function() {};
                if (n.prototype = e.prototype,
                t.prototype = new n,
                t.prototype.constructor = t,
                t.superclass = e.prototype,
                e.prototype.constructor == Object.prototype.constructor && (e.prototype.constructor = e),
                i) {
                    var r;
                    for (r in i)
                        t.prototype[r] = i[r];
                    var o = function() {}
                      , s = ["toString", "valueOf"];
                    try {
                        /MSIE/.test(navigator.userAgent) && (o = function(t, e) {
                            for (r = 0; r < s.length; r += 1) {
                                var i = s[r]
                                  , n = e[i];
                                "function" == typeof n && n != Object.prototype[i] && (t[i] = n)
                            }
                        }
                        )
                    } catch (t) {}
                    o(t.prototype, i)
                }
            }
        };
        var L = {};
        void 0 !== L.asn1 && L.asn1 || (L.asn1 = {}),
        L.asn1.ASN1Util = new function() {
            this.integerToByteHex = function(t) {
                var e = t.toString(16);
                return e.length % 2 == 1 && (e = "0" + e),
                e
            }
            ,
            this.bigIntToMinTwosComplementsHex = function(t) {
                var e = t.toString(16);
                if ("-" != e.substr(0, 1))
                    e.length % 2 == 1 ? e = "0" + e : e.match(/^[0-7]/) || (e = "00" + e);
                else {
                    var i = e.substr(1).length;
                    i % 2 == 1 ? i += 1 : e.match(/^[0-7]/) || (i += 2);
                    for (var n = "", r = 0; r < i; r++)
                        n += "f";
                    e = new x.Jh(n,16).xor(t).add(x.Jh.ONE).toString(16).replace(/^-/, "")
                }
                return e
            }
            ,
            this.getPEMStringFromHex = function(t, e) {
                return hextopem(t, e)
            }
            ,
            this.newObject = function(t) {
                var e = L.asn1
                  , i = e.DERBoolean
                  , n = e.DERInteger
                  , r = e.DERBitString
                  , o = e.DEROctetString
                  , s = e.DERNull
                  , a = e.DERObjectIdentifier
                  , l = e.DEREnumerated
                  , c = e.DERUTF8String
                  , h = e.DERNumericString
                  , u = e.DERPrintableString
                  , d = e.DERTeletexString
                  , f = e.DERIA5String
                  , p = e.DERUTCTime
                  , m = e.DERGeneralizedTime
                  , g = e.DERSequence
                  , _ = e.DERSet
                  , y = e.DERTaggedObject
                  , v = e.ASN1Util.newObject
                  , x = Object.keys(t);
                if (1 != x.length)
                    throw "key of param shall be only one.";
                var b = x[0];
                if (-1 == ":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":" + b + ":"))
                    throw "undefined key: " + b;
                if ("bool" == b)
                    return new i(t[b]);
                if ("int" == b)
                    return new n(t[b]);
                if ("bitstr" == b)
                    return new r(t[b]);
                if ("octstr" == b)
                    return new o(t[b]);
                if ("null" == b)
                    return new s(t[b]);
                if ("oid" == b)
                    return new a(t[b]);
                if ("enum" == b)
                    return new l(t[b]);
                if ("utf8str" == b)
                    return new c(t[b]);
                if ("numstr" == b)
                    return new h(t[b]);
                if ("prnstr" == b)
                    return new u(t[b]);
                if ("telstr" == b)
                    return new d(t[b]);
                if ("ia5str" == b)
                    return new f(t[b]);
                if ("utctime" == b)
                    return new p(t[b]);
                if ("gentime" == b)
                    return new m(t[b]);
                if ("seq" == b) {
                    for (var w = t[b], E = [], T = 0; T < w.length; T++) {
                        var S = v(w[T]);
                        E.push(S)
                    }
                    return new g({
                        array: E
                    })
                }
                if ("set" == b) {
                    for (w = t[b],
                    E = [],
                    T = 0; T < w.length; T++) {
                        S = v(w[T]);
                        E.push(S)
                    }
                    return new _({
                        array: E
                    })
                }
                if ("tag" == b) {
                    var C = t[b];
                    if ("[object Array]" === Object.prototype.toString.call(C) && 3 == C.length) {
                        var A = v(C[2]);
                        return new y({
                            tag: C[0],
                            explicit: C[1],
                            obj: A
                        })
                    }
                    var I = {};
                    if (void 0 !== C.explicit && (I.explicit = C.explicit),
                    void 0 !== C.tag && (I.tag = C.tag),
                    void 0 === C.obj)
                        throw "obj shall be specified for 'tag'.";
                    return I.obj = v(C.obj),
                    new y(I)
                }
            }
            ,
            this.jsonToASN1HEX = function(t) {
                return this.newObject(t).getEncodedHex()
            }
        }
        ,
        L.asn1.ASN1Util.oidHexToInt = function(t) {
            for (var e = "", i = parseInt(t.substr(0, 2), 16), n = (e = Math.floor(i / 40) + "." + i % 40,
            ""), r = 2; r < t.length; r += 2) {
                var o = ("00000000" + parseInt(t.substr(r, 2), 16).toString(2)).slice(-8);
                if (n += o.substr(1, 7),
                "0" == o.substr(0, 1))
                    e = e + "." + new x.Jh(n,2).toString(10),
                    n = ""
            }
            return e
        }
        ,
        L.asn1.ASN1Util.oidIntToHex = function(t) {
            var e = function(t) {
                var e = t.toString(16);
                return 1 == e.length && (e = "0" + e),
                e
            }
              , i = function(t) {
                var i = ""
                  , n = new x.Jh(t,10).toString(2)
                  , r = 7 - n.length % 7;
                7 == r && (r = 0);
                for (var o = "", s = 0; s < r; s++)
                    o += "0";
                n = o + n;
                for (s = 0; s < n.length - 1; s += 7) {
                    var a = n.substr(s, 7);
                    s != n.length - 7 && (a = "1" + a),
                    i += e(parseInt(a, 2))
                }
                return i
            };
            if (!t.match(/^[0-9.]+$/))
                throw "malformed oid string: " + t;
            var n = ""
              , r = t.split(".")
              , o = 40 * parseInt(r[0]) + parseInt(r[1]);
            n += e(o),
            r.splice(0, 2);
            for (var s = 0; s < r.length; s++)
                n += i(r[s]);
            return n
        }
        ,
        L.asn1.ASN1Object = function() {
            this.getLengthHexFromValue = function() {
                if (void 0 === this.hV || null == this.hV)
                    throw "this.hV is null or undefined.";
                if (this.hV.length % 2 == 1)
                    throw "value hex must be even length: n=0,v=" + this.hV;
                var t = this.hV.length / 2
                  , e = t.toString(16);
                if (e.length % 2 == 1 && (e = "0" + e),
                t < 128)
                    return e;
                var i = e.length / 2;
                if (i > 15)
                    throw "ASN.1 length too long to represent by 8x: n = " + t.toString(16);
                return (128 + i).toString(16) + e
            }
            ,
            this.getEncodedHex = function() {
                return (null == this.hTLV || this.isModified) && (this.hV = this.getFreshValueHex(),
                this.hL = this.getLengthHexFromValue(),
                this.hTLV = this.hT + this.hL + this.hV,
                this.isModified = !1),
                this.hTLV
            }
            ,
            this.getValueHex = function() {
                return this.getEncodedHex(),
                this.hV
            }
            ,
            this.getFreshValueHex = function() {
                return ""
            }
        }
        ,
        L.asn1.DERAbstractString = function(t) {
            L.asn1.DERAbstractString.superclass.constructor.call(this);
            this.getString = function() {
                return this.s
            }
            ,
            this.setString = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.s = t,
                this.hV = stohex(this.s)
            }
            ,
            this.setStringHex = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.s = null,
                this.hV = t
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && ("string" == typeof t ? this.setString(t) : void 0 !== t.str ? this.setString(t.str) : void 0 !== t.hex && this.setStringHex(t.hex))
        }
        ,
        D.lang.extend(L.asn1.DERAbstractString, L.asn1.ASN1Object),
        L.asn1.DERAbstractTime = function(t) {
            L.asn1.DERAbstractTime.superclass.constructor.call(this);
            this.localDateToUTC = function(t) {
                return utc = t.getTime() + 6e4 * t.getTimezoneOffset(),
                new Date(utc)
            }
            ,
            this.formatDate = function(t, e, i) {
                var n = this.zeroPadding
                  , r = this.localDateToUTC(t)
                  , o = String(r.getFullYear());
                "utc" == e && (o = o.substr(2, 2));
                var s = o + n(String(r.getMonth() + 1), 2) + n(String(r.getDate()), 2) + n(String(r.getHours()), 2) + n(String(r.getMinutes()), 2) + n(String(r.getSeconds()), 2);
                if (!0 === i) {
                    var a = r.getMilliseconds();
                    if (0 != a) {
                        var l = n(String(a), 3);
                        s = s + "." + (l = l.replace(/[0]+$/, ""))
                    }
                }
                return s + "Z"
            }
            ,
            this.zeroPadding = function(t, e) {
                return t.length >= e ? t : new Array(e - t.length + 1).join("0") + t
            }
            ,
            this.getString = function() {
                return this.s
            }
            ,
            this.setString = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.s = t,
                this.hV = stohex(t)
            }
            ,
            this.setByDateValue = function(t, e, i, n, r, o) {
                var s = new Date(Date.UTC(t, e - 1, i, n, r, o, 0));
                this.setByDate(s)
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
        }
        ,
        D.lang.extend(L.asn1.DERAbstractTime, L.asn1.ASN1Object),
        L.asn1.DERAbstractStructured = function(t) {
            L.asn1.DERAbstractString.superclass.constructor.call(this);
            this.setByASN1ObjectArray = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.asn1Array = t
            }
            ,
            this.appendASN1Object = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.asn1Array.push(t)
            }
            ,
            this.asn1Array = new Array,
            void 0 !== t && void 0 !== t.array && (this.asn1Array = t.array)
        }
        ,
        D.lang.extend(L.asn1.DERAbstractStructured, L.asn1.ASN1Object),
        L.asn1.DERBoolean = function() {
            L.asn1.DERBoolean.superclass.constructor.call(this),
            this.hT = "01",
            this.hTLV = "0101ff"
        }
        ,
        D.lang.extend(L.asn1.DERBoolean, L.asn1.ASN1Object),
        L.asn1.DERInteger = function(t) {
            L.asn1.DERInteger.superclass.constructor.call(this),
            this.hT = "02",
            this.setByBigInteger = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.hV = L.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)
            }
            ,
            this.setByInteger = function(t) {
                var e = new x.Jh(String(t),10);
                this.setByBigInteger(e)
            }
            ,
            this.setValueHex = function(t) {
                this.hV = t
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && (void 0 !== t.bigint ? this.setByBigInteger(t.bigint) : void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex))
        }
        ,
        D.lang.extend(L.asn1.DERInteger, L.asn1.ASN1Object),
        L.asn1.DERBitString = function(t) {
            if (void 0 !== t && void 0 !== t.obj) {
                var e = L.asn1.ASN1Util.newObject(t.obj);
                t.hex = "00" + e.getEncodedHex()
            }
            L.asn1.DERBitString.superclass.constructor.call(this),
            this.hT = "03",
            this.setHexValueIncludingUnusedBits = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.hV = t
            }
            ,
            this.setUnusedBitsAndHexValue = function(t, e) {
                if (t < 0 || 7 < t)
                    throw "unused bits shall be from 0 to 7: u = " + t;
                var i = "0" + t;
                this.hTLV = null,
                this.isModified = !0,
                this.hV = i + e
            }
            ,
            this.setByBinaryString = function(t) {
                var e = 8 - (t = t.replace(/0+$/, "")).length % 8;
                8 == e && (e = 0);
                for (var i = 0; i <= e; i++)
                    t += "0";
                var n = "";
                for (i = 0; i < t.length - 1; i += 8) {
                    var r = t.substr(i, 8)
                      , o = parseInt(r, 2).toString(16);
                    1 == o.length && (o = "0" + o),
                    n += o
                }
                this.hTLV = null,
                this.isModified = !0,
                this.hV = "0" + e + n
            }
            ,
            this.setByBooleanArray = function(t) {
                for (var e = "", i = 0; i < t.length; i++)
                    1 == t[i] ? e += "1" : e += "0";
                this.setByBinaryString(e)
            }
            ,
            this.newFalseArray = function(t) {
                for (var e = new Array(t), i = 0; i < t; i++)
                    e[i] = !1;
                return e
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && ("string" == typeof t && t.toLowerCase().match(/^[0-9a-f]+$/) ? this.setHexValueIncludingUnusedBits(t) : void 0 !== t.hex ? this.setHexValueIncludingUnusedBits(t.hex) : void 0 !== t.bin ? this.setByBinaryString(t.bin) : void 0 !== t.array && this.setByBooleanArray(t.array))
        }
        ,
        D.lang.extend(L.asn1.DERBitString, L.asn1.ASN1Object),
        L.asn1.DEROctetString = function(t) {
            if (void 0 !== t && void 0 !== t.obj) {
                var e = L.asn1.ASN1Util.newObject(t.obj);
                t.hex = e.getEncodedHex()
            }
            L.asn1.DEROctetString.superclass.constructor.call(this, t),
            this.hT = "04"
        }
        ,
        D.lang.extend(L.asn1.DEROctetString, L.asn1.DERAbstractString),
        L.asn1.DERNull = function() {
            L.asn1.DERNull.superclass.constructor.call(this),
            this.hT = "05",
            this.hTLV = "0500"
        }
        ,
        D.lang.extend(L.asn1.DERNull, L.asn1.ASN1Object),
        L.asn1.DERObjectIdentifier = function(t) {
            var e = function(t) {
                var e = t.toString(16);
                return 1 == e.length && (e = "0" + e),
                e
            }
              , i = function(t) {
                var i = ""
                  , n = new x.Jh(t,10).toString(2)
                  , r = 7 - n.length % 7;
                7 == r && (r = 0);
                for (var o = "", s = 0; s < r; s++)
                    o += "0";
                n = o + n;
                for (s = 0; s < n.length - 1; s += 7) {
                    var a = n.substr(s, 7);
                    s != n.length - 7 && (a = "1" + a),
                    i += e(parseInt(a, 2))
                }
                return i
            };
            L.asn1.DERObjectIdentifier.superclass.constructor.call(this),
            this.hT = "06",
            this.setValueHex = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.s = null,
                this.hV = t
            }
            ,
            this.setValueOidString = function(t) {
                if (!t.match(/^[0-9.]+$/))
                    throw "malformed oid string: " + t;
                var n = ""
                  , r = t.split(".")
                  , o = 40 * parseInt(r[0]) + parseInt(r[1]);
                n += e(o),
                r.splice(0, 2);
                for (var s = 0; s < r.length; s++)
                    n += i(r[s]);
                this.hTLV = null,
                this.isModified = !0,
                this.s = null,
                this.hV = n
            }
            ,
            this.setValueName = function(t) {
                var e = L.asn1.x509.OID.name2oid(t);
                if ("" === e)
                    throw "DERObjectIdentifier oidName undefined: " + t;
                this.setValueOidString(e)
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && ("string" == typeof t ? t.match(/^[0-2].[0-9.]+$/) ? this.setValueOidString(t) : this.setValueName(t) : void 0 !== t.oid ? this.setValueOidString(t.oid) : void 0 !== t.hex ? this.setValueHex(t.hex) : void 0 !== t.name && this.setValueName(t.name))
        }
        ,
        D.lang.extend(L.asn1.DERObjectIdentifier, L.asn1.ASN1Object),
        L.asn1.DEREnumerated = function(t) {
            L.asn1.DEREnumerated.superclass.constructor.call(this),
            this.hT = "0a",
            this.setByBigInteger = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.hV = L.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)
            }
            ,
            this.setByInteger = function(t) {
                var e = new x.Jh(String(t),10);
                this.setByBigInteger(e)
            }
            ,
            this.setValueHex = function(t) {
                this.hV = t
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && (void 0 !== t.int ? this.setByInteger(t.int) : "number" == typeof t ? this.setByInteger(t) : void 0 !== t.hex && this.setValueHex(t.hex))
        }
        ,
        D.lang.extend(L.asn1.DEREnumerated, L.asn1.ASN1Object),
        L.asn1.DERUTF8String = function(t) {
            L.asn1.DERUTF8String.superclass.constructor.call(this, t),
            this.hT = "0c"
        }
        ,
        D.lang.extend(L.asn1.DERUTF8String, L.asn1.DERAbstractString),
        L.asn1.DERNumericString = function(t) {
            L.asn1.DERNumericString.superclass.constructor.call(this, t),
            this.hT = "12"
        }
        ,
        D.lang.extend(L.asn1.DERNumericString, L.asn1.DERAbstractString),
        L.asn1.DERPrintableString = function(t) {
            L.asn1.DERPrintableString.superclass.constructor.call(this, t),
            this.hT = "13"
        }
        ,
        D.lang.extend(L.asn1.DERPrintableString, L.asn1.DERAbstractString),
        L.asn1.DERTeletexString = function(t) {
            L.asn1.DERTeletexString.superclass.constructor.call(this, t),
            this.hT = "14"
        }
        ,
        D.lang.extend(L.asn1.DERTeletexString, L.asn1.DERAbstractString),
        L.asn1.DERIA5String = function(t) {
            L.asn1.DERIA5String.superclass.constructor.call(this, t),
            this.hT = "16"
        }
        ,
        D.lang.extend(L.asn1.DERIA5String, L.asn1.DERAbstractString),
        L.asn1.DERUTCTime = function(t) {
            L.asn1.DERUTCTime.superclass.constructor.call(this, t),
            this.hT = "17",
            this.setByDate = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.date = t,
                this.s = this.formatDate(this.date, "utc"),
                this.hV = stohex(this.s)
            }
            ,
            this.getFreshValueHex = function() {
                return void 0 === this.date && void 0 === this.s && (this.date = new Date,
                this.s = this.formatDate(this.date, "utc"),
                this.hV = stohex(this.s)),
                this.hV
            }
            ,
            void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{12}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date))
        }
        ,
        D.lang.extend(L.asn1.DERUTCTime, L.asn1.DERAbstractTime),
        L.asn1.DERGeneralizedTime = function(t) {
            L.asn1.DERGeneralizedTime.superclass.constructor.call(this, t),
            this.hT = "18",
            this.withMillis = !1,
            this.setByDate = function(t) {
                this.hTLV = null,
                this.isModified = !0,
                this.date = t,
                this.s = this.formatDate(this.date, "gen", this.withMillis),
                this.hV = stohex(this.s)
            }
            ,
            this.getFreshValueHex = function() {
                return void 0 === this.date && void 0 === this.s && (this.date = new Date,
                this.s = this.formatDate(this.date, "gen", this.withMillis),
                this.hV = stohex(this.s)),
                this.hV
            }
            ,
            void 0 !== t && (void 0 !== t.str ? this.setString(t.str) : "string" == typeof t && t.match(/^[0-9]{14}Z$/) ? this.setString(t) : void 0 !== t.hex ? this.setStringHex(t.hex) : void 0 !== t.date && this.setByDate(t.date),
            !0 === t.millis && (this.withMillis = !0))
        }
        ,
        D.lang.extend(L.asn1.DERGeneralizedTime, L.asn1.DERAbstractTime),
        L.asn1.DERSequence = function(t) {
            L.asn1.DERSequence.superclass.constructor.call(this, t),
            this.hT = "30",
            this.getFreshValueHex = function() {
                for (var t = "", e = 0; e < this.asn1Array.length; e++) {
                    t += this.asn1Array[e].getEncodedHex()
                }
                return this.hV = t,
                this.hV
            }
        }
        ,
        D.lang.extend(L.asn1.DERSequence, L.asn1.DERAbstractStructured),
        L.asn1.DERSet = function(t) {
            L.asn1.DERSet.superclass.constructor.call(this, t),
            this.hT = "31",
            this.sortFlag = !0,
            this.getFreshValueHex = function() {
                for (var t = new Array, e = 0; e < this.asn1Array.length; e++) {
                    var i = this.asn1Array[e];
                    t.push(i.getEncodedHex())
                }
                return 1 == this.sortFlag && t.sort(),
                this.hV = t.join(""),
                this.hV
            }
            ,
            void 0 !== t && void 0 !== t.sortflag && 0 == t.sortflag && (this.sortFlag = !1)
        }
        ,
        D.lang.extend(L.asn1.DERSet, L.asn1.DERAbstractStructured),
        L.asn1.DERTaggedObject = function(t) {
            L.asn1.DERTaggedObject.superclass.constructor.call(this),
            this.hT = "a0",
            this.hV = "",
            this.isExplicit = !0,
            this.asn1Object = null,
            this.setASN1Object = function(t, e, i) {
                this.hT = e,
                this.isExplicit = t,
                this.asn1Object = i,
                this.isExplicit ? (this.hV = this.asn1Object.getEncodedHex(),
                this.hTLV = null,
                this.isModified = !0) : (this.hV = null,
                this.hTLV = i.getEncodedHex(),
                this.hTLV = this.hTLV.replace(/^../, e),
                this.isModified = !1)
            }
            ,
            this.getFreshValueHex = function() {
                return this.hV
            }
            ,
            void 0 !== t && (void 0 !== t.tag && (this.hT = t.tag),
            void 0 !== t.explicit && (this.isExplicit = t.explicit),
            void 0 !== t.obj && (this.asn1Object = t.obj,
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object)))
        }
        ,
        D.lang.extend(L.asn1.DERTaggedObject, L.asn1.ASN1Object);
        var B, z, F = (B = function(t, e) {
            return B = Object.setPrototypeOf || {
                __proto__: []
            }instanceof Array && function(t, e) {
                t.__proto__ = e
            }
            || function(t, e) {
                for (var i in e)
                    Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i])
            }
            ,
            B(t, e)
        }
        ,
        function(t, e) {
            if ("function" != typeof e && null !== e)
                throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
            function i() {
                this.constructor = t
            }
            B(t, e),
            t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype,
            new i)
        }
        ), N = function(t) {
            function e(i) {
                var n = t.call(this) || this;
                return i && ("string" == typeof i ? n.parseKey(i) : (e.hasPrivateKeyProperty(i) || e.hasPublicKeyProperty(i)) && n.parsePropertiesFrom(i)),
                n
            }
            return F(e, t),
            e.prototype.parseKey = function(t) {
                try {
                    var e = 0
                      , i = 0
                      , n = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/.test(t) ? h(t) : u.unarmor(t)
                      , r = y.decode(n);
                    if (3 === r.sub.length && (r = r.sub[2].sub[0]),
                    9 === r.sub.length) {
                        e = r.sub[1].getHexStringValue(),
                        this.n = (0,
                        x.BF)(e, 16),
                        i = r.sub[2].getHexStringValue(),
                        this.e = parseInt(i, 16);
                        var o = r.sub[3].getHexStringValue();
                        this.d = (0,
                        x.BF)(o, 16);
                        var s = r.sub[4].getHexStringValue();
                        this.p = (0,
                        x.BF)(s, 16);
                        var a = r.sub[5].getHexStringValue();
                        this.q = (0,
                        x.BF)(a, 16);
                        var l = r.sub[6].getHexStringValue();
                        this.dmp1 = (0,
                        x.BF)(l, 16);
                        var c = r.sub[7].getHexStringValue();
                        this.dmq1 = (0,
                        x.BF)(c, 16);
                        var d = r.sub[8].getHexStringValue();
                        this.coeff = (0,
                        x.BF)(d, 16)
                    } else {
                        if (2 !== r.sub.length)
                            return !1;
                        if (r.sub[0].sub) {
                            var f = r.sub[1].sub[0];
                            e = f.sub[0].getHexStringValue(),
                            this.n = (0,
                            x.BF)(e, 16),
                            i = f.sub[1].getHexStringValue(),
                            this.e = parseInt(i, 16)
                        } else
                            e = r.sub[0].getHexStringValue(),
                            this.n = (0,
                            x.BF)(e, 16),
                            i = r.sub[1].getHexStringValue(),
                            this.e = parseInt(i, 16)
                    }
                    return !0
                } catch (t) {
                    return !1
                }
            }
            ,
            e.prototype.getPrivateBaseKey = function() {
                var t = {
                    array: [new L.asn1.DERInteger({
                        int: 0
                    }), new L.asn1.DERInteger({
                        bigint: this.n
                    }), new L.asn1.DERInteger({
                        int: this.e
                    }), new L.asn1.DERInteger({
                        bigint: this.d
                    }), new L.asn1.DERInteger({
                        bigint: this.p
                    }), new L.asn1.DERInteger({
                        bigint: this.q
                    }), new L.asn1.DERInteger({
                        bigint: this.dmp1
                    }), new L.asn1.DERInteger({
                        bigint: this.dmq1
                    }), new L.asn1.DERInteger({
                        bigint: this.coeff
                    })]
                };
                return new L.asn1.DERSequence(t).getEncodedHex()
            }
            ,
            e.prototype.getPrivateBaseKeyB64 = function() {
                return a(this.getPrivateBaseKey())
            }
            ,
            e.prototype.getPublicBaseKey = function() {
                var t = new L.asn1.DERSequence({
                    array: [new L.asn1.DERObjectIdentifier({
                        oid: "1.2.840.113549.1.1.1"
                    }), new L.asn1.DERNull]
                })
                  , e = new L.asn1.DERSequence({
                    array: [new L.asn1.DERInteger({
                        bigint: this.n
                    }), new L.asn1.DERInteger({
                        int: this.e
                    })]
                })
                  , i = new L.asn1.DERBitString({
                    hex: "00" + e.getEncodedHex()
                });
                return new L.asn1.DERSequence({
                    array: [t, i]
                }).getEncodedHex()
            }
            ,
            e.prototype.getPublicBaseKeyB64 = function() {
                return a(this.getPublicBaseKey())
            }
            ,
            e.wordwrap = function(t, e) {
                if (!t)
                    return t;
                var i = "(.{1," + (e = e || 64) + "})( +|$\n?)|(.{1," + e + "})";
                return t.match(RegExp(i, "g")).join("\n")
            }
            ,
            e.prototype.getPrivateKey = function() {
                var t = "-----BEGIN RSA PRIVATE KEY-----\n";
                return t += e.wordwrap(this.getPrivateBaseKeyB64()) + "\n",
                t += "-----END RSA PRIVATE KEY-----"
            }
            ,
            e.prototype.getPublicKey = function() {
                var t = "-----BEGIN PUBLIC KEY-----\n";
                return t += e.wordwrap(this.getPublicBaseKeyB64()) + "\n",
                t += "-----END PUBLIC KEY-----"
            }
            ,
            e.hasPublicKeyProperty = function(t) {
                return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e")
            }
            ,
            e.hasPrivateKeyProperty = function(t) {
                return (t = t || {}).hasOwnProperty("n") && t.hasOwnProperty("e") && t.hasOwnProperty("d") && t.hasOwnProperty("p") && t.hasOwnProperty("q") && t.hasOwnProperty("dmp1") && t.hasOwnProperty("dmq1") && t.hasOwnProperty("coeff")
            }
            ,
            e.prototype.parsePropertiesFrom = function(t) {
                this.n = t.n,
                this.e = t.e,
                t.hasOwnProperty("d") && (this.d = t.d,
                this.p = t.p,
                this.q = t.q,
                this.dmp1 = t.dmp1,
                this.dmq1 = t.dmq1,
                this.coeff = t.coeff)
            }
            ,
            e
        }(O), j = i(34155), U = i(25108), V = void 0 !== j ? null === (z = {
            NODE_ENV: "production",
            VUE_APP_TYPE: "cloud",
            VUE_APP_MODEL: "single",
            VUE_APP_ACCESS: "normal",
            VUE_APP_ENV: "prd",
            VUE_APP_BASE_URL_KEY: "cloud_single_normal_production_prd",
            BASE_URL: "/"
        }) || void 0 === z ? void 0 : z.npm_package_version : void 0, G = function() {
            function t(t) {
                void 0 === t && (t = {}),
                t = t || {},
                this.default_key_size = t.default_key_size ? parseInt(t.default_key_size, 10) : 1024,
                this.default_public_exponent = t.default_public_exponent || "010001",
                this.log = t.log || !1,
                this.key = null
            }
            return t.prototype.setKey = function(t) {
                this.log && this.key && U.warn("A key was already set, overriding existing."),
                this.key = new N(t)
            }
            ,
            t.prototype.setPrivateKey = function(t) {
                this.setKey(t)
            }
            ,
            t.prototype.setPublicKey = function(t) {
                this.setKey(t)
            }
            ,
            t.prototype.decrypt = function(t) {
                try {
                    return this.getKey().decrypt(l(t))
                } catch (t) {
                    return !1
                }
            }
            ,
            t.prototype.encrypt = function(t) {
                try {
                    return a(this.getKey().encrypt(t))
                } catch (t) {
                    return !1
                }
            }
            ,
            t.prototype.sign = function(t, e, i) {
                try {
                    return a(this.getKey().sign(t, e, i))
                } catch (t) {
                    return !1
                }
            }
            ,
            t.prototype.verify = function(t, e, i) {
                try {
                    return this.getKey().verify(t, l(e), i)
                } catch (t) {
                    return !1
                }
            }
            ,
            t.prototype.getKey = function(t) {
                if (!this.key) {
                    if (this.key = new N,
                    t && "[object Function]" === {}.toString.call(t))
                        return void this.key.generateAsync(this.default_key_size, this.default_public_exponent, t);
                    this.key.generate(this.default_key_size, this.default_public_exponent)
                }
                return this.key
            }
            ,
            t.prototype.getPrivateKey = function() {
                return this.getKey().getPrivateKey()
            }
            ,
            t.prototype.getPrivateKeyB64 = function() {
                return this.getKey().getPrivateBaseKeyB64()
            }
            ,
            t.prototype.getPublicKey = function() {
                return this.getKey().getPublicKey()
            }
            ,
            t.prototype.getPublicKeyB64 = function() {
                return this.getKey().getPublicBaseKeyB64()
            }
            ,
            t.version = V,
            t
        }(), Z = G
    },
    42529: function(t, e, i) {
        "use strict";
        i.d(e, {
            BF: function() {
                return f
            },
            Jh: function() {
                return a
            },
            cR: function() {
                return d
            }
        });
        var n, r = i(24829), o = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], s = (1 << 26) / o[o.length - 1], a = function() {
            function t(t, e, i) {
                null != t && ("number" == typeof t ? this.fromNumber(t, e, i) : null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
            }
            return t.prototype.toString = function(t) {
                if (this.s < 0)
                    return "-" + this.negate().toString(t);
                var e;
                if (16 == t)
                    e = 4;
                else if (8 == t)
                    e = 3;
                else if (2 == t)
                    e = 1;
                else if (32 == t)
                    e = 5;
                else {
                    if (4 != t)
                        return this.toRadix(t);
                    e = 2
                }
                var i, n = (1 << e) - 1, o = !1, s = "", a = this.t, l = this.DB - a * this.DB % e;
                if (a-- > 0)
                    for (l < this.DB && (i = this[a] >> l) > 0 && (o = !0,
                    s = (0,
                    r.vL)(i)); a >= 0; )
                        l < e ? (i = (this[a] & (1 << l) - 1) << e - l,
                        i |= this[--a] >> (l += this.DB - e)) : (i = this[a] >> (l -= e) & n,
                        l <= 0 && (l += this.DB,
                        --a)),
                        i > 0 && (o = !0),
                        o && (s += (0,
                        r.vL)(i));
                return o ? s : "0"
            }
            ,
            t.prototype.negate = function() {
                var e = d();
                return t.ZERO.subTo(this, e),
                e
            }
            ,
            t.prototype.abs = function() {
                return this.s < 0 ? this.negate() : this
            }
            ,
            t.prototype.compareTo = function(t) {
                var e = this.s - t.s;
                if (0 != e)
                    return e;
                var i = this.t;
                if (0 != (e = i - t.t))
                    return this.s < 0 ? -e : e;
                for (; --i >= 0; )
                    if (0 != (e = this[i] - t[i]))
                        return e;
                return 0
            }
            ,
            t.prototype.bitLength = function() {
                return this.t <= 0 ? 0 : this.DB * (this.t - 1) + x(this[this.t - 1] ^ this.s & this.DM)
            }
            ,
            t.prototype.mod = function(e) {
                var i = d();
                return this.abs().divRemTo(e, null, i),
                this.s < 0 && i.compareTo(t.ZERO) > 0 && e.subTo(i, i),
                i
            }
            ,
            t.prototype.modPowInt = function(t, e) {
                var i;
                return i = t < 256 || e.isEven() ? new c(e) : new h(e),
                this.exp(t, i)
            }
            ,
            t.prototype.clone = function() {
                var t = d();
                return this.copyTo(t),
                t
            }
            ,
            t.prototype.intValue = function() {
                if (this.s < 0) {
                    if (1 == this.t)
                        return this[0] - this.DV;
                    if (0 == this.t)
                        return -1
                } else {
                    if (1 == this.t)
                        return this[0];
                    if (0 == this.t)
                        return 0
                }
                return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]
            }
            ,
            t.prototype.byteValue = function() {
                return 0 == this.t ? this.s : this[0] << 24 >> 24
            }
            ,
            t.prototype.shortValue = function() {
                return 0 == this.t ? this.s : this[0] << 16 >> 16
            }
            ,
            t.prototype.signum = function() {
                return this.s < 0 ? -1 : this.t <= 0 || 1 == this.t && this[0] <= 0 ? 0 : 1
            }
            ,
            t.prototype.toByteArray = function() {
                var t = this.t
                  , e = [];
                e[0] = this.s;
                var i, n = this.DB - t * this.DB % 8, r = 0;
                if (t-- > 0)
                    for (n < this.DB && (i = this[t] >> n) != (this.s & this.DM) >> n && (e[r++] = i | this.s << this.DB - n); t >= 0; )
                        n < 8 ? (i = (this[t] & (1 << n) - 1) << 8 - n,
                        i |= this[--t] >> (n += this.DB - 8)) : (i = this[t] >> (n -= 8) & 255,
                        n <= 0 && (n += this.DB,
                        --t)),
                        0 != (128 & i) && (i |= -256),
                        0 == r && (128 & this.s) != (128 & i) && ++r,
                        (r > 0 || i != this.s) && (e[r++] = i);
                return e
            }
            ,
            t.prototype.equals = function(t) {
                return 0 == this.compareTo(t)
            }
            ,
            t.prototype.min = function(t) {
                return this.compareTo(t) < 0 ? this : t
            }
            ,
            t.prototype.max = function(t) {
                return this.compareTo(t) > 0 ? this : t
            }
            ,
            t.prototype.and = function(t) {
                var e = d();
                return this.bitwiseTo(t, r.E2, e),
                e
            }
            ,
            t.prototype.or = function(t) {
                var e = d();
                return this.bitwiseTo(t, r.QL, e),
                e
            }
            ,
            t.prototype.xor = function(t) {
                var e = d();
                return this.bitwiseTo(t, r.rL, e),
                e
            }
            ,
            t.prototype.andNot = function(t) {
                var e = d();
                return this.bitwiseTo(t, r.dG, e),
                e
            }
            ,
            t.prototype.not = function() {
                for (var t = d(), e = 0; e < this.t; ++e)
                    t[e] = this.DM & ~this[e];
                return t.t = this.t,
                t.s = ~this.s,
                t
            }
            ,
            t.prototype.shiftLeft = function(t) {
                var e = d();
                return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e),
                e
            }
            ,
            t.prototype.shiftRight = function(t) {
                var e = d();
                return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e),
                e
            }
            ,
            t.prototype.getLowestSetBit = function() {
                for (var t = 0; t < this.t; ++t)
                    if (0 != this[t])
                        return t * this.DB + (0,
                        r.WP)(this[t]);
                return this.s < 0 ? this.t * this.DB : -1
            }
            ,
            t.prototype.bitCount = function() {
                for (var t = 0, e = this.s & this.DM, i = 0; i < this.t; ++i)
                    t += (0,
                    r.O2)(this[i] ^ e);
                return t
            }
            ,
            t.prototype.testBit = function(t) {
                var e = Math.floor(t / this.DB);
                return e >= this.t ? 0 != this.s : 0 != (this[e] & 1 << t % this.DB)
            }
            ,
            t.prototype.setBit = function(t) {
                return this.changeBit(t, r.QL)
            }
            ,
            t.prototype.clearBit = function(t) {
                return this.changeBit(t, r.dG)
            }
            ,
            t.prototype.flipBit = function(t) {
                return this.changeBit(t, r.rL)
            }
            ,
            t.prototype.add = function(t) {
                var e = d();
                return this.addTo(t, e),
                e
            }
            ,
            t.prototype.subtract = function(t) {
                var e = d();
                return this.subTo(t, e),
                e
            }
            ,
            t.prototype.multiply = function(t) {
                var e = d();
                return this.multiplyTo(t, e),
                e
            }
            ,
            t.prototype.divide = function(t) {
                var e = d();
                return this.divRemTo(t, e, null),
                e
            }
            ,
            t.prototype.remainder = function(t) {
                var e = d();
                return this.divRemTo(t, null, e),
                e
            }
            ,
            t.prototype.divideAndRemainder = function(t) {
                var e = d()
                  , i = d();
                return this.divRemTo(t, e, i),
                [e, i]
            }
            ,
            t.prototype.modPow = function(t, e) {
                var i, n, r = t.bitLength(), o = v(1);
                if (r <= 0)
                    return o;
                i = r < 18 ? 1 : r < 48 ? 3 : r < 144 ? 4 : r < 768 ? 5 : 6,
                n = r < 8 ? new c(e) : e.isEven() ? new u(e) : new h(e);
                var s = []
                  , a = 3
                  , l = i - 1
                  , f = (1 << i) - 1;
                if (s[1] = n.convert(this),
                i > 1) {
                    var p = d();
                    for (n.sqrTo(s[1], p); a <= f; )
                        s[a] = d(),
                        n.mulTo(p, s[a - 2], s[a]),
                        a += 2
                }
                var m, g, _ = t.t - 1, y = !0, b = d();
                for (r = x(t[_]) - 1; _ >= 0; ) {
                    for (r >= l ? m = t[_] >> r - l & f : (m = (t[_] & (1 << r + 1) - 1) << l - r,
                    _ > 0 && (m |= t[_ - 1] >> this.DB + r - l)),
                    a = i; 0 == (1 & m); )
                        m >>= 1,
                        --a;
                    if ((r -= a) < 0 && (r += this.DB,
                    --_),
                    y)
                        s[m].copyTo(o),
                        y = !1;
                    else {
                        for (; a > 1; )
                            n.sqrTo(o, b),
                            n.sqrTo(b, o),
                            a -= 2;
                        a > 0 ? n.sqrTo(o, b) : (g = o,
                        o = b,
                        b = g),
                        n.mulTo(b, s[m], o)
                    }
                    for (; _ >= 0 && 0 == (t[_] & 1 << r); )
                        n.sqrTo(o, b),
                        g = o,
                        o = b,
                        b = g,
                        --r < 0 && (r = this.DB - 1,
                        --_)
                }
                return n.revert(o)
            }
            ,
            t.prototype.modInverse = function(e) {
                var i = e.isEven();
                if (this.isEven() && i || 0 == e.signum())
                    return t.ZERO;
                for (var n = e.clone(), r = this.clone(), o = v(1), s = v(0), a = v(0), l = v(1); 0 != n.signum(); ) {
                    for (; n.isEven(); )
                        n.rShiftTo(1, n),
                        i ? (o.isEven() && s.isEven() || (o.addTo(this, o),
                        s.subTo(e, s)),
                        o.rShiftTo(1, o)) : s.isEven() || s.subTo(e, s),
                        s.rShiftTo(1, s);
                    for (; r.isEven(); )
                        r.rShiftTo(1, r),
                        i ? (a.isEven() && l.isEven() || (a.addTo(this, a),
                        l.subTo(e, l)),
                        a.rShiftTo(1, a)) : l.isEven() || l.subTo(e, l),
                        l.rShiftTo(1, l);
                    n.compareTo(r) >= 0 ? (n.subTo(r, n),
                    i && o.subTo(a, o),
                    s.subTo(l, s)) : (r.subTo(n, r),
                    i && a.subTo(o, a),
                    l.subTo(s, l))
                }
                return 0 != r.compareTo(t.ONE) ? t.ZERO : l.compareTo(e) >= 0 ? l.subtract(e) : l.signum() < 0 ? (l.addTo(e, l),
                l.signum() < 0 ? l.add(e) : l) : l
            }
            ,
            t.prototype.pow = function(t) {
                return this.exp(t, new l)
            }
            ,
            t.prototype.gcd = function(t) {
                var e = this.s < 0 ? this.negate() : this.clone()
                  , i = t.s < 0 ? t.negate() : t.clone();
                if (e.compareTo(i) < 0) {
                    var n = e;
                    e = i,
                    i = n
                }
                var r = e.getLowestSetBit()
                  , o = i.getLowestSetBit();
                if (o < 0)
                    return e;
                for (r < o && (o = r),
                o > 0 && (e.rShiftTo(o, e),
                i.rShiftTo(o, i)); e.signum() > 0; )
                    (r = e.getLowestSetBit()) > 0 && e.rShiftTo(r, e),
                    (r = i.getLowestSetBit()) > 0 && i.rShiftTo(r, i),
                    e.compareTo(i) >= 0 ? (e.subTo(i, e),
                    e.rShiftTo(1, e)) : (i.subTo(e, i),
                    i.rShiftTo(1, i));
                return o > 0 && i.lShiftTo(o, i),
                i
            }
            ,
            t.prototype.isProbablePrime = function(t) {
                var e, i = this.abs();
                if (1 == i.t && i[0] <= o[o.length - 1]) {
                    for (e = 0; e < o.length; ++e)
                        if (i[0] == o[e])
                            return !0;
                    return !1
                }
                if (i.isEven())
                    return !1;
                for (e = 1; e < o.length; ) {
                    for (var n = o[e], r = e + 1; r < o.length && n < s; )
                        n *= o[r++];
                    for (n = i.modInt(n); e < r; )
                        if (n % o[e++] == 0)
                            return !1
                }
                return i.millerRabin(t)
            }
            ,
            t.prototype.copyTo = function(t) {
                for (var e = this.t - 1; e >= 0; --e)
                    t[e] = this[e];
                t.t = this.t,
                t.s = this.s
            }
            ,
            t.prototype.fromInt = function(t) {
                this.t = 1,
                this.s = t < 0 ? -1 : 0,
                t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0
            }
            ,
            t.prototype.fromString = function(e, i) {
                var n;
                if (16 == i)
                    n = 4;
                else if (8 == i)
                    n = 3;
                else if (256 == i)
                    n = 8;
                else if (2 == i)
                    n = 1;
                else if (32 == i)
                    n = 5;
                else {
                    if (4 != i)
                        return void this.fromRadix(e, i);
                    n = 2
                }
                this.t = 0,
                this.s = 0;
                for (var r = e.length, o = !1, s = 0; --r >= 0; ) {
                    var a = 8 == n ? 255 & +e[r] : y(e, r);
                    a < 0 ? "-" == e.charAt(r) && (o = !0) : (o = !1,
                    0 == s ? this[this.t++] = a : s + n > this.DB ? (this[this.t - 1] |= (a & (1 << this.DB - s) - 1) << s,
                    this[this.t++] = a >> this.DB - s) : this[this.t - 1] |= a << s,
                    (s += n) >= this.DB && (s -= this.DB))
                }
                8 == n && 0 != (128 & +e[0]) && (this.s = -1,
                s > 0 && (this[this.t - 1] |= (1 << this.DB - s) - 1 << s)),
                this.clamp(),
                o && t.ZERO.subTo(this, this)
            }
            ,
            t.prototype.clamp = function() {
                for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t; )
                    --this.t
            }
            ,
            t.prototype.dlShiftTo = function(t, e) {
                var i;
                for (i = this.t - 1; i >= 0; --i)
                    e[i + t] = this[i];
                for (i = t - 1; i >= 0; --i)
                    e[i] = 0;
                e.t = this.t + t,
                e.s = this.s
            }
            ,
            t.prototype.drShiftTo = function(t, e) {
                for (var i = t; i < this.t; ++i)
                    e[i - t] = this[i];
                e.t = Math.max(this.t - t, 0),
                e.s = this.s
            }
            ,
            t.prototype.lShiftTo = function(t, e) {
                for (var i = t % this.DB, n = this.DB - i, r = (1 << n) - 1, o = Math.floor(t / this.DB), s = this.s << i & this.DM, a = this.t - 1; a >= 0; --a)
                    e[a + o + 1] = this[a] >> n | s,
                    s = (this[a] & r) << i;
                for (a = o - 1; a >= 0; --a)
                    e[a] = 0;
                e[o] = s,
                e.t = this.t + o + 1,
                e.s = this.s,
                e.clamp()
            }
            ,
            t.prototype.rShiftTo = function(t, e) {
                e.s = this.s;
                var i = Math.floor(t / this.DB);
                if (i >= this.t)
                    e.t = 0;
                else {
                    var n = t % this.DB
                      , r = this.DB - n
                      , o = (1 << n) - 1;
                    e[0] = this[i] >> n;
                    for (var s = i + 1; s < this.t; ++s)
                        e[s - i - 1] |= (this[s] & o) << r,
                        e[s - i] = this[s] >> n;
                    n > 0 && (e[this.t - i - 1] |= (this.s & o) << r),
                    e.t = this.t - i,
                    e.clamp()
                }
            }
            ,
            t.prototype.subTo = function(t, e) {
                for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r; )
                    n += this[i] - t[i],
                    e[i++] = n & this.DM,
                    n >>= this.DB;
                if (t.t < this.t) {
                    for (n -= t.s; i < this.t; )
                        n += this[i],
                        e[i++] = n & this.DM,
                        n >>= this.DB;
                    n += this.s
                } else {
                    for (n += this.s; i < t.t; )
                        n -= t[i],
                        e[i++] = n & this.DM,
                        n >>= this.DB;
                    n -= t.s
                }
                e.s = n < 0 ? -1 : 0,
                n < -1 ? e[i++] = this.DV + n : n > 0 && (e[i++] = n),
                e.t = i,
                e.clamp()
            }
            ,
            t.prototype.multiplyTo = function(e, i) {
                var n = this.abs()
                  , r = e.abs()
                  , o = n.t;
                for (i.t = o + r.t; --o >= 0; )
                    i[o] = 0;
                for (o = 0; o < r.t; ++o)
                    i[o + n.t] = n.am(0, r[o], i, o, 0, n.t);
                i.s = 0,
                i.clamp(),
                this.s != e.s && t.ZERO.subTo(i, i)
            }
            ,
            t.prototype.squareTo = function(t) {
                for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0; )
                    t[i] = 0;
                for (i = 0; i < e.t - 1; ++i) {
                    var n = e.am(i, e[i], t, 2 * i, 0, 1);
                    (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV,
                    t[i + e.t + 1] = 1)
                }
                t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)),
                t.s = 0,
                t.clamp()
            }
            ,
            t.prototype.divRemTo = function(e, i, n) {
                var r = e.abs();
                if (!(r.t <= 0)) {
                    var o = this.abs();
                    if (o.t < r.t)
                        return null != i && i.fromInt(0),
                        void (null != n && this.copyTo(n));
                    null == n && (n = d());
                    var s = d()
                      , a = this.s
                      , l = e.s
                      , c = this.DB - x(r[r.t - 1]);
                    c > 0 ? (r.lShiftTo(c, s),
                    o.lShiftTo(c, n)) : (r.copyTo(s),
                    o.copyTo(n));
                    var h = s.t
                      , u = s[h - 1];
                    if (0 != u) {
                        var f = u * (1 << this.F1) + (h > 1 ? s[h - 2] >> this.F2 : 0)
                          , p = this.FV / f
                          , m = (1 << this.F1) / f
                          , g = 1 << this.F2
                          , _ = n.t
                          , y = _ - h
                          , v = null == i ? d() : i;
                        for (s.dlShiftTo(y, v),
                        n.compareTo(v) >= 0 && (n[n.t++] = 1,
                        n.subTo(v, n)),
                        t.ONE.dlShiftTo(h, v),
                        v.subTo(s, s); s.t < h; )
                            s[s.t++] = 0;
                        for (; --y >= 0; ) {
                            var b = n[--_] == u ? this.DM : Math.floor(n[_] * p + (n[_ - 1] + g) * m);
                            if ((n[_] += s.am(0, b, n, y, 0, h)) < b)
                                for (s.dlShiftTo(y, v),
                                n.subTo(v, n); n[_] < --b; )
                                    n.subTo(v, n)
                        }
                        null != i && (n.drShiftTo(h, i),
                        a != l && t.ZERO.subTo(i, i)),
                        n.t = h,
                        n.clamp(),
                        c > 0 && n.rShiftTo(c, n),
                        a < 0 && t.ZERO.subTo(n, n)
                    }
                }
            }
            ,
            t.prototype.invDigit = function() {
                if (this.t < 1)
                    return 0;
                var t = this[0];
                if (0 == (1 & t))
                    return 0;
                var e = 3 & t;
                return (e = (e = (e = (e = e * (2 - (15 & t) * e) & 15) * (2 - (255 & t) * e) & 255) * (2 - ((65535 & t) * e & 65535)) & 65535) * (2 - t * e % this.DV) % this.DV) > 0 ? this.DV - e : -e
            }
            ,
            t.prototype.isEven = function() {
                return 0 == (this.t > 0 ? 1 & this[0] : this.s)
            }
            ,
            t.prototype.exp = function(e, i) {
                if (e > 4294967295 || e < 1)
                    return t.ONE;
                var n = d()
                  , r = d()
                  , o = i.convert(this)
                  , s = x(e) - 1;
                for (o.copyTo(n); --s >= 0; )
                    if (i.sqrTo(n, r),
                    (e & 1 << s) > 0)
                        i.mulTo(r, o, n);
                    else {
                        var a = n;
                        n = r,
                        r = a
                    }
                return i.revert(n)
            }
            ,
            t.prototype.chunkSize = function(t) {
                return Math.floor(Math.LN2 * this.DB / Math.log(t))
            }
            ,
            t.prototype.toRadix = function(t) {
                if (null == t && (t = 10),
                0 == this.signum() || t < 2 || t > 36)
                    return "0";
                var e = this.chunkSize(t)
                  , i = Math.pow(t, e)
                  , n = v(i)
                  , r = d()
                  , o = d()
                  , s = "";
                for (this.divRemTo(n, r, o); r.signum() > 0; )
                    s = (i + o.intValue()).toString(t).substr(1) + s,
                    r.divRemTo(n, r, o);
                return o.intValue().toString(t) + s
            }
            ,
            t.prototype.fromRadix = function(e, i) {
                this.fromInt(0),
                null == i && (i = 10);
                for (var n = this.chunkSize(i), r = Math.pow(i, n), o = !1, s = 0, a = 0, l = 0; l < e.length; ++l) {
                    var c = y(e, l);
                    c < 0 ? "-" == e.charAt(l) && 0 == this.signum() && (o = !0) : (a = i * a + c,
                    ++s >= n && (this.dMultiply(r),
                    this.dAddOffset(a, 0),
                    s = 0,
                    a = 0))
                }
                s > 0 && (this.dMultiply(Math.pow(i, s)),
                this.dAddOffset(a, 0)),
                o && t.ZERO.subTo(this, this)
            }
            ,
            t.prototype.fromNumber = function(e, i, n) {
                if ("number" == typeof i)
                    if (e < 2)
                        this.fromInt(1);
                    else
                        for (this.fromNumber(e, n),
                        this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), r.QL, this),
                        this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(i); )
                            this.dAddOffset(2, 0),
                            this.bitLength() > e && this.subTo(t.ONE.shiftLeft(e - 1), this);
                else {
                    var o = []
                      , s = 7 & e;
                    o.length = 1 + (e >> 3),
                    i.nextBytes(o),
                    s > 0 ? o[0] &= (1 << s) - 1 : o[0] = 0,
                    this.fromString(o, 256)
                }
            }
            ,
            t.prototype.bitwiseTo = function(t, e, i) {
                var n, r, o = Math.min(t.t, this.t);
                for (n = 0; n < o; ++n)
                    i[n] = e(this[n], t[n]);
                if (t.t < this.t) {
                    for (r = t.s & this.DM,
                    n = o; n < this.t; ++n)
                        i[n] = e(this[n], r);
                    i.t = this.t
                } else {
                    for (r = this.s & this.DM,
                    n = o; n < t.t; ++n)
                        i[n] = e(r, t[n]);
                    i.t = t.t
                }
                i.s = e(this.s, t.s),
                i.clamp()
            }
            ,
            t.prototype.changeBit = function(e, i) {
                var n = t.ONE.shiftLeft(e);
                return this.bitwiseTo(n, i, n),
                n
            }
            ,
            t.prototype.addTo = function(t, e) {
                for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r; )
                    n += this[i] + t[i],
                    e[i++] = n & this.DM,
                    n >>= this.DB;
                if (t.t < this.t) {
                    for (n += t.s; i < this.t; )
                        n += this[i],
                        e[i++] = n & this.DM,
                        n >>= this.DB;
                    n += this.s
                } else {
                    for (n += this.s; i < t.t; )
                        n += t[i],
                        e[i++] = n & this.DM,
                        n >>= this.DB;
                    n += t.s
                }
                e.s = n < 0 ? -1 : 0,
                n > 0 ? e[i++] = n : n < -1 && (e[i++] = this.DV + n),
                e.t = i,
                e.clamp()
            }
            ,
            t.prototype.dMultiply = function(t) {
                this[this.t] = this.am(0, t - 1, this, 0, 0, this.t),
                ++this.t,
                this.clamp()
            }
            ,
            t.prototype.dAddOffset = function(t, e) {
                if (0 != t) {
                    for (; this.t <= e; )
                        this[this.t++] = 0;
                    for (this[e] += t; this[e] >= this.DV; )
                        this[e] -= this.DV,
                        ++e >= this.t && (this[this.t++] = 0),
                        ++this[e]
                }
            }
            ,
            t.prototype.multiplyLowerTo = function(t, e, i) {
                var n = Math.min(this.t + t.t, e);
                for (i.s = 0,
                i.t = n; n > 0; )
                    i[--n] = 0;
                for (var r = i.t - this.t; n < r; ++n)
                    i[n + this.t] = this.am(0, t[n], i, n, 0, this.t);
                for (r = Math.min(t.t, e); n < r; ++n)
                    this.am(0, t[n], i, n, 0, e - n);
                i.clamp()
            }
            ,
            t.prototype.multiplyUpperTo = function(t, e, i) {
                --e;
                var n = i.t = this.t + t.t - e;
                for (i.s = 0; --n >= 0; )
                    i[n] = 0;
                for (n = Math.max(e - this.t, 0); n < t.t; ++n)
                    i[this.t + n - e] = this.am(e - n, t[n], i, 0, 0, this.t + n - e);
                i.clamp(),
                i.drShiftTo(1, i)
            }
            ,
            t.prototype.modInt = function(t) {
                if (t <= 0)
                    return 0;
                var e = this.DV % t
                  , i = this.s < 0 ? t - 1 : 0;
                if (this.t > 0)
                    if (0 == e)
                        i = this[0] % t;
                    else
                        for (var n = this.t - 1; n >= 0; --n)
                            i = (e * i + this[n]) % t;
                return i
            }
            ,
            t.prototype.millerRabin = function(e) {
                var i = this.subtract(t.ONE)
                  , n = i.getLowestSetBit();
                if (n <= 0)
                    return !1;
                var r = i.shiftRight(n);
                (e = e + 1 >> 1) > o.length && (e = o.length);
                for (var s = d(), a = 0; a < e; ++a) {
                    s.fromInt(o[Math.floor(Math.random() * o.length)]);
                    var l = s.modPow(r, this);
                    if (0 != l.compareTo(t.ONE) && 0 != l.compareTo(i)) {
                        for (var c = 1; c++ < n && 0 != l.compareTo(i); )
                            if (0 == (l = l.modPowInt(2, this)).compareTo(t.ONE))
                                return !1;
                        if (0 != l.compareTo(i))
                            return !1
                    }
                }
                return !0
            }
            ,
            t.prototype.square = function() {
                var t = d();
                return this.squareTo(t),
                t
            }
            ,
            t.prototype.gcda = function(t, e) {
                var i = this.s < 0 ? this.negate() : this.clone()
                  , n = t.s < 0 ? t.negate() : t.clone();
                if (i.compareTo(n) < 0) {
                    var r = i;
                    i = n,
                    n = r
                }
                var o = i.getLowestSetBit()
                  , s = n.getLowestSetBit();
                if (s < 0)
                    e(i);
                else {
                    o < s && (s = o),
                    s > 0 && (i.rShiftTo(s, i),
                    n.rShiftTo(s, n));
                    var a = function() {
                        (o = i.getLowestSetBit()) > 0 && i.rShiftTo(o, i),
                        (o = n.getLowestSetBit()) > 0 && n.rShiftTo(o, n),
                        i.compareTo(n) >= 0 ? (i.subTo(n, i),
                        i.rShiftTo(1, i)) : (n.subTo(i, n),
                        n.rShiftTo(1, n)),
                        i.signum() > 0 ? setTimeout(a, 0) : (s > 0 && n.lShiftTo(s, n),
                        setTimeout((function() {
                            e(n)
                        }
                        ), 0))
                    };
                    setTimeout(a, 10)
                }
            }
            ,
            t.prototype.fromNumberAsync = function(e, i, n, o) {
                if ("number" == typeof i)
                    if (e < 2)
                        this.fromInt(1);
                    else {
                        this.fromNumber(e, n),
                        this.testBit(e - 1) || this.bitwiseTo(t.ONE.shiftLeft(e - 1), r.QL, this),
                        this.isEven() && this.dAddOffset(1, 0);
                        var s = this
                          , a = function() {
                            s.dAddOffset(2, 0),
                            s.bitLength() > e && s.subTo(t.ONE.shiftLeft(e - 1), s),
                            s.isProbablePrime(i) ? setTimeout((function() {
                                o()
                            }
                            ), 0) : setTimeout(a, 0)
                        };
                        setTimeout(a, 0)
                    }
                else {
                    var l = []
                      , c = 7 & e;
                    l.length = 1 + (e >> 3),
                    i.nextBytes(l),
                    c > 0 ? l[0] &= (1 << c) - 1 : l[0] = 0,
                    this.fromString(l, 256)
                }
            }
            ,
            t
        }(), l = function() {
            function t() {}
            return t.prototype.convert = function(t) {
                return t
            }
            ,
            t.prototype.revert = function(t) {
                return t
            }
            ,
            t.prototype.mulTo = function(t, e, i) {
                t.multiplyTo(e, i)
            }
            ,
            t.prototype.sqrTo = function(t, e) {
                t.squareTo(e)
            }
            ,
            t
        }(), c = function() {
            function t(t) {
                this.m = t
            }
            return t.prototype.convert = function(t) {
                return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
            }
            ,
            t.prototype.revert = function(t) {
                return t
            }
            ,
            t.prototype.reduce = function(t) {
                t.divRemTo(this.m, null, t)
            }
            ,
            t.prototype.mulTo = function(t, e, i) {
                t.multiplyTo(e, i),
                this.reduce(i)
            }
            ,
            t.prototype.sqrTo = function(t, e) {
                t.squareTo(e),
                this.reduce(e)
            }
            ,
            t
        }(), h = function() {
            function t(t) {
                this.m = t,
                this.mp = t.invDigit(),
                this.mpl = 32767 & this.mp,
                this.mph = this.mp >> 15,
                this.um = (1 << t.DB - 15) - 1,
                this.mt2 = 2 * t.t
            }
            return t.prototype.convert = function(t) {
                var e = d();
                return t.abs().dlShiftTo(this.m.t, e),
                e.divRemTo(this.m, null, e),
                t.s < 0 && e.compareTo(a.ZERO) > 0 && this.m.subTo(e, e),
                e
            }
            ,
            t.prototype.revert = function(t) {
                var e = d();
                return t.copyTo(e),
                this.reduce(e),
                e
            }
            ,
            t.prototype.reduce = function(t) {
                for (; t.t <= this.mt2; )
                    t[t.t++] = 0;
                for (var e = 0; e < this.m.t; ++e) {
                    var i = 32767 & t[e]
                      , n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                    for (t[i = e + this.m.t] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV; )
                        t[i] -= t.DV,
                        t[++i]++
                }
                t.clamp(),
                t.drShiftTo(this.m.t, t),
                t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
            }
            ,
            t.prototype.mulTo = function(t, e, i) {
                t.multiplyTo(e, i),
                this.reduce(i)
            }
            ,
            t.prototype.sqrTo = function(t, e) {
                t.squareTo(e),
                this.reduce(e)
            }
            ,
            t
        }(), u = function() {
            function t(t) {
                this.m = t,
                this.r2 = d(),
                this.q3 = d(),
                a.ONE.dlShiftTo(2 * t.t, this.r2),
                this.mu = this.r2.divide(t)
            }
            return t.prototype.convert = function(t) {
                if (t.s < 0 || t.t > 2 * this.m.t)
                    return t.mod(this.m);
                if (t.compareTo(this.m) < 0)
                    return t;
                var e = d();
                return t.copyTo(e),
                this.reduce(e),
                e
            }
            ,
            t.prototype.revert = function(t) {
                return t
            }
            ,
            t.prototype.reduce = function(t) {
                for (t.drShiftTo(this.m.t - 1, this.r2),
                t.t > this.m.t + 1 && (t.t = this.m.t + 1,
                t.clamp()),
                this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
                this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0; )
                    t.dAddOffset(1, this.m.t + 1);
                for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; )
                    t.subTo(this.m, t)
            }
            ,
            t.prototype.mulTo = function(t, e, i) {
                t.multiplyTo(e, i),
                this.reduce(i)
            }
            ,
            t.prototype.sqrTo = function(t, e) {
                t.squareTo(e),
                this.reduce(e)
            }
            ,
            t
        }();
        function d() {
            return new a(null)
        }
        function f(t, e) {
            return new a(t,e)
        }
        var p = "undefined" != typeof navigator;
        p && "Microsoft Internet Explorer" == navigator.appName ? (a.prototype.am = function(t, e, i, n, r, o) {
            for (var s = 32767 & e, a = e >> 15; --o >= 0; ) {
                var l = 32767 & this[t]
                  , c = this[t++] >> 15
                  , h = a * l + c * s;
                r = ((l = s * l + ((32767 & h) << 15) + i[n] + (1073741823 & r)) >>> 30) + (h >>> 15) + a * c + (r >>> 30),
                i[n++] = 1073741823 & l
            }
            return r
        }
        ,
        n = 30) : p && "Netscape" != navigator.appName ? (a.prototype.am = function(t, e, i, n, r, o) {
            for (; --o >= 0; ) {
                var s = e * this[t++] + i[n] + r;
                r = Math.floor(s / 67108864),
                i[n++] = 67108863 & s
            }
            return r
        }
        ,
        n = 26) : (a.prototype.am = function(t, e, i, n, r, o) {
            for (var s = 16383 & e, a = e >> 14; --o >= 0; ) {
                var l = 16383 & this[t]
                  , c = this[t++] >> 14
                  , h = a * l + c * s;
                r = ((l = s * l + ((16383 & h) << 14) + i[n] + r) >> 28) + (h >> 14) + a * c,
                i[n++] = 268435455 & l
            }
            return r
        }
        ,
        n = 28),
        a.prototype.DB = n,
        a.prototype.DM = (1 << n) - 1,
        a.prototype.DV = 1 << n;
        a.prototype.FV = Math.pow(2, 52),
        a.prototype.F1 = 52 - n,
        a.prototype.F2 = 2 * n - 52;
        var m, g, _ = [];
        for (m = "0".charCodeAt(0),
        g = 0; g <= 9; ++g)
            _[m++] = g;
        for (m = "a".charCodeAt(0),
        g = 10; g < 36; ++g)
            _[m++] = g;
        for (m = "A".charCodeAt(0),
        g = 10; g < 36; ++g)
            _[m++] = g;
        function y(t, e) {
            var i = _[t.charCodeAt(e)];
            return null == i ? -1 : i
        }
        function v(t) {
            var e = d();
            return e.fromInt(t),
            e
        }
        function x(t) {
            var e, i = 1;
            return 0 != (e = t >>> 16) && (t = e,
            i += 16),
            0 != (e = t >> 8) && (t = e,
            i += 8),
            0 != (e = t >> 4) && (t = e,
            i += 4),
            0 != (e = t >> 2) && (t = e,
            i += 2),
            0 != (e = t >> 1) && (t = e,
            i += 1),
            i
        }
        a.ZERO = v(0),
        a.ONE = v(1)
    },
    24829: function(t, e, i) {
        "use strict";
        i.d(e, {
            E2: function() {
                return o
            },
            O2: function() {
                return h
            },
            QL: function() {
                return s
            },
            WP: function() {
                return c
            },
            dG: function() {
                return l
            },
            rL: function() {
                return a
            },
            vL: function() {
                return r
            }
        });
        var n = "0123456789abcdefghijklmnopqrstuvwxyz";
        function r(t) {
            return n.charAt(t)
        }
        function o(t, e) {
            return t & e
        }
        function s(t, e) {
            return t | e
        }
        function a(t, e) {
            return t ^ e
        }
        function l(t, e) {
            return t & ~e
        }
        function c(t) {
            if (0 == t)
                return -1;
            var e = 0;
            return 0 == (65535 & t) && (t >>= 16,
            e += 16),
            0 == (255 & t) && (t >>= 8,
            e += 8),
            0 == (15 & t) && (t >>= 4,
            e += 4),
            0 == (3 & t) && (t >>= 2,
            e += 2),
            0 == (1 & t) && ++e,
            e
        }
        function h(t) {
            for (var e = 0; 0 != t; )
                t &= t - 1,
                ++e;
            return e
        }
    },
    6158: function(t, e, i) {
        var n = i(25108);
        t.exports = function() {
            "use strict";
            var t, e, i;
            function r(n, r) {
                if (t)
                    if (e) {
                        var o = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + t + ")(sharedChunk); (" + e + ")(sharedChunk); self.onerror = null;"
                          , s = {};
                        t(s),
                        i = r(s),
                        "undefined" != typeof window && window && window.URL && window.URL.createObjectURL && (i.workerUrl = window.URL.createObjectURL(new Blob([o],{
                            type: "text/javascript"
                        })))
                    } else
                        e = r;
                else
                    t = r
            }
            return r(["exports"], (function(t) {
                var e = "undefined" != typeof self ? self : {}
                  , i = "2.15.0";
                let r;
                const o = {
                    API_URL: "https://api.mapbox.com",
                    get API_URL_REGEX() {
                        if (null == r) {
                            const t = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
                            try {
                                r = null != {
                                    NODE_ENV: "production",
                                    VUE_APP_TYPE: "cloud",
                                    VUE_APP_MODEL: "single",
                                    VUE_APP_ACCESS: "normal",
                                    VUE_APP_ENV: "prd",
                                    VUE_APP_BASE_URL_KEY: "cloud_single_normal_production_prd",
                                    BASE_URL: "/"
                                }.API_URL_REGEX ? new RegExp({
                                    NODE_ENV: "production",
                                    VUE_APP_TYPE: "cloud",
                                    VUE_APP_MODEL: "single",
                                    VUE_APP_ACCESS: "normal",
                                    VUE_APP_ENV: "prd",
                                    VUE_APP_BASE_URL_KEY: "cloud_single_normal_production_prd",
                                    BASE_URL: "/"
                                }.API_URL_REGEX) : t
                            } catch (e) {
                                r = t
                            }
                        }
                        return r
                    },
                    get API_TILEJSON_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i
                    },
                    get API_SPRITE_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i
                    },
                    get API_FONTS_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i
                    },
                    get API_STYLE_REGEX() {
                        return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i
                    },
                    get API_CDN_URL_REGEX() {
                        return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i
                    },
                    get EVENTS_URL() {
                        if (!o.API_URL)
                            return null;
                        try {
                            const t = new URL(o.API_URL);
                            return "api.mapbox.cn" === t.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t.hostname ? "https://events.mapbox.com/events/v2" : null
                        } catch (t) {
                            return null
                        }
                    },
                    SESSION_PATH: "/map-sessions/v1",
                    FEEDBACK_URL: "https://apps.mapbox.com/feedback",
                    TILE_URL_VERSION: "v4",
                    RASTER_URL_PREFIX: "raster/v1",
                    REQUIRE_ACCESS_TOKEN: !0,
                    ACCESS_TOKEN: null,
                    MAX_PARALLEL_IMAGE_REQUESTS: 16
                }
                  , s = {
                    supported: !1,
                    testSupport: function(t) {
                        !c && l && (h ? u(t) : a = t)
                    }
                };
                let a, l, c = !1, h = !1;
                function u(t) {
                    const e = t.createTexture();
                    t.bindTexture(t.TEXTURE_2D, e);
                    try {
                        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, l),
                        t.isContextLost())
                            return;
                        s.supported = !0
                    } catch (t) {}
                    t.deleteTexture(e),
                    c = !0
                }
                e.document && (l = e.document.createElement("img"),
                l.onload = function() {
                    a && u(a),
                    a = null,
                    h = !0
                }
                ,
                l.onerror = function() {
                    c = !0,
                    a = null
                }
                ,
                l.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
                const d = "01";
                function f(t) {
                    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
                }
                var p = m;
                function m(t, e, i, n) {
                    this.cx = 3 * t,
                    this.bx = 3 * (i - t) - this.cx,
                    this.ax = 1 - this.cx - this.bx,
                    this.cy = 3 * e,
                    this.by = 3 * (n - e) - this.cy,
                    this.ay = 1 - this.cy - this.by,
                    this.p1x = t,
                    this.p1y = e,
                    this.p2x = i,
                    this.p2y = n
                }
                m.prototype = {
                    sampleCurveX: function(t) {
                        return ((this.ax * t + this.bx) * t + this.cx) * t
                    },
                    sampleCurveY: function(t) {
                        return ((this.ay * t + this.by) * t + this.cy) * t
                    },
                    sampleCurveDerivativeX: function(t) {
                        return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                    },
                    solveCurveX: function(t, e) {
                        if (void 0 === e && (e = 1e-6),
                        t < 0)
                            return 0;
                        if (t > 1)
                            return 1;
                        for (var i = t, n = 0; n < 8; n++) {
                            var r = this.sampleCurveX(i) - t;
                            if (Math.abs(r) < e)
                                return i;
                            var o = this.sampleCurveDerivativeX(i);
                            if (Math.abs(o) < 1e-6)
                                break;
                            i -= r / o
                        }
                        var s = 0
                          , a = 1;
                        for (i = t,
                        n = 0; n < 20 && (r = this.sampleCurveX(i),
                        !(Math.abs(r - t) < e)); n++)
                            t > r ? s = i : a = i,
                            i = .5 * (a - s) + s;
                        return i
                    },
                    solve: function(t, e) {
                        return this.sampleCurveY(this.solveCurveX(t, e))
                    }
                };
                var g = f(p)
                  , _ = y;
                function y(t, e) {
                    this.x = t,
                    this.y = e
                }
                y.prototype = {
                    clone: function() {
                        return new y(this.x,this.y)
                    },
                    add: function(t) {
                        return this.clone()._add(t)
                    },
                    sub: function(t) {
                        return this.clone()._sub(t)
                    },
                    multByPoint: function(t) {
                        return this.clone()._multByPoint(t)
                    },
                    divByPoint: function(t) {
                        return this.clone()._divByPoint(t)
                    },
                    mult: function(t) {
                        return this.clone()._mult(t)
                    },
                    div: function(t) {
                        return this.clone()._div(t)
                    },
                    rotate: function(t) {
                        return this.clone()._rotate(t)
                    },
                    rotateAround: function(t, e) {
                        return this.clone()._rotateAround(t, e)
                    },
                    matMult: function(t) {
                        return this.clone()._matMult(t)
                    },
                    unit: function() {
                        return this.clone()._unit()
                    },
                    perp: function() {
                        return this.clone()._perp()
                    },
                    round: function() {
                        return this.clone()._round()
                    },
                    mag: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    equals: function(t) {
                        return this.x === t.x && this.y === t.y
                    },
                    dist: function(t) {
                        return Math.sqrt(this.distSqr(t))
                    },
                    distSqr: function(t) {
                        var e = t.x - this.x
                          , i = t.y - this.y;
                        return e * e + i * i
                    },
                    angle: function() {
                        return Math.atan2(this.y, this.x)
                    },
                    angleTo: function(t) {
                        return Math.atan2(this.y - t.y, this.x - t.x)
                    },
                    angleWith: function(t) {
                        return this.angleWithSep(t.x, t.y)
                    },
                    angleWithSep: function(t, e) {
                        return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e)
                    },
                    _matMult: function(t) {
                        var e = t[2] * this.x + t[3] * this.y;
                        return this.x = t[0] * this.x + t[1] * this.y,
                        this.y = e,
                        this
                    },
                    _add: function(t) {
                        return this.x += t.x,
                        this.y += t.y,
                        this
                    },
                    _sub: function(t) {
                        return this.x -= t.x,
                        this.y -= t.y,
                        this
                    },
                    _mult: function(t) {
                        return this.x *= t,
                        this.y *= t,
                        this
                    },
                    _div: function(t) {
                        return this.x /= t,
                        this.y /= t,
                        this
                    },
                    _multByPoint: function(t) {
                        return this.x *= t.x,
                        this.y *= t.y,
                        this
                    },
                    _divByPoint: function(t) {
                        return this.x /= t.x,
                        this.y /= t.y,
                        this
                    },
                    _unit: function() {
                        return this._div(this.mag()),
                        this
                    },
                    _perp: function() {
                        var t = this.y;
                        return this.y = this.x,
                        this.x = -t,
                        this
                    },
                    _rotate: function(t) {
                        var e = Math.cos(t)
                          , i = Math.sin(t)
                          , n = i * this.x + e * this.y;
                        return this.x = e * this.x - i * this.y,
                        this.y = n,
                        this
                    },
                    _rotateAround: function(t, e) {
                        var i = Math.cos(t)
                          , n = Math.sin(t)
                          , r = e.y + n * (this.x - e.x) + i * (this.y - e.y);
                        return this.x = e.x + i * (this.x - e.x) - n * (this.y - e.y),
                        this.y = r,
                        this
                    },
                    _round: function() {
                        return this.x = Math.round(this.x),
                        this.y = Math.round(this.y),
                        this
                    }
                },
                y.convert = function(t) {
                    return t instanceof y ? t : Array.isArray(t) ? new y(t[0],t[1]) : t
                }
                ;
                var v = f(_);
                const x = Math.PI / 180
                  , b = 180 / Math.PI;
                function w(t) {
                    return t * x
                }
                function E(t) {
                    return t * b
                }
                const T = [[0, 0], [1, 0], [1, 1], [0, 1]];
                function S(t) {
                    if (t <= 0)
                        return 0;
                    if (t >= 1)
                        return 1;
                    const e = t * t
                      , i = e * t;
                    return 4 * (t < .5 ? i : 3 * (t - e) + i - .75)
                }
                function C(t, e, i, n) {
                    const r = new g(t,e,i,n);
                    return function(t) {
                        return r.solve(t)
                    }
                }
                const A = C(.25, .1, .25, 1);
                function I(t, e, i) {
                    return Math.min(i, Math.max(e, t))
                }
                function M(t, e, i) {
                    return (i = I((i - t) / (e - t), 0, 1)) * i * (3 - 2 * i)
                }
                function P(t, e, i) {
                    const n = i - e
                      , r = ((t - e) % n + n) % n + e;
                    return r === e ? i : r
                }
                function k(t, e, i) {
                    if (!t.length)
                        return i(null, []);
                    let n = t.length;
                    const r = new Array(t.length);
                    let o = null;
                    t.forEach(( (t, s) => {
                        e(t, ( (t, e) => {
                            t && (o = t),
                            r[s] = e,
                            0 == --n && i(o, r)
                        }
                        ))
                    }
                    ))
                }
                function O(t) {
                    const e = [];
                    for (const i in t)
                        e.push(t[i]);
                    return e
                }
                function R(t, ...e) {
                    for (const i of e)
                        for (const e in i)
                            t[e] = i[e];
                    return t
                }
                let D = 1;
                function L() {
                    return D++
                }
                function B() {
                    return function t(e) {
                        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t)
                    }()
                }
                function z(t) {
                    return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                }
                function F(t) {
                    return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t)
                }
                function N(t, e) {
                    t.forEach((t => {
                        e[t] && (e[t] = e[t].bind(e))
                    }
                    ))
                }
                function j(t, e) {
                    return -1 !== t.indexOf(e, t.length - e.length)
                }
                function U(t, e, i) {
                    const n = {};
                    for (const r in t)
                        n[r] = e.call(i || this, t[r], r, t);
                    return n
                }
                function V(t, e, i) {
                    const n = {};
                    for (const r in t)
                        e.call(i || this, t[r], r, t) && (n[r] = t[r]);
                    return n
                }
                function G(t) {
                    return Array.isArray(t) ? t.map(G) : "object" == typeof t && t ? U(t, G) : t
                }
                const Z = {};
                function q(t) {
                    Z[t] || (void 0 !== n && n.warn(t),
                    Z[t] = !0)
                }
                function W(t, e, i) {
                    return (i.y - t.y) * (e.x - t.x) > (e.y - t.y) * (i.x - t.x)
                }
                function H(t) {
                    let e = 0;
                    for (let i, n, r = 0, o = t.length, s = o - 1; r < o; s = r++)
                        i = t[r],
                        n = t[s],
                        e += (n.x - i.x) * (i.y + n.y);
                    return e
                }
                function $() {
                    return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope
                }
                function X(t) {
                    const e = {};
                    if (t.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, ( (t, i, n, r) => {
                        const o = n || r;
                        return e[i] = !o || o.toLowerCase(),
                        ""
                    }
                    )),
                    e["max-age"]) {
                        const t = parseInt(e["max-age"], 10);
                        isNaN(t) ? delete e["max-age"] : e["max-age"] = t
                    }
                    return e
                }
                let Y = null;
                function K(t) {
                    if (null == Y) {
                        const e = t.navigator ? t.navigator.userAgent : null;
                        Y = !!t.safari || !(!e || !(/\b(iPad|iPhone|iPod)\b/.test(e) || e.match("Safari") && !e.match("Chrome")))
                    }
                    return Y
                }
                function J(t) {
                    try {
                        const i = e[t];
                        return i.setItem("_mapbox_test_", 1),
                        i.removeItem("_mapbox_test_"),
                        !0
                    } catch (t) {
                        return !1
                    }
                }
                function Q(t, e) {
                    return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]]
                }
                const tt = "mapbox-tiles";
                let et, it, nt = 500, rt = 50;
                function ot() {
                    try {
                        return e.caches
                    } catch (t) {}
                }
                function st() {
                    ot() && !et && (et = e.caches.open(tt))
                }
                function at(t) {
                    const e = t.indexOf("?");
                    if (e < 0)
                        return t;
                    const i = function(t) {
                        const e = t.indexOf("?");
                        return e > 0 ? t.slice(e + 1).split("&") : []
                    }(t)
                      , n = i.filter((t => {
                        const e = t.split("=");
                        return "language" === e[0] || "worldview" === e[0]
                    }
                    ));
                    return n.length ? `${t.slice(0, e)}?${n.join("&")}` : t.slice(0, e)
                }
                let lt = 1 / 0;
                const ct = {
                    Unknown: "Unknown",
                    Style: "Style",
                    Source: "Source",
                    Tile: "Tile",
                    Glyphs: "Glyphs",
                    SpriteImage: "SpriteImage",
                    SpriteJSON: "SpriteJSON",
                    Image: "Image"
                };
                "function" == typeof Object.freeze && Object.freeze(ct);
                class ht extends Error {
                    constructor(t, e, i) {
                        401 === e && bt(i) && (t += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"),
                        super(t),
                        this.status = e,
                        this.url = i
                    }
                    toString() {
                        return `${this.name}: ${this.message} (${this.status}): ${this.url}`
                    }
                }
                const ut = $() ? () => self.worker && self.worker.referrer : () => ("blob:" === e.location.protocol ? e.parent : e).location.href
                  , dt = function(t, i) {
                    if (!(/^file:/.test(n = t.url) || /^file:/.test(ut()) && !/^\w+:/.test(n))) {
                        if (e.fetch && e.Request && e.AbortController && e.Request.prototype.hasOwnProperty("signal"))
                            return function(t, i) {
                                const n = new e.AbortController
                                  , r = new e.Request(t.url,{
                                    method: t.method || "GET",
                                    body: t.body,
                                    credentials: t.credentials,
                                    headers: t.headers,
                                    referrer: ut(),
                                    referrerPolicy: t.referrerPolicy,
                                    signal: n.signal
                                });
                                let o = !1
                                  , s = !1;
                                const a = (l = r.url).indexOf("sku=") > 0 && bt(l);
                                var l;
                                "json" === t.type && r.headers.set("Accept", "application/json");
                                const c = (n, o, l) => {
                                    if (s)
                                        return;
                                    if (n && "SecurityError" !== n.message && q(n.toString()),
                                    o && l)
                                        return h(o);
                                    const c = Date.now();
                                    e.fetch(r).then((e => {
                                        if (e.ok) {
                                            const t = a ? e.clone() : null;
                                            return h(e, t, c)
                                        }
                                        return i(new ht(e.statusText,e.status,t.url))
                                    }
                                    )).catch((e => {
                                        "AbortError" !== e.name && i(new Error(`${e.message} ${t.url}`))
                                    }
                                    ))
                                }
                                  , h = (n, a, l) => {
                                    ("arrayBuffer" === t.type ? n.arrayBuffer() : "json" === t.type ? n.json() : n.text()).then((t => {
                                        s || (a && l && function(t, i, n) {
                                            if (st(),
                                            !et)
                                                return;
                                            const r = {
                                                status: i.status,
                                                statusText: i.statusText,
                                                headers: new e.Headers
                                            };
                                            i.headers.forEach(( (t, e) => r.headers.set(e, t)));
                                            const o = X(i.headers.get("Cache-Control") || "");
                                            if (o["no-store"])
                                                return;
                                            o["max-age"] && r.headers.set("Expires", new Date(n + 1e3 * o["max-age"]).toUTCString());
                                            const s = r.headers.get("Expires");
                                            s && (new Date(s).getTime() - n < 42e4 || function(t, e) {
                                                if (void 0 === it)
                                                    try {
                                                        new Response(new ReadableStream),
                                                        it = !0
                                                    } catch (t) {
                                                        it = !1
                                                    }
                                                it ? e(t.body) : t.blob().then(e)
                                            }(i, (i => {
                                                const n = new e.Response(i,r);
                                                st(),
                                                et && et.then((e => e.put(at(t.url), n))).catch((t => q(t.message)))
                                            }
                                            )))
                                        }(r, a, l),
                                        o = !0,
                                        i(null, t, n.headers.get("Cache-Control"), n.headers.get("Expires")))
                                    }
                                    )).catch((t => {
                                        s || i(new Error(t.message))
                                    }
                                    ))
                                }
                                ;
                                return a ? function(t, e) {
                                    if (st(),
                                    !et)
                                        return e(null);
                                    const i = at(t.url);
                                    et.then((t => {
                                        t.match(i).then((n => {
                                            const r = function(t) {
                                                if (!t)
                                                    return !1;
                                                const e = new Date(t.headers.get("Expires") || 0)
                                                  , i = X(t.headers.get("Cache-Control") || "");
                                                return e > Date.now() && !i["no-cache"]
                                            }(n);
                                            t.delete(i),
                                            r && t.put(i, n.clone()),
                                            e(null, n, r)
                                        }
                                        )).catch(e)
                                    }
                                    )).catch(e)
                                }(r, c) : c(null, null),
                                {
                                    cancel: () => {
                                        s = !0,
                                        o || n.abort()
                                    }
                                }
                            }(t, i);
                        if ($() && self.worker && self.worker.actor)
                            return self.worker.actor.send("getResource", t, i, void 0, !0)
                    }
                    var n;
                    return function(t, i) {
                        const n = new e.XMLHttpRequest;
                        n.open(t.method || "GET", t.url, !0),
                        "arrayBuffer" === t.type && (n.responseType = "arraybuffer");
                        for (const e in t.headers)
                            n.setRequestHeader(e, t.headers[e]);
                        return "json" === t.type && (n.responseType = "text",
                        n.setRequestHeader("Accept", "application/json")),
                        n.withCredentials = "include" === t.credentials,
                        n.onerror = () => {
                            i(new Error(n.statusText))
                        }
                        ,
                        n.onload = () => {
                            if ((n.status >= 200 && n.status < 300 || 0 === n.status) && null !== n.response) {
                                let e = n.response;
                                if ("json" === t.type)
                                    try {
                                        e = JSON.parse(n.response)
                                    } catch (t) {
                                        return i(t)
                                    }
                                i(null, e, n.getResponseHeader("Cache-Control"), n.getResponseHeader("Expires"))
                            } else
                                i(new ht(n.statusText,n.status,t.url))
                        }
                        ,
                        n.send(t.body),
                        {
                            cancel: () => n.abort()
                        }
                    }(t, i)
                }
                  , ft = function(t, e) {
                    return dt(R(t, {
                        type: "arrayBuffer"
                    }), e)
                };
                function pt(t) {
                    const i = e.document.createElement("a");
                    return i.href = t,
                    i.protocol === e.document.location.protocol && i.host === e.document.location.host
                }
                const mt = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                let gt, _t;
                gt = [],
                _t = 0;
                const yt = function(t, i) {
                    if (s.supported && (t.headers || (t.headers = {}),
                    t.headers.accept = "image/webp,*/*"),
                    _t >= o.MAX_PARALLEL_IMAGE_REQUESTS) {
                        const e = {
                            requestParameters: t,
                            callback: i,
                            cancelled: !1,
                            cancel() {
                                this.cancelled = !0
                            }
                        };
                        return gt.push(e),
                        e
                    }
                    _t++;
                    let n = !1;
                    const r = () => {
                        if (!n)
                            for (n = !0,
                            _t--; gt.length && _t < o.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                                const t = gt.shift()
                                  , {requestParameters: e, callback: i, cancelled: n} = t;
                                n || (t.cancel = yt(e, i).cancel)
                            }
                    }
                      , a = ft(t, ( (t, n, o, s) => {
                        r(),
                        t ? i(t) : n && (e.createImageBitmap ? function(t, i) {
                            const n = new e.Blob([new Uint8Array(t)],{
                                type: "image/png"
                            });
                            e.createImageBitmap(n).then((t => {
                                i(null, t)
                            }
                            )).catch((t => {
                                i(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`))
                            }
                            ))
                        }(n, ( (t, e) => i(t, e, o, s))) : function(t, i) {
                            const n = new e.Image
                              , r = e.URL;
                            n.onload = () => {
                                i(null, n),
                                r.revokeObjectURL(n.src),
                                n.onload = null,
                                e.requestAnimationFrame(( () => {
                                    n.src = mt
                                }
                                ))
                            }
                            ,
                            n.onerror = () => i(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                            const o = new e.Blob([new Uint8Array(t)],{
                                type: "image/png"
                            });
                            n.src = t.byteLength ? r.createObjectURL(o) : mt
                        }(n, ( (t, e) => i(t, e, o, s))))
                    }
                    ));
                    return {
                        cancel: () => {
                            a.cancel(),
                            r()
                        }
                    }
                }
                  , vt = "NO_ACCESS_TOKEN";
                function xt(t) {
                    return 0 === t.indexOf("mapbox:")
                }
                function bt(t) {
                    return o.API_URL_REGEX.test(t)
                }
                function wt(t) {
                    return o.API_CDN_URL_REGEX.test(t)
                }
                function Et(t) {
                    return o.API_STYLE_REGEX.test(t) && !Tt(t)
                }
                function Tt(t) {
                    return o.API_SPRITE_REGEX.test(t)
                }
                const St = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
                function Ct(t) {
                    const e = t.match(St);
                    if (!e)
                        throw new Error("Unable to parse URL object");
                    return {
                        protocol: e[1],
                        authority: e[2],
                        path: e[3] || "/",
                        params: e[4] ? e[4].split("&") : []
                    }
                }
                function At(t) {
                    const e = t.params.length ? `?${t.params.join("&")}` : "";
                    return `${t.protocol}://${t.authority}${t.path}${e}`
                }
                const It = "mapbox.eventData";
                function Mt(t) {
                    if (!t)
                        return null;
                    const i = t.split(".");
                    if (!i || 3 !== i.length)
                        return null;
                    try {
                        return JSON.parse(decodeURIComponent(e.atob(i[1]).split("").map((t => "%" + ("00" + t.charCodeAt(0).toString(16)).slice(-2))).join("")))
                    } catch (t) {
                        return null
                    }
                }
                class Pt {
                    constructor(t) {
                        this.type = t,
                        this.anonId = null,
                        this.eventData = {},
                        this.queue = [],
                        this.pendingRequest = null
                    }
                    getStorageKey(t) {
                        const i = Mt(o.ACCESS_TOKEN);
                        let n = "";
                        return n = i && i.u ? e.btoa(encodeURIComponent(i.u).replace(/%([0-9A-F]{2})/g, ( (t, e) => String.fromCharCode(Number("0x" + e))))) : o.ACCESS_TOKEN || "",
                        t ? `${It}.${t}:${n}` : `${It}:${n}`
                    }
                    fetchEventData() {
                        const t = J("localStorage")
                          , i = this.getStorageKey()
                          , n = this.getStorageKey("uuid");
                        if (t)
                            try {
                                const t = e.localStorage.getItem(i);
                                t && (this.eventData = JSON.parse(t));
                                const r = e.localStorage.getItem(n);
                                r && (this.anonId = r)
                            } catch (t) {
                                q("Unable to read from LocalStorage")
                            }
                    }
                    saveEventData() {
                        const t = J("localStorage")
                          , i = this.getStorageKey()
                          , n = this.getStorageKey("uuid");
                        if (t)
                            try {
                                e.localStorage.setItem(n, this.anonId),
                                Object.keys(this.eventData).length >= 1 && e.localStorage.setItem(i, JSON.stringify(this.eventData))
                            } catch (t) {
                                q("Unable to write to LocalStorage")
                            }
                    }
                    processRequests(t) {}
                    postEvent(t, e, i, n) {
                        if (!o.EVENTS_URL)
                            return;
                        const r = Ct(o.EVENTS_URL);
                        r.params.push(`access_token=${n || o.ACCESS_TOKEN || ""}`);
                        const s = {
                            event: this.type,
                            created: new Date(t).toISOString()
                        }
                          , a = e ? R(s, e) : s
                          , l = {
                            url: At(r),
                            headers: {
                                "Content-Type": "text/plain"
                            },
                            body: JSON.stringify([a])
                        };
                        this.pendingRequest = function(t, e) {
                            return dt(R(t, {
                                method: "POST"
                            }), e)
                        }(l, (t => {
                            this.pendingRequest = null,
                            i(t),
                            this.saveEventData(),
                            this.processRequests(n)
                        }
                        ))
                    }
                    queueRequest(t, e) {
                        this.queue.push(t),
                        this.processRequests(e)
                    }
                }
                const kt = new class extends Pt {
                    constructor(t) {
                        super("appUserTurnstile"),
                        this._customAccessToken = t
                    }
                    postTurnstileEvent(t, e) {
                        o.EVENTS_URL && o.ACCESS_TOKEN && Array.isArray(t) && t.some((t => xt(t) || bt(t))) && this.queueRequest(Date.now(), e)
                    }
                    processRequests(t) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                        const e = Mt(o.ACCESS_TOKEN)
                          , n = e ? e.u : o.ACCESS_TOKEN;
                        let r = n !== this.eventData.tokenU;
                        F(this.anonId) || (this.anonId = B(),
                        r = !0);
                        const s = this.queue.shift();
                        if (this.eventData.lastSuccess) {
                            const t = new Date(this.eventData.lastSuccess)
                              , e = new Date(s)
                              , i = (s - this.eventData.lastSuccess) / 864e5;
                            r = r || i >= 1 || i < -1 || t.getDate() !== e.getDate()
                        } else
                            r = !0;
                        r ? this.postEvent(s, {
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: i,
                            skuId: d,
                            "enabled.telemetry": !1,
                            userId: this.anonId
                        }, (t => {
                            t || (this.eventData.lastSuccess = s,
                            this.eventData.tokenU = n)
                        }
                        ), t) : this.processRequests()
                    }
                }
                  , Ot = kt.postTurnstileEvent.bind(kt)
                  , Rt = new class extends Pt {
                    constructor() {
                        super("map.load"),
                        this.success = {},
                        this.skuToken = ""
                    }
                    postMapLoadEvent(t, e, i, n) {
                        this.skuToken = e,
                        this.errorCb = n,
                        o.EVENTS_URL && (i || o.ACCESS_TOKEN ? this.queueRequest({
                            id: t,
                            timestamp: Date.now()
                        }, i) : this.errorCb(new Error(vt)))
                    }
                    processRequests(t) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {id: e, timestamp: n} = this.queue.shift();
                        e && this.success[e] || (this.anonId || this.fetchEventData(),
                        F(this.anonId) || (this.anonId = B()),
                        this.postEvent(n, {
                            sdkIdentifier: "mapbox-gl-js",
                            sdkVersion: i,
                            skuId: d,
                            skuToken: this.skuToken,
                            userId: this.anonId
                        }, (t => {
                            t ? this.errorCb(t) : e && (this.success[e] = !0)
                        }
                        ), t))
                    }
                }
                  , Dt = Rt.postMapLoadEvent.bind(Rt)
                  , Lt = new class extends Pt {
                    constructor() {
                        super("gljs.performance")
                    }
                    postPerformanceEvent(t, e) {
                        o.EVENTS_URL && (t || o.ACCESS_TOKEN) && this.queueRequest({
                            timestamp: Date.now(),
                            performanceData: e
                        }, t)
                    }
                    processRequests(t) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {timestamp: n, performanceData: r} = this.queue.shift()
                          , o = function(t) {
                            const n = e.performance.getEntriesByType("resource")
                              , r = e.performance.getEntriesByType("mark")
                              , o = function(t) {
                                const e = {};
                                if (t)
                                    for (const i in t)
                                        if ("other" !== i)
                                            for (const n of t[i]) {
                                                const t = `${i}ResolveRangeMin`
                                                  , r = `${i}ResolveRangeMax`
                                                  , o = `${i}RequestCount`
                                                  , s = `${i}RequestCachedCount`;
                                                e[t] = Math.min(e[t] || 1 / 0, n.startTime),
                                                e[r] = Math.max(e[r] || -1 / 0, n.responseEnd);
                                                const a = t => {
                                                    void 0 === e[t] && (e[t] = 0),
                                                    ++e[t]
                                                }
                                                ;
                                                void 0 !== n.transferSize && 0 === n.transferSize && a(s),
                                                a(o)
                                            }
                                return e
                            }(function(t, e) {
                                const i = {};
                                if (t)
                                    for (const n of t) {
                                        const t = e(n);
                                        void 0 === i[t] && (i[t] = []),
                                        i[t].push(n)
                                    }
                                return i
                            }(n, Vt))
                              , s = e.devicePixelRatio
                              , a = e.navigator.connection || e.navigator.mozConnection || e.navigator.webkitConnection
                              , l = {
                                counters: [],
                                metadata: [],
                                attributes: []
                            }
                              , c = (t, e, i) => {
                                null != i && t.push({
                                    name: e,
                                    value: i.toString()
                                })
                            }
                            ;
                            for (const t in o)
                                c(l.counters, t, o[t]);
                            if (t.interactionRange[0] !== 1 / 0 && t.interactionRange[1] !== -1 / 0 && (c(l.counters, "interactionRangeMin", t.interactionRange[0]),
                            c(l.counters, "interactionRangeMax", t.interactionRange[1])),
                            r)
                                for (const t of Object.keys(jt)) {
                                    const e = jt[t]
                                      , i = r.find((t => t.name === e));
                                    i && c(l.counters, e, i.startTime)
                                }
                            return c(l.counters, "visibilityHidden", t.visibilityHidden),
                            c(l.attributes, "style", function(t) {
                                if (t)
                                    for (const e of t) {
                                        const t = e.name.split("?")[0];
                                        if (Et(t)) {
                                            const e = t.split("/").slice(-2);
                                            if (2 === e.length)
                                                return `mapbox://styles/${e[0]}/${e[1]}`
                                        }
                                    }
                            }(n)),
                            c(l.attributes, "terrainEnabled", t.terrainEnabled ? "true" : "false"),
                            c(l.attributes, "fogEnabled", t.fogEnabled ? "true" : "false"),
                            c(l.attributes, "projection", t.projection),
                            c(l.attributes, "zoom", t.zoom),
                            c(l.metadata, "devicePixelRatio", s),
                            c(l.metadata, "connectionEffectiveType", a ? a.effectiveType : void 0),
                            c(l.metadata, "navigatorUserAgent", e.navigator.userAgent),
                            c(l.metadata, "screenWidth", e.screen.width),
                            c(l.metadata, "screenHeight", e.screen.height),
                            c(l.metadata, "windowWidth", e.innerWidth),
                            c(l.metadata, "windowHeight", e.innerHeight),
                            c(l.metadata, "mapWidth", t.width / s),
                            c(l.metadata, "mapHeight", t.height / s),
                            c(l.metadata, "webglRenderer", t.renderer),
                            c(l.metadata, "webglVendor", t.vendor),
                            c(l.metadata, "sdkVersion", i),
                            c(l.metadata, "sdkIdentifier", "mapbox-gl-js"),
                            l
                        }(r);
                        for (const t of o.metadata)
                            ;
                        for (const t of o.counters)
                            ;
                        for (const t of o.attributes)
                            ;
                        this.postEvent(n, o, ( () => {}
                        ), t)
                    }
                }
                  , Bt = Lt.postPerformanceEvent.bind(Lt)
                  , zt = new class extends Pt {
                    constructor() {
                        super("map.auth"),
                        this.success = {},
                        this.skuToken = ""
                    }
                    getSession(t, e, i, n) {
                        if (!o.API_URL || !o.SESSION_PATH)
                            return;
                        const r = Ct(o.API_URL + o.SESSION_PATH);
                        r.params.push(`sku=${e || ""}`),
                        r.params.push(`access_token=${n || o.ACCESS_TOKEN || ""}`);
                        const s = {
                            url: At(r),
                            headers: {
                                "Content-Type": "text/plain"
                            }
                        };
                        this.pendingRequest = function(t, e) {
                            return dt(R(t, {
                                method: "GET"
                            }), e)
                        }(s, (t => {
                            this.pendingRequest = null,
                            i(t),
                            this.saveEventData(),
                            this.processRequests(n)
                        }
                        ))
                    }
                    getSessionAPI(t, e, i, n) {
                        this.skuToken = e,
                        this.errorCb = n,
                        o.SESSION_PATH && o.API_URL && (i || o.ACCESS_TOKEN ? this.queueRequest({
                            id: t,
                            timestamp: Date.now()
                        }, i) : this.errorCb(new Error(vt)))
                    }
                    processRequests(t) {
                        if (this.pendingRequest || 0 === this.queue.length)
                            return;
                        const {id: e, timestamp: i} = this.queue.shift();
                        e && this.success[e] || this.getSession(i, this.skuToken, (t => {
                            t ? this.errorCb(t) : e && (this.success[e] = !0)
                        }
                        ), t)
                    }
                }
                  , Ft = zt.getSessionAPI.bind(zt)
                  , Nt = new Set
                  , jt = {
                    create: "create",
                    load: "load",
                    fullLoad: "fullLoad"
                }
                  , Ut = {
                    mark(t) {
                        e.performance.mark(t)
                    },
                    measure(t, i, n) {
                        e.performance.measure(t, i, n)
                    }
                };
                function Vt(t) {
                    const e = t.name.split("?")[0];
                    return wt(e) && e.includes("mapbox-gl.js") ? "javascript" : wt(e) && e.includes("mapbox-gl.css") ? "css" : function(t) {
                        return o.API_FONTS_REGEX.test(t)
                    }(e) ? "fontRange" : Tt(e) ? "sprite" : Et(e) ? "style" : function(t) {
                        return o.API_TILEJSON_REGEX.test(t)
                    }(e) ? "tilejson" : "other"
                }
                const Gt = e.performance;
                function Zt(t) {
                    const e = t ? t.url.toString() : void 0;
                    return Gt.getEntriesByName(e)
                }
                let qt, Wt, Ht, $t;
                const Xt = {
                    now: () => void 0 !== Ht ? Ht : e.performance.now(),
                    setNow(t) {
                        Ht = t
                    },
                    restoreNow() {
                        Ht = void 0
                    },
                    frame(t) {
                        const i = e.requestAnimationFrame(t);
                        return {
                            cancel: () => e.cancelAnimationFrame(i)
                        }
                    },
                    getImageData(t, i=0) {
                        const {width: n, height: r} = t;
                        $t || ($t = e.document.createElement("canvas"));
                        const o = $t.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!o)
                            throw new Error("failed to create canvas 2d context");
                        return (n > $t.width || r > $t.height) && ($t.width = n,
                        $t.height = r),
                        o.clearRect(-i, -i, n + 2 * i, r + 2 * i),
                        o.drawImage(t, 0, 0, n, r),
                        o.getImageData(-i, -i, n + 2 * i, r + 2 * i)
                    },
                    resolveURL: t => (qt || (qt = e.document.createElement("a")),
                    qt.href = t,
                    qt.href),
                    get devicePixelRatio() {
                        return e.devicePixelRatio
                    },
                    get prefersReducedMotion() {
                        return !!e.matchMedia && (null == Wt && (Wt = e.matchMedia("(prefers-reduced-motion: reduce)")),
                        Wt.matches)
                    }
                };
                function Yt(t, e, i) {
                    i[t] && -1 !== i[t].indexOf(e) || (i[t] = i[t] || [],
                    i[t].push(e))
                }
                function Kt(t, e, i) {
                    if (i && i[t]) {
                        const n = i[t].indexOf(e);
                        -1 !== n && i[t].splice(n, 1)
                    }
                }
                class Jt {
                    constructor(t, e={}) {
                        R(this, e),
                        this.type = t
                    }
                }
                class Qt extends Jt {
                    constructor(t, e={}) {
                        super("error", R({
                            error: t
                        }, e))
                    }
                }
                class te {
                    on(t, e) {
                        return this._listeners = this._listeners || {},
                        Yt(t, e, this._listeners),
                        this
                    }
                    off(t, e) {
                        return Kt(t, e, this._listeners),
                        Kt(t, e, this._oneTimeListeners),
                        this
                    }
                    once(t, e) {
                        return e ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        Yt(t, e, this._oneTimeListeners),
                        this) : new Promise((e => this.once(t, e)))
                    }
                    fire(t, e) {
                        "string" == typeof t && (t = new Jt(t,e || {}));
                        const i = t.type;
                        if (this.listens(i)) {
                            t.target = this;
                            const e = this._listeners && this._listeners[i] ? this._listeners[i].slice() : [];
                            for (const i of e)
                                i.call(this, t);
                            const n = this._oneTimeListeners && this._oneTimeListeners[i] ? this._oneTimeListeners[i].slice() : [];
                            for (const e of n)
                                Kt(i, e, this._oneTimeListeners),
                                e.call(this, t);
                            const r = this._eventedParent;
                            r && (R(t, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData),
                            r.fire(t))
                        } else
                            t instanceof Qt && n.error(t.error);
                        return this
                    }
                    listens(t) {
                        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t))
                    }
                    setEventedParent(t, e) {
                        return this._eventedParent = t,
                        this._eventedParentData = e,
                        this
                    }
                }
                var ee = JSON.parse('{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"terrain":{"type":"terrain"},"fog":{"type":"fog"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_geojson","source_video","source_image"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"scheme":{"type":"enum","values":{"xyz":{},"tms":{}},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":{},"mapbox":{}},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"background":{},"sky":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":{},"round":{},"square":{}},"default":"butt","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":{},"round":{},"miter":{}},"default":"miter","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"requires":[{"line-join":"miter"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"requires":[{"line-join":"round"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":{},"line":{},"line-center":{}},"default":"point","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"units":"pixels","requires":[{"symbol-placement":"line"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":{},"viewport-y":{},"source":{}},"default":"auto","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"units":"factor of the original icon size","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"units":"ems","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":{},"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","units":"ems","default":0,"requires":["text-field"],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"requires":["text-field",{"symbol-placement":["point"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field",{"!":"text-variable-anchor"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"units":"degrees","requires":["text-field",{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":{},"vertical":{}},"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":["line","line-center"]}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","units":"ems","length":2,"default":[0,0],"requires":["text-field",{"!":"text-radial-offset"}],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"requires":["text-field"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"requires":["text-field","icon-image"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible","property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"transition":false,"property-type":"data-driven","expression":{"interpolated":false,"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{},"within":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"property-type":"data-constant","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":{},"equalEarth":{},"equirectangular":{},"lambertConformalConic":{},"mercator":{},"naturalEarth":{},"winkelTripel":{},"globe":{}},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90],"transition":false,"requires":[{"name":["albers","lambertConformalConic"]}]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["source"]}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"fill-extrusion-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true,"requires":["fill-extrusion-edge-radius"]},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"requires":["fill-extrusion-edge-radius"],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"line-pattern"}],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"transition":false,"units":"line widths","requires":[{"!":"line-pattern"}],"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","transition":false,"requires":[{"!":"line-pattern"},{"source":"geojson","has":{"lineMetrics":true}}],"expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"transition":false,"requires":[{"source":"geojson","has":{"lineMetrics":true}}],"property-type":"constant"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"units":"pixels","expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"transition":false,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"transition":false,"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["icon-image"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"units":"pixels","requires":["text-field"],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"units":"degrees","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":{},"nearest":{}},"default":"linear","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"transition":false,"units":"milliseconds","expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"transition":false,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":{},"viewport":{}},"default":"viewport","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"requires":[{"!":"background-pattern"}],"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":{},"atmosphere":{}},"default":"atmosphere","expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"requires":[{"sky-type":"atmosphere"}],"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","requires":[{"sky-type":"atmosphere"}],"default":10,"minimum":0,"maximum":100,"transition":false,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","requires":[{"sky-type":"gradient"}],"value":"number","default":[0,0],"length":2,"units":"degrees","minimum":[0,0],"maximum":[360,180],"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","requires":[{"sky-type":"gradient"}],"default":90,"minimum":0,"maximum":180,"transition":false,"expression":{"interpolated":false,"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"transition":false,"requires":[{"sky-type":"gradient"}],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","transition":false,"requires":[{"sky-type":"atmosphere"}],"property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}');
                function ie(t, ...e) {
                    for (const i of e)
                        for (const e in i)
                            t[e] = i[e];
                    return t
                }
                function ne(t) {
                    return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t
                }
                function re(t) {
                    if (Array.isArray(t))
                        return t.map(re);
                    if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {
                        const e = {};
                        for (const i in t)
                            e[i] = re(t[i]);
                        return e
                    }
                    return ne(t)
                }
                class oe extends Error {
                    constructor(t, e) {
                        super(e),
                        this.message = e,
                        this.key = t
                    }
                }
                var se = oe;
                class ae {
                    constructor(t, e=[]) {
                        this.parent = t,
                        this.bindings = {};
                        for (const [t,i] of e)
                            this.bindings[t] = i
                    }
                    concat(t) {
                        return new ae(this,t)
                    }
                    get(t) {
                        if (this.bindings[t])
                            return this.bindings[t];
                        if (this.parent)
                            return this.parent.get(t);
                        throw new Error(`${t} not found in scope.`)
                    }
                    has(t) {
                        return !!this.bindings[t] || !!this.parent && this.parent.has(t)
                    }
                }
                var le = ae;
                const ce = {
                    kind: "null"
                }
                  , he = {
                    kind: "number"
                }
                  , ue = {
                    kind: "string"
                }
                  , de = {
                    kind: "boolean"
                }
                  , fe = {
                    kind: "color"
                }
                  , pe = {
                    kind: "object"
                }
                  , me = {
                    kind: "value"
                }
                  , ge = {
                    kind: "collator"
                }
                  , _e = {
                    kind: "formatted"
                }
                  , ye = {
                    kind: "resolvedImage"
                };
                function ve(t, e) {
                    return {
                        kind: "array",
                        itemType: t,
                        N: e
                    }
                }
                function xe(t) {
                    if ("array" === t.kind) {
                        const e = xe(t.itemType);
                        return "number" == typeof t.N ? `array<${e}, ${t.N}>` : "value" === t.itemType.kind ? "array" : `array<${e}>`
                    }
                    return t.kind
                }
                const be = [ce, he, ue, de, fe, _e, pe, ve(me), ye];
                function we(t, e) {
                    if ("error" === e.kind)
                        return null;
                    if ("array" === t.kind) {
                        if ("array" === e.kind && (0 === e.N && "value" === e.itemType.kind || !we(t.itemType, e.itemType)) && ("number" != typeof t.N || t.N === e.N))
                            return null
                    } else {
                        if (t.kind === e.kind)
                            return null;
                        if ("value" === t.kind)
                            for (const t of be)
                                if (!we(t, e))
                                    return null
                    }
                    return `Expected ${xe(t)} but found ${xe(e)} instead.`
                }
                function Ee(t, e) {
                    return e.some((e => e.kind === t.kind))
                }
                function Te(t, e) {
                    return e.some((e => "null" === e ? null === t : "array" === e ? Array.isArray(t) : "object" === e ? t && !Array.isArray(t) && "object" == typeof t : e === typeof t))
                }
                var Se, Ce = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    rebeccapurple: [102, 51, 153, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                };
                function Ae(t) {
                    return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t
                }
                function Ie(t) {
                    return Ae("%" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t))
                }
                function Me(t) {
                    return (e = "%" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;
                    var e
                }
                function Pe(t, e, i) {
                    return i < 0 ? i += 1 : i > 1 && (i -= 1),
                    6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
                }
                try {
                    Se = {}.parseCSSColor = function(t) {
                        var e, i = t.replace(/ /g, "").toLowerCase();
                        if (i in Ce)
                            return Ce[i].slice();
                        if ("#" === i[0])
                            return 4 === i.length ? (e = parseInt(i.substr(1), 16)) >= 0 && e <= 4095 ? [(3840 & e) >> 4 | (3840 & e) >> 8, 240 & e | (240 & e) >> 4, 15 & e | (15 & e) << 4, 1] : null : 7 === i.length && (e = parseInt(i.substr(1), 16)) >= 0 && e <= 16777215 ? [(16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 1] : null;
                        var n = i.indexOf("(")
                          , r = i.indexOf(")");
                        if (-1 !== n && r + 1 === i.length) {
                            var o = i.substr(0, n)
                              , s = i.substr(n + 1, r - (n + 1)).split(",")
                              , a = 1;
                            switch (o) {
                            case "rgba":
                                if (4 !== s.length)
                                    return null;
                                a = Me(s.pop());
                            case "rgb":
                                return 3 !== s.length ? null : [Ie(s[0]), Ie(s[1]), Ie(s[2]), a];
                            case "hsla":
                                if (4 !== s.length)
                                    return null;
                                a = Me(s.pop());
                            case "hsl":
                                if (3 !== s.length)
                                    return null;
                                var l = (parseFloat(s[0]) % 360 + 360) % 360 / 360
                                  , c = Me(s[1])
                                  , h = Me(s[2])
                                  , u = h <= .5 ? h * (c + 1) : h + c - h * c
                                  , d = 2 * h - u;
                                return [Ae(255 * Pe(d, u, l + 1 / 3)), Ae(255 * Pe(d, u, l)), Ae(255 * Pe(d, u, l - 1 / 3)), a];
                            default:
                                return null
                            }
                        }
                        return null
                    }
                } catch (t) {}
                class ke {
                    constructor(t, e, i, n=1) {
                        this.r = t,
                        this.g = e,
                        this.b = i,
                        this.a = n
                    }
                    static parse(t) {
                        if (!t)
                            return;
                        if (t instanceof ke)
                            return t;
                        if ("string" != typeof t)
                            return;
                        const e = Se(t);
                        return e ? new ke(e[0] / 255 * e[3],e[1] / 255 * e[3],e[2] / 255 * e[3],e[3]) : void 0
                    }
                    toString() {
                        const [t,e,i,n] = this.toArray();
                        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(i)},${n})`
                    }
                    toArray() {
                        const {r: t, g: e, b: i, a: n} = this;
                        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * i / n, n]
                    }
                    toArray01() {
                        const {r: t, g: e, b: i, a: n} = this;
                        return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, i / n, n]
                    }
                    toArray01PremultipliedAlpha() {
                        const {r: t, g: e, b: i, a: n} = this;
                        return [t, e, i, n]
                    }
                }
                ke.black = new ke(0,0,0,1),
                ke.white = new ke(1,1,1,1),
                ke.transparent = new ke(0,0,0,0),
                ke.red = new ke(1,0,0,1),
                ke.blue = new ke(0,0,1,1);
                var Oe = ke;
                class Re {
                    constructor(t, e, i) {
                        this.sensitivity = t ? e ? "variant" : "case" : e ? "accent" : "base",
                        this.locale = i,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(t, e) {
                        return this.collator.compare(t, e)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                class De {
                    constructor(t, e, i, n, r) {
                        this.text = t.normalize ? t.normalize() : t,
                        this.image = e,
                        this.scale = i,
                        this.fontStack = n,
                        this.textColor = r
                    }
                }
                class Le {
                    constructor(t) {
                        this.sections = t
                    }
                    static fromString(t) {
                        return new Le([new De(t,null,null,null,null)])
                    }
                    isEmpty() {
                        return 0 === this.sections.length || !this.sections.some((t => 0 !== t.text.length || t.image && 0 !== t.image.name.length))
                    }
                    static factory(t) {
                        return t instanceof Le ? t : Le.fromString(t)
                    }
                    toString() {
                        return 0 === this.sections.length ? "" : this.sections.map((t => t.text)).join("")
                    }
                    serialize() {
                        const t = ["format"];
                        for (const e of this.sections) {
                            if (e.image) {
                                t.push(["image", e.image.name]);
                                continue
                            }
                            t.push(e.text);
                            const i = {};
                            e.fontStack && (i["text-font"] = ["literal", e.fontStack.split(",")]),
                            e.scale && (i["font-scale"] = e.scale),
                            e.textColor && (i["text-color"] = ["rgba"].concat(e.textColor.toArray())),
                            t.push(i)
                        }
                        return t
                    }
                }
                class Be {
                    constructor(t) {
                        this.name = t.name,
                        this.available = t.available
                    }
                    toString() {
                        return this.name
                    }
                    static fromString(t) {
                        return t ? new Be({
                            name: t,
                            available: !1
                        }) : null
                    }
                    serialize() {
                        return ["image", this.name]
                    }
                }
                function ze(t, e, i, n) {
                    return "number" == typeof t && t >= 0 && t <= 255 && "number" == typeof e && e >= 0 && e <= 255 && "number" == typeof i && i >= 0 && i <= 255 ? void 0 === n || "number" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, i, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n ? [t, e, i, n] : [t, e, i]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
                }
                function Fe(t) {
                    if (null === t)
                        return !0;
                    if ("string" == typeof t)
                        return !0;
                    if ("boolean" == typeof t)
                        return !0;
                    if ("number" == typeof t)
                        return !0;
                    if (t instanceof Oe)
                        return !0;
                    if (t instanceof Re)
                        return !0;
                    if (t instanceof Le)
                        return !0;
                    if (t instanceof Be)
                        return !0;
                    if (Array.isArray(t)) {
                        for (const e of t)
                            if (!Fe(e))
                                return !1;
                        return !0
                    }
                    if ("object" == typeof t) {
                        for (const e in t)
                            if (!Fe(t[e]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function Ne(t) {
                    if (null === t)
                        return ce;
                    if ("string" == typeof t)
                        return ue;
                    if ("boolean" == typeof t)
                        return de;
                    if ("number" == typeof t)
                        return he;
                    if (t instanceof Oe)
                        return fe;
                    if (t instanceof Re)
                        return ge;
                    if (t instanceof Le)
                        return _e;
                    if (t instanceof Be)
                        return ye;
                    if (Array.isArray(t)) {
                        const e = t.length;
                        let i;
                        for (const e of t) {
                            const t = Ne(e);
                            if (i) {
                                if (i === t)
                                    continue;
                                i = me;
                                break
                            }
                            i = t
                        }
                        return ve(i || me, e)
                    }
                    return pe
                }
                function je(t) {
                    const e = typeof t;
                    return null === t ? "" : "string" === e || "number" === e || "boolean" === e ? String(t) : t instanceof Oe || t instanceof Le || t instanceof Be ? t.toString() : JSON.stringify(t)
                }
                class Ue {
                    constructor(t, e) {
                        this.type = t,
                        this.value = e
                    }
                    static parse(t, e) {
                        if (2 !== t.length)
                            return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (!Fe(t[1]))
                            return e.error("invalid value");
                        const i = t[1];
                        let n = Ne(i);
                        const r = e.expectedType;
                        return "array" !== n.kind || 0 !== n.N || !r || "array" !== r.kind || "number" == typeof r.N && 0 !== r.N || (n = r),
                        new Ue(n,i)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof Oe ? ["rgba"].concat(this.value.toArray()) : this.value instanceof Le ? this.value.serialize() : this.value
                    }
                }
                var Ve = Ue
                  , Ge = class {
                    constructor(t) {
                        this.name = "ExpressionEvaluationError",
                        this.message = t
                    }
                    toJSON() {
                        return this.message
                    }
                }
                ;
                const Ze = {
                    string: ue,
                    number: he,
                    boolean: de,
                    object: pe
                };
                class qe {
                    constructor(t, e) {
                        this.type = t,
                        this.args = e
                    }
                    static parse(t, e) {
                        if (t.length < 2)
                            return e.error("Expected at least one argument.");
                        let i, n = 1;
                        const r = t[0];
                        if ("array" === r) {
                            let r, o;
                            if (t.length > 2) {
                                const i = t[1];
                                if ("string" != typeof i || !(i in Ze) || "object" === i)
                                    return e.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                r = Ze[i],
                                n++
                            } else
                                r = me;
                            if (t.length > 3) {
                                if (null !== t[2] && ("number" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2])))
                                    return e.error('The length argument to "array" must be a positive integer literal', 2);
                                o = t[2],
                                n++
                            }
                            i = ve(r, o)
                        } else
                            i = Ze[r];
                        const o = [];
                        for (; n < t.length; n++) {
                            const i = e.parse(t[n], n, me);
                            if (!i)
                                return null;
                            o.push(i)
                        }
                        return new qe(i,o)
                    }
                    evaluate(t) {
                        for (let e = 0; e < this.args.length; e++) {
                            const i = this.args[e].evaluate(t);
                            if (!we(this.type, Ne(i)))
                                return i;
                            if (e === this.args.length - 1)
                                throw new Ge(`Expected value to be of type ${xe(this.type)}, but found ${xe(Ne(i))} instead.`)
                        }
                        return null
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                    serialize() {
                        const t = this.type
                          , e = [t.kind];
                        if ("array" === t.kind) {
                            const i = t.itemType;
                            if ("string" === i.kind || "number" === i.kind || "boolean" === i.kind) {
                                e.push(i.kind);
                                const n = t.N;
                                ("number" == typeof n || this.args.length > 1) && e.push(n)
                            }
                        }
                        return e.concat(this.args.map((t => t.serialize())))
                    }
                }
                var We = qe;
                class He {
                    constructor(t) {
                        this.type = _e,
                        this.sections = t
                    }
                    static parse(t, e) {
                        if (t.length < 2)
                            return e.error("Expected at least one argument.");
                        const i = t[1];
                        if (!Array.isArray(i) && "object" == typeof i)
                            return e.error("First argument must be an image or text section.");
                        const n = [];
                        let r = !1;
                        for (let i = 1; i <= t.length - 1; ++i) {
                            const o = t[i];
                            if (r && "object" == typeof o && !Array.isArray(o)) {
                                r = !1;
                                let t = null;
                                if (o["font-scale"] && (t = e.parse(o["font-scale"], 1, he),
                                !t))
                                    return null;
                                let i = null;
                                if (o["text-font"] && (i = e.parse(o["text-font"], 1, ve(ue)),
                                !i))
                                    return null;
                                let s = null;
                                if (o["text-color"] && (s = e.parse(o["text-color"], 1, fe),
                                !s))
                                    return null;
                                const a = n[n.length - 1];
                                a.scale = t,
                                a.font = i,
                                a.textColor = s
                            } else {
                                const o = e.parse(t[i], 1, me);
                                if (!o)
                                    return null;
                                const s = o.type.kind;
                                if ("string" !== s && "value" !== s && "null" !== s && "resolvedImage" !== s)
                                    return e.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                r = !0,
                                n.push({
                                    content: o,
                                    scale: null,
                                    font: null,
                                    textColor: null
                                })
                            }
                        }
                        return new He(n)
                    }
                    evaluate(t) {
                        return new Le(this.sections.map((e => {
                            const i = e.content.evaluate(t);
                            return Ne(i) === ye ? new De("",i,null,null,null) : new De(je(i),null,e.scale ? e.scale.evaluate(t) : null,e.font ? e.font.evaluate(t).join(",") : null,e.textColor ? e.textColor.evaluate(t) : null)
                        }
                        )))
                    }
                    eachChild(t) {
                        for (const e of this.sections)
                            t(e.content),
                            e.scale && t(e.scale),
                            e.font && t(e.font),
                            e.textColor && t(e.textColor)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const t = ["format"];
                        for (const e of this.sections) {
                            t.push(e.content.serialize());
                            const i = {};
                            e.scale && (i["font-scale"] = e.scale.serialize()),
                            e.font && (i["text-font"] = e.font.serialize()),
                            e.textColor && (i["text-color"] = e.textColor.serialize()),
                            t.push(i)
                        }
                        return t
                    }
                }
                class $e {
                    constructor(t) {
                        this.type = ye,
                        this.input = t
                    }
                    static parse(t, e) {
                        if (2 !== t.length)
                            return e.error("Expected two arguments.");
                        const i = e.parse(t[1], 1, ue);
                        return i ? new $e(i) : e.error("No image name provided.")
                    }
                    evaluate(t) {
                        const e = this.input.evaluate(t)
                          , i = Be.fromString(e);
                        return i && t.availableImages && (i.available = t.availableImages.indexOf(e) > -1),
                        i
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return ["image", this.input.serialize()]
                    }
                }
                const Xe = {
                    "to-boolean": de,
                    "to-color": fe,
                    "to-number": he,
                    "to-string": ue
                };
                class Ye {
                    constructor(t, e) {
                        this.type = t,
                        this.args = e
                    }
                    static parse(t, e) {
                        if (t.length < 2)
                            return e.error("Expected at least one argument.");
                        const i = t[0];
                        if (("to-boolean" === i || "to-string" === i) && 2 !== t.length)
                            return e.error("Expected one argument.");
                        const n = Xe[i]
                          , r = [];
                        for (let i = 1; i < t.length; i++) {
                            const n = e.parse(t[i], i, me);
                            if (!n)
                                return null;
                            r.push(n)
                        }
                        return new Ye(n,r)
                    }
                    evaluate(t) {
                        if ("boolean" === this.type.kind)
                            return Boolean(this.args[0].evaluate(t));
                        if ("color" === this.type.kind) {
                            let e, i;
                            for (const n of this.args) {
                                if (e = n.evaluate(t),
                                i = null,
                                e instanceof Oe)
                                    return e;
                                if ("string" == typeof e) {
                                    const i = t.parseColor(e);
                                    if (i)
                                        return i
                                } else if (Array.isArray(e) && (i = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : ze(e[0], e[1], e[2], e[3]),
                                !i))
                                    return new Oe(e[0] / 255,e[1] / 255,e[2] / 255,e[3])
                            }
                            throw new Ge(i || `Could not parse color from value '${"string" == typeof e ? e : String(JSON.stringify(e))}'`)
                        }
                        if ("number" === this.type.kind) {
                            let e = null;
                            for (const i of this.args) {
                                if (e = i.evaluate(t),
                                null === e)
                                    return 0;
                                const n = Number(e);
                                if (!isNaN(n))
                                    return n
                            }
                            throw new Ge(`Could not convert ${JSON.stringify(e)} to number.`)
                        }
                        return "formatted" === this.type.kind ? Le.fromString(je(this.args[0].evaluate(t))) : "resolvedImage" === this.type.kind ? Be.fromString(je(this.args[0].evaluate(t))) : je(this.args[0].evaluate(t))
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                    serialize() {
                        if ("formatted" === this.type.kind)
                            return new He([{
                                content: this.args[0],
                                scale: null,
                                font: null,
                                textColor: null
                            }]).serialize();
                        if ("resolvedImage" === this.type.kind)
                            return new $e(this.args[0]).serialize();
                        const t = [`to-${this.type.kind}`];
                        return this.eachChild((e => {
                            t.push(e.serialize())
                        }
                        )),
                        t
                    }
                }
                var Ke = Ye;
                const Je = ["Unknown", "Point", "LineString", "Polygon"];
                var Qe = class {
                    constructor() {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = {},
                        this.availableImages = null,
                        this.canonical = null,
                        this.featureTileCoord = null,
                        this.featureDistanceData = null
                    }
                    id() {
                        return this.feature && void 0 !== this.feature.id ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? "number" == typeof this.feature.type ? Je[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    distanceFromCenter() {
                        if (this.featureTileCoord && this.featureDistanceData) {
                            const t = this.featureDistanceData.center
                              , e = this.featureDistanceData.scale
                              , {x: i, y: n} = this.featureTileCoord;
                            return this.featureDistanceData.bearing[0] * (i * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1])
                        }
                        return 0
                    }
                    parseColor(t) {
                        let e = this._parseColorCache[t];
                        return e || (e = this._parseColorCache[t] = Oe.parse(t)),
                        e
                    }
                }
                ;
                class ti {
                    constructor(t, e, i, n) {
                        this.name = t,
                        this.type = e,
                        this._evaluate = i,
                        this.args = n
                    }
                    evaluate(t) {
                        return this._evaluate(t, this.args)
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return [this.name].concat(this.args.map((t => t.serialize())))
                    }
                    static parse(t, e) {
                        const i = t[0]
                          , n = ti.definitions[i];
                        if (!n)
                            return e.error(`Unknown expression "${i}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const r = Array.isArray(n) ? n[0] : n.type
                          , o = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads
                          , s = o.filter(( ([e]) => !Array.isArray(e) || e.length === t.length - 1));
                        let a = null;
                        for (const [n,o] of s) {
                            a = new Ai(e.registry,e.path,null,e.scope);
                            const s = [];
                            let l = !1;
                            for (let e = 1; e < t.length; e++) {
                                const i = t[e]
                                  , r = Array.isArray(n) ? n[e - 1] : n.type
                                  , o = a.parse(i, 1 + s.length, r);
                                if (!o) {
                                    l = !0;
                                    break
                                }
                                s.push(o)
                            }
                            if (!l)
                                if (Array.isArray(n) && n.length !== s.length)
                                    a.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);
                                else {
                                    for (let t = 0; t < s.length; t++) {
                                        const e = Array.isArray(n) ? n[t] : n.type
                                          , i = s[t];
                                        a.concat(t + 1).checkSubtype(e, i.type)
                                    }
                                    if (0 === a.errors.length)
                                        return new ti(i,r,o,s)
                                }
                        }
                        if (1 === s.length)
                            e.errors.push(...a.errors);
                        else {
                            const i = (s.length ? s : o).map(( ([t]) => {
                                return e = t,
                                Array.isArray(e) ? `(${e.map(xe).join(", ")})` : `(${xe(e.type)}...)`;
                                var e
                            }
                            )).join(" | ")
                              , n = [];
                            for (let i = 1; i < t.length; i++) {
                                const r = e.parse(t[i], 1 + n.length);
                                if (!r)
                                    return null;
                                n.push(xe(r.type))
                            }
                            e.error(`Expected arguments of type ${i}, but found (${n.join(", ")}) instead.`)
                        }
                        return null
                    }
                    static register(t, e) {
                        ti.definitions = e;
                        for (const i in e)
                            t[i] = ti
                    }
                }
                var ei = ti;
                class ii {
                    constructor(t, e, i) {
                        this.type = ge,
                        this.locale = i,
                        this.caseSensitive = t,
                        this.diacriticSensitive = e
                    }
                    static parse(t, e) {
                        if (2 !== t.length)
                            return e.error("Expected one argument.");
                        const i = t[1];
                        if ("object" != typeof i || Array.isArray(i))
                            return e.error("Collator options argument must be an object.");
                        const n = e.parse(void 0 !== i["case-sensitive"] && i["case-sensitive"], 1, de);
                        if (!n)
                            return null;
                        const r = e.parse(void 0 !== i["diacritic-sensitive"] && i["diacritic-sensitive"], 1, de);
                        if (!r)
                            return null;
                        let o = null;
                        return i.locale && (o = e.parse(i.locale, 1, ue),
                        !o) ? null : new ii(n,r,o)
                    }
                    evaluate(t) {
                        return new Re(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
                    }
                    eachChild(t) {
                        t(this.caseSensitive),
                        t(this.diacriticSensitive),
                        this.locale && t(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const t = {};
                        return t["case-sensitive"] = this.caseSensitive.serialize(),
                        t["diacritic-sensitive"] = this.diacriticSensitive.serialize(),
                        this.locale && (t.locale = this.locale.serialize()),
                        ["collator", t]
                    }
                }
                const ni = 8192;
                function ri(t, e) {
                    t[0] = Math.min(t[0], e[0]),
                    t[1] = Math.min(t[1], e[1]),
                    t[2] = Math.max(t[2], e[0]),
                    t[3] = Math.max(t[3], e[1])
                }
                function oi(t, e) {
                    return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3])
                }
                function si(t, e) {
                    const i = (180 + t[0]) / 360
                      , n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360
                      , r = Math.pow(2, e.z);
                    return [Math.round(i * r * ni), Math.round(n * r * ni)]
                }
                function ai(t, e, i) {
                    const n = t[0] - e[0]
                      , r = t[1] - e[1]
                      , o = t[0] - i[0]
                      , s = t[1] - i[1];
                    return n * s - o * r == 0 && n * o <= 0 && r * s <= 0
                }
                function li(t, e) {
                    let i = !1;
                    for (let s = 0, a = e.length; s < a; s++) {
                        const a = e[s];
                        for (let e = 0, s = a.length; e < s - 1; e++) {
                            if (ai(t, a[e], a[e + 1]))
                                return !1;
                            (r = a[e])[1] > (n = t)[1] != (o = a[e + 1])[1] > n[1] && n[0] < (o[0] - r[0]) * (n[1] - r[1]) / (o[1] - r[1]) + r[0] && (i = !i)
                        }
                    }
                    var n, r, o;
                    return i
                }
                function ci(t, e) {
                    for (let i = 0; i < e.length; i++)
                        if (li(t, e[i]))
                            return !0;
                    return !1
                }
                function hi(t, e, i, n) {
                    const r = n[0] - i[0]
                      , o = n[1] - i[1]
                      , s = (t[0] - i[0]) * o - r * (t[1] - i[1])
                      , a = (e[0] - i[0]) * o - r * (e[1] - i[1]);
                    return s > 0 && a < 0 || s < 0 && a > 0
                }
                function ui(t, e, i) {
                    for (const c of i)
                        for (let i = 0; i < c.length - 1; ++i)
                            if (0 != (a = [(s = c[i + 1])[0] - (o = c[i])[0], s[1] - o[1]])[0] * (l = [(r = e)[0] - (n = t)[0], r[1] - n[1]])[1] - a[1] * l[0] && hi(n, r, o, s) && hi(o, s, n, r))
                                return !0;
                    var n, r, o, s, a, l;
                    return !1
                }
                function di(t, e) {
                    for (let i = 0; i < t.length; ++i)
                        if (!li(t[i], e))
                            return !1;
                    for (let i = 0; i < t.length - 1; ++i)
                        if (ui(t[i], t[i + 1], e))
                            return !1;
                    return !0
                }
                function fi(t, e) {
                    for (let i = 0; i < e.length; i++)
                        if (di(t, e[i]))
                            return !0;
                    return !1
                }
                function pi(t, e, i) {
                    const n = [];
                    for (let r = 0; r < t.length; r++) {
                        const o = [];
                        for (let n = 0; n < t[r].length; n++) {
                            const s = si(t[r][n], i);
                            ri(e, s),
                            o.push(s)
                        }
                        n.push(o)
                    }
                    return n
                }
                function mi(t, e, i) {
                    const n = [];
                    for (let r = 0; r < t.length; r++) {
                        const o = pi(t[r], e, i);
                        n.push(o)
                    }
                    return n
                }
                function gi(t, e, i, n) {
                    if (t[0] < i[0] || t[0] > i[2]) {
                        const e = .5 * n;
                        let r = t[0] - i[0] > e ? -n : i[0] - t[0] > e ? n : 0;
                        0 === r && (r = t[0] - i[2] > e ? -n : i[2] - t[0] > e ? n : 0),
                        t[0] += r
                    }
                    ri(e, t)
                }
                function _i(t, e, i, n) {
                    const r = Math.pow(2, n.z) * ni
                      , o = [n.x * ni, n.y * ni]
                      , s = [];
                    if (!t)
                        return s;
                    for (const n of t)
                        for (const t of n) {
                            const n = [t.x + o[0], t.y + o[1]];
                            gi(n, e, i, r),
                            s.push(n)
                        }
                    return s
                }
                function yi(t, e, i, n) {
                    const r = Math.pow(2, n.z) * ni
                      , o = [n.x * ni, n.y * ni]
                      , s = [];
                    if (!t)
                        return s;
                    for (const i of t) {
                        const t = [];
                        for (const n of i) {
                            const i = [n.x + o[0], n.y + o[1]];
                            ri(e, i),
                            t.push(i)
                        }
                        s.push(t)
                    }
                    if (e[2] - e[0] <= r / 2) {
                        (a = e)[0] = a[1] = 1 / 0,
                        a[2] = a[3] = -1 / 0;
                        for (const t of s)
                            for (const n of t)
                                gi(n, e, i, r)
                    }
                    var a;
                    return s
                }
                class vi {
                    constructor(t, e) {
                        this.type = de,
                        this.geojson = t,
                        this.geometries = e
                    }
                    static parse(t, e) {
                        if (2 !== t.length)
                            return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (Fe(t[1])) {
                            const e = t[1];
                            if ("FeatureCollection" === e.type)
                                for (let t = 0; t < e.features.length; ++t) {
                                    const i = e.features[t].geometry.type;
                                    if ("Polygon" === i || "MultiPolygon" === i)
                                        return new vi(e,e.features[t].geometry)
                                }
                            else if ("Feature" === e.type) {
                                const t = e.geometry.type;
                                if ("Polygon" === t || "MultiPolygon" === t)
                                    return new vi(e,e.geometry)
                            } else if ("Polygon" === e.type || "MultiPolygon" === e.type)
                                return new vi(e,e)
                        }
                        return e.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (null != t.geometry() && null != t.canonicalID()) {
                            if ("Point" === t.geometryType())
                                return function(t, e) {
                                    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , r = t.canonicalID();
                                    if (!r)
                                        return !1;
                                    if ("Polygon" === e.type) {
                                        const o = pi(e.coordinates, n, r)
                                          , s = _i(t.geometry(), i, n, r);
                                        if (!oi(i, n))
                                            return !1;
                                        for (const t of s)
                                            if (!li(t, o))
                                                return !1
                                    }
                                    if ("MultiPolygon" === e.type) {
                                        const o = mi(e.coordinates, n, r)
                                          , s = _i(t.geometry(), i, n, r);
                                        if (!oi(i, n))
                                            return !1;
                                        for (const t of s)
                                            if (!ci(t, o))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries);
                            if ("LineString" === t.geometryType())
                                return function(t, e) {
                                    const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , r = t.canonicalID();
                                    if (!r)
                                        return !1;
                                    if ("Polygon" === e.type) {
                                        const o = pi(e.coordinates, n, r)
                                          , s = yi(t.geometry(), i, n, r);
                                        if (!oi(i, n))
                                            return !1;
                                        for (const t of s)
                                            if (!di(t, o))
                                                return !1
                                    }
                                    if ("MultiPolygon" === e.type) {
                                        const o = mi(e.coordinates, n, r)
                                          , s = yi(t.geometry(), i, n, r);
                                        if (!oi(i, n))
                                            return !1;
                                        for (const t of s)
                                            if (!fi(t, o))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return ["within", this.geojson]
                    }
                }
                var xi = vi;
                function bi(t) {
                    if (t instanceof ei) {
                        if ("get" === t.name && 1 === t.args.length)
                            return !1;
                        if ("feature-state" === t.name)
                            return !1;
                        if ("has" === t.name && 1 === t.args.length)
                            return !1;
                        if ("properties" === t.name || "geometry-type" === t.name || "id" === t.name)
                            return !1;
                        if (/^filter-/.test(t.name))
                            return !1
                    }
                    if (t instanceof xi)
                        return !1;
                    let e = !0;
                    return t.eachChild((t => {
                        e && !bi(t) && (e = !1)
                    }
                    )),
                    e
                }
                function wi(t) {
                    if (t instanceof ei && "feature-state" === t.name)
                        return !1;
                    let e = !0;
                    return t.eachChild((t => {
                        e && !wi(t) && (e = !1)
                    }
                    )),
                    e
                }
                function Ei(t, e) {
                    if (t instanceof ei && e.indexOf(t.name) >= 0)
                        return !1;
                    let i = !0;
                    return t.eachChild((t => {
                        i && !Ei(t, e) && (i = !1)
                    }
                    )),
                    i
                }
                class Ti {
                    constructor(t, e) {
                        this.type = e.type,
                        this.name = t,
                        this.boundExpression = e
                    }
                    static parse(t, e) {
                        if (2 !== t.length || "string" != typeof t[1])
                            return e.error("'var' expression requires exactly one string literal argument.");
                        const i = t[1];
                        return e.scope.has(i) ? new Ti(i,e.scope.get(i)) : e.error(`Unknown variable "${i}". Make sure "${i}" has been bound in an enclosing "let" expression before using it.`, 1)
                    }
                    evaluate(t) {
                        return this.boundExpression.evaluate(t)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return ["var", this.name]
                    }
                }
                var Si = Ti;
                class Ci {
                    constructor(t, e=[], i, n=new le, r=[]) {
                        this.registry = t,
                        this.path = e,
                        this.key = e.map((t => `[${t}]`)).join(""),
                        this.scope = n,
                        this.errors = r,
                        this.expectedType = i
                    }
                    parse(t, e, i, n, r={}) {
                        return e ? this.concat(e, i, n)._parse(t, r) : this._parse(t, r)
                    }
                    _parse(t, e) {
                        function i(t, e, i) {
                            return "assert" === i ? new We(e,[t]) : "coerce" === i ? new Ke(e,[t]) : t
                        }
                        if (null !== t && "string" != typeof t && "boolean" != typeof t && "number" != typeof t || (t = ["literal", t]),
                        Array.isArray(t)) {
                            if (0 === t.length)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const n = t[0];
                            if ("string" != typeof n)
                                return this.error(`Expression name must be a string, but found ${typeof n} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                                null;
                            const r = this.registry[n];
                            if (r) {
                                let n = r.parse(t, this);
                                if (!n)
                                    return null;
                                if (this.expectedType) {
                                    const t = this.expectedType
                                      , r = n.type;
                                    if ("string" !== t.kind && "number" !== t.kind && "boolean" !== t.kind && "object" !== t.kind && "array" !== t.kind || "value" !== r.kind)
                                        if ("color" !== t.kind && "formatted" !== t.kind && "resolvedImage" !== t.kind || "value" !== r.kind && "string" !== r.kind) {
                                            if (this.checkSubtype(t, r))
                                                return null
                                        } else
                                            n = i(n, t, e.typeAnnotation || "coerce");
                                    else
                                        n = i(n, t, e.typeAnnotation || "assert")
                                }
                                if (!(n instanceof Ve) && "resolvedImage" !== n.type.kind && Ii(n)) {
                                    const e = new Qe;
                                    try {
                                        n = new Ve(n.type,n.evaluate(e))
                                    } catch (t) {
                                        return this.error(t.message),
                                        null
                                    }
                                }
                                return n
                            }
                            return this.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0)
                        }
                        return this.error(void 0 === t ? "'undefined' value invalid. Use null instead." : "object" == typeof t ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
                    }
                    concat(t, e, i) {
                        const n = "number" == typeof t ? this.path.concat(t) : this.path
                          , r = i ? this.scope.concat(i) : this.scope;
                        return new Ci(this.registry,n,e || null,r,this.errors)
                    }
                    error(t, ...e) {
                        const i = `${this.key}${e.map((t => `[${t}]`)).join("")}`;
                        this.errors.push(new se(i,t))
                    }
                    checkSubtype(t, e) {
                        const i = we(t, e);
                        return i && this.error(i),
                        i
                    }
                }
                var Ai = Ci;
                function Ii(t) {
                    if (t instanceof Si)
                        return Ii(t.boundExpression);
                    if (t instanceof ei && "error" === t.name)
                        return !1;
                    if (t instanceof ii)
                        return !1;
                    if (t instanceof xi)
                        return !1;
                    const e = t instanceof Ke || t instanceof We;
                    let i = !0;
                    return t.eachChild((t => {
                        i = e ? i && Ii(t) : i && t instanceof Ve
                    }
                    )),
                    !!i && bi(t) && Ei(t, ["zoom", "heatmap-density", "line-progress", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center"])
                }
                function Mi(t, e) {
                    const i = t.length - 1;
                    let n, r, o = 0, s = i, a = 0;
                    for (; o <= s; )
                        if (a = Math.floor((o + s) / 2),
                        n = t[a],
                        r = t[a + 1],
                        n <= e) {
                            if (a === i || e < r)
                                return a;
                            o = a + 1
                        } else {
                            if (!(n > e))
                                throw new Ge("Input is not a number.");
                            s = a - 1
                        }
                    return 0
                }
                class Pi {
                    constructor(t, e, i) {
                        this.type = t,
                        this.input = e,
                        this.labels = [],
                        this.outputs = [];
                        for (const [t,e] of i)
                            this.labels.push(t),
                            this.outputs.push(e)
                    }
                    static parse(t, e) {
                        if (t.length - 1 < 4)
                            return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return e.error("Expected an even number of arguments.");
                        const i = e.parse(t[1], 1, he);
                        if (!i)
                            return null;
                        const n = [];
                        let r = null;
                        e.expectedType && "value" !== e.expectedType.kind && (r = e.expectedType);
                        for (let i = 1; i < t.length; i += 2) {
                            const o = 1 === i ? -1 / 0 : t[i]
                              , s = t[i + 1]
                              , a = i
                              , l = i + 1;
                            if ("number" != typeof o)
                                return e.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a);
                            if (n.length && n[n.length - 1][0] >= o)
                                return e.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a);
                            const c = e.parse(s, l, r);
                            if (!c)
                                return null;
                            r = r || c.type,
                            n.push([o, c])
                        }
                        return new Pi(r,i,n)
                    }
                    evaluate(t) {
                        const e = this.labels
                          , i = this.outputs;
                        if (1 === e.length)
                            return i[0].evaluate(t);
                        const n = this.input.evaluate(t);
                        if (n <= e[0])
                            return i[0].evaluate(t);
                        const r = e.length;
                        return n >= e[r - 1] ? i[r - 1].evaluate(t) : i[Mi(e, n)].evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const e of this.outputs)
                            t(e)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined()))
                    }
                    serialize() {
                        const t = ["step", this.input.serialize()];
                        for (let e = 0; e < this.labels.length; e++)
                            e > 0 && t.push(this.labels[e]),
                            t.push(this.outputs[e].serialize());
                        return t
                    }
                }
                var ki = Pi;
                function Oi(t, e, i) {
                    return t * (1 - i) + e * i
                }
                var Ri = Object.freeze({
                    __proto__: null,
                    array: function(t, e, i) {
                        return t.map(( (t, n) => Oi(t, e[n], i)))
                    },
                    color: function(t, e, i) {
                        return new Oe(Oi(t.r, e.r, i),Oi(t.g, e.g, i),Oi(t.b, e.b, i),Oi(t.a, e.a, i))
                    },
                    number: Oi
                });
                const Di = .95047
                  , Li = 1.08883
                  , Bi = 4 / 29
                  , zi = 6 / 29
                  , Fi = 3 * zi * zi
                  , Ni = zi * zi * zi
                  , ji = Math.PI / 180
                  , Ui = 180 / Math.PI;
                function Vi(t) {
                    return t > Ni ? Math.pow(t, 1 / 3) : t / Fi + Bi
                }
                function Gi(t) {
                    return t > zi ? t * t * t : Fi * (t - Bi)
                }
                function Zi(t) {
                    return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055)
                }
                function qi(t) {
                    return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)
                }
                function Wi(t) {
                    const e = qi(t.r)
                      , i = qi(t.g)
                      , n = qi(t.b)
                      , r = Vi((.4124564 * e + .3575761 * i + .1804375 * n) / Di)
                      , o = Vi((.2126729 * e + .7151522 * i + .072175 * n) / 1);
                    return {
                        l: 116 * o - 16,
                        a: 500 * (r - o),
                        b: 200 * (o - Vi((.0193339 * e + .119192 * i + .9503041 * n) / Li)),
                        alpha: t.a
                    }
                }
                function Hi(t) {
                    let e = (t.l + 16) / 116
                      , i = isNaN(t.a) ? e : e + t.a / 500
                      , n = isNaN(t.b) ? e : e - t.b / 200;
                    return e = 1 * Gi(e),
                    i = Di * Gi(i),
                    n = Li * Gi(n),
                    new Oe(Zi(3.2404542 * i - 1.5371385 * e - .4985314 * n),Zi(-.969266 * i + 1.8760108 * e + .041556 * n),Zi(.0556434 * i - .2040259 * e + 1.0572252 * n),t.alpha)
                }
                function $i(t, e, i) {
                    const n = e - t;
                    return t + i * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n)
                }
                const Xi = {
                    forward: Wi,
                    reverse: Hi,
                    interpolate: function(t, e, i) {
                        return {
                            l: Oi(t.l, e.l, i),
                            a: Oi(t.a, e.a, i),
                            b: Oi(t.b, e.b, i),
                            alpha: Oi(t.alpha, e.alpha, i)
                        }
                    }
                }
                  , Yi = {
                    forward: function(t) {
                        const {l: e, a: i, b: n} = Wi(t)
                          , r = Math.atan2(n, i) * Ui;
                        return {
                            h: r < 0 ? r + 360 : r,
                            c: Math.sqrt(i * i + n * n),
                            l: e,
                            alpha: t.a
                        }
                    },
                    reverse: function(t) {
                        const e = t.h * ji
                          , i = t.c;
                        return Hi({
                            l: t.l,
                            a: Math.cos(e) * i,
                            b: Math.sin(e) * i,
                            alpha: t.alpha
                        })
                    },
                    interpolate: function(t, e, i) {
                        return {
                            h: $i(t.h, e.h, i),
                            c: Oi(t.c, e.c, i),
                            l: Oi(t.l, e.l, i),
                            alpha: Oi(t.alpha, e.alpha, i)
                        }
                    }
                };
                var Ki = Object.freeze({
                    __proto__: null,
                    hcl: Yi,
                    lab: Xi
                });
                class Ji {
                    constructor(t, e, i, n, r) {
                        this.type = t,
                        this.operator = e,
                        this.interpolation = i,
                        this.input = n,
                        this.labels = [],
                        this.outputs = [];
                        for (const [t,e] of r)
                            this.labels.push(t),
                            this.outputs.push(e)
                    }
                    static interpolationFactor(t, e, i, n) {
                        let r = 0;
                        if ("exponential" === t.name)
                            r = Qi(e, t.base, i, n);
                        else if ("linear" === t.name)
                            r = Qi(e, 1, i, n);
                        else if ("cubic-bezier" === t.name) {
                            const o = t.controlPoints;
                            r = new g(o[0],o[1],o[2],o[3]).solve(Qi(e, 1, i, n))
                        }
                        return r
                    }
                    static parse(t, e) {
                        let[i,n,r,...o] = t;
                        if (!Array.isArray(n) || 0 === n.length)
                            return e.error("Expected an interpolation type expression.", 1);
                        if ("linear" === n[0])
                            n = {
                                name: "linear"
                            };
                        else if ("exponential" === n[0]) {
                            const t = n[1];
                            if ("number" != typeof t)
                                return e.error("Exponential interpolation requires a numeric base.", 1, 1);
                            n = {
                                name: "exponential",
                                base: t
                            }
                        } else {
                            if ("cubic-bezier" !== n[0])
                                return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
                            {
                                const t = n.slice(1);
                                if (4 !== t.length || t.some((t => "number" != typeof t || t < 0 || t > 1)))
                                    return e.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                n = {
                                    name: "cubic-bezier",
                                    controlPoints: t
                                }
                            }
                        }
                        if (t.length - 1 < 4)
                            return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return e.error("Expected an even number of arguments.");
                        if (r = e.parse(r, 2, he),
                        !r)
                            return null;
                        const s = [];
                        let a = null;
                        "interpolate-hcl" === i || "interpolate-lab" === i ? a = fe : e.expectedType && "value" !== e.expectedType.kind && (a = e.expectedType);
                        for (let t = 0; t < o.length; t += 2) {
                            const i = o[t]
                              , n = o[t + 1]
                              , r = t + 3
                              , l = t + 4;
                            if ("number" != typeof i)
                                return e.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', r);
                            if (s.length && s[s.length - 1][0] >= i)
                                return e.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', r);
                            const c = e.parse(n, l, a);
                            if (!c)
                                return null;
                            a = a || c.type,
                            s.push([i, c])
                        }
                        return "number" === a.kind || "color" === a.kind || "array" === a.kind && "number" === a.itemType.kind && "number" == typeof a.N ? new Ji(a,i,n,r,s) : e.error(`Type ${xe(a)} is not interpolatable.`)
                    }
                    evaluate(t) {
                        const e = this.labels
                          , i = this.outputs;
                        if (1 === e.length)
                            return i[0].evaluate(t);
                        const n = this.input.evaluate(t);
                        if (n <= e[0])
                            return i[0].evaluate(t);
                        const r = e.length;
                        if (n >= e[r - 1])
                            return i[r - 1].evaluate(t);
                        const o = Mi(e, n)
                          , s = Ji.interpolationFactor(this.interpolation, n, e[o], e[o + 1])
                          , a = i[o].evaluate(t)
                          , l = i[o + 1].evaluate(t);
                        return "interpolate" === this.operator ? Ri[this.type.kind.toLowerCase()](a, l, s) : "interpolate-hcl" === this.operator ? Yi.reverse(Yi.interpolate(Yi.forward(a), Yi.forward(l), s)) : Xi.reverse(Xi.interpolate(Xi.forward(a), Xi.forward(l), s))
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const e of this.outputs)
                            t(e)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined()))
                    }
                    serialize() {
                        let t;
                        t = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
                        const e = [this.operator, t, this.input.serialize()];
                        for (let t = 0; t < this.labels.length; t++)
                            e.push(this.labels[t], this.outputs[t].serialize());
                        return e
                    }
                }
                function Qi(t, e, i, n) {
                    const r = n - i
                      , o = t - i;
                    return 0 === r ? 0 : 1 === e ? o / r : (Math.pow(e, o) - 1) / (Math.pow(e, r) - 1)
                }
                var tn = Ji;
                class en {
                    constructor(t, e) {
                        this.type = t,
                        this.args = e
                    }
                    static parse(t, e) {
                        if (t.length < 2)
                            return e.error("Expectected at least one argument.");
                        let i = null;
                        const n = e.expectedType;
                        n && "value" !== n.kind && (i = n);
                        const r = [];
                        for (const n of t.slice(1)) {
                            const t = e.parse(n, 1 + r.length, i, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!t)
                                return null;
                            i = i || t.type,
                            r.push(t)
                        }
                        const o = n && r.some((t => we(n, t.type)));
                        return new en(o ? me : i,r)
                    }
                    evaluate(t) {
                        let e, i = null, n = 0;
                        for (const r of this.args) {
                            if (n++,
                            i = r.evaluate(t),
                            i && i instanceof Be && !i.available && (e || (e = i),
                            i = null,
                            n === this.args.length))
                                return e;
                            if (null !== i)
                                break
                        }
                        return i
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every((t => t.outputDefined()))
                    }
                    serialize() {
                        const t = ["coalesce"];
                        return this.eachChild((e => {
                            t.push(e.serialize())
                        }
                        )),
                        t
                    }
                }
                var nn = en;
                class rn {
                    constructor(t, e) {
                        this.type = e.type,
                        this.bindings = [].concat(t),
                        this.result = e
                    }
                    evaluate(t) {
                        return this.result.evaluate(t)
                    }
                    eachChild(t) {
                        for (const e of this.bindings)
                            t(e[1]);
                        t(this.result)
                    }
                    static parse(t, e) {
                        if (t.length < 4)
                            return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                        const i = [];
                        for (let n = 1; n < t.length - 1; n += 2) {
                            const r = t[n];
                            if ("string" != typeof r)
                                return e.error(`Expected string, but found ${typeof r} instead.`, n);
                            if (/[^a-zA-Z0-9_]/.test(r))
                                return e.error("Variable names must contain only alphanumeric characters or '_'.", n);
                            const o = e.parse(t[n + 1], n + 1);
                            if (!o)
                                return null;
                            i.push([r, o])
                        }
                        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, i);
                        return n ? new rn(i,n) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                    serialize() {
                        const t = ["let"];
                        for (const [e,i] of this.bindings)
                            t.push(e, i.serialize());
                        return t.push(this.result.serialize()),
                        t
                    }
                }
                var on = rn;
                class sn {
                    constructor(t, e, i) {
                        this.type = t,
                        this.index = e,
                        this.input = i
                    }
                    static parse(t, e) {
                        if (3 !== t.length)
                            return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const i = e.parse(t[1], 1, he)
                          , n = e.parse(t[2], 2, ve(e.expectedType || me));
                        return i && n ? new sn(n.type.itemType,i,n) : null
                    }
                    evaluate(t) {
                        const e = this.index.evaluate(t)
                          , i = this.input.evaluate(t);
                        if (e < 0)
                            throw new Ge(`Array index out of bounds: ${e} < 0.`);
                        if (e >= i.length)
                            throw new Ge(`Array index out of bounds: ${e} > ${i.length - 1}.`);
                        if (e !== Math.floor(e))
                            throw new Ge(`Array index must be an integer, but found ${e} instead.`);
                        return i[e]
                    }
                    eachChild(t) {
                        t(this.index),
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return ["at", this.index.serialize(), this.input.serialize()]
                    }
                }
                var an = sn;
                class ln {
                    constructor(t, e) {
                        this.type = de,
                        this.needle = t,
                        this.haystack = e
                    }
                    static parse(t, e) {
                        if (3 !== t.length)
                            return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const i = e.parse(t[1], 1, me)
                          , n = e.parse(t[2], 2, me);
                        return i && n ? Ee(i.type, [de, ue, he, ce, me]) ? new ln(i,n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${xe(i.type)} instead`) : null
                    }
                    evaluate(t) {
                        const e = this.needle.evaluate(t)
                          , i = this.haystack.evaluate(t);
                        if (null == i)
                            return !1;
                        if (!Te(e, ["boolean", "string", "number", "null"]))
                            throw new Ge(`Expected first argument to be of type boolean, string, number or null, but found ${xe(Ne(e))} instead.`);
                        if (!Te(i, ["string", "array"]))
                            throw new Ge(`Expected second argument to be of type array or string, but found ${xe(Ne(i))} instead.`);
                        return i.indexOf(e) >= 0
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                    serialize() {
                        return ["in", this.needle.serialize(), this.haystack.serialize()]
                    }
                }
                var cn = ln;
                class hn {
                    constructor(t, e, i) {
                        this.type = he,
                        this.needle = t,
                        this.haystack = e,
                        this.fromIndex = i
                    }
                    static parse(t, e) {
                        if (t.length <= 2 || t.length >= 5)
                            return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const i = e.parse(t[1], 1, me)
                          , n = e.parse(t[2], 2, me);
                        if (!i || !n)
                            return null;
                        if (!Ee(i.type, [de, ue, he, ce, me]))
                            return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${xe(i.type)} instead`);
                        if (4 === t.length) {
                            const r = e.parse(t[3], 3, he);
                            return r ? new hn(i,n,r) : null
                        }
                        return new hn(i,n)
                    }
                    evaluate(t) {
                        const e = this.needle.evaluate(t)
                          , i = this.haystack.evaluate(t);
                        if (!Te(e, ["boolean", "string", "number", "null"]))
                            throw new Ge(`Expected first argument to be of type boolean, string, number or null, but found ${xe(Ne(e))} instead.`);
                        if (!Te(i, ["string", "array"]))
                            throw new Ge(`Expected second argument to be of type array or string, but found ${xe(Ne(i))} instead.`);
                        if (this.fromIndex) {
                            const n = this.fromIndex.evaluate(t);
                            return i.indexOf(e, n)
                        }
                        return i.indexOf(e)
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack),
                        this.fromIndex && t(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        if (null != this.fromIndex && void 0 !== this.fromIndex) {
                            const t = this.fromIndex.serialize();
                            return ["index-of", this.needle.serialize(), this.haystack.serialize(), t]
                        }
                        return ["index-of", this.needle.serialize(), this.haystack.serialize()]
                    }
                }
                var un = hn;
                class dn {
                    constructor(t, e, i, n, r, o) {
                        this.inputType = t,
                        this.type = e,
                        this.input = i,
                        this.cases = n,
                        this.outputs = r,
                        this.otherwise = o
                    }
                    static parse(t, e) {
                        if (t.length < 5)
                            return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 1)
                            return e.error("Expected an even number of arguments.");
                        let i, n;
                        e.expectedType && "value" !== e.expectedType.kind && (n = e.expectedType);
                        const r = {}
                          , o = [];
                        for (let s = 2; s < t.length - 1; s += 2) {
                            let a = t[s];
                            const l = t[s + 1];
                            Array.isArray(a) || (a = [a]);
                            const c = e.concat(s);
                            if (0 === a.length)
                                return c.error("Expected at least one branch label.");
                            for (const t of a) {
                                if ("number" != typeof t && "string" != typeof t)
                                    return c.error("Branch labels must be numbers or strings.");
                                if ("number" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER)
                                    return c.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if ("number" == typeof t && Math.floor(t) !== t)
                                    return c.error("Numeric branch labels must be integer values.");
                                if (i) {
                                    if (c.checkSubtype(i, Ne(t)))
                                        return null
                                } else
                                    i = Ne(t);
                                if (void 0 !== r[String(t)])
                                    return c.error("Branch labels must be unique.");
                                r[String(t)] = o.length
                            }
                            const h = e.parse(l, s, n);
                            if (!h)
                                return null;
                            n = n || h.type,
                            o.push(h)
                        }
                        const s = e.parse(t[1], 1, me);
                        if (!s)
                            return null;
                        const a = e.parse(t[t.length - 1], t.length - 1, n);
                        return a ? "value" !== s.type.kind && e.concat(1).checkSubtype(i, s.type) ? null : new dn(i,n,s,r,o,a) : null
                    }
                    evaluate(t) {
                        const e = this.input.evaluate(t);
                        return (Ne(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input),
                        this.outputs.forEach(t),
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every((t => t.outputDefined())) && this.otherwise.outputDefined()
                    }
                    serialize() {
                        const t = ["match", this.input.serialize()]
                          , e = Object.keys(this.cases).sort()
                          , i = []
                          , n = {};
                        for (const t of e) {
                            const e = n[this.cases[t]];
                            void 0 === e ? (n[this.cases[t]] = i.length,
                            i.push([this.cases[t], [t]])) : i[e][1].push(t)
                        }
                        const r = t => "number" === this.inputType.kind ? Number(t) : t;
                        for (const [e,n] of i)
                            t.push(1 === n.length ? r(n[0]) : n.map(r)),
                            t.push(this.outputs[e].serialize());
                        return t.push(this.otherwise.serialize()),
                        t
                    }
                }
                var fn = dn;
                class pn {
                    constructor(t, e, i) {
                        this.type = t,
                        this.branches = e,
                        this.otherwise = i
                    }
                    static parse(t, e) {
                        if (t.length < 4)
                            return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 0)
                            return e.error("Expected an odd number of arguments.");
                        let i;
                        e.expectedType && "value" !== e.expectedType.kind && (i = e.expectedType);
                        const n = [];
                        for (let r = 1; r < t.length - 1; r += 2) {
                            const o = e.parse(t[r], r, de);
                            if (!o)
                                return null;
                            const s = e.parse(t[r + 1], r + 1, i);
                            if (!s)
                                return null;
                            n.push([o, s]),
                            i = i || s.type
                        }
                        const r = e.parse(t[t.length - 1], t.length - 1, i);
                        return r ? new pn(i,n,r) : null
                    }
                    evaluate(t) {
                        for (const [e,i] of this.branches)
                            if (e.evaluate(t))
                                return i.evaluate(t);
                        return this.otherwise.evaluate(t)
                    }
                    eachChild(t) {
                        for (const [e,i] of this.branches)
                            t(e),
                            t(i);
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every(( ([t,e]) => e.outputDefined())) && this.otherwise.outputDefined()
                    }
                    serialize() {
                        const t = ["case"];
                        return this.eachChild((e => {
                            t.push(e.serialize())
                        }
                        )),
                        t
                    }
                }
                var mn = pn;
                class gn {
                    constructor(t, e, i, n) {
                        this.type = t,
                        this.input = e,
                        this.beginIndex = i,
                        this.endIndex = n
                    }
                    static parse(t, e) {
                        if (t.length <= 2 || t.length >= 5)
                            return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const i = e.parse(t[1], 1, me)
                          , n = e.parse(t[2], 2, he);
                        if (!i || !n)
                            return null;
                        if (!Ee(i.type, [ve(me), ue, me]))
                            return e.error(`Expected first argument to be of type array or string, but found ${xe(i.type)} instead`);
                        if (4 === t.length) {
                            const r = e.parse(t[3], 3, he);
                            return r ? new gn(i.type,i,n,r) : null
                        }
                        return new gn(i.type,i,n)
                    }
                    evaluate(t) {
                        const e = this.input.evaluate(t)
                          , i = this.beginIndex.evaluate(t);
                        if (!Te(e, ["string", "array"]))
                            throw new Ge(`Expected first argument to be of type array or string, but found ${xe(Ne(e))} instead.`);
                        if (this.endIndex) {
                            const n = this.endIndex.evaluate(t);
                            return e.slice(i, n)
                        }
                        return e.slice(i)
                    }
                    eachChild(t) {
                        t(this.input),
                        t(this.beginIndex),
                        this.endIndex && t(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        if (null != this.endIndex && void 0 !== this.endIndex) {
                            const t = this.endIndex.serialize();
                            return ["slice", this.input.serialize(), this.beginIndex.serialize(), t]
                        }
                        return ["slice", this.input.serialize(), this.beginIndex.serialize()]
                    }
                }
                var _n = gn;
                function yn(t, e) {
                    return "==" === t || "!=" === t ? "boolean" === e.kind || "string" === e.kind || "number" === e.kind || "null" === e.kind || "value" === e.kind : "string" === e.kind || "number" === e.kind || "value" === e.kind
                }
                function vn(t, e, i, n) {
                    return 0 === n.compare(e, i)
                }
                function xn(t, e, i) {
                    const n = "==" !== t && "!=" !== t;
                    return class r {
                        constructor(t, e, i) {
                            this.type = de,
                            this.lhs = t,
                            this.rhs = e,
                            this.collator = i,
                            this.hasUntypedArgument = "value" === t.type.kind || "value" === e.type.kind
                        }
                        static parse(t, e) {
                            if (3 !== t.length && 4 !== t.length)
                                return e.error("Expected two or three arguments.");
                            const i = t[0];
                            let o = e.parse(t[1], 1, me);
                            if (!o)
                                return null;
                            if (!yn(i, o.type))
                                return e.concat(1).error(`"${i}" comparisons are not supported for type '${xe(o.type)}'.`);
                            let s = e.parse(t[2], 2, me);
                            if (!s)
                                return null;
                            if (!yn(i, s.type))
                                return e.concat(2).error(`"${i}" comparisons are not supported for type '${xe(s.type)}'.`);
                            if (o.type.kind !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind)
                                return e.error(`Cannot compare types '${xe(o.type)}' and '${xe(s.type)}'.`);
                            n && ("value" === o.type.kind && "value" !== s.type.kind ? o = new We(s.type,[o]) : "value" !== o.type.kind && "value" === s.type.kind && (s = new We(o.type,[s])));
                            let a = null;
                            if (4 === t.length) {
                                if ("string" !== o.type.kind && "string" !== s.type.kind && "value" !== o.type.kind && "value" !== s.type.kind)
                                    return e.error("Cannot use collator to compare non-string types.");
                                if (a = e.parse(t[3], 3, ge),
                                !a)
                                    return null
                            }
                            return new r(o,s,a)
                        }
                        evaluate(r) {
                            const o = this.lhs.evaluate(r)
                              , s = this.rhs.evaluate(r);
                            if (n && this.hasUntypedArgument) {
                                const e = Ne(o)
                                  , i = Ne(s);
                                if (e.kind !== i.kind || "string" !== e.kind && "number" !== e.kind)
                                    throw new Ge(`Expected arguments for "${t}" to be (string, string) or (number, number), but found (${e.kind}, ${i.kind}) instead.`)
                            }
                            if (this.collator && !n && this.hasUntypedArgument) {
                                const t = Ne(o)
                                  , i = Ne(s);
                                if ("string" !== t.kind || "string" !== i.kind)
                                    return e(r, o, s)
                            }
                            return this.collator ? i(r, o, s, this.collator.evaluate(r)) : e(r, o, s)
                        }
                        eachChild(t) {
                            t(this.lhs),
                            t(this.rhs),
                            this.collator && t(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                        serialize() {
                            const e = [t];
                            return this.eachChild((t => {
                                e.push(t.serialize())
                            }
                            )),
                            e
                        }
                    }
                }
                const bn = xn("==", (function(t, e, i) {
                    return e === i
                }
                ), vn)
                  , wn = xn("!=", (function(t, e, i) {
                    return e !== i
                }
                ), (function(t, e, i, n) {
                    return !vn(0, e, i, n)
                }
                ))
                  , En = xn("<", (function(t, e, i) {
                    return e < i
                }
                ), (function(t, e, i, n) {
                    return n.compare(e, i) < 0
                }
                ))
                  , Tn = xn(">", (function(t, e, i) {
                    return e > i
                }
                ), (function(t, e, i, n) {
                    return n.compare(e, i) > 0
                }
                ))
                  , Sn = xn("<=", (function(t, e, i) {
                    return e <= i
                }
                ), (function(t, e, i, n) {
                    return n.compare(e, i) <= 0
                }
                ))
                  , Cn = xn(">=", (function(t, e, i) {
                    return e >= i
                }
                ), (function(t, e, i, n) {
                    return n.compare(e, i) >= 0
                }
                ));
                class An {
                    constructor(t, e, i, n, r, o) {
                        this.type = ue,
                        this.number = t,
                        this.locale = e,
                        this.currency = i,
                        this.unit = n,
                        this.minFractionDigits = r,
                        this.maxFractionDigits = o
                    }
                    static parse(t, e) {
                        if (3 !== t.length)
                            return e.error("Expected two arguments.");
                        const i = e.parse(t[1], 1, he);
                        if (!i)
                            return null;
                        const n = t[2];
                        if ("object" != typeof n || Array.isArray(n))
                            return e.error("NumberFormat options argument must be an object.");
                        let r = null;
                        if (n.locale && (r = e.parse(n.locale, 1, ue),
                        !r))
                            return null;
                        let o = null;
                        if (n.currency && (o = e.parse(n.currency, 1, ue),
                        !o))
                            return null;
                        let s = null;
                        if (n.unit && (s = e.parse(n.unit, 1, ue),
                        !s))
                            return null;
                        let a = null;
                        if (n["min-fraction-digits"] && (a = e.parse(n["min-fraction-digits"], 1, he),
                        !a))
                            return null;
                        let l = null;
                        return n["max-fraction-digits"] && (l = e.parse(n["max-fraction-digits"], 1, he),
                        !l) ? null : new An(i,r,o,s,a,l)
                    }
                    evaluate(t) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                            style: (this.currency ? "currency" : this.unit && "unit") || "decimal",
                            currency: this.currency ? this.currency.evaluate(t) : void 0,
                            unit: this.unit ? this.unit.evaluate(t) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                        }).format(this.number.evaluate(t))
                    }
                    eachChild(t) {
                        t(this.number),
                        this.locale && t(this.locale),
                        this.currency && t(this.currency),
                        this.unit && t(this.unit),
                        this.minFractionDigits && t(this.minFractionDigits),
                        this.maxFractionDigits && t(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const t = {};
                        return this.locale && (t.locale = this.locale.serialize()),
                        this.currency && (t.currency = this.currency.serialize()),
                        this.unit && (t.unit = this.unit.serialize()),
                        this.minFractionDigits && (t["min-fraction-digits"] = this.minFractionDigits.serialize()),
                        this.maxFractionDigits && (t["max-fraction-digits"] = this.maxFractionDigits.serialize()),
                        ["number-format", this.number.serialize(), t]
                    }
                }
                class In {
                    constructor(t) {
                        this.type = he,
                        this.input = t
                    }
                    static parse(t, e) {
                        if (2 !== t.length)
                            return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const i = e.parse(t[1], 1);
                        return i ? "array" !== i.type.kind && "string" !== i.type.kind && "value" !== i.type.kind ? e.error(`Expected argument of type string or array, but found ${xe(i.type)} instead.`) : new In(i) : null
                    }
                    evaluate(t) {
                        const e = this.input.evaluate(t);
                        if ("string" == typeof e)
                            return e.length;
                        if (Array.isArray(e))
                            return e.length;
                        throw new Ge(`Expected value to be of type string or array, but found ${xe(Ne(e))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        const t = ["length"];
                        return this.eachChild((e => {
                            t.push(e.serialize())
                        }
                        )),
                        t
                    }
                }
                const Mn = {
                    "==": bn,
                    "!=": wn,
                    ">": Tn,
                    "<": En,
                    ">=": Cn,
                    "<=": Sn,
                    array: We,
                    at: an,
                    boolean: We,
                    case: mn,
                    coalesce: nn,
                    collator: ii,
                    format: He,
                    image: $e,
                    in: cn,
                    "index-of": un,
                    interpolate: tn,
                    "interpolate-hcl": tn,
                    "interpolate-lab": tn,
                    length: In,
                    let: on,
                    literal: Ve,
                    match: fn,
                    number: We,
                    "number-format": An,
                    object: We,
                    slice: _n,
                    step: ki,
                    string: We,
                    "to-boolean": Ke,
                    "to-color": Ke,
                    "to-number": Ke,
                    "to-string": Ke,
                    var: Si,
                    within: xi
                };
                function Pn(t, [e,i,n,r]) {
                    e = e.evaluate(t),
                    i = i.evaluate(t),
                    n = n.evaluate(t);
                    const o = r ? r.evaluate(t) : 1
                      , s = ze(e, i, n, o);
                    if (s)
                        throw new Ge(s);
                    return new Oe(e / 255 * o,i / 255 * o,n / 255 * o,o)
                }
                function kn(t, e) {
                    return t in e
                }
                function On(t, e) {
                    const i = e[t];
                    return void 0 === i ? null : i
                }
                function Rn(t) {
                    return {
                        type: t
                    }
                }
                ei.register(Mn, {
                    error: [{
                        kind: "error"
                    }, [ue], (t, [e]) => {
                        throw new Ge(e.evaluate(t))
                    }
                    ],
                    typeof: [ue, [me], (t, [e]) => xe(Ne(e.evaluate(t)))],
                    "to-rgba": [ve(he, 4), [fe], (t, [e]) => e.evaluate(t).toArray()],
                    rgb: [fe, [he, he, he], Pn],
                    rgba: [fe, [he, he, he, he], Pn],
                    has: {
                        type: de,
                        overloads: [[[ue], (t, [e]) => kn(e.evaluate(t), t.properties())], [[ue, pe], (t, [e,i]) => kn(e.evaluate(t), i.evaluate(t))]]
                    },
                    get: {
                        type: me,
                        overloads: [[[ue], (t, [e]) => On(e.evaluate(t), t.properties())], [[ue, pe], (t, [e,i]) => On(e.evaluate(t), i.evaluate(t))]]
                    },
                    "feature-state": [me, [ue], (t, [e]) => On(e.evaluate(t), t.featureState || {})],
                    properties: [pe, [], t => t.properties()],
                    "geometry-type": [ue, [], t => t.geometryType()],
                    id: [me, [], t => t.id()],
                    zoom: [he, [], t => t.globals.zoom],
                    pitch: [he, [], t => t.globals.pitch || 0],
                    "distance-from-center": [he, [], t => t.distanceFromCenter()],
                    "heatmap-density": [he, [], t => t.globals.heatmapDensity || 0],
                    "line-progress": [he, [], t => t.globals.lineProgress || 0],
                    "sky-radial-progress": [he, [], t => t.globals.skyRadialProgress || 0],
                    accumulated: [me, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],
                    "+": [he, Rn(he), (t, e) => {
                        let i = 0;
                        for (const n of e)
                            i += n.evaluate(t);
                        return i
                    }
                    ],
                    "*": [he, Rn(he), (t, e) => {
                        let i = 1;
                        for (const n of e)
                            i *= n.evaluate(t);
                        return i
                    }
                    ],
                    "-": {
                        type: he,
                        overloads: [[[he, he], (t, [e,i]) => e.evaluate(t) - i.evaluate(t)], [[he], (t, [e]) => -e.evaluate(t)]]
                    },
                    "/": [he, [he, he], (t, [e,i]) => e.evaluate(t) / i.evaluate(t)],
                    "%": [he, [he, he], (t, [e,i]) => e.evaluate(t) % i.evaluate(t)],
                    ln2: [he, [], () => Math.LN2],
                    pi: [he, [], () => Math.PI],
                    e: [he, [], () => Math.E],
                    "^": [he, [he, he], (t, [e,i]) => Math.pow(e.evaluate(t), i.evaluate(t))],
                    sqrt: [he, [he], (t, [e]) => Math.sqrt(e.evaluate(t))],
                    log10: [he, [he], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],
                    ln: [he, [he], (t, [e]) => Math.log(e.evaluate(t))],
                    log2: [he, [he], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],
                    sin: [he, [he], (t, [e]) => Math.sin(e.evaluate(t))],
                    cos: [he, [he], (t, [e]) => Math.cos(e.evaluate(t))],
                    tan: [he, [he], (t, [e]) => Math.tan(e.evaluate(t))],
                    asin: [he, [he], (t, [e]) => Math.asin(e.evaluate(t))],
                    acos: [he, [he], (t, [e]) => Math.acos(e.evaluate(t))],
                    atan: [he, [he], (t, [e]) => Math.atan(e.evaluate(t))],
                    min: [he, Rn(he), (t, e) => Math.min(...e.map((e => e.evaluate(t))))],
                    max: [he, Rn(he), (t, e) => Math.max(...e.map((e => e.evaluate(t))))],
                    abs: [he, [he], (t, [e]) => Math.abs(e.evaluate(t))],
                    round: [he, [he], (t, [e]) => {
                        const i = e.evaluate(t);
                        return i < 0 ? -Math.round(-i) : Math.round(i)
                    }
                    ],
                    floor: [he, [he], (t, [e]) => Math.floor(e.evaluate(t))],
                    ceil: [he, [he], (t, [e]) => Math.ceil(e.evaluate(t))],
                    "filter-==": [de, [ue, me], (t, [e,i]) => t.properties()[e.value] === i.value],
                    "filter-id-==": [de, [me], (t, [e]) => t.id() === e.value],
                    "filter-type-==": [de, [ue], (t, [e]) => t.geometryType() === e.value],
                    "filter-<": [de, [ue, me], (t, [e,i]) => {
                        const n = t.properties()[e.value]
                          , r = i.value;
                        return typeof n == typeof r && n < r
                    }
                    ],
                    "filter-id-<": [de, [me], (t, [e]) => {
                        const i = t.id()
                          , n = e.value;
                        return typeof i == typeof n && i < n
                    }
                    ],
                    "filter->": [de, [ue, me], (t, [e,i]) => {
                        const n = t.properties()[e.value]
                          , r = i.value;
                        return typeof n == typeof r && n > r
                    }
                    ],
                    "filter-id->": [de, [me], (t, [e]) => {
                        const i = t.id()
                          , n = e.value;
                        return typeof i == typeof n && i > n
                    }
                    ],
                    "filter-<=": [de, [ue, me], (t, [e,i]) => {
                        const n = t.properties()[e.value]
                          , r = i.value;
                        return typeof n == typeof r && n <= r
                    }
                    ],
                    "filter-id-<=": [de, [me], (t, [e]) => {
                        const i = t.id()
                          , n = e.value;
                        return typeof i == typeof n && i <= n
                    }
                    ],
                    "filter->=": [de, [ue, me], (t, [e,i]) => {
                        const n = t.properties()[e.value]
                          , r = i.value;
                        return typeof n == typeof r && n >= r
                    }
                    ],
                    "filter-id->=": [de, [me], (t, [e]) => {
                        const i = t.id()
                          , n = e.value;
                        return typeof i == typeof n && i >= n
                    }
                    ],
                    "filter-has": [de, [me], (t, [e]) => e.value in t.properties()],
                    "filter-has-id": [de, [], t => null !== t.id() && void 0 !== t.id()],
                    "filter-type-in": [de, [ve(ue)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],
                    "filter-id-in": [de, [ve(me)], (t, [e]) => e.value.indexOf(t.id()) >= 0],
                    "filter-in-small": [de, [ue, ve(me)], (t, [e,i]) => i.value.indexOf(t.properties()[e.value]) >= 0],
                    "filter-in-large": [de, [ue, ve(me)], (t, [e,i]) => function(t, e, i, n) {
                        for (; i <= n; ) {
                            const r = i + n >> 1;
                            if (e[r] === t)
                                return !0;
                            e[r] > t ? n = r - 1 : i = r + 1
                        }
                        return !1
                    }(t.properties()[e.value], i.value, 0, i.value.length - 1)],
                    all: {
                        type: de,
                        overloads: [[[de, de], (t, [e,i]) => e.evaluate(t) && i.evaluate(t)], [Rn(de), (t, e) => {
                            for (const i of e)
                                if (!i.evaluate(t))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: de,
                        overloads: [[[de, de], (t, [e,i]) => e.evaluate(t) || i.evaluate(t)], [Rn(de), (t, e) => {
                            for (const i of e)
                                if (i.evaluate(t))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [de, [de], (t, [e]) => !e.evaluate(t)],
                    "is-supported-script": [de, [ue], (t, [e]) => {
                        const i = t.globals && t.globals.isSupportedScript;
                        return !i || i(e.evaluate(t))
                    }
                    ],
                    upcase: [ue, [ue], (t, [e]) => e.evaluate(t).toUpperCase()],
                    downcase: [ue, [ue], (t, [e]) => e.evaluate(t).toLowerCase()],
                    concat: [ue, Rn(me), (t, e) => e.map((e => je(e.evaluate(t)))).join("")],
                    "resolved-locale": [ue, [ge], (t, [e]) => e.evaluate(t).resolvedLocale()]
                });
                var Dn = Mn;
                function Ln(t) {
                    return {
                        result: "success",
                        value: t
                    }
                }
                function Bn(t) {
                    return {
                        result: "error",
                        value: t
                    }
                }
                function zn(t) {
                    return "data-driven" === t["property-type"]
                }
                function Fn(t) {
                    return !!t.expression && t.expression.parameters.indexOf("zoom") > -1
                }
                function Nn(t) {
                    return !!t.expression && t.expression.interpolated
                }
                function jn(t) {
                    return t instanceof Number ? "number" : t instanceof String ? "string" : t instanceof Boolean ? "boolean" : Array.isArray(t) ? "array" : null === t ? "null" : typeof t
                }
                function Un(t) {
                    return "object" == typeof t && null !== t && !Array.isArray(t)
                }
                function Vn(t) {
                    return t
                }
                function Gn(t, e) {
                    const i = "color" === e.type
                      , n = t.stops && "object" == typeof t.stops[0][0]
                      , r = n || !(n || void 0 !== t.property)
                      , o = t.type || (Nn(e) ? "exponential" : "interval");
                    if (i && ((t = ie({}, t)).stops && (t.stops = t.stops.map((t => [t[0], Oe.parse(t[1])]))),
                    t.default = Oe.parse(t.default ? t.default : e.default)),
                    t.colorSpace && "rgb" !== t.colorSpace && !Ki[t.colorSpace])
                        throw new Error(`Unknown color space: ${t.colorSpace}`);
                    let s, a, l;
                    if ("exponential" === o)
                        s = Hn;
                    else if ("interval" === o)
                        s = Wn;
                    else if ("categorical" === o) {
                        s = qn,
                        a = Object.create(null);
                        for (const e of t.stops)
                            a[e[0]] = e[1];
                        l = typeof t.stops[0][0]
                    } else {
                        if ("identity" !== o)
                            throw new Error(`Unknown function type "${o}"`);
                        s = $n
                    }
                    if (n) {
                        const i = {}
                          , n = [];
                        for (let e = 0; e < t.stops.length; e++) {
                            const r = t.stops[e]
                              , o = r[0].zoom;
                            void 0 === i[o] && (i[o] = {
                                zoom: o,
                                type: t.type,
                                property: t.property,
                                default: t.default,
                                stops: []
                            },
                            n.push(o)),
                            i[o].stops.push([r[0].value, r[1]])
                        }
                        const r = [];
                        for (const t of n)
                            r.push([i[t].zoom, Gn(i[t], e)]);
                        const o = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: o,
                            interpolationFactor: tn.interpolationFactor.bind(void 0, o),
                            zoomStops: r.map((t => t[0])),
                            evaluate: ({zoom: i}, n) => Hn({
                                stops: r,
                                base: t.base
                            }, e, i).evaluate(i, n)
                        }
                    }
                    if (r) {
                        const i = "exponential" === o ? {
                            name: "exponential",
                            base: void 0 !== t.base ? t.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: i,
                            interpolationFactor: tn.interpolationFactor.bind(void 0, i),
                            zoomStops: t.stops.map((t => t[0])),
                            evaluate: ({zoom: i}) => s(t, e, i, a, l)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(i, n) {
                            const r = n && n.properties ? n.properties[t.property] : void 0;
                            return void 0 === r ? Zn(t.default, e.default) : s(t, e, r, a, l)
                        }
                    }
                }
                function Zn(t, e, i) {
                    return void 0 !== t ? t : void 0 !== e ? e : void 0 !== i ? i : void 0
                }
                function qn(t, e, i, n, r) {
                    return Zn(typeof i === r ? n[i] : void 0, t.default, e.default)
                }
                function Wn(t, e, i) {
                    if ("number" !== jn(i))
                        return Zn(t.default, e.default);
                    const n = t.stops.length;
                    if (1 === n)
                        return t.stops[0][1];
                    if (i <= t.stops[0][0])
                        return t.stops[0][1];
                    if (i >= t.stops[n - 1][0])
                        return t.stops[n - 1][1];
                    const r = Mi(t.stops.map((t => t[0])), i);
                    return t.stops[r][1]
                }
                function Hn(t, e, i) {
                    const n = void 0 !== t.base ? t.base : 1;
                    if ("number" !== jn(i))
                        return Zn(t.default, e.default);
                    const r = t.stops.length;
                    if (1 === r)
                        return t.stops[0][1];
                    if (i <= t.stops[0][0])
                        return t.stops[0][1];
                    if (i >= t.stops[r - 1][0])
                        return t.stops[r - 1][1];
                    const o = Mi(t.stops.map((t => t[0])), i)
                      , s = function(t, e, i, n) {
                        const r = n - i
                          , o = t - i;
                        return 0 === r ? 0 : 1 === e ? o / r : (Math.pow(e, o) - 1) / (Math.pow(e, r) - 1)
                    }(i, n, t.stops[o][0], t.stops[o + 1][0])
                      , a = t.stops[o][1]
                      , l = t.stops[o + 1][1];
                    let c = Ri[e.type] || Vn;
                    if (t.colorSpace && "rgb" !== t.colorSpace) {
                        const e = Ki[t.colorSpace];
                        c = (t, i) => e.reverse(e.interpolate(e.forward(t), e.forward(i), s))
                    }
                    return "function" == typeof a.evaluate ? {
                        evaluate(...t) {
                            const e = a.evaluate.apply(void 0, t)
                              , i = l.evaluate.apply(void 0, t);
                            if (void 0 !== e && void 0 !== i)
                                return c(e, i, s)
                        }
                    } : c(a, l, s)
                }
                function $n(t, e, i) {
                    return "color" === e.type ? i = Oe.parse(i) : "formatted" === e.type ? i = Le.fromString(i.toString()) : "resolvedImage" === e.type ? i = Be.fromString(i.toString()) : jn(i) === e.type || "enum" === e.type && e.values[i] || (i = void 0),
                    Zn(i, t.default, e.default)
                }
                class Xn {
                    constructor(t, e) {
                        this.expression = t,
                        this._warningHistory = {},
                        this._evaluator = new Qe,
                        this._defaultValue = e ? function(t) {
                            return "color" === t.type && (Un(t.default) || Array.isArray(t.default)) ? new Oe(0,0,0,0) : "color" === t.type ? Oe.parse(t.default) || null : void 0 === t.default ? null : t.default
                        }(e) : null,
                        this._enumValues = e && "enum" === e.type ? e.values : null
                    }
                    evaluateWithoutErrorHandling(t, e, i, n, r, o, s, a) {
                        return this._evaluator.globals = t,
                        this._evaluator.feature = e,
                        this._evaluator.featureState = i,
                        this._evaluator.canonical = n || null,
                        this._evaluator.availableImages = r || null,
                        this._evaluator.formattedSection = o,
                        this._evaluator.featureTileCoord = s || null,
                        this._evaluator.featureDistanceData = a || null,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(t, e, i, r, o, s, a, l) {
                        this._evaluator.globals = t,
                        this._evaluator.feature = e || null,
                        this._evaluator.featureState = i || null,
                        this._evaluator.canonical = r || null,
                        this._evaluator.availableImages = o || null,
                        this._evaluator.formattedSection = s || null,
                        this._evaluator.featureTileCoord = a || null,
                        this._evaluator.featureDistanceData = l || null;
                        try {
                            const t = this.expression.evaluate(this._evaluator);
                            if (null == t || "number" == typeof t && t != t)
                                return this._defaultValue;
                            if (this._enumValues && !(t in this._enumValues))
                                throw new Ge(`Expected value to be one of ${Object.keys(this._enumValues).map((t => JSON.stringify(t))).join(", ")}, but found ${JSON.stringify(t)} instead.`);
                            return t
                        } catch (t) {
                            return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0,
                            void 0 !== n && n.warn(t.message)),
                            this._defaultValue
                        }
                    }
                }
                function Yn(t) {
                    return Array.isArray(t) && t.length > 0 && "string" == typeof t[0] && t[0]in Dn
                }
                function Kn(t, e) {
                    const i = new Ai(Dn,[],e ? function(t) {
                        const e = {
                            color: fe,
                            string: ue,
                            number: he,
                            enum: ue,
                            boolean: de,
                            formatted: _e,
                            resolvedImage: ye
                        };
                        return "array" === t.type ? ve(e[t.value] || me, t.length) : e[t.type]
                    }(e) : void 0)
                      , n = i.parse(t, void 0, void 0, void 0, e && "string" === e.type ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return n ? Ln(new Xn(n,e)) : Bn(i.errors)
                }
                class Jn {
                    constructor(t, e) {
                        this.kind = t,
                        this._styleExpression = e,
                        this.isStateDependent = "constant" !== t && !wi(e.expression)
                    }
                    evaluateWithoutErrorHandling(t, e, i, n, r, o) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, n, r, o)
                    }
                    evaluate(t, e, i, n, r, o) {
                        return this._styleExpression.evaluate(t, e, i, n, r, o)
                    }
                }
                class Qn {
                    constructor(t, e, i, n) {
                        this.kind = t,
                        this.zoomStops = i,
                        this._styleExpression = e,
                        this.isStateDependent = "camera" !== t && !wi(e.expression),
                        this.interpolationType = n
                    }
                    evaluateWithoutErrorHandling(t, e, i, n, r, o) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, e, i, n, r, o)
                    }
                    evaluate(t, e, i, n, r, o) {
                        return this._styleExpression.evaluate(t, e, i, n, r, o)
                    }
                    interpolationFactor(t, e, i) {
                        return this.interpolationType ? tn.interpolationFactor(this.interpolationType, t, e, i) : 0
                    }
                }
                function tr(t, e) {
                    if ("error" === (t = Kn(t, e)).result)
                        return t;
                    const i = t.value.expression
                      , n = bi(i);
                    if (!n && !zn(e))
                        return Bn([new se("","data expressions not supported")]);
                    const r = Ei(i, ["zoom", "pitch", "distance-from-center"]);
                    if (!r && !Fn(e))
                        return Bn([new se("","zoom expressions not supported")]);
                    const o = ir(i);
                    return o || r ? o instanceof se ? Bn([o]) : o instanceof tn && !Nn(e) ? Bn([new se("",'"interpolate" expressions cannot be used with this property')]) : Ln(o ? new Qn(n ? "camera" : "composite",t.value,o.labels,o instanceof tn ? o.interpolation : void 0) : new Jn(n ? "constant" : "source",t.value)) : Bn([new se("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
                }
                class er {
                    constructor(t, e) {
                        this._parameters = t,
                        this._specification = e,
                        ie(this, Gn(this._parameters, this._specification))
                    }
                    static deserialize(t) {
                        return new er(t._parameters,t._specification)
                    }
                    static serialize(t) {
                        return {
                            _parameters: t._parameters,
                            _specification: t._specification
                        }
                    }
                }
                function ir(t) {
                    let e = null;
                    if (t instanceof on)
                        e = ir(t.result);
                    else if (t instanceof nn) {
                        for (const i of t.args)
                            if (e = ir(i),
                            e)
                                break
                    } else
                        (t instanceof ki || t instanceof tn) && t.input instanceof ei && "zoom" === t.input.name && (e = t);
                    return e instanceof se || t.eachChild((t => {
                        const i = ir(t);
                        i instanceof se ? e = i : !e && i ? e = new se("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && i && e !== i && (e = new se("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    )),
                    e
                }
                class nr {
                    constructor(t, e, i, n) {
                        this.message = (t ? `${t}: ` : "") + i,
                        n && (this.identifier = n),
                        null != e && e.__line__ && (this.line = e.__line__)
                    }
                }
                function rr(t) {
                    const e = t.key
                      , i = t.value
                      , n = t.valueSpec || {}
                      , r = t.objectElementValidators || {}
                      , o = t.style
                      , s = t.styleSpec;
                    let a = [];
                    const l = jn(i);
                    if ("object" !== l)
                        return [new nr(e,i,`object expected, ${l} found`)];
                    for (const t in i) {
                        const l = t.split(".")[0];
                        let c;
                        r[l] ? c = r[l] : n[l] ? c = Fr : r["*"] ? c = r["*"] : n["*"] && (c = Fr),
                        c ? a = a.concat(c({
                            key: (e ? `${e}.` : e) + t,
                            value: i[t],
                            valueSpec: n[l] || n["*"],
                            style: o,
                            styleSpec: s,
                            object: i,
                            objectKey: t
                        }, i)) : a.push(new nr(e,i[t],`unknown property "${t}"`))
                    }
                    for (const t in n)
                        r[t] || n[t].required && void 0 === n[t].default && void 0 === i[t] && a.push(new nr(e,i,`missing required property "${t}"`));
                    return a
                }
                function or(t) {
                    const e = t.value
                      , i = t.valueSpec
                      , n = t.style
                      , r = t.styleSpec
                      , o = t.key
                      , s = t.arrayElementValidator || Fr;
                    if ("array" !== jn(e))
                        return [new nr(o,e,`array expected, ${jn(e)} found`)];
                    if (i.length && e.length !== i.length)
                        return [new nr(o,e,`array length ${i.length} expected, length ${e.length} found`)];
                    if (i["min-length"] && e.length < i["min-length"])
                        return [new nr(o,e,`array length at least ${i["min-length"]} expected, length ${e.length} found`)];
                    let a = {
                        type: i.value,
                        values: i.values,
                        minimum: i.minimum,
                        maximum: i.maximum,
                        function: void 0
                    };
                    r.$version < 7 && (a.function = i.function),
                    "object" === jn(i.value) && (a = i.value);
                    let l = [];
                    for (let t = 0; t < e.length; t++)
                        l = l.concat(s({
                            array: e,
                            arrayIndex: t,
                            value: e[t],
                            valueSpec: a,
                            style: n,
                            styleSpec: r,
                            key: `${o}[${t}]`
                        }));
                    return l
                }
                function sr(t) {
                    const e = t.key
                      , i = t.value
                      , n = t.valueSpec;
                    let r = jn(i);
                    if ("number" === r && i != i && (r = "NaN"),
                    "number" !== r)
                        return [new nr(e,i,`number expected, ${r} found`)];
                    if ("minimum"in n) {
                        let r = n.minimum;
                        if ("array" === jn(n.minimum) && (r = n.minimum[t.arrayIndex]),
                        i < r)
                            return [new nr(e,i,`${i} is less than the minimum value ${r}`)]
                    }
                    if ("maximum"in n) {
                        let r = n.maximum;
                        if ("array" === jn(n.maximum) && (r = n.maximum[t.arrayIndex]),
                        i > r)
                            return [new nr(e,i,`${i} is greater than the maximum value ${r}`)]
                    }
                    return []
                }
                function ar(t) {
                    const e = t.valueSpec
                      , i = ne(t.value.type);
                    let n, r, o, s = {};
                    const a = "categorical" !== i && void 0 === t.value.property
                      , l = !a
                      , c = "array" === jn(t.value.stops) && "array" === jn(t.value.stops[0]) && "object" === jn(t.value.stops[0][0])
                      , h = rr({
                        key: t.key,
                        value: t.value,
                        valueSpec: t.styleSpec.function,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            stops: function(t) {
                                if ("identity" === i)
                                    return [new nr(t.key,t.value,'identity function may not have a "stops" property')];
                                let e = [];
                                const n = t.value;
                                return e = e.concat(or({
                                    key: t.key,
                                    value: n,
                                    valueSpec: t.valueSpec,
                                    style: t.style,
                                    styleSpec: t.styleSpec,
                                    arrayElementValidator: u
                                })),
                                "array" === jn(n) && 0 === n.length && e.push(new nr(t.key,n,"array must have at least one stop")),
                                e
                            },
                            default: function(t) {
                                return Fr({
                                    key: t.key,
                                    value: t.value,
                                    valueSpec: e,
                                    style: t.style,
                                    styleSpec: t.styleSpec
                                })
                            }
                        }
                    });
                    return "identity" === i && a && h.push(new nr(t.key,t.value,'missing required property "property"')),
                    "identity" === i || t.value.stops || h.push(new nr(t.key,t.value,'missing required property "stops"')),
                    "exponential" === i && t.valueSpec.expression && !Nn(t.valueSpec) && h.push(new nr(t.key,t.value,"exponential functions not supported")),
                    t.styleSpec.$version >= 8 && (l && !zn(t.valueSpec) ? h.push(new nr(t.key,t.value,"property functions not supported")) : a && !Fn(t.valueSpec) && h.push(new nr(t.key,t.value,"zoom functions not supported"))),
                    "categorical" !== i && !c || void 0 !== t.value.property || h.push(new nr(t.key,t.value,'"property" property is required')),
                    h;
                    function u(t) {
                        let i = [];
                        const n = t.value
                          , a = t.key;
                        if ("array" !== jn(n))
                            return [new nr(a,n,`array expected, ${jn(n)} found`)];
                        if (2 !== n.length)
                            return [new nr(a,n,`array length 2 expected, length ${n.length} found`)];
                        if (c) {
                            if ("object" !== jn(n[0]))
                                return [new nr(a,n,`object expected, ${jn(n[0])} found`)];
                            if (void 0 === n[0].zoom)
                                return [new nr(a,n,"object stop key must have zoom")];
                            if (void 0 === n[0].value)
                                return [new nr(a,n,"object stop key must have value")];
                            const e = ne(n[0].zoom);
                            if ("number" != typeof e)
                                return [new nr(a,n[0].zoom,"stop zoom values must be numbers")];
                            if (o && o > e)
                                return [new nr(a,n[0].zoom,"stop zoom values must appear in ascending order")];
                            e !== o && (o = e,
                            r = void 0,
                            s = {}),
                            i = i.concat(rr({
                                key: `${a}[0]`,
                                value: n[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                style: t.style,
                                styleSpec: t.styleSpec,
                                objectElementValidators: {
                                    zoom: sr,
                                    value: d
                                }
                            }))
                        } else
                            i = i.concat(d({
                                key: `${a}[0]`,
                                value: n[0],
                                valueSpec: {},
                                style: t.style,
                                styleSpec: t.styleSpec
                            }, n));
                        return Yn(re(n[1])) ? i.concat([new nr(`${a}[1]`,n[1],"expressions are not allowed in function stops.")]) : i.concat(Fr({
                            key: `${a}[1]`,
                            value: n[1],
                            valueSpec: e,
                            style: t.style,
                            styleSpec: t.styleSpec
                        }))
                    }
                    function d(t, o) {
                        const a = jn(t.value)
                          , l = ne(t.value)
                          , c = null !== t.value ? t.value : o;
                        if (n) {
                            if (a !== n)
                                return [new nr(t.key,c,`${a} stop domain type must match previous stop domain type ${n}`)]
                        } else
                            n = a;
                        if ("number" !== a && "string" !== a && "boolean" !== a && "number" != typeof l && "string" != typeof l && "boolean" != typeof l)
                            return [new nr(t.key,c,"stop domain value must be a number, string, or boolean")];
                        if ("number" !== a && "categorical" !== i) {
                            let n = `number expected, ${a} found`;
                            return zn(e) && void 0 === i && (n += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new nr(t.key,c,n)]
                        }
                        return "categorical" !== i || "number" !== a || "number" == typeof l && isFinite(l) && Math.floor(l) === l ? "categorical" !== i && "number" === a && "number" == typeof l && "number" == typeof r && void 0 !== r && l < r ? [new nr(t.key,c,"stop domain values must appear in ascending order")] : (r = l,
                        "categorical" === i && l in s ? [new nr(t.key,c,"stop domain values must be unique")] : (s[l] = !0,
                        [])) : [new nr(t.key,c,`integer expected, found ${String(l)}`)]
                    }
                }
                function lr(t) {
                    const e = ("property" === t.expressionContext ? tr : Kn)(re(t.value), t.valueSpec);
                    if ("error" === e.result)
                        return e.value.map((e => new nr(`${t.key}${e.key}`,t.value,e.message)));
                    const i = e.value.expression || e.value._styleExpression.expression;
                    if ("property" === t.expressionContext && "text-font" === t.propertyKey && !i.outputDefined())
                        return [new nr(t.key,t.value,`Invalid data expression for "${t.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if ("property" === t.expressionContext && "layout" === t.propertyType && !wi(i))
                        return [new nr(t.key,t.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if ("filter" === t.expressionContext)
                        return cr(i, t);
                    if (t.expressionContext && 0 === t.expressionContext.indexOf("cluster")) {
                        if (!Ei(i, ["zoom", "feature-state"]))
                            return [new nr(t.key,t.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if ("cluster-initial" === t.expressionContext && !bi(i))
                            return [new nr(t.key,t.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function cr(t, e) {
                    const i = new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
                    if (e.valueSpec && e.valueSpec.expression)
                        for (const t of e.valueSpec.expression.parameters)
                            i.delete(t);
                    if (0 === i.size)
                        return [];
                    const n = [];
                    return t instanceof ei && i.has(t.name) ? [new nr(e.key,e.value,`["${t.name}"] expression is not supported in a filter for a ${e.object.type} layer with id: ${e.object.id}`)] : (t.eachChild((t => {
                        n.push(...cr(t, e))
                    }
                    )),
                    n)
                }
                function hr(t) {
                    const e = t.key
                      , i = t.value
                      , n = t.valueSpec
                      , r = [];
                    return Array.isArray(n.values) ? -1 === n.values.indexOf(ne(i)) && r.push(new nr(e,i,`expected one of [${n.values.join(", ")}], ${JSON.stringify(i)} found`)) : -1 === Object.keys(n.values).indexOf(ne(i)) && r.push(new nr(e,i,`expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(i)} found`)),
                    r
                }
                function ur(t) {
                    if (!0 === t || !1 === t)
                        return !0;
                    if (!Array.isArray(t) || 0 === t.length)
                        return !1;
                    switch (t[0]) {
                    case "has":
                        return t.length >= 2 && "$id" !== t[1] && "$type" !== t[1];
                    case "in":
                        return t.length >= 3 && ("string" != typeof t[1] || Array.isArray(t[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);
                    case "any":
                    case "all":
                        for (const e of t.slice(1))
                            if (!ur(e) && "boolean" != typeof e)
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                function dr(t, e="fill") {
                    if (null == t)
                        return {
                            filter: () => !0,
                            needGeometry: !1,
                            needFeature: !1
                        };
                    ur(t) || (t = vr(t));
                    const i = t;
                    let r = !0;
                    try {
                        r = function(t) {
                            if (!mr(t))
                                return t;
                            let e = re(t);
                            return pr(e),
                            e = fr(e),
                            e
                        }(i)
                    } catch (t) {
                        n.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(i, null, 2)}\n        `)
                    }
                    const o = ee[`filter_${e}`]
                      , s = Kn(r, o);
                    let a = null;
                    if ("error" === s.result)
                        throw new Error(s.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                    a = (t, e, i) => s.value.evaluate(t, e, {}, i);
                    let l = null
                      , c = null;
                    if (r !== i) {
                        const t = Kn(i, o);
                        if ("error" === t.result)
                            throw new Error(t.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                        l = (e, i, n, r, o) => t.value.evaluate(e, i, {}, n, void 0, void 0, r, o),
                        c = !bi(t.value.expression)
                    }
                    return {
                        filter: a,
                        dynamicFilter: l || void 0,
                        needGeometry: yr(r),
                        needFeature: !!c
                    }
                }
                function fr(t) {
                    if (!Array.isArray(t))
                        return t;
                    const e = function(t) {
                        if (gr.has(t[0]))
                            for (let e = 1; e < t.length; e++)
                                if (mr(t[e]))
                                    return !0;
                        return t
                    }(t);
                    return !0 === e ? e : e.map((t => fr(t)))
                }
                function pr(t) {
                    let e = !1;
                    const i = [];
                    if ("case" === t[0]) {
                        for (let n = 1; n < t.length - 1; n += 2)
                            e = e || mr(t[n]),
                            i.push(t[n + 1]);
                        i.push(t[t.length - 1])
                    } else if ("match" === t[0]) {
                        e = e || mr(t[1]);
                        for (let e = 2; e < t.length - 1; e += 2)
                            i.push(t[e + 1]);
                        i.push(t[t.length - 1])
                    } else if ("step" === t[0]) {
                        e = e || mr(t[1]);
                        for (let e = 1; e < t.length - 1; e += 2)
                            i.push(t[e + 1])
                    }
                    e && (t.length = 0,
                    t.push("any", ...i));
                    for (let e = 1; e < t.length; e++)
                        pr(t[e])
                }
                function mr(t) {
                    if (!Array.isArray(t))
                        return !1;
                    if ("pitch" === (e = t[0]) || "distance-from-center" === e)
                        return !0;
                    var e;
                    for (let e = 1; e < t.length; e++)
                        if (mr(t[e]))
                            return !0;
                    return !1
                }
                const gr = new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
                function _r(t, e) {
                    return t < e ? -1 : t > e ? 1 : 0
                }
                function yr(t) {
                    if (!Array.isArray(t))
                        return !1;
                    if ("within" === t[0])
                        return !0;
                    for (let e = 1; e < t.length; e++)
                        if (yr(t[e]))
                            return !0;
                    return !1
                }
                function vr(t) {
                    if (!t)
                        return !0;
                    const e = t[0];
                    return t.length <= 1 ? "any" !== e : "==" === e ? xr(t[1], t[2], "==") : "!=" === e ? Er(xr(t[1], t[2], "==")) : "<" === e || ">" === e || "<=" === e || ">=" === e ? xr(t[1], t[2], e) : "any" === e ? (i = t.slice(1),
                    ["any"].concat(i.map(vr))) : "all" === e ? ["all"].concat(t.slice(1).map(vr)) : "none" === e ? ["all"].concat(t.slice(1).map(vr).map(Er)) : "in" === e ? br(t[1], t.slice(2)) : "!in" === e ? Er(br(t[1], t.slice(2))) : "has" === e ? wr(t[1]) : "!has" === e ? Er(wr(t[1])) : "within" !== e || t;
                    var i
                }
                function xr(t, e, i) {
                    switch (t) {
                    case "$type":
                        return [`filter-type-${i}`, e];
                    case "$id":
                        return [`filter-id-${i}`, e];
                    default:
                        return [`filter-${i}`, t, e]
                    }
                }
                function br(t, e) {
                    if (0 === e.length)
                        return !1;
                    switch (t) {
                    case "$type":
                        return ["filter-type-in", ["literal", e]];
                    case "$id":
                        return ["filter-id-in", ["literal", e]];
                    default:
                        return e.length > 200 && !e.some((t => typeof t != typeof e[0])) ? ["filter-in-large", t, ["literal", e.sort(_r)]] : ["filter-in-small", t, ["literal", e]]
                    }
                }
                function wr(t) {
                    switch (t) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", t]
                    }
                }
                function Er(t) {
                    return ["!", t]
                }
                function Tr(t) {
                    return ur(re(t.value)) ? lr(ie({}, t, {
                        expressionContext: "filter",
                        valueSpec: t.styleSpec[`filter_${t.layerType || "fill"}`]
                    })) : Sr(t)
                }
                function Sr(t) {
                    const e = t.value
                      , i = t.key;
                    if ("array" !== jn(e))
                        return [new nr(i,e,`array expected, ${jn(e)} found`)];
                    const n = t.styleSpec;
                    let r, o = [];
                    if (e.length < 1)
                        return [new nr(i,e,"filter array must have at least 1 element")];
                    switch (o = o.concat(hr({
                        key: `${i}[0]`,
                        value: e[0],
                        valueSpec: n.filter_operator,
                        style: t.style,
                        styleSpec: t.styleSpec
                    })),
                    ne(e[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        e.length >= 2 && "$type" === ne(e[1]) && o.push(new nr(i,e,`"$type" cannot be use with operator "${e[0]}"`));
                    case "==":
                    case "!=":
                        3 !== e.length && o.push(new nr(i,e,`filter array for operator "${e[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        e.length >= 2 && (r = jn(e[1]),
                        "string" !== r && o.push(new nr(`${i}[1]`,e[1],`string expected, ${r} found`)));
                        for (let s = 2; s < e.length; s++)
                            r = jn(e[s]),
                            "$type" === ne(e[1]) ? o = o.concat(hr({
                                key: `${i}[${s}]`,
                                value: e[s],
                                valueSpec: n.geometry_type,
                                style: t.style,
                                styleSpec: t.styleSpec
                            })) : "string" !== r && "number" !== r && "boolean" !== r && o.push(new nr(`${i}[${s}]`,e[s],`string, number, or boolean expected, ${r} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let n = 1; n < e.length; n++)
                            o = o.concat(Sr({
                                key: `${i}[${n}]`,
                                value: e[n],
                                style: t.style,
                                styleSpec: t.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        r = jn(e[1]),
                        2 !== e.length ? o.push(new nr(i,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "string" !== r && o.push(new nr(`${i}[1]`,e[1],`string expected, ${r} found`));
                        break;
                    case "within":
                        r = jn(e[1]),
                        2 !== e.length ? o.push(new nr(i,e,`filter array for "${e[0]}" operator must have 2 elements`)) : "object" !== r && o.push(new nr(`${i}[1]`,e[1],`object expected, ${r} found`))
                    }
                    return o
                }
                function Cr(t, e) {
                    const i = t.key
                      , n = t.style
                      , r = t.styleSpec
                      , o = t.value
                      , s = t.objectKey
                      , a = r[`${e}_${t.layerType}`];
                    if (!a)
                        return [];
                    const l = s.match(/^(.*)-transition$/);
                    if ("paint" === e && l && a[l[1]] && a[l[1]].transition)
                        return Fr({
                            key: i,
                            value: o,
                            valueSpec: r.transition,
                            style: n,
                            styleSpec: r
                        });
                    const c = t.valueSpec || a[s];
                    if (!c)
                        return [new nr(i,o,`unknown property "${s}"`)];
                    let h;
                    if ("string" === jn(o) && zn(c) && !c.tokens && (h = /^{([^}]+)}$/.exec(o))) {
                        const t = `\`{ "type": "identity", "property": ${h ? JSON.stringify(h[1]) : '"_"'} }\``;
                        return [new nr(i,o,`"${s}" does not support interpolation syntax\nUse an identity property function instead: ${t}.`)]
                    }
                    const u = [];
                    return "symbol" === t.layerType && ("text-field" === s && n && !n.glyphs && u.push(new nr(i,o,'use of "text-field" requires a style "glyphs" property')),
                    "text-font" === s && Un(re(o)) && "identity" === ne(o.type) && u.push(new nr(i,o,'"text-font" does not support identity functions'))),
                    u.concat(Fr({
                        key: t.key,
                        value: o,
                        valueSpec: c,
                        style: n,
                        styleSpec: r,
                        expressionContext: "property",
                        propertyType: e,
                        propertyKey: s
                    }))
                }
                function Ar(t) {
                    return Cr(t, "paint")
                }
                function Ir(t) {
                    return Cr(t, "layout")
                }
                function Mr(t) {
                    let e = [];
                    const i = t.value
                      , n = t.key
                      , r = t.style
                      , o = t.styleSpec;
                    i.type || i.ref || e.push(new nr(n,i,'either "type" or "ref" is required'));
                    let s = ne(i.type);
                    const a = ne(i.ref);
                    if (i.id) {
                        const o = ne(i.id);
                        for (let s = 0; s < t.arrayIndex; s++) {
                            const t = r.layers[s];
                            ne(t.id) === o && e.push(new nr(n,i.id,`duplicate layer id "${i.id}", previously used at line ${t.id.__line__}`))
                        }
                    }
                    if ("ref"in i) {
                        let t;
                        ["type", "source", "source-layer", "filter", "layout"].forEach((t => {
                            t in i && e.push(new nr(n,i[t],`"${t}" is prohibited for ref layers`))
                        }
                        )),
                        r.layers.forEach((e => {
                            ne(e.id) === a && (t = e)
                        }
                        )),
                        t ? t.ref ? e.push(new nr(n,i.ref,"ref cannot reference another ref layer")) : s = ne(t.type) : "string" == typeof a && e.push(new nr(n,i.ref,`ref layer "${a}" not found`))
                    } else if ("background" !== s && "sky" !== s)
                        if (i.source) {
                            const t = r.sources && r.sources[i.source]
                              , o = t && ne(t.type);
                            t ? "vector" === o && "raster" === s ? e.push(new nr(n,i.source,`layer "${i.id}" requires a raster source`)) : "raster" === o && "raster" !== s ? e.push(new nr(n,i.source,`layer "${i.id}" requires a vector source`)) : "vector" !== o || i["source-layer"] ? "raster-dem" === o && "hillshade" !== s ? e.push(new nr(n,i.source,"raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s || !i.paint || !i.paint["line-gradient"] && !i.paint["line-trim-offset"] || "geojson" === o && t.lineMetrics || e.push(new nr(n,i,`layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new nr(n,i,`layer "${i.id}" must specify a "source-layer"`)) : e.push(new nr(n,i.source,`source "${i.source}" not found`))
                        } else
                            e.push(new nr(n,i,'missing required property "source"'));
                    return e = e.concat(rr({
                        key: n,
                        value: i,
                        valueSpec: o.layer,
                        style: t.style,
                        styleSpec: t.styleSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => Fr({
                                key: `${n}.type`,
                                value: i.type,
                                valueSpec: o.layer.type,
                                style: t.style,
                                styleSpec: t.styleSpec,
                                object: i,
                                objectKey: "type"
                            }),
                            filter: t => Tr(ie({
                                layerType: s
                            }, t)),
                            layout: t => rr({
                                layer: i,
                                key: t.key,
                                value: t.value,
                                valueSpec: {},
                                style: t.style,
                                styleSpec: t.styleSpec,
                                objectElementValidators: {
                                    "*": t => Ir(ie({
                                        layerType: s
                                    }, t))
                                }
                            }),
                            paint: t => rr({
                                layer: i,
                                key: t.key,
                                value: t.value,
                                valueSpec: {},
                                style: t.style,
                                styleSpec: t.styleSpec,
                                objectElementValidators: {
                                    "*": t => Ar(ie({
                                        layerType: s
                                    }, t))
                                }
                            })
                        }
                    })),
                    e
                }
                function Pr(t) {
                    const e = t.value
                      , i = t.key
                      , n = jn(e);
                    return "string" !== n ? [new nr(i,e,`string expected, ${n} found`)] : []
                }
                const kr = {
                    promoteId: function({key: t, value: e}) {
                        if ("string" === jn(e))
                            return Pr({
                                key: t,
                                value: e
                            });
                        {
                            const i = [];
                            for (const n in e)
                                i.push(...Pr({
                                    key: `${t}.${n}`,
                                    value: e[n]
                                }));
                            return i
                        }
                    }
                };
                function Or(t) {
                    const e = t.value
                      , i = t.key
                      , n = t.styleSpec
                      , r = t.style;
                    if (!e.type)
                        return [new nr(i,e,'"type" is required')];
                    const o = ne(e.type);
                    let s;
                    switch (o) {
                    case "vector":
                    case "raster":
                    case "raster-dem":
                        return s = rr({
                            key: i,
                            value: e,
                            valueSpec: n[`source_${o.replace("-", "_")}`],
                            style: t.style,
                            styleSpec: n,
                            objectElementValidators: kr
                        }),
                        s;
                    case "geojson":
                        if (s = rr({
                            key: i,
                            value: e,
                            valueSpec: n.source_geojson,
                            style: r,
                            styleSpec: n,
                            objectElementValidators: kr
                        }),
                        e.cluster)
                            for (const t in e.clusterProperties) {
                                const [n,r] = e.clusterProperties[t]
                                  , o = "string" == typeof n ? [n, ["accumulated"], ["get", t]] : n;
                                s.push(...lr({
                                    key: `${i}.${t}.map`,
                                    value: r,
                                    expressionContext: "cluster-map"
                                })),
                                s.push(...lr({
                                    key: `${i}.${t}.reduce`,
                                    value: o,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return s;
                    case "video":
                        return rr({
                            key: i,
                            value: e,
                            valueSpec: n.source_video,
                            style: r,
                            styleSpec: n
                        });
                    case "image":
                        return rr({
                            key: i,
                            value: e,
                            valueSpec: n.source_image,
                            style: r,
                            styleSpec: n
                        });
                    case "canvas":
                        return [new nr(i,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return hr({
                            key: `${i}.type`,
                            value: e.type,
                            valueSpec: {
                                values: Rr(n)
                            },
                            style: r,
                            styleSpec: n
                        })
                    }
                }
                function Rr(t) {
                    return t.source.reduce(( (e, i) => {
                        const n = t[i];
                        return "enum" === n.type.type && (e = e.concat(Object.keys(n.type.values))),
                        e
                    }
                    ), [])
                }
                function Dr(t) {
                    const e = t.value
                      , i = t.styleSpec
                      , n = i.light
                      , r = t.style;
                    let o = [];
                    const s = jn(e);
                    if (void 0 === e)
                        return o;
                    if ("object" !== s)
                        return o = o.concat([new nr("light",e,`object expected, ${s} found`)]),
                        o;
                    for (const t in e) {
                        const s = t.match(/^(.*)-transition$/);
                        o = o.concat(s && n[s[1]] && n[s[1]].transition ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: i.transition,
                            style: r,
                            styleSpec: i
                        }) : n[t] ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: n[t],
                            style: r,
                            styleSpec: i
                        }) : [new nr(t,e[t],`unknown property "${t}"`)])
                    }
                    return o
                }
                function Lr(t) {
                    const e = t.value
                      , i = t.key
                      , n = t.style
                      , r = t.styleSpec
                      , o = r.terrain;
                    let s = [];
                    const a = jn(e);
                    if (void 0 === e)
                        return s;
                    if ("object" !== a)
                        return s = s.concat([new nr("terrain",e,`object expected, ${a} found`)]),
                        s;
                    for (const t in e) {
                        const i = t.match(/^(.*)-transition$/);
                        s = s.concat(i && o[i[1]] && o[i[1]].transition ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: r.transition,
                            style: n,
                            styleSpec: r
                        }) : o[t] ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: o[t],
                            style: n,
                            styleSpec: r
                        }) : [new nr(t,e[t],`unknown property "${t}"`)])
                    }
                    if (e.source) {
                        const t = n.sources && n.sources[e.source]
                          , r = t && ne(t.type);
                        t ? "raster-dem" !== r && s.push(new nr(i,e.source,`terrain cannot be used with a source of type ${String(r)}, it only be used with a "raster-dem" source type`)) : s.push(new nr(i,e.source,`source "${e.source}" not found`))
                    } else
                        s.push(new nr(i,e,'terrain is missing required property "source"'));
                    return s
                }
                function Br(t) {
                    const e = t.value
                      , i = t.style
                      , n = t.styleSpec
                      , r = n.fog;
                    let o = [];
                    const s = jn(e);
                    if (void 0 === e)
                        return o;
                    if ("object" !== s)
                        return o = o.concat([new nr("fog",e,`object expected, ${s} found`)]),
                        o;
                    for (const t in e) {
                        const s = t.match(/^(.*)-transition$/);
                        o = o.concat(s && r[s[1]] && r[s[1]].transition ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: n.transition,
                            style: i,
                            styleSpec: n
                        }) : r[t] ? Fr({
                            key: t,
                            value: e[t],
                            valueSpec: r[t],
                            style: i,
                            styleSpec: n
                        }) : [new nr(t,e[t],`unknown property "${t}"`)])
                    }
                    return o
                }
                const zr = {
                    "*": () => [],
                    array: or,
                    boolean: function(t) {
                        const e = t.value
                          , i = t.key
                          , n = jn(e);
                        return "boolean" !== n ? [new nr(i,e,`boolean expected, ${n} found`)] : []
                    },
                    number: sr,
                    color: function(t) {
                        const e = t.key
                          , i = t.value
                          , n = jn(i);
                        return "string" !== n ? [new nr(e,i,`color expected, ${n} found`)] : null === Se(i) ? [new nr(e,i,`color expected, "${i}" found`)] : []
                    },
                    enum: hr,
                    filter: Tr,
                    function: ar,
                    layer: Mr,
                    object: rr,
                    source: Or,
                    light: Dr,
                    terrain: Lr,
                    fog: Br,
                    string: Pr,
                    formatted: function(t) {
                        return 0 === Pr(t).length ? [] : lr(t)
                    },
                    resolvedImage: function(t) {
                        return 0 === Pr(t).length ? [] : lr(t)
                    },
                    projection: function(t) {
                        const e = t.value
                          , i = t.styleSpec
                          , n = i.projection
                          , r = t.style;
                        let o = [];
                        const s = jn(e);
                        if ("object" === s)
                            for (const t in e)
                                o = o.concat(Fr({
                                    key: t,
                                    value: e[t],
                                    valueSpec: n[t],
                                    style: r,
                                    styleSpec: i
                                }));
                        else
                            "string" !== s && (o = o.concat([new nr("projection",e,`object or string expected, ${s} found`)]));
                        return o
                    }
                };
                function Fr(t) {
                    const e = t.value
                      , i = t.valueSpec
                      , n = t.styleSpec;
                    return i.expression && Un(ne(e)) ? ar(t) : i.expression && Yn(re(e)) ? lr(t) : i.type && zr[i.type] ? zr[i.type](t) : rr(ie({}, t, {
                        valueSpec: i.type ? n[i.type] : i
                    }))
                }
                function Nr(t) {
                    const e = t.value
                      , i = t.key
                      , n = Pr(t);
                    return n.length || (-1 === e.indexOf("{fontstack}") && n.push(new nr(i,e,'"glyphs" url must include a "{fontstack}" token')),
                    -1 === e.indexOf("{range}") && n.push(new nr(i,e,'"glyphs" url must include a "{range}" token'))),
                    n
                }
                function jr(t, e=ee) {
                    return Gr(Fr({
                        key: "",
                        value: t,
                        valueSpec: e.$root,
                        styleSpec: e,
                        style: t,
                        objectElementValidators: {
                            glyphs: Nr,
                            "*": () => []
                        }
                    }))
                }
                const Ur = t => Gr(Ar(t))
                  , Vr = t => Gr(Ir(t));
                function Gr(t) {
                    return t.slice().sort(( (t, e) => t.line && e.line ? t.line - e.line : 0))
                }
                function Zr(t, e) {
                    let i = !1;
                    if (e && e.length)
                        for (const n of e)
                            t.fire(new Qt(new Error(n.message))),
                            i = !0;
                    return i
                }
                var qr = Hr
                  , Wr = 3;
                function Hr(t, e, i) {
                    var n = this.cells = [];
                    if (t instanceof ArrayBuffer) {
                        this.arrayBuffer = t;
                        var r = new Int32Array(this.arrayBuffer);
                        t = r[0],
                        this.d = (e = r[1]) + 2 * (i = r[2]);
                        for (var o = 0; o < this.d * this.d; o++) {
                            var s = r[Wr + o]
                              , a = r[Wr + o + 1];
                            n.push(s === a ? null : r.subarray(s, a))
                        }
                        var l = r[Wr + n.length + 1];
                        this.keys = r.subarray(r[Wr + n.length], l),
                        this.bboxes = r.subarray(l),
                        this.insert = this._insertReadonly
                    } else {
                        this.d = e + 2 * i;
                        for (var c = 0; c < this.d * this.d; c++)
                            n.push([]);
                        this.keys = [],
                        this.bboxes = []
                    }
                    this.n = e,
                    this.extent = t,
                    this.padding = i,
                    this.scale = e / t,
                    this.uid = 0;
                    var h = i / e * t;
                    this.min = -h,
                    this.max = t + h
                }
                Hr.prototype.insert = function(t, e, i, n, r) {
                    this._forEachCell(e, i, n, r, this._insertCell, this.uid++),
                    this.keys.push(t),
                    this.bboxes.push(e),
                    this.bboxes.push(i),
                    this.bboxes.push(n),
                    this.bboxes.push(r)
                }
                ,
                Hr.prototype._insertReadonly = function() {
                    throw "Cannot insert into a GridIndex created from an ArrayBuffer."
                }
                ,
                Hr.prototype._insertCell = function(t, e, i, n, r, o) {
                    this.cells[r].push(o)
                }
                ,
                Hr.prototype.query = function(t, e, i, n, r) {
                    var o = this.min
                      , s = this.max;
                    if (t <= o && e <= o && s <= i && s <= n && !r)
                        return Array.prototype.slice.call(this.keys);
                    var a = [];
                    return this._forEachCell(t, e, i, n, this._queryCell, a, {}, r),
                    a
                }
                ,
                Hr.prototype._queryCell = function(t, e, i, n, r, o, s, a) {
                    var l = this.cells[r];
                    if (null !== l)
                        for (var c = this.keys, h = this.bboxes, u = 0; u < l.length; u++) {
                            var d = l[u];
                            if (void 0 === s[d]) {
                                var f = 4 * d;
                                (a ? a(h[f + 0], h[f + 1], h[f + 2], h[f + 3]) : t <= h[f + 2] && e <= h[f + 3] && i >= h[f + 0] && n >= h[f + 1]) ? (s[d] = !0,
                                o.push(c[d])) : s[d] = !1
                            }
                        }
                }
                ,
                Hr.prototype._forEachCell = function(t, e, i, n, r, o, s, a) {
                    for (var l = this._convertToCellCoord(t), c = this._convertToCellCoord(e), h = this._convertToCellCoord(i), u = this._convertToCellCoord(n), d = l; d <= h; d++)
                        for (var f = c; f <= u; f++) {
                            var p = this.d * f + d;
                            if ((!a || a(this._convertFromCellCoord(d), this._convertFromCellCoord(f), this._convertFromCellCoord(d + 1), this._convertFromCellCoord(f + 1))) && r.call(this, t, e, i, n, p, o, s, a))
                                return
                        }
                }
                ,
                Hr.prototype._convertFromCellCoord = function(t) {
                    return (t - this.padding) / this.scale
                }
                ,
                Hr.prototype._convertToCellCoord = function(t) {
                    return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
                }
                ,
                Hr.prototype.toArrayBuffer = function() {
                    if (this.arrayBuffer)
                        return this.arrayBuffer;
                    for (var t = this.cells, e = Wr + this.cells.length + 1 + 1, i = 0, n = 0; n < this.cells.length; n++)
                        i += this.cells[n].length;
                    var r = new Int32Array(e + i + this.keys.length + this.bboxes.length);
                    r[0] = this.extent,
                    r[1] = this.n,
                    r[2] = this.padding;
                    for (var o = e, s = 0; s < t.length; s++) {
                        var a = t[s];
                        r[Wr + s] = o,
                        r.set(a, o),
                        o += a.length
                    }
                    return r[Wr + t.length] = o,
                    r.set(this.keys, o),
                    r[Wr + t.length + 1] = o += this.keys.length,
                    r.set(this.bboxes, o),
                    o += this.bboxes.length,
                    r.buffer
                }
                ;
                var $r = f(qr);
                const Xr = {};
                function Yr(t, e, i={}) {
                    Object.defineProperty(t, "_classRegistryKey", {
                        value: e,
                        writeable: !1
                    }),
                    Xr[e] = {
                        klass: t,
                        omit: i.omit || []
                    }
                }
                Yr(Object, "Object"),
                $r.serialize = function(t, e) {
                    const i = t.toArrayBuffer();
                    return e && e.push(i),
                    {
                        buffer: i
                    }
                }
                ,
                $r.deserialize = function(t) {
                    return new $r(t.buffer)
                }
                ,
                Object.defineProperty($r, "name", {
                    value: "Grid"
                }),
                Yr($r, "Grid"),
                Yr(Oe, "Color"),
                Yr(Error, "Error"),
                Yr(ht, "AJAXError"),
                Yr(Be, "ResolvedImage"),
                Yr(er, "StylePropertyFunction"),
                Yr(Xn, "StyleExpression", {
                    omit: ["_evaluator"]
                }),
                Yr(Qn, "ZoomDependentExpression"),
                Yr(Jn, "ZoomConstantExpression"),
                Yr(ei, "CompoundExpression", {
                    omit: ["_evaluate"]
                });
                for (const t in Dn)
                    Xr[Dn[t]._classRegistryKey] || Yr(Dn[t], `Expression${t}`);
                function Kr(t) {
                    return t && "undefined" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && "ArrayBuffer" === t.constructor.name)
                }
                function Jr(t) {
                    return e.ImageBitmap && t instanceof e.ImageBitmap
                }
                function Qr(t, i) {
                    if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp)
                        return t;
                    if (Kr(t) || Jr(t))
                        return i && i.push(t),
                        t;
                    if (ArrayBuffer.isView(t)) {
                        const e = t;
                        return i && i.push(e.buffer),
                        e
                    }
                    if (t instanceof e.ImageData)
                        return i && i.push(t.data.buffer),
                        t;
                    if (Array.isArray(t)) {
                        const e = [];
                        for (const n of t)
                            e.push(Qr(n, i));
                        return e
                    }
                    if ("object" == typeof t) {
                        const e = t.constructor
                          , n = e._classRegistryKey;
                        if (!n)
                            throw new Error(`can't serialize object of unregistered class ${n}`);
                        const r = e.serialize ? e.serialize(t, i) : {};
                        if (!e.serialize) {
                            for (const e in t)
                                t.hasOwnProperty(e) && (Xr[n].omit.indexOf(e) >= 0 || (r[e] = Qr(t[e], i)));
                            t instanceof Error && (r.message = t.message)
                        }
                        if (r.$name)
                            throw new Error("$name property is reserved for worker serialization logic.");
                        return "Object" !== n && (r.$name = n),
                        r
                    }
                    throw new Error("can't serialize object of type " + typeof t)
                }
                function to(t) {
                    if (null == t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || Kr(t) || Jr(t) || ArrayBuffer.isView(t) || t instanceof e.ImageData)
                        return t;
                    if (Array.isArray(t))
                        return t.map(to);
                    if ("object" == typeof t) {
                        const e = t.$name || "Object"
                          , {klass: i} = Xr[e];
                        if (!i)
                            throw new Error(`can't deserialize unregistered class ${e}`);
                        if (i.deserialize)
                            return i.deserialize(t);
                        const n = Object.create(i.prototype);
                        for (const e of Object.keys(t))
                            "$name" !== e && (n[e] = to(t[e]));
                        return n
                    }
                    throw new Error("can't deserialize object of type " + typeof t)
                }
                const eo = {
                    "Latin-1 Supplement": t => t >= 128 && t <= 255,
                    Arabic: t => t >= 1536 && t <= 1791,
                    "Arabic Supplement": t => t >= 1872 && t <= 1919,
                    "Arabic Extended-A": t => t >= 2208 && t <= 2303,
                    "Hangul Jamo": t => t >= 4352 && t <= 4607,
                    "Unified Canadian Aboriginal Syllabics": t => t >= 5120 && t <= 5759,
                    Khmer: t => t >= 6016 && t <= 6143,
                    "Unified Canadian Aboriginal Syllabics Extended": t => t >= 6320 && t <= 6399,
                    "General Punctuation": t => t >= 8192 && t <= 8303,
                    "Letterlike Symbols": t => t >= 8448 && t <= 8527,
                    "Number Forms": t => t >= 8528 && t <= 8591,
                    "Miscellaneous Technical": t => t >= 8960 && t <= 9215,
                    "Control Pictures": t => t >= 9216 && t <= 9279,
                    "Optical Character Recognition": t => t >= 9280 && t <= 9311,
                    "Enclosed Alphanumerics": t => t >= 9312 && t <= 9471,
                    "Geometric Shapes": t => t >= 9632 && t <= 9727,
                    "Miscellaneous Symbols": t => t >= 9728 && t <= 9983,
                    "Miscellaneous Symbols and Arrows": t => t >= 11008 && t <= 11263,
                    "CJK Radicals Supplement": t => t >= 11904 && t <= 12031,
                    "Kangxi Radicals": t => t >= 12032 && t <= 12255,
                    "Ideographic Description Characters": t => t >= 12272 && t <= 12287,
                    "CJK Symbols and Punctuation": t => t >= 12288 && t <= 12351,
                    Hiragana: t => t >= 12352 && t <= 12447,
                    Katakana: t => t >= 12448 && t <= 12543,
                    Bopomofo: t => t >= 12544 && t <= 12591,
                    "Hangul Compatibility Jamo": t => t >= 12592 && t <= 12687,
                    Kanbun: t => t >= 12688 && t <= 12703,
                    "Bopomofo Extended": t => t >= 12704 && t <= 12735,
                    "CJK Strokes": t => t >= 12736 && t <= 12783,
                    "Katakana Phonetic Extensions": t => t >= 12784 && t <= 12799,
                    "Enclosed CJK Letters and Months": t => t >= 12800 && t <= 13055,
                    "CJK Compatibility": t => t >= 13056 && t <= 13311,
                    "CJK Unified Ideographs Extension A": t => t >= 13312 && t <= 19903,
                    "Yijing Hexagram Symbols": t => t >= 19904 && t <= 19967,
                    "CJK Unified Ideographs": t => t >= 19968 && t <= 40959,
                    "Yi Syllables": t => t >= 40960 && t <= 42127,
                    "Yi Radicals": t => t >= 42128 && t <= 42191,
                    "Hangul Jamo Extended-A": t => t >= 43360 && t <= 43391,
                    "Hangul Syllables": t => t >= 44032 && t <= 55215,
                    "Hangul Jamo Extended-B": t => t >= 55216 && t <= 55295,
                    "Private Use Area": t => t >= 57344 && t <= 63743,
                    "CJK Compatibility Ideographs": t => t >= 63744 && t <= 64255,
                    "Arabic Presentation Forms-A": t => t >= 64336 && t <= 65023,
                    "Vertical Forms": t => t >= 65040 && t <= 65055,
                    "CJK Compatibility Forms": t => t >= 65072 && t <= 65103,
                    "Small Form Variants": t => t >= 65104 && t <= 65135,
                    "Arabic Presentation Forms-B": t => t >= 65136 && t <= 65279,
                    "Halfwidth and Fullwidth Forms": t => t >= 65280 && t <= 65519
                };
                function io(t) {
                    for (const e of t)
                        if (oo(e.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function no(t) {
                    for (const e of t)
                        if (!ro(e.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function ro(t) {
                    return !(eo.Arabic(t) || eo["Arabic Supplement"](t) || eo["Arabic Extended-A"](t) || eo["Arabic Presentation Forms-A"](t) || eo["Arabic Presentation Forms-B"](t))
                }
                function oo(t) {
                    return !(746 !== t && 747 !== t && (t < 4352 || !(eo["Bopomofo Extended"](t) || eo.Bopomofo(t) || eo["CJK Compatibility Forms"](t) && !(t >= 65097 && t <= 65103) || eo["CJK Compatibility Ideographs"](t) || eo["CJK Compatibility"](t) || eo["CJK Radicals Supplement"](t) || eo["CJK Strokes"](t) || !(!eo["CJK Symbols and Punctuation"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || eo["CJK Unified Ideographs Extension A"](t) || eo["CJK Unified Ideographs"](t) || eo["Enclosed CJK Letters and Months"](t) || eo["Hangul Compatibility Jamo"](t) || eo["Hangul Jamo Extended-A"](t) || eo["Hangul Jamo Extended-B"](t) || eo["Hangul Jamo"](t) || eo["Hangul Syllables"](t) || eo.Hiragana(t) || eo["Ideographic Description Characters"](t) || eo.Kanbun(t) || eo["Kangxi Radicals"](t) || eo["Katakana Phonetic Extensions"](t) || eo.Katakana(t) && 12540 !== t || !(!eo["Halfwidth and Fullwidth Forms"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!eo["Small Form Variants"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || eo["Unified Canadian Aboriginal Syllabics"](t) || eo["Unified Canadian Aboriginal Syllabics Extended"](t) || eo["Vertical Forms"](t) || eo["Yijing Hexagram Symbols"](t) || eo["Yi Syllables"](t) || eo["Yi Radicals"](t))))
                }
                function so(t) {
                    return !(oo(t) || function(t) {
                        return !!(eo["Latin-1 Supplement"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || eo["General Punctuation"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || eo["Letterlike Symbols"](t) || eo["Number Forms"](t) || eo["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || eo["Control Pictures"](t) && 9251 !== t || eo["Optical Character Recognition"](t) || eo["Enclosed Alphanumerics"](t) || eo["Geometric Shapes"](t) || eo["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || eo["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || eo["CJK Symbols and Punctuation"](t) || eo.Katakana(t) || eo["Private Use Area"](t) || eo["CJK Compatibility Forms"](t) || eo["Small Form Variants"](t) || eo["Halfwidth and Fullwidth Forms"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t)
                    }(t))
                }
                function ao(t) {
                    return t >= 1424 && t <= 2303 || eo["Arabic Presentation Forms-A"](t) || eo["Arabic Presentation Forms-B"](t)
                }
                function lo(t, e) {
                    return !(!e && ao(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || eo.Khmer(t))
                }
                function co(t) {
                    for (const e of t)
                        if (ao(e.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const ho = "deferred"
                  , uo = "loading"
                  , fo = "loaded";
                let po = null
                  , mo = "unavailable"
                  , go = null;
                const _o = function(t) {
                    t && "string" == typeof t && t.indexOf("NetworkError") > -1 && (mo = "error"),
                    po && po(t)
                };
                function yo() {
                    vo.fire(new Jt("pluginStateChange",{
                        pluginStatus: mo,
                        pluginURL: go
                    }))
                }
                const vo = new te
                  , xo = function() {
                    return mo
                }
                  , bo = function() {
                    if (mo !== ho || !go)
                        throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
                    mo = uo,
                    yo(),
                    go && ft({
                        url: go
                    }, (t => {
                        t ? _o(t) : (mo = fo,
                        yo())
                    }
                    ))
                }
                  , wo = {
                    applyArabicShaping: null,
                    processBidirectionalText: null,
                    processStyledBidirectionalText: null,
                    isLoaded: () => mo === fo || null != wo.applyArabicShaping,
                    isLoading: () => mo === uo,
                    setState(t) {
                        mo = t.pluginStatus,
                        go = t.pluginURL
                    },
                    isParsed: () => null != wo.applyArabicShaping && null != wo.processBidirectionalText && null != wo.processStyledBidirectionalText,
                    getPluginURL: () => go
                };
                class Eo {
                    constructor(t, e) {
                        this.zoom = t,
                        e ? (this.now = e.now,
                        this.fadeDuration = e.fadeDuration,
                        this.transition = e.transition,
                        this.pitch = e.pitch) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.transition = {},
                        this.pitch = 0)
                    }
                    isSupportedScript(t) {
                        return function(t, e) {
                            for (const i of t)
                                if (!lo(i.charCodeAt(0), e))
                                    return !1;
                            return !0
                        }(t, wo.isLoaded())
                    }
                }
                class To {
                    constructor(t, e) {
                        this.property = t,
                        this.value = e,
                        this.expression = function(t, e) {
                            if (Un(t))
                                return new er(t,e);
                            if (Yn(t)) {
                                const i = tr(t, e);
                                if ("error" === i.result)
                                    throw new Error(i.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                                return i.value
                            }
                            {
                                let i = t;
                                return "string" == typeof t && "color" === e.type && (i = Oe.parse(t)),
                                {
                                    kind: "constant",
                                    evaluate: () => i
                                }
                            }
                        }(void 0 === e ? t.specification.default : e, t.specification)
                    }
                    isDataDriven() {
                        return "source" === this.expression.kind || "composite" === this.expression.kind
                    }
                    possiblyEvaluate(t, e, i) {
                        return this.property.possiblyEvaluate(this, t, e, i)
                    }
                }
                class So {
                    constructor(t) {
                        this.property = t,
                        this.value = new To(t,void 0)
                    }
                    transitioned(t, e) {
                        return new Ao(this.property,this.value,e,R({}, t.transition, this.transition),t.now)
                    }
                    untransitioned() {
                        return new Ao(this.property,this.value,null,{},0)
                    }
                }
                class Co {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitionablePropertyValues)
                    }
                    getValue(t) {
                        return G(this._values[t].value.value)
                    }
                    setValue(t, e) {
                        this._values.hasOwnProperty(t) || (this._values[t] = new So(this._values[t].property)),
                        this._values[t].value = new To(this._values[t].property,null === e ? void 0 : G(e))
                    }
                    getTransition(t) {
                        return G(this._values[t].transition)
                    }
                    setTransition(t, e) {
                        this._values.hasOwnProperty(t) || (this._values[t] = new So(this._values[t].property)),
                        this._values[t].transition = G(e) || void 0
                    }
                    serialize() {
                        const t = {};
                        for (const e of Object.keys(this._values)) {
                            const i = this.getValue(e);
                            void 0 !== i && (t[e] = i);
                            const n = this.getTransition(e);
                            void 0 !== n && (t[`${e}-transition`] = n)
                        }
                        return t
                    }
                    transitioned(t, e) {
                        const i = new Io(this._properties);
                        for (const n of Object.keys(this._values))
                            i._values[n] = this._values[n].transitioned(t, e._values[n]);
                        return i
                    }
                    untransitioned() {
                        const t = new Io(this._properties);
                        for (const e of Object.keys(this._values))
                            t._values[e] = this._values[e].untransitioned();
                        return t
                    }
                }
                class Ao {
                    constructor(t, e, i, n, r) {
                        const o = n.delay || 0
                          , s = n.duration || 0;
                        r = r || 0,
                        this.property = t,
                        this.value = e,
                        this.begin = r + o,
                        this.end = this.begin + s,
                        t.specification.transition && (n.delay || n.duration) && (this.prior = i)
                    }
                    possiblyEvaluate(t, e, i) {
                        const n = t.now || 0
                          , r = this.value.possiblyEvaluate(t, e, i)
                          , o = this.prior;
                        if (o) {
                            if (n > this.end)
                                return this.prior = null,
                                r;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                r;
                            if (n < this.begin)
                                return o.possiblyEvaluate(t, e, i);
                            {
                                const s = (n - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(o.possiblyEvaluate(t, e, i), r, S(s))
                            }
                        }
                        return r
                    }
                }
                class Io {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(t, e, i) {
                        const n = new ko(this._properties);
                        for (const r of Object.keys(this._values))
                            n._values[r] = this._values[r].possiblyEvaluate(t, e, i);
                        return n
                    }
                    hasTransition() {
                        for (const t of Object.keys(this._values))
                            if (this._values[t].prior)
                                return !0;
                        return !1
                    }
                }
                class Mo {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPropertyValues)
                    }
                    getValue(t) {
                        return G(this._values[t].value)
                    }
                    setValue(t, e) {
                        this._values[t] = new To(this._values[t].property,null === e ? void 0 : G(e))
                    }
                    serialize() {
                        const t = {};
                        for (const e of Object.keys(this._values)) {
                            const i = this.getValue(e);
                            void 0 !== i && (t[e] = i)
                        }
                        return t
                    }
                    possiblyEvaluate(t, e, i) {
                        const n = new ko(this._properties);
                        for (const r of Object.keys(this._values))
                            n._values[r] = this._values[r].possiblyEvaluate(t, e, i);
                        return n
                    }
                }
                class Po {
                    constructor(t, e, i) {
                        this.property = t,
                        this.value = e,
                        this.parameters = i
                    }
                    isConstant() {
                        return "constant" === this.value.kind
                    }
                    constantOr(t) {
                        return "constant" === this.value.kind ? this.value.value : t
                    }
                    evaluate(t, e, i, n) {
                        return this.property.evaluate(this.value, this.parameters, t, e, i, n)
                    }
                }
                class ko {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPossiblyEvaluatedValues)
                    }
                    get(t) {
                        return this._values[t]
                    }
                }
                class Oo {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, e) {
                        return t.expression.evaluate(e)
                    }
                    interpolate(t, e, i) {
                        const n = Ri[this.specification.type];
                        return n ? n(t, e, i) : t
                    }
                }
                class Ro {
                    constructor(t, e) {
                        this.specification = t,
                        this.overrides = e
                    }
                    possiblyEvaluate(t, e, i, n) {
                        return new Po(this,"constant" === t.expression.kind || "camera" === t.expression.kind ? {
                            kind: "constant",
                            value: t.expression.evaluate(e, null, {}, i, n)
                        } : t.expression,e)
                    }
                    interpolate(t, e, i) {
                        if ("constant" !== t.value.kind || "constant" !== e.value.kind)
                            return t;
                        if (void 0 === t.value.value || void 0 === e.value.value)
                            return new Po(this,{
                                kind: "constant",
                                value: void 0
                            },t.parameters);
                        const n = Ri[this.specification.type];
                        return n ? new Po(this,{
                            kind: "constant",
                            value: n(t.value.value, e.value.value, i)
                        },t.parameters) : t
                    }
                    evaluate(t, e, i, n, r, o) {
                        return "constant" === t.kind ? t.value : t.evaluate(e, i, n, r, o)
                    }
                }
                class Do {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, e, i, n) {
                        return !!t.expression.evaluate(e, null, {}, i, n)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class Lo {
                    constructor(t) {
                        this.properties = t,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        const e = new Eo(0,{});
                        for (const i in t) {
                            const n = t[i];
                            n.specification.overridable && this.overridableProperties.push(i);
                            const r = this.defaultPropertyValues[i] = new To(n,void 0)
                              , o = this.defaultTransitionablePropertyValues[i] = new So(n);
                            this.defaultTransitioningPropertyValues[i] = o.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[i] = r.possiblyEvaluate(e)
                        }
                    }
                }
                function Bo(t, e) {
                    return 256 * (t = I(Math.floor(t), 0, 255)) + I(Math.floor(e), 0, 255)
                }
                Yr(Ro, "DataDrivenProperty"),
                Yr(Oo, "DataConstantProperty"),
                Yr(Do, "ColorRampProperty");
                const zo = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class Fo {
                    constructor(t, e) {
                        this._structArray = t,
                        this._pos1 = e * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class No {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(t, e) {
                        return t._trim(),
                        e && (t.isTransferred = !0,
                        e.push(t.arrayBuffer)),
                        {
                            length: t.length,
                            arrayBuffer: t.arrayBuffer
                        }
                    }
                    static deserialize(t) {
                        const e = Object.create(this.prototype);
                        return e.arrayBuffer = t.arrayBuffer,
                        e.length = t.length,
                        e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement,
                        e._refreshViews(),
                        e
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(t) {
                        this.reserve(t),
                        this.length = t
                    }
                    reserve(t) {
                        if (t > this.capacity) {
                            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const e = this.uint8;
                            this._refreshViews(),
                            e && this.uint8.set(e)
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                    destroy() {
                        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null,
                        this.arrayBuffer = null
                    }
                }
                function jo(t, e=1) {
                    let i = 0
                      , n = 0;
                    return {
                        members: t.map((t => {
                            const r = zo[t.type].BYTES_PER_ELEMENT
                              , o = i = Uo(i, Math.max(e, r))
                              , s = t.components || 1;
                            return n = Math.max(n, r),
                            i += r * s,
                            {
                                name: t.name,
                                type: t.type,
                                components: s,
                                offset: o
                            }
                        }
                        )),
                        size: Uo(i, Math.max(n, e)),
                        alignment: e
                    }
                }
                function Uo(t, e) {
                    return Math.ceil(t / e) * e
                }
                class Vo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t, e)
                    }
                    emplace(t, e, i) {
                        const n = 2 * t;
                        return this.int16[n + 0] = e,
                        this.int16[n + 1] = i,
                        t
                    }
                }
                Vo.prototype.bytesPerElement = 4,
                Yr(Vo, "StructArrayLayout2i4");
                class Go extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t, e, i)
                    }
                    emplace(t, e, i, n) {
                        const r = 3 * t;
                        return this.int16[r + 0] = e,
                        this.int16[r + 1] = i,
                        this.int16[r + 2] = n,
                        t
                    }
                }
                Go.prototype.bytesPerElement = 6,
                Yr(Go, "StructArrayLayout3i6");
                class Zo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t, e, i, n)
                    }
                    emplace(t, e, i, n, r) {
                        const o = 4 * t;
                        return this.int16[o + 0] = e,
                        this.int16[o + 1] = i,
                        this.int16[o + 2] = n,
                        this.int16[o + 3] = r,
                        t
                    }
                }
                Zo.prototype.bytesPerElement = 8,
                Yr(Zo, "StructArrayLayout4i8");
                class qo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, e, i, n, r, o, s)
                    }
                    emplace(t, e, i, n, r, o, s, a) {
                        const l = 6 * t
                          , c = 12 * t
                          , h = 3 * t;
                        return this.int16[l + 0] = e,
                        this.int16[l + 1] = i,
                        this.uint8[c + 4] = n,
                        this.uint8[c + 5] = r,
                        this.uint8[c + 6] = o,
                        this.uint8[c + 7] = s,
                        this.float32[h + 2] = a,
                        t
                    }
                }
                qo.prototype.bytesPerElement = 12,
                Yr(qo, "StructArrayLayout2i4ub1f12");
                class Wo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t, e, i, n)
                    }
                    emplace(t, e, i, n, r) {
                        const o = 4 * t;
                        return this.float32[o + 0] = e,
                        this.float32[o + 1] = i,
                        this.float32[o + 2] = n,
                        this.float32[o + 3] = r,
                        t
                    }
                }
                Wo.prototype.bytesPerElement = 16,
                Yr(Wo, "StructArrayLayout4f16");
                class Ho extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, t, e, i, n, r)
                    }
                    emplace(t, e, i, n, r, o) {
                        const s = 6 * t
                          , a = 3 * t;
                        return this.uint16[s + 0] = e,
                        this.uint16[s + 1] = i,
                        this.uint16[s + 2] = n,
                        this.uint16[s + 3] = r,
                        this.float32[a + 2] = o,
                        t
                    }
                }
                Ho.prototype.bytesPerElement = 12,
                Yr(Ho, "StructArrayLayout4ui1f12");
                class $o extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t, e, i, n)
                    }
                    emplace(t, e, i, n, r) {
                        const o = 4 * t;
                        return this.uint16[o + 0] = e,
                        this.uint16[o + 1] = i,
                        this.uint16[o + 2] = n,
                        this.uint16[o + 3] = r,
                        t
                    }
                }
                $o.prototype.bytesPerElement = 8,
                Yr($o, "StructArrayLayout4ui8");
                class Xo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o) {
                        const s = this.length;
                        return this.resize(s + 1),
                        this.emplace(s, t, e, i, n, r, o)
                    }
                    emplace(t, e, i, n, r, o, s) {
                        const a = 6 * t;
                        return this.int16[a + 0] = e,
                        this.int16[a + 1] = i,
                        this.int16[a + 2] = n,
                        this.int16[a + 3] = r,
                        this.int16[a + 4] = o,
                        this.int16[a + 5] = s,
                        t
                    }
                }
                Xo.prototype.bytesPerElement = 12,
                Yr(Xo, "StructArrayLayout6i12");
                class Yo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s, a, l, c, h, u) {
                        const d = this.length;
                        return this.resize(d + 1),
                        this.emplace(d, t, e, i, n, r, o, s, a, l, c, h, u)
                    }
                    emplace(t, e, i, n, r, o, s, a, l, c, h, u, d) {
                        const f = 12 * t;
                        return this.int16[f + 0] = e,
                        this.int16[f + 1] = i,
                        this.int16[f + 2] = n,
                        this.int16[f + 3] = r,
                        this.uint16[f + 4] = o,
                        this.uint16[f + 5] = s,
                        this.uint16[f + 6] = a,
                        this.uint16[f + 7] = l,
                        this.int16[f + 8] = c,
                        this.int16[f + 9] = h,
                        this.int16[f + 10] = u,
                        this.int16[f + 11] = d,
                        t
                    }
                }
                Yo.prototype.bytesPerElement = 24,
                Yr(Yo, "StructArrayLayout4i4ui4i24");
                class Ko extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o) {
                        const s = this.length;
                        return this.resize(s + 1),
                        this.emplace(s, t, e, i, n, r, o)
                    }
                    emplace(t, e, i, n, r, o, s) {
                        const a = 10 * t
                          , l = 5 * t;
                        return this.int16[a + 0] = e,
                        this.int16[a + 1] = i,
                        this.int16[a + 2] = n,
                        this.float32[l + 2] = r,
                        this.float32[l + 3] = o,
                        this.float32[l + 4] = s,
                        t
                    }
                }
                Ko.prototype.bytesPerElement = 20,
                Yr(Ko, "StructArrayLayout3i3f20");
                class Jo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const e = this.length;
                        return this.resize(e + 1),
                        this.emplace(e, t)
                    }
                    emplace(t, e) {
                        return this.uint32[1 * t + 0] = e,
                        t
                    }
                }
                Jo.prototype.bytesPerElement = 4,
                Yr(Jo, "StructArrayLayout1ul4");
                class Qo extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s, a, l, c, h, u, d) {
                        const f = this.length;
                        return this.resize(f + 1),
                        this.emplace(f, t, e, i, n, r, o, s, a, l, c, h, u, d)
                    }
                    emplace(t, e, i, n, r, o, s, a, l, c, h, u, d, f) {
                        const p = 20 * t
                          , m = 10 * t;
                        return this.int16[p + 0] = e,
                        this.int16[p + 1] = i,
                        this.int16[p + 2] = n,
                        this.int16[p + 3] = r,
                        this.int16[p + 4] = o,
                        this.float32[m + 3] = s,
                        this.float32[m + 4] = a,
                        this.float32[m + 5] = l,
                        this.float32[m + 6] = c,
                        this.int16[p + 14] = h,
                        this.uint32[m + 8] = u,
                        this.uint16[p + 18] = d,
                        this.uint16[p + 19] = f,
                        t
                    }
                }
                Qo.prototype.bytesPerElement = 40,
                Yr(Qo, "StructArrayLayout5i4f1i1ul2ui40");
                class ts extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s) {
                        const a = this.length;
                        return this.resize(a + 1),
                        this.emplace(a, t, e, i, n, r, o, s)
                    }
                    emplace(t, e, i, n, r, o, s, a) {
                        const l = 8 * t;
                        return this.int16[l + 0] = e,
                        this.int16[l + 1] = i,
                        this.int16[l + 2] = n,
                        this.int16[l + 4] = r,
                        this.int16[l + 5] = o,
                        this.int16[l + 6] = s,
                        this.int16[l + 7] = a,
                        t
                    }
                }
                ts.prototype.bytesPerElement = 16,
                Yr(ts, "StructArrayLayout3i2i2i16");
                class es extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, t, e, i, n, r)
                    }
                    emplace(t, e, i, n, r, o) {
                        const s = 4 * t
                          , a = 8 * t;
                        return this.float32[s + 0] = e,
                        this.float32[s + 1] = i,
                        this.float32[s + 2] = n,
                        this.int16[a + 6] = r,
                        this.int16[a + 7] = o,
                        t
                    }
                }
                es.prototype.bytesPerElement = 16,
                Yr(es, "StructArrayLayout2f1f2i16");
                class is extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t, e, i, n)
                    }
                    emplace(t, e, i, n, r) {
                        const o = 12 * t
                          , s = 3 * t;
                        return this.uint8[o + 0] = e,
                        this.uint8[o + 1] = i,
                        this.float32[s + 1] = n,
                        this.float32[s + 2] = r,
                        t
                    }
                }
                is.prototype.bytesPerElement = 12,
                Yr(is, "StructArrayLayout2ub2f12");
                class ns extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t, e, i)
                    }
                    emplace(t, e, i, n) {
                        const r = 3 * t;
                        return this.float32[r + 0] = e,
                        this.float32[r + 1] = i,
                        this.float32[r + 2] = n,
                        t
                    }
                }
                ns.prototype.bytesPerElement = 12,
                Yr(ns, "StructArrayLayout3f12");
                class rs extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t, e, i)
                    }
                    emplace(t, e, i, n) {
                        const r = 3 * t;
                        return this.uint16[r + 0] = e,
                        this.uint16[r + 1] = i,
                        this.uint16[r + 2] = n,
                        t
                    }
                }
                rs.prototype.bytesPerElement = 6,
                Yr(rs, "StructArrayLayout3ui6");
                class os extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x) {
                        const b = this.length;
                        return this.resize(b + 1),
                        this.emplace(b, t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x)
                    }
                    emplace(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x, b) {
                        const w = 30 * t
                          , E = 15 * t
                          , T = 60 * t;
                        return this.int16[w + 0] = e,
                        this.int16[w + 1] = i,
                        this.int16[w + 2] = n,
                        this.float32[E + 2] = r,
                        this.float32[E + 3] = o,
                        this.uint16[w + 8] = s,
                        this.uint16[w + 9] = a,
                        this.uint32[E + 5] = l,
                        this.uint32[E + 6] = c,
                        this.uint32[E + 7] = h,
                        this.uint16[w + 16] = u,
                        this.uint16[w + 17] = d,
                        this.uint16[w + 18] = f,
                        this.float32[E + 10] = p,
                        this.float32[E + 11] = m,
                        this.uint8[T + 48] = g,
                        this.uint8[T + 49] = _,
                        this.uint8[T + 50] = y,
                        this.uint32[E + 13] = v,
                        this.int16[w + 28] = x,
                        this.uint8[T + 58] = b,
                        t
                    }
                }
                os.prototype.bytesPerElement = 60,
                Yr(os, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
                class ss extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x, b, w, E, T, S, C, A, I, M) {
                        const P = this.length;
                        return this.resize(P + 1),
                        this.emplace(P, t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x, b, w, E, T, S, C, A, I, M)
                    }
                    emplace(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x, b, w, E, T, S, C, A, I, M, P) {
                        const k = 38 * t
                          , O = 19 * t;
                        return this.int16[k + 0] = e,
                        this.int16[k + 1] = i,
                        this.int16[k + 2] = n,
                        this.float32[O + 2] = r,
                        this.float32[O + 3] = o,
                        this.int16[k + 8] = s,
                        this.int16[k + 9] = a,
                        this.int16[k + 10] = l,
                        this.int16[k + 11] = c,
                        this.int16[k + 12] = h,
                        this.int16[k + 13] = u,
                        this.uint16[k + 14] = d,
                        this.uint16[k + 15] = f,
                        this.uint16[k + 16] = p,
                        this.uint16[k + 17] = m,
                        this.uint16[k + 18] = g,
                        this.uint16[k + 19] = _,
                        this.uint16[k + 20] = y,
                        this.uint16[k + 21] = v,
                        this.uint16[k + 22] = x,
                        this.uint16[k + 23] = b,
                        this.uint16[k + 24] = w,
                        this.uint16[k + 25] = E,
                        this.uint16[k + 26] = T,
                        this.uint16[k + 27] = S,
                        this.uint16[k + 28] = C,
                        this.uint32[O + 15] = A,
                        this.float32[O + 16] = I,
                        this.float32[O + 17] = M,
                        this.float32[O + 18] = P,
                        t
                    }
                }
                ss.prototype.bytesPerElement = 76,
                Yr(ss, "StructArrayLayout3i2f6i15ui1ul3f76");
                class as extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const e = this.length;
                        return this.resize(e + 1),
                        this.emplace(e, t)
                    }
                    emplace(t, e) {
                        return this.float32[1 * t + 0] = e,
                        t
                    }
                }
                as.prototype.bytesPerElement = 4,
                Yr(as, "StructArrayLayout1f4");
                class ls extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n, r) {
                        const o = this.length;
                        return this.resize(o + 1),
                        this.emplace(o, t, e, i, n, r)
                    }
                    emplace(t, e, i, n, r, o) {
                        const s = 5 * t;
                        return this.float32[s + 0] = e,
                        this.float32[s + 1] = i,
                        this.float32[s + 2] = n,
                        this.float32[s + 3] = r,
                        this.float32[s + 4] = o,
                        t
                    }
                }
                ls.prototype.bytesPerElement = 20,
                Yr(ls, "StructArrayLayout5f20");
                class cs extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e, i, n) {
                        const r = this.length;
                        return this.resize(r + 1),
                        this.emplace(r, t, e, i, n)
                    }
                    emplace(t, e, i, n, r) {
                        const o = 6 * t;
                        return this.uint32[3 * t + 0] = e,
                        this.uint16[o + 2] = i,
                        this.uint16[o + 3] = n,
                        this.uint16[o + 4] = r,
                        t
                    }
                }
                cs.prototype.bytesPerElement = 12,
                Yr(cs, "StructArrayLayout1ul3ui12");
                class hs extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t, e)
                    }
                    emplace(t, e, i) {
                        const n = 2 * t;
                        return this.uint16[n + 0] = e,
                        this.uint16[n + 1] = i,
                        t
                    }
                }
                hs.prototype.bytesPerElement = 4,
                Yr(hs, "StructArrayLayout2ui4");
                class us extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const e = this.length;
                        return this.resize(e + 1),
                        this.emplace(e, t)
                    }
                    emplace(t, e) {
                        return this.uint16[1 * t + 0] = e,
                        t
                    }
                }
                us.prototype.bytesPerElement = 2,
                Yr(us, "StructArrayLayout1ui2");
                class ds extends No {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, e) {
                        const i = this.length;
                        return this.resize(i + 1),
                        this.emplace(i, t, e)
                    }
                    emplace(t, e, i) {
                        const n = 2 * t;
                        return this.float32[n + 0] = e,
                        this.float32[n + 1] = i,
                        t
                    }
                }
                ds.prototype.bytesPerElement = 8,
                Yr(ds, "StructArrayLayout2f8");
                class fs extends Fo {
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get tileAnchorX() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get tileAnchorY() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get x1() {
                        return this._structArray.float32[this._pos4 + 3]
                    }
                    get y1() {
                        return this._structArray.float32[this._pos4 + 4]
                    }
                    get x2() {
                        return this._structArray.float32[this._pos4 + 5]
                    }
                    get y2() {
                        return this._structArray.float32[this._pos4 + 6]
                    }
                    get padding() {
                        return this._structArray.int16[this._pos2 + 14]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 8]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                }
                fs.prototype.size = 40;
                class ps extends Qo {
                    get(t) {
                        return new fs(this,t)
                    }
                }
                Yr(ps, "CollisionBoxArray");
                class ms extends Fo {
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get tileAnchorX() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                    get tileAnchorY() {
                        return this._structArray.float32[this._pos4 + 3]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 5]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 6]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 7]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 10]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 11]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 48]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 49]
                    }
                    set placedOrientation(t) {
                        this._structArray.uint8[this._pos1 + 49] = t
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 50]
                    }
                    set hidden(t) {
                        this._structArray.uint8[this._pos1 + 50] = t
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 13]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 13] = t
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 28]
                    }
                    get flipState() {
                        return this._structArray.uint8[this._pos1 + 58]
                    }
                    set flipState(t) {
                        this._structArray.uint8[this._pos1 + 58] = t
                    }
                }
                ms.prototype.size = 60;
                class gs extends os {
                    get(t) {
                        return new ms(this,t)
                    }
                }
                Yr(gs, "PlacedSymbolArray");
                class _s extends Fo {
                    get projectedAnchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get projectedAnchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get projectedAnchorZ() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get tileAnchorX() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                    get tileAnchorY() {
                        return this._structArray.float32[this._pos4 + 3]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 8]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 9]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 10]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 11]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 12]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 13]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 23]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 24]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 25]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 26]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 27]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 28]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 15]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 15] = t
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 16]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 17]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 18]
                    }
                }
                _s.prototype.size = 76;
                class ys extends ss {
                    get(t) {
                        return new _s(this,t)
                    }
                }
                Yr(ys, "SymbolInstanceArray");
                class vs extends as {
                    getoffsetX(t) {
                        return this.float32[1 * t + 0]
                    }
                }
                Yr(vs, "GlyphOffsetArray");
                class xs extends Vo {
                    getx(t) {
                        return this.int16[2 * t + 0]
                    }
                    gety(t) {
                        return this.int16[2 * t + 1]
                    }
                }
                Yr(xs, "SymbolLineVertexArray");
                class bs extends Fo {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get layoutVertexArrayOffset() {
                        return this._structArray.uint16[this._pos2 + 4]
                    }
                }
                bs.prototype.size = 12;
                class ws extends cs {
                    get(t) {
                        return new bs(this,t)
                    }
                }
                Yr(ws, "FeatureIndexArray");
                class Es extends hs {
                    geta_centroid_pos0(t) {
                        return this.uint16[2 * t + 0]
                    }
                    geta_centroid_pos1(t) {
                        return this.uint16[2 * t + 1]
                    }
                }
                Yr(Es, "FillExtrusionCentroidArray");
                const Ts = jo([{
                    name: "a_pattern",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio",
                    components: 1,
                    type: "Float32"
                }])
                  , Ss = jo([{
                    name: "a_dash",
                    components: 4,
                    type: "Uint16"
                }]);
                var Cs = {
                    exports: {}
                }
                  , As = {
                    exports: {}
                };
                As.exports = function(t, e) {
                    var i, n, r, o, s, a, l, c;
                    for (n = t.length - (i = 3 & t.length),
                    r = e,
                    s = 3432918353,
                    a = 461845907,
                    c = 0; c < n; )
                        l = 255 & t.charCodeAt(c) | (255 & t.charCodeAt(++c)) << 8 | (255 & t.charCodeAt(++c)) << 16 | (255 & t.charCodeAt(++c)) << 24,
                        ++c,
                        r = 27492 + (65535 & (o = 5 * (65535 & (r = (r ^= l = (65535 & (l = (l = (65535 & l) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 13 | r >>> 19)) + ((5 * (r >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (o >>> 16) & 65535) << 16);
                    switch (l = 0,
                    i) {
                    case 3:
                        l ^= (255 & t.charCodeAt(c + 2)) << 16;
                    case 2:
                        l ^= (255 & t.charCodeAt(c + 1)) << 8;
                    case 1:
                        r ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(c))) * s + (((l >>> 16) * s & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295
                    }
                    return r ^= t.length,
                    r = 2246822507 * (65535 & (r ^= r >>> 16)) + ((2246822507 * (r >>> 16) & 65535) << 16) & 4294967295,
                    r = 3266489909 * (65535 & (r ^= r >>> 13)) + ((3266489909 * (r >>> 16) & 65535) << 16) & 4294967295,
                    (r ^= r >>> 16) >>> 0
                }
                ;
                var Is = As.exports
                  , Ms = {
                    exports: {}
                };
                Ms.exports = function(t, e) {
                    for (var i, n = t.length, r = e ^ n, o = 0; n >= 4; )
                        i = 1540483477 * (65535 & (i = 255 & t.charCodeAt(o) | (255 & t.charCodeAt(++o)) << 8 | (255 & t.charCodeAt(++o)) << 16 | (255 & t.charCodeAt(++o)) << 24)) + ((1540483477 * (i >>> 16) & 65535) << 16),
                        r = 1540483477 * (65535 & r) + ((1540483477 * (r >>> 16) & 65535) << 16) ^ (i = 1540483477 * (65535 & (i ^= i >>> 24)) + ((1540483477 * (i >>> 16) & 65535) << 16)),
                        n -= 4,
                        ++o;
                    switch (n) {
                    case 3:
                        r ^= (255 & t.charCodeAt(o + 2)) << 16;
                    case 2:
                        r ^= (255 & t.charCodeAt(o + 1)) << 8;
                    case 1:
                        r = 1540483477 * (65535 & (r ^= 255 & t.charCodeAt(o))) + ((1540483477 * (r >>> 16) & 65535) << 16)
                    }
                    return r = 1540483477 * (65535 & (r ^= r >>> 13)) + ((1540483477 * (r >>> 16) & 65535) << 16),
                    (r ^= r >>> 15) >>> 0
                }
                ;
                var Ps = Is
                  , ks = Ms.exports;
                Cs.exports = Ps,
                Cs.exports.murmur3 = Ps,
                Cs.exports.murmur2 = ks;
                var Os = f(Cs.exports);
                class Rs {
                    constructor() {
                        this.ids = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(t, e, i, n) {
                        this.ids.push(Ds(t)),
                        this.positions.push(e, i, n)
                    }
                    getPositions(t) {
                        const e = Ds(t);
                        let i = 0
                          , n = this.ids.length - 1;
                        for (; i < n; ) {
                            const t = i + n >> 1;
                            this.ids[t] >= e ? n = t : i = t + 1
                        }
                        const r = [];
                        for (; this.ids[i] === e; )
                            r.push({
                                index: this.positions[3 * i],
                                start: this.positions[3 * i + 1],
                                end: this.positions[3 * i + 2]
                            }),
                            i++;
                        return r
                    }
                    static serialize(t, e) {
                        const i = new Float64Array(t.ids)
                          , n = new Uint32Array(t.positions);
                        return Ls(i, n, 0, i.length - 1),
                        e && e.push(i.buffer, n.buffer),
                        {
                            ids: i,
                            positions: n
                        }
                    }
                    static deserialize(t) {
                        const e = new Rs;
                        return e.ids = t.ids,
                        e.positions = t.positions,
                        e.indexed = !0,
                        e
                    }
                }
                function Ds(t) {
                    const e = +t;
                    return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : Os(String(t))
                }
                function Ls(t, e, i, n) {
                    for (; i < n; ) {
                        const r = t[i + n >> 1];
                        let o = i - 1
                          , s = n + 1;
                        for (; ; ) {
                            do {
                                o++
                            } while (t[o] < r);
                            do {
                                s--
                            } while (t[s] > r);
                            if (o >= s)
                                break;
                            Bs(t, o, s),
                            Bs(e, 3 * o, 3 * s),
                            Bs(e, 3 * o + 1, 3 * s + 1),
                            Bs(e, 3 * o + 2, 3 * s + 2)
                        }
                        s - i < n - s ? (Ls(t, e, i, s),
                        i = s + 1) : (Ls(t, e, s + 1, n),
                        n = s)
                    }
                }
                function Bs(t, e, i) {
                    const n = t[e];
                    t[e] = t[i],
                    t[i] = n
                }
                Yr(Rs, "FeaturePositionMap");
                class zs {
                    constructor(t) {
                        this.gl = t.gl,
                        this.initialized = !1
                    }
                    fetchUniformLocation(t, e) {
                        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e),
                        this.initialized = !0),
                        !!this.location
                    }
                }
                class Fs extends zs {
                    constructor(t) {
                        super(t),
                        this.current = 0
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && this.current !== i && (this.current = i,
                        this.gl.uniform1f(this.location, i))
                    }
                }
                class Ns extends zs {
                    constructor(t) {
                        super(t),
                        this.current = [0, 0, 0, 0]
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] && i[3] === this.current[3] || (this.current = i,
                        this.gl.uniform4f(this.location, i[0], i[1], i[2], i[3])))
                    }
                }
                class js extends zs {
                    constructor(t) {
                        super(t),
                        this.current = Oe.transparent
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && (i.r === this.current.r && i.g === this.current.g && i.b === this.current.b && i.a === this.current.a || (this.current = i,
                        this.gl.uniform4f(this.location, i.r, i.g, i.b, i.a)))
                    }
                }
                const Us = new Float32Array(16)
                  , Vs = new Float32Array(9)
                  , Gs = new Float32Array(4);
                function Zs(t) {
                    return [Bo(255 * t.r, 255 * t.g), Bo(255 * t.b, 255 * t.a)]
                }
                class qs {
                    constructor(t, e, i) {
                        this.value = t,
                        this.uniformNames = e.map((t => `u_${t}`)),
                        this.type = i
                    }
                    setUniform(t, e, i, n, r) {
                        e.set(t, r, n.constantOr(this.value))
                    }
                    getBinding(t, e) {
                        return "color" === this.type ? new js(t) : new Fs(t)
                    }
                }
                class Ws {
                    constructor(t, e) {
                        this.uniformNames = e.map((t => `u_${t}`)),
                        this.pattern = null,
                        this.pixelRatio = 1
                    }
                    setConstantPatternPositions(t) {
                        this.pixelRatio = t.pixelRatio || 1,
                        this.pattern = t.tl.concat(t.br)
                    }
                    setUniform(t, e, i, n, r) {
                        const o = "u_pattern" === r || "u_dash" === r ? this.pattern : "u_pixel_ratio" === r ? this.pixelRatio : null;
                        o && e.set(t, r, o)
                    }
                    getBinding(t, e) {
                        return "u_pattern" === e || "u_dash" === e ? new Ns(t) : new Fs(t)
                    }
                }
                class Hs {
                    constructor(t, e, i, n) {
                        this.expression = t,
                        this.type = i,
                        this.maxValue = 0,
                        this.paintVertexAttributes = e.map((t => ({
                            name: `a_${t}`,
                            type: "Float32",
                            components: "color" === i ? 2 : 1,
                            offset: 0
                        }))),
                        this.paintVertexArray = new n
                    }
                    populatePaintArray(t, e, i, n, r, o) {
                        const s = this.paintVertexArray.length
                          , a = this.expression.evaluate(new Eo(0), e, {}, r, n, o);
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(s, t, a)
                    }
                    updatePaintArray(t, e, i, n, r) {
                        const o = this.expression.evaluate({
                            zoom: 0
                        }, i, n, void 0, r);
                        this._setPaintValue(t, e, o)
                    }
                    _setPaintValue(t, e, i) {
                        if ("color" === this.type) {
                            const n = Zs(i);
                            for (let i = t; i < e; i++)
                                this.paintVertexArray.emplace(i, n[0], n[1])
                        } else {
                            for (let n = t; n < e; n++)
                                this.paintVertexArray.emplace(n, i);
                            this.maxValue = Math.max(this.maxValue, Math.abs(i))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class $s {
                    constructor(t, e, i, n, r, o) {
                        this.expression = t,
                        this.uniformNames = e.map((t => `u_${t}_t`)),
                        this.type = i,
                        this.useIntegerZoom = n,
                        this.zoom = r,
                        this.maxValue = 0,
                        this.paintVertexAttributes = e.map((t => ({
                            name: `a_${t}`,
                            type: "Float32",
                            components: "color" === i ? 4 : 2,
                            offset: 0
                        }))),
                        this.paintVertexArray = new o
                    }
                    populatePaintArray(t, e, i, n, r, o) {
                        const s = this.expression.evaluate(new Eo(this.zoom), e, {}, r, n, o)
                          , a = this.expression.evaluate(new Eo(this.zoom + 1), e, {}, r, n, o)
                          , l = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(l, t, s, a)
                    }
                    updatePaintArray(t, e, i, n, r) {
                        const o = this.expression.evaluate({
                            zoom: this.zoom
                        }, i, n, void 0, r)
                          , s = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, i, n, void 0, r);
                        this._setPaintValue(t, e, o, s)
                    }
                    _setPaintValue(t, e, i, n) {
                        if ("color" === this.type) {
                            const r = Zs(i)
                              , o = Zs(n);
                            for (let i = t; i < e; i++)
                                this.paintVertexArray.emplace(i, r[0], r[1], o[0], o[1])
                        } else {
                            for (let r = t; r < e; r++)
                                this.paintVertexArray.emplace(r, i, n);
                            this.maxValue = Math.max(this.maxValue, Math.abs(i), Math.abs(n))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(t, e, i, n, r) {
                        const o = this.useIntegerZoom ? Math.floor(i.zoom) : i.zoom
                          , s = I(this.expression.interpolationFactor(o, this.zoom, this.zoom + 1), 0, 1);
                        e.set(t, r, s)
                    }
                    getBinding(t, e) {
                        return new Fs(t)
                    }
                }
                class Xs {
                    constructor(t, e, i, n, r) {
                        this.expression = t,
                        this.layerId = r,
                        this.paintVertexAttributes = ("array" === i ? Ss : Ts).members;
                        for (let t = 0; t < e.length; ++t)
                            ;
                        this.paintVertexArray = new n
                    }
                    populatePaintArray(t, e, i) {
                        const n = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t),
                        this._setPaintValues(n, t, e.patterns && e.patterns[this.layerId], i)
                    }
                    updatePaintArray(t, e, i, n, r, o) {
                        this._setPaintValues(t, e, i.patterns && i.patterns[this.layerId], o)
                    }
                    _setPaintValues(t, e, i, n) {
                        if (!n || !i)
                            return;
                        const r = n[i];
                        if (!r)
                            return;
                        const {tl: o, br: s, pixelRatio: a} = r;
                        for (let i = t; i < e; i++)
                            this.paintVertexArray.emplace(i, o[0], o[1], s[0], s[1], a)
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class Ys {
                    constructor(t, e, i=( () => !0)) {
                        this.binders = {},
                        this._buffers = [];
                        const n = [];
                        for (const r in t.paint._values) {
                            if (!i(r))
                                continue;
                            const o = t.paint.get(r);
                            if (!(o instanceof Po && zn(o.property.specification)))
                                continue;
                            const s = Qs(r, t.type)
                              , a = o.value
                              , l = o.property.specification.type
                              , c = !!o.property.useIntegerZoom
                              , h = "line-dasharray" === r || r.endsWith("pattern")
                              , u = "line-dasharray" === r && "constant" !== t.layout.get("line-cap").value.kind;
                            if ("constant" !== a.kind || u)
                                if ("source" === a.kind || u || h) {
                                    const e = ia(r, l, "source");
                                    this.binders[r] = h ? new Xs(a,s,l,e,t.id) : new Hs(a,s,l,e),
                                    n.push(`/a_${r}`)
                                } else {
                                    const t = ia(r, l, "composite");
                                    this.binders[r] = new $s(a,s,l,c,e,t),
                                    n.push(`/z_${r}`)
                                }
                            else
                                this.binders[r] = h ? new Ws(a.value,s) : new qs(a.value,s,l),
                                n.push(`/u_${r}`)
                        }
                        this.cacheKey = n.sort().join("")
                    }
                    getMaxValue(t) {
                        const e = this.binders[t];
                        return e instanceof Hs || e instanceof $s ? e.maxValue : 0
                    }
                    populatePaintArrays(t, e, i, n, r, o) {
                        for (const s in this.binders) {
                            const a = this.binders[s];
                            (a instanceof Hs || a instanceof $s || a instanceof Xs) && a.populatePaintArray(t, e, i, n, r, o)
                        }
                    }
                    setConstantPatternPositions(t) {
                        for (const e in this.binders) {
                            const i = this.binders[e];
                            i instanceof Ws && i.setConstantPatternPositions(t)
                        }
                    }
                    updatePaintArrays(t, e, i, n, r, o) {
                        let s = !1;
                        for (const a in t) {
                            const l = e.getPositions(a);
                            for (const e of l) {
                                const l = i.feature(e.index);
                                for (const i in this.binders) {
                                    const c = this.binders[i];
                                    if ((c instanceof Hs || c instanceof $s || c instanceof Xs) && !0 === c.expression.isStateDependent) {
                                        const h = n.paint.get(i);
                                        c.expression = h.value,
                                        c.updatePaintArray(e.start, e.end, l, t[a], r, o),
                                        s = !0
                                    }
                                }
                            }
                        }
                        return s
                    }
                    defines() {
                        const t = [];
                        for (const e in this.binders) {
                            const i = this.binders[e];
                            (i instanceof qs || i instanceof Ws) && t.push(...i.uniformNames.map((t => `#define HAS_UNIFORM_${t}`)))
                        }
                        return t
                    }
                    getBinderAttributes() {
                        const t = [];
                        for (const e in this.binders) {
                            const i = this.binders[e];
                            if (i instanceof Hs || i instanceof $s || i instanceof Xs)
                                for (let e = 0; e < i.paintVertexAttributes.length; e++)
                                    t.push(i.paintVertexAttributes[e].name)
                        }
                        return t
                    }
                    getBinderUniforms() {
                        const t = [];
                        for (const e in this.binders) {
                            const i = this.binders[e];
                            if (i instanceof qs || i instanceof Ws || i instanceof $s)
                                for (const e of i.uniformNames)
                                    t.push(e)
                        }
                        return t
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(t) {
                        const e = [];
                        for (const i in this.binders) {
                            const n = this.binders[i];
                            if (n instanceof qs || n instanceof Ws || n instanceof $s)
                                for (const r of n.uniformNames)
                                    e.push({
                                        name: r,
                                        property: i,
                                        binding: n.getBinding(t, r)
                                    })
                        }
                        return e
                    }
                    setUniforms(t, e, i, n, r) {
                        for (const {name: e, property: o, binding: s} of i)
                            this.binders[o].setUniform(t, s, r, n.get(o), e)
                    }
                    updatePaintBuffers() {
                        this._buffers = [];
                        for (const t in this.binders) {
                            const e = this.binders[t];
                            (e instanceof Hs || e instanceof $s || e instanceof Xs) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer)
                        }
                    }
                    upload(t) {
                        for (const e in this.binders) {
                            const i = this.binders[e];
                            (i instanceof Hs || i instanceof $s || i instanceof Xs) && i.upload(t)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const t in this.binders) {
                            const e = this.binders[t];
                            (e instanceof Hs || e instanceof $s || e instanceof Xs) && e.destroy()
                        }
                    }
                }
                class Ks {
                    constructor(t, e, i=( () => !0)) {
                        this.programConfigurations = {};
                        for (const n of t)
                            this.programConfigurations[n.id] = new Ys(n,e,i);
                        this.needsUpload = !1,
                        this._featureMap = new Rs,
                        this._bufferOffset = 0
                    }
                    populatePaintArrays(t, e, i, n, r, o, s) {
                        for (const i in this.programConfigurations)
                            this.programConfigurations[i].populatePaintArrays(t, e, n, r, o, s);
                        void 0 !== e.id && this._featureMap.add(e.id, i, this._bufferOffset, t),
                        this._bufferOffset = t,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(t, e, i, n, r) {
                        for (const o of i)
                            this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, e, o, n, r) || this.needsUpload
                    }
                    get(t) {
                        return this.programConfigurations[t]
                    }
                    upload(t) {
                        if (this.needsUpload) {
                            for (const e in this.programConfigurations)
                                this.programConfigurations[e].upload(t);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const t in this.programConfigurations)
                            this.programConfigurations[t].destroy()
                    }
                }
                const Js = {
                    "text-opacity": ["opacity"],
                    "icon-opacity": ["opacity"],
                    "text-color": ["fill_color"],
                    "icon-color": ["fill_color"],
                    "text-halo-color": ["halo_color"],
                    "icon-halo-color": ["halo_color"],
                    "text-halo-blur": ["halo_blur"],
                    "icon-halo-blur": ["halo_blur"],
                    "text-halo-width": ["halo_width"],
                    "icon-halo-width": ["halo_width"],
                    "line-gap-width": ["gapwidth"],
                    "line-pattern": ["pattern", "pixel_ratio"],
                    "fill-pattern": ["pattern", "pixel_ratio"],
                    "fill-extrusion-pattern": ["pattern", "pixel_ratio"],
                    "line-dasharray": ["dash"]
                };
                function Qs(t, e) {
                    return Js[t] || [t.replace(`${e}-`, "").replace(/-/g, "_")]
                }
                const ta = {
                    "line-pattern": {
                        source: Ho,
                        composite: Ho
                    },
                    "fill-pattern": {
                        source: Ho,
                        composite: Ho
                    },
                    "fill-extrusion-pattern": {
                        source: Ho,
                        composite: Ho
                    },
                    "line-dasharray": {
                        source: $o,
                        composite: $o
                    }
                }
                  , ea = {
                    color: {
                        source: ds,
                        composite: Wo
                    },
                    number: {
                        source: as,
                        composite: ds
                    }
                };
                function ia(t, e, i) {
                    const n = ta[t];
                    return n && n[i] || ea[e][i]
                }
                Yr(qs, "ConstantBinder"),
                Yr(Ws, "PatternConstantBinder"),
                Yr(Hs, "SourceExpressionBinder"),
                Yr(Xs, "PatternCompositeBinder"),
                Yr($s, "CompositeExpressionBinder"),
                Yr(Ys, "ProgramConfiguration", {
                    omit: ["_buffers"]
                }),
                Yr(Ks, "ProgramConfigurationSet");
                const na = "-transition";
                class ra extends te {
                    constructor(t, e) {
                        if (super(),
                        this.id = t.id,
                        this.type = t.type,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1,
                            needFeature: !1
                        },
                        this._filterCompiled = !1,
                        "custom" !== t.type && (this.metadata = t.metadata,
                        this.minzoom = t.minzoom,
                        this.maxzoom = t.maxzoom,
                        "background" !== t.type && "sky" !== t.type && (this.source = t.source,
                        this.sourceLayer = t["source-layer"],
                        this.filter = t.filter),
                        e.layout && (this._unevaluatedLayout = new Mo(e.layout)),
                        e.paint)) {
                            this._transitionablePaint = new Co(e.paint);
                            for (const e in t.paint)
                                this.setPaintProperty(e, t.paint[e], {
                                    validate: !1
                                });
                            for (const e in t.layout)
                                this.setLayoutProperty(e, t.layout[e], {
                                    validate: !1
                                });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(),
                            this.paint = new ko(e.paint)
                        }
                    }
                    getLayoutProperty(t) {
                        return "visibility" === t ? this.visibility : this._unevaluatedLayout.getValue(t)
                    }
                    setLayoutProperty(t, e, i={}) {
                        null != e && this._validate(Vr, `layers.${this.id}.layout.${t}`, t, e, i) || ("visibility" !== t ? this._unevaluatedLayout.setValue(t, e) : this.visibility = e)
                    }
                    getPaintProperty(t) {
                        return j(t, na) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
                    }
                    setPaintProperty(t, e, i={}) {
                        if (null != e && this._validate(Ur, `layers.${this.id}.paint.${t}`, t, e, i))
                            return !1;
                        if (j(t, na))
                            return this._transitionablePaint.setTransition(t.slice(0, -11), e || void 0),
                            !1;
                        {
                            const i = this._transitionablePaint._values[t]
                              , n = i.value.isDataDriven()
                              , r = i.value;
                            this._transitionablePaint.setValue(t, e),
                            this._handleSpecialPaintPropertyUpdate(t);
                            const o = this._transitionablePaint._values[t].value
                              , s = o.isDataDriven()
                              , a = j(t, "pattern") || "line-dasharray" === t;
                            return s || n || a || this._handleOverridablePaintPropertyUpdate(t, r, o)
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(t) {}
                    getProgramIds() {
                        return null
                    }
                    getProgramConfiguration(t) {
                        return null
                    }
                    _handleOverridablePaintPropertyUpdate(t, e, i) {
                        return !1
                    }
                    isHidden(t) {
                        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || "none" === this.visibility
                    }
                    updateTransitions(t) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(t, e) {
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e)
                    }
                    serialize() {
                        const t = {
                            id: this.id,
                            type: this.type,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        };
                        return this.visibility && (t.layout = t.layout || {},
                        t.layout.visibility = this.visibility),
                        V(t, ( (t, e) => !(void 0 === t || "layout" === e && !Object.keys(t).length || "paint" === e && !Object.keys(t).length)))
                    }
                    _validate(t, e, i, n, r={}) {
                        return (!r || !1 !== r.validate) && Zr(this, t.call(jr, {
                            key: e,
                            layerType: this.type,
                            objectKey: i,
                            value: n,
                            styleSpec: ee,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            }
                        }))
                    }
                    is3D() {
                        return !1
                    }
                    isSky() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    resize() {}
                    isStateDependent() {
                        for (const t in this.paint._values) {
                            const e = this.paint.get(t);
                            if (e instanceof Po && zn(e.property.specification) && ("source" === e.value.kind || "composite" === e.value.kind) && e.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                    compileFilter() {
                        this._filterCompiled || (this._featureFilter = dr(this.filter),
                        this._filterCompiled = !0)
                    }
                    invalidateCompiledFilter() {
                        this._filterCompiled = !1
                    }
                    dynamicFilter() {
                        return this._featureFilter.dynamicFilter
                    }
                    dynamicFilterNeedsFeature() {
                        return this._featureFilter.needFeature
                    }
                }
                const oa = jo([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , sa = jo([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }]);
                class aa {
                    constructor(t=[]) {
                        this.segments = t
                    }
                    prepareSegment(t, e, i, n) {
                        let r = this.segments[this.segments.length - 1];
                        return t > aa.MAX_VERTEX_ARRAY_LENGTH && q(`Max vertices per segment is ${aa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`),
                        (!r || r.vertexLength + t > aa.MAX_VERTEX_ARRAY_LENGTH || r.sortKey !== n) && (r = {
                            vertexOffset: e.length,
                            primitiveOffset: i.length,
                            vertexLength: 0,
                            primitiveLength: 0
                        },
                        void 0 !== n && (r.sortKey = n),
                        this.segments.push(r)),
                        r
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const t of this.segments)
                            for (const e in t.vaos)
                                t.vaos[e].destroy()
                    }
                    static simpleSegment(t, e, i, n) {
                        return new aa([{
                            vertexOffset: t,
                            primitiveOffset: e,
                            vertexLength: i,
                            primitiveLength: n,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                aa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Yr(aa, "SegmentVector");
                var la = 8192;
                class ca {
                    constructor(t, e) {
                        t && (e ? this.setSouthWest(t).setNorthEast(e) : 4 === t.length ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]))
                    }
                    setNorthEast(t) {
                        return this._ne = t instanceof Gl ? new Gl(t.lng,t.lat) : Gl.convert(t),
                        this
                    }
                    setSouthWest(t) {
                        return this._sw = t instanceof Gl ? new Gl(t.lng,t.lat) : Gl.convert(t),
                        this
                    }
                    extend(t) {
                        const e = this._sw
                          , i = this._ne;
                        let n, r;
                        if (t instanceof Gl)
                            n = t,
                            r = t;
                        else {
                            if (!(t instanceof ca))
                                return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(ca.convert(t)) : this.extend(Gl.convert(t)) : "object" == typeof t && null !== t && t.hasOwnProperty("lat") && (t.hasOwnProperty("lon") || t.hasOwnProperty("lng")) ? this.extend(Gl.convert(t)) : this;
                            if (n = t._sw,
                            r = t._ne,
                            !n || !r)
                                return this
                        }
                        return e || i ? (e.lng = Math.min(n.lng, e.lng),
                        e.lat = Math.min(n.lat, e.lat),
                        i.lng = Math.max(r.lng, i.lng),
                        i.lat = Math.max(r.lat, i.lat)) : (this._sw = new Gl(n.lng,n.lat),
                        this._ne = new Gl(r.lng,r.lat)),
                        this
                    }
                    getCenter() {
                        return new Gl((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new Gl(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new Gl(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(t) {
                        const {lng: e, lat: i} = Gl.convert(t);
                        let n = this._sw.lng <= e && e <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng),
                        this._sw.lat <= i && i <= this._ne.lat && n
                    }
                    static convert(t) {
                        return !t || t instanceof ca ? t : new ca(t)
                    }
                }
                var ha = 1e-6
                  , ua = "undefined" != typeof Float32Array ? Float32Array : Array;
                function da() {
                    var t = new ua(9);
                    return ua != Float32Array && (t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[5] = 0,
                    t[6] = 0,
                    t[7] = 0),
                    t[0] = 1,
                    t[4] = 1,
                    t[8] = 1,
                    t
                }
                function fa(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3]
                      , a = e[4]
                      , l = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8]
                      , d = i[0]
                      , f = i[1]
                      , p = i[2]
                      , m = i[3]
                      , g = i[4]
                      , _ = i[5]
                      , y = i[6]
                      , v = i[7]
                      , x = i[8];
                    return t[0] = d * n + f * s + p * c,
                    t[1] = d * r + f * a + p * h,
                    t[2] = d * o + f * l + p * u,
                    t[3] = m * n + g * s + _ * c,
                    t[4] = m * r + g * a + _ * h,
                    t[5] = m * o + g * l + _ * u,
                    t[6] = y * n + v * s + x * c,
                    t[7] = y * r + v * a + x * h,
                    t[8] = y * o + v * l + x * u,
                    t
                }
                function pa(t) {
                    return t[0] = 1,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = 1,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[10] = 1,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t
                }
                function ma(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = e[3]
                      , s = e[4]
                      , a = e[5]
                      , l = e[6]
                      , c = e[7]
                      , h = e[8]
                      , u = e[9]
                      , d = e[10]
                      , f = e[11]
                      , p = e[12]
                      , m = e[13]
                      , g = e[14]
                      , _ = e[15]
                      , y = i * a - n * s
                      , v = i * l - r * s
                      , x = i * c - o * s
                      , b = n * l - r * a
                      , w = n * c - o * a
                      , E = r * c - o * l
                      , T = h * m - u * p
                      , S = h * g - d * p
                      , C = h * _ - f * p
                      , A = u * g - d * m
                      , I = u * _ - f * m
                      , M = d * _ - f * g
                      , P = y * M - v * I + x * A + b * C - w * S + E * T;
                    return P ? (t[0] = (a * M - l * I + c * A) * (P = 1 / P),
                    t[1] = (r * I - n * M - o * A) * P,
                    t[2] = (m * E - g * w + _ * b) * P,
                    t[3] = (d * w - u * E - f * b) * P,
                    t[4] = (l * C - s * M - c * S) * P,
                    t[5] = (i * M - r * C + o * S) * P,
                    t[6] = (g * x - p * E - _ * v) * P,
                    t[7] = (h * E - d * x + f * v) * P,
                    t[8] = (s * I - a * C + c * T) * P,
                    t[9] = (n * C - i * I - o * T) * P,
                    t[10] = (p * w - m * x + _ * y) * P,
                    t[11] = (u * x - h * w - f * y) * P,
                    t[12] = (a * S - s * A - l * T) * P,
                    t[13] = (i * A - n * S + r * T) * P,
                    t[14] = (m * v - p * b - g * y) * P,
                    t[15] = (h * b - u * v + d * y) * P,
                    t) : null
                }
                function ga(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3]
                      , a = e[4]
                      , l = e[5]
                      , c = e[6]
                      , h = e[7]
                      , u = e[8]
                      , d = e[9]
                      , f = e[10]
                      , p = e[11]
                      , m = e[12]
                      , g = e[13]
                      , _ = e[14]
                      , y = e[15]
                      , v = i[0]
                      , x = i[1]
                      , b = i[2]
                      , w = i[3];
                    return t[0] = v * n + x * a + b * u + w * m,
                    t[1] = v * r + x * l + b * d + w * g,
                    t[2] = v * o + x * c + b * f + w * _,
                    t[3] = v * s + x * h + b * p + w * y,
                    t[4] = (v = i[4]) * n + (x = i[5]) * a + (b = i[6]) * u + (w = i[7]) * m,
                    t[5] = v * r + x * l + b * d + w * g,
                    t[6] = v * o + x * c + b * f + w * _,
                    t[7] = v * s + x * h + b * p + w * y,
                    t[8] = (v = i[8]) * n + (x = i[9]) * a + (b = i[10]) * u + (w = i[11]) * m,
                    t[9] = v * r + x * l + b * d + w * g,
                    t[10] = v * o + x * c + b * f + w * _,
                    t[11] = v * s + x * h + b * p + w * y,
                    t[12] = (v = i[12]) * n + (x = i[13]) * a + (b = i[14]) * u + (w = i[15]) * m,
                    t[13] = v * r + x * l + b * d + w * g,
                    t[14] = v * o + x * c + b * f + w * _,
                    t[15] = v * s + x * h + b * p + w * y,
                    t
                }
                function _a(t, e, i) {
                    var n, r, o, s, a, l, c, h, u, d, f, p, m = i[0], g = i[1], _ = i[2];
                    return e === t ? (t[12] = e[0] * m + e[4] * g + e[8] * _ + e[12],
                    t[13] = e[1] * m + e[5] * g + e[9] * _ + e[13],
                    t[14] = e[2] * m + e[6] * g + e[10] * _ + e[14],
                    t[15] = e[3] * m + e[7] * g + e[11] * _ + e[15]) : (r = e[1],
                    o = e[2],
                    s = e[3],
                    a = e[4],
                    l = e[5],
                    c = e[6],
                    h = e[7],
                    u = e[8],
                    d = e[9],
                    f = e[10],
                    p = e[11],
                    t[0] = n = e[0],
                    t[1] = r,
                    t[2] = o,
                    t[3] = s,
                    t[4] = a,
                    t[5] = l,
                    t[6] = c,
                    t[7] = h,
                    t[8] = u,
                    t[9] = d,
                    t[10] = f,
                    t[11] = p,
                    t[12] = n * m + a * g + u * _ + e[12],
                    t[13] = r * m + l * g + d * _ + e[13],
                    t[14] = o * m + c * g + f * _ + e[14],
                    t[15] = s * m + h * g + p * _ + e[15]),
                    t
                }
                function ya(t, e, i) {
                    var n = i[0]
                      , r = i[1]
                      , o = i[2];
                    return t[0] = e[0] * n,
                    t[1] = e[1] * n,
                    t[2] = e[2] * n,
                    t[3] = e[3] * n,
                    t[4] = e[4] * r,
                    t[5] = e[5] * r,
                    t[6] = e[6] * r,
                    t[7] = e[7] * r,
                    t[8] = e[8] * o,
                    t[9] = e[9] * o,
                    t[10] = e[10] * o,
                    t[11] = e[11] * o,
                    t[12] = e[12],
                    t[13] = e[13],
                    t[14] = e[14],
                    t[15] = e[15],
                    t
                }
                function va(t, e, i) {
                    var n = Math.sin(i)
                      , r = Math.cos(i)
                      , o = e[4]
                      , s = e[5]
                      , a = e[6]
                      , l = e[7]
                      , c = e[8]
                      , h = e[9]
                      , u = e[10]
                      , d = e[11];
                    return e !== t && (t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[3],
                    t[12] = e[12],
                    t[13] = e[13],
                    t[14] = e[14],
                    t[15] = e[15]),
                    t[4] = o * r + c * n,
                    t[5] = s * r + h * n,
                    t[6] = a * r + u * n,
                    t[7] = l * r + d * n,
                    t[8] = c * r - o * n,
                    t[9] = h * r - s * n,
                    t[10] = u * r - a * n,
                    t[11] = d * r - l * n,
                    t
                }
                function xa(t, e, i) {
                    var n = Math.sin(i)
                      , r = Math.cos(i)
                      , o = e[0]
                      , s = e[1]
                      , a = e[2]
                      , l = e[3]
                      , c = e[8]
                      , h = e[9]
                      , u = e[10]
                      , d = e[11];
                    return e !== t && (t[4] = e[4],
                    t[5] = e[5],
                    t[6] = e[6],
                    t[7] = e[7],
                    t[12] = e[12],
                    t[13] = e[13],
                    t[14] = e[14],
                    t[15] = e[15]),
                    t[0] = o * r - c * n,
                    t[1] = s * r - h * n,
                    t[2] = a * r - u * n,
                    t[3] = l * r - d * n,
                    t[8] = o * n + c * r,
                    t[9] = s * n + h * r,
                    t[10] = a * n + u * r,
                    t[11] = l * n + d * r,
                    t
                }
                function ba(t, e) {
                    return t[0] = e[0],
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = e[1],
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[10] = e[2],
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t
                }
                function wa(t, e, i) {
                    var n, r, o, s = i[0], a = i[1], l = i[2], c = Math.hypot(s, a, l);
                    return c < ha ? null : (s *= c = 1 / c,
                    a *= c,
                    l *= c,
                    n = Math.sin(e),
                    r = Math.cos(e),
                    t[0] = s * s * (o = 1 - r) + r,
                    t[1] = a * s * o + l * n,
                    t[2] = l * s * o - a * n,
                    t[3] = 0,
                    t[4] = s * a * o - l * n,
                    t[5] = a * a * o + r,
                    t[6] = l * a * o + s * n,
                    t[7] = 0,
                    t[8] = s * l * o + a * n,
                    t[9] = a * l * o - s * n,
                    t[10] = l * l * o + r,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t)
                }
                Math.hypot || (Math.hypot = function() {
                    for (var t = 0, e = arguments.length; e--; )
                        t += arguments[e] * arguments[e];
                    return Math.sqrt(t)
                }
                );
                var Ea = ga;
                function Ta() {
                    var t = new ua(3);
                    return ua != Float32Array && (t[0] = 0,
                    t[1] = 0,
                    t[2] = 0),
                    t
                }
                function Sa(t) {
                    var e = new ua(3);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e
                }
                function Ca(t) {
                    return Math.hypot(t[0], t[1], t[2])
                }
                function Aa(t, e, i) {
                    var n = new ua(3);
                    return n[0] = t,
                    n[1] = e,
                    n[2] = i,
                    n
                }
                function Ia(t, e, i) {
                    return t[0] = e[0] + i[0],
                    t[1] = e[1] + i[1],
                    t[2] = e[2] + i[2],
                    t
                }
                function Ma(t, e, i) {
                    return t[0] = e[0] - i[0],
                    t[1] = e[1] - i[1],
                    t[2] = e[2] - i[2],
                    t
                }
                function Pa(t, e, i) {
                    return t[0] = e[0] * i[0],
                    t[1] = e[1] * i[1],
                    t[2] = e[2] * i[2],
                    t
                }
                function ka(t, e, i) {
                    return t[0] = Math.min(e[0], i[0]),
                    t[1] = Math.min(e[1], i[1]),
                    t[2] = Math.min(e[2], i[2]),
                    t
                }
                function Oa(t, e, i) {
                    return t[0] = Math.max(e[0], i[0]),
                    t[1] = Math.max(e[1], i[1]),
                    t[2] = Math.max(e[2], i[2]),
                    t
                }
                function Ra(t, e, i) {
                    return t[0] = e[0] * i,
                    t[1] = e[1] * i,
                    t[2] = e[2] * i,
                    t
                }
                function Da(t, e, i, n) {
                    return t[0] = e[0] + i[0] * n,
                    t[1] = e[1] + i[1] * n,
                    t[2] = e[2] + i[2] * n,
                    t
                }
                function La(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = i * i + n * n + r * r;
                    return o > 0 && (o = 1 / Math.sqrt(o)),
                    t[0] = e[0] * o,
                    t[1] = e[1] * o,
                    t[2] = e[2] * o,
                    t
                }
                function Ba(t, e) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
                }
                function za(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = i[0]
                      , a = i[1]
                      , l = i[2];
                    return t[0] = r * l - o * a,
                    t[1] = o * s - n * l,
                    t[2] = n * a - r * s,
                    t
                }
                function Fa(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = i[3] * n + i[7] * r + i[11] * o + i[15];
                    return t[0] = (i[0] * n + i[4] * r + i[8] * o + i[12]) / (s = s || 1),
                    t[1] = (i[1] * n + i[5] * r + i[9] * o + i[13]) / s,
                    t[2] = (i[2] * n + i[6] * r + i[10] * o + i[14]) / s,
                    t
                }
                function Na(t, e, i) {
                    var n = i[0]
                      , r = i[1]
                      , o = i[2]
                      , s = e[0]
                      , a = e[1]
                      , l = e[2]
                      , c = r * l - o * a
                      , h = o * s - n * l
                      , u = n * a - r * s
                      , d = r * u - o * h
                      , f = o * c - n * u
                      , p = n * h - r * c
                      , m = 2 * i[3];
                    return h *= m,
                    u *= m,
                    f *= 2,
                    p *= 2,
                    t[0] = s + (c *= m) + (d *= 2),
                    t[1] = a + h + f,
                    t[2] = l + u + p,
                    t
                }
                var ja, Ua = Ma, Va = Pa, Ga = Ca;
                function Za(t, e, i) {
                    return t[0] = e[0] * i,
                    t[1] = e[1] * i,
                    t[2] = e[2] * i,
                    t[3] = e[3] * i,
                    t
                }
                function qa(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = e[3]
                      , s = i * i + n * n + r * r + o * o;
                    return s > 0 && (s = 1 / Math.sqrt(s)),
                    t[0] = i * s,
                    t[1] = n * s,
                    t[2] = r * s,
                    t[3] = o * s,
                    t
                }
                function Wa(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3];
                    return t[0] = i[0] * n + i[4] * r + i[8] * o + i[12] * s,
                    t[1] = i[1] * n + i[5] * r + i[9] * o + i[13] * s,
                    t[2] = i[2] * n + i[6] * r + i[10] * o + i[14] * s,
                    t[3] = i[3] * n + i[7] * r + i[11] * o + i[15] * s,
                    t
                }
                function Ha() {
                    var t = new ua(4);
                    return ua != Float32Array && (t[0] = 0,
                    t[1] = 0,
                    t[2] = 0),
                    t[3] = 1,
                    t
                }
                function $a(t) {
                    return t[0] = 0,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 1,
                    t
                }
                function Xa(t, e, i) {
                    i *= .5;
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3]
                      , a = Math.sin(i)
                      , l = Math.cos(i);
                    return t[0] = n * l + s * a,
                    t[1] = r * l + o * a,
                    t[2] = o * l - r * a,
                    t[3] = s * l - n * a,
                    t
                }
                function Ya(t, e, i) {
                    i *= .5;
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3]
                      , a = Math.sin(i)
                      , l = Math.cos(i);
                    return t[0] = n * l - o * a,
                    t[1] = r * l + s * a,
                    t[2] = o * l + n * a,
                    t[3] = s * l - r * a,
                    t
                }
                Ta(),
                ja = new ua(4),
                ua != Float32Array && (ja[0] = 0,
                ja[1] = 0,
                ja[2] = 0,
                ja[3] = 0);
                var Ka = qa;
                Ta(),
                Aa(1, 0, 0),
                Aa(0, 1, 0),
                Ha(),
                Ha(),
                da();
                const Ja = jo([{
                    type: "Float32",
                    name: "a_globe_pos",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }])
                  , {members: Qa} = Ja
                  , tl = jo([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }]);
                var el = jo([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                class il {
                    constructor(t, e) {
                        this.pos = t,
                        this.dir = e
                    }
                    intersectsPlane(t, e, i) {
                        const n = Ba(e, this.dir);
                        if (Math.abs(n) < 1e-6)
                            return !1;
                        const r = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;
                        return i[0] = this.pos[0] + this.dir[0] * r,
                        i[1] = this.pos[1] + this.dir[1] * r,
                        i[2] = this.pos[2] + this.dir[2] * r,
                        !0
                    }
                    closestPointOnSphere(t, e, i) {
                        if (function(t, e) {
                            var i = t[0]
                              , n = t[1]
                              , r = t[2]
                              , o = e[0]
                              , s = e[1]
                              , a = e[2];
                            return Math.abs(i - o) <= ha * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(n - s) <= ha * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(r - a) <= ha * Math.max(1, Math.abs(r), Math.abs(a))
                        }(this.pos, t) || 0 === e)
                            return i[0] = i[1] = i[2] = 0,
                            !1;
                        const [n,r,o] = this.dir
                          , s = this.pos[0] - t[0]
                          , a = this.pos[1] - t[1]
                          , l = this.pos[2] - t[2]
                          , c = n * n + r * r + o * o
                          , h = 2 * (s * n + a * r + l * o)
                          , u = h * h - 4 * c * (s * s + a * a + l * l - e * e);
                        if (u < 0) {
                            const t = Math.max(-h / 2, 0)
                              , c = s + n * t
                              , u = a + r * t
                              , d = l + o * t
                              , f = Math.hypot(c, u, d);
                            return i[0] = c * e / f,
                            i[1] = u * e / f,
                            i[2] = d * e / f,
                            !1
                        }
                        {
                            const t = (-h - Math.sqrt(u)) / (2 * c);
                            if (t < 0) {
                                const t = Math.hypot(s, a, l);
                                return i[0] = s * e / t,
                                i[1] = a * e / t,
                                i[2] = l * e / t,
                                !1
                            }
                            return i[0] = s + n * t,
                            i[1] = a + r * t,
                            i[2] = l + o * t,
                            !0
                        }
                    }
                }
                class nl {
                    constructor(t, e, i, n, r) {
                        this.TL = t,
                        this.TR = e,
                        this.BR = i,
                        this.BL = n,
                        this.horizon = r
                    }
                    static fromInvProjectionMatrix(t, e, i) {
                        const n = [-1, 1, 1]
                          , r = [1, 1, 1]
                          , o = [1, -1, 1]
                          , s = [-1, -1, 1]
                          , a = Fa(n, n, t)
                          , l = Fa(r, r, t)
                          , c = Fa(o, o, t)
                          , h = Fa(s, s, t);
                        return new nl(a,l,c,h,e / i)
                    }
                }
                class rl {
                    constructor(t, e) {
                        this.points = t,
                        this.planes = e
                    }
                    static fromInvProjectionMatrix(t, e, i, n) {
                        const r = Math.pow(2, i)
                          , o = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((i => {
                            const o = Wa([], i, t)
                              , s = 1 / o[3] / e * r;
                            return function(t, e, i) {
                                return t[0] = e[0] * i[0],
                                t[1] = e[1] * i[1],
                                t[2] = e[2] * i[2],
                                t[3] = e[3] * i[3],
                                t
                            }(o, o, [s, s, n ? 1 / o[3] : s, s])
                        }
                        ))
                          , s = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t => {
                            const e = La([], za([], Ua([], o[t[0]], o[t[1]]), Ua([], o[t[2]], o[t[1]])))
                              , i = -Ba(e, o[t[1]]);
                            return e.concat(i)
                        }
                        ));
                        return new rl(o,s)
                    }
                }
                class ol {
                    static fromPoints(t) {
                        const e = [1 / 0, 1 / 0, 1 / 0]
                          , i = [-1 / 0, -1 / 0, -1 / 0];
                        for (const n of t)
                            ka(e, e, n),
                            Oa(i, i, n);
                        return new ol(e,i)
                    }
                    static applyTransform(t, e) {
                        const i = t.getCorners();
                        for (let t = 0; t < i.length; ++t)
                            Fa(i[t], i[t], e);
                        return ol.fromPoints(i)
                    }
                    constructor(t, e) {
                        this.min = t,
                        this.max = e,
                        this.center = Ra([], Ia([], this.min, this.max), .5)
                    }
                    quadrant(t) {
                        const e = [t % 2 == 0, t < 2]
                          , i = Sa(this.min)
                          , n = Sa(this.max);
                        for (let t = 0; t < e.length; t++)
                            i[t] = e[t] ? this.min[t] : this.center[t],
                            n[t] = e[t] ? this.center[t] : this.max[t];
                        return n[2] = this.max[2],
                        new ol(i,n)
                    }
                    distanceX(t) {
                        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0]
                    }
                    distanceY(t) {
                        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1]
                    }
                    distanceZ(t) {
                        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2]
                    }
                    getCorners() {
                        const t = this.min
                          , e = this.max;
                        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]]
                    }
                    intersects(t) {
                        const e = this.getCorners();
                        let i = !0;
                        for (let n = 0; n < t.planes.length; n++) {
                            const r = t.planes[n];
                            let o = 0;
                            for (let t = 0; t < e.length; t++)
                                o += Ba(r, e[t]) + r[3] >= 0;
                            if (0 === o)
                                return 0;
                            o !== e.length && (i = !1)
                        }
                        if (i)
                            return 2;
                        for (let e = 0; e < 3; e++) {
                            let i = Number.MAX_VALUE
                              , n = -Number.MAX_VALUE;
                            for (let r = 0; r < t.points.length; r++) {
                                const o = t.points[r][e] - this.min[e];
                                i = Math.min(i, o),
                                n = Math.max(n, o)
                            }
                            if (n < 0 || i > this.max[e] - this.min[e])
                                return 0
                        }
                        return 1
                    }
                }
                const sl = 5
                  , al = 6
                  , ll = la / Math.PI / 2
                  , cl = 16383
                  , hl = 64
                  , ul = [hl, 32, 16]
                  , dl = -ll
                  , fl = ll
                  , pl = [new ol([dl, dl, dl],[fl, fl, fl]), new ol([dl, dl, dl],[0, 0, fl]), new ol([0, dl, dl],[fl, 0, fl]), new ol([dl, 0, dl],[0, fl, fl]), new ol([0, 0, dl],[fl, fl, fl])];
                function ml(t) {
                    return t * ll / jl
                }
                function gl(t, e, i, n=!0) {
                    const r = Ra([], t._camera.position, t.worldSize)
                      , o = [e, i, 1, 1];
                    Wa(o, o, t.pixelMatrixInverse),
                    Za(o, o, 1 / o[3]);
                    const s = La([], Ua([], o, r))
                      , a = t.globeMatrix
                      , l = [a[12], a[13], a[14]]
                      , c = Ua([], l, r)
                      , h = Ca(c)
                      , u = La([], c)
                      , d = t.worldSize / (2 * Math.PI)
                      , f = Ba(u, s)
                      , p = Math.asin(d / h);
                    if (p < Math.acos(f)) {
                        if (!n)
                            return null;
                        const t = []
                          , e = [];
                        Ra(t, s, h / f),
                        La(e, Ua(e, t, c)),
                        La(s, Ia(s, c, Ra(s, e, Math.tan(p) * h)))
                    }
                    const m = [];
                    new il(r,s).closestPointOnSphere(l, d, m);
                    const g = La([], Q(a, 0))
                      , _ = La([], Q(a, 1))
                      , y = La([], Q(a, 2))
                      , v = Ba(g, m)
                      , x = Ba(_, m)
                      , b = Ba(y, m)
                      , w = E(Math.asin(-x / d));
                    let T = E(Math.atan2(v, b));
                    T = t.center.lng + function(t, e) {
                        const i = (e - t + 180) % 360 - 180;
                        return i < -180 ? i + 360 : i
                    }(t.center.lng, T);
                    const S = ql(T)
                      , C = I(Wl(w), 0, 1);
                    return new Ql(S,C)
                }
                class _l {
                    constructor(t, e, i) {
                        this.a = Ua([], t, i),
                        this.b = Ua([], e, i),
                        this.center = i;
                        const n = La([], this.a)
                          , r = La([], this.b);
                        this.angle = Math.acos(Ba(n, r))
                    }
                }
                function yl(t, e) {
                    if (0 === t.angle)
                        return null;
                    let i;
                    return i = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)),
                    i < 0 || i > 1 ? null : function(t, e, i, n) {
                        const r = Math.sin(i);
                        return t * (Math.sin((1 - n) * i) / r) + e * (Math.sin(n * i) / r)
                    }(t.a[e], t.b[e], t.angle, I(i, 0, 1)) + t.center[e]
                }
                function vl(t) {
                    if (t.z <= 1)
                        return pl[t.z + 2 * t.y + t.x];
                    const e = Sl(Tl(t));
                    return ol.fromPoints(e)
                }
                function xl(t, e, i) {
                    return Ra(t, t, 1 - i),
                    Da(t, t, e, i)
                }
                function bl(t, e) {
                    const i = Dl(e.zoom);
                    if (0 === i)
                        return vl(t);
                    const n = Tl(t)
                      , r = Sl(n)
                      , o = ql(n.getWest()) * e.worldSize
                      , s = ql(n.getEast()) * e.worldSize
                      , a = Wl(n.getNorth()) * e.worldSize
                      , l = Wl(n.getSouth()) * e.worldSize
                      , c = [o, a, 0]
                      , h = [s, a, 0]
                      , u = [o, l, 0]
                      , d = [s, l, 0]
                      , f = ma([], e.globeMatrix);
                    return Fa(c, c, f),
                    Fa(h, h, f),
                    Fa(u, u, f),
                    Fa(d, d, f),
                    r[0] = xl(r[0], u, i),
                    r[1] = xl(r[1], d, i),
                    r[2] = xl(r[2], h, i),
                    r[3] = xl(r[3], c, i),
                    ol.fromPoints(r)
                }
                function wl(t, e, i) {
                    for (const n of t)
                        Fa(n, n, e),
                        Ra(n, n, i)
                }
                function El(t, e, i) {
                    const n = e / t.worldSize
                      , r = t.globeMatrix;
                    if (i.z <= 1) {
                        const t = vl(i).getCorners();
                        return wl(t, r, n),
                        ol.fromPoints(t)
                    }
                    const o = Tl(i)
                      , s = Sl(o);
                    wl(s, r, n);
                    const a = Number.MAX_VALUE
                      , l = [-a, -a, -a]
                      , c = [a, a, a];
                    if (o.contains(t.center)) {
                        for (const t of s)
                            ka(c, c, t),
                            Oa(l, l, t);
                        l[2] = 0;
                        const e = t.point
                          , i = [e.x * n, e.y * n, 0];
                        return ka(c, c, i),
                        Oa(l, l, i),
                        new ol(c,l)
                    }
                    const h = [r[12] * n, r[13] * n, r[14] * n]
                      , u = o.getCenter()
                      , d = I(t.center.lat, -Kl, Kl)
                      , f = I(u.lat, -Kl, Kl)
                      , p = ql(t.center.lng)
                      , m = Wl(d);
                    let g = p - ql(u.lng);
                    const _ = m - Wl(f);
                    g > .5 ? g -= 1 : g < -.5 && (g += 1);
                    let y = 0;
                    Math.abs(g) > Math.abs(_) ? y = g >= 0 ? 1 : 3 : (y = _ >= 0 ? 0 : 2,
                    Da(h, h, [r[4] * n, r[5] * n, r[6] * n], -Math.sin(w(_ >= 0 ? o.getSouth() : o.getNorth())) * ll));
                    const v = s[y]
                      , x = s[(y + 1) % 4]
                      , b = new _l(v,x,h)
                      , E = [yl(b, 0) || v[0], yl(b, 1) || v[1], yl(b, 2) || v[2]]
                      , T = Dl(t.zoom);
                    if (T > 0) {
                        const n = function({x: t, y: e, z: i}, n, r, o, s) {
                            const a = 1 / (1 << i);
                            let l = t * a
                              , c = l + a
                              , h = e * a
                              , u = h + a
                              , d = 0;
                            const f = (l + c) / 2 - o;
                            return f > .5 ? d = -1 : f < -.5 && (d = 1),
                            l = ((l + d) * n - (o *= n)) * r + o,
                            c = ((c + d) * n - o) * r + o,
                            h = (h * n - (s *= n)) * r + s,
                            u = (u * n - s) * r + s,
                            [[l, u, 0], [c, u, 0], [c, h, 0], [l, h, 0]]
                        }(i, e, t._pixelsPerMercatorPixel, p, m);
                        for (let t = 0; t < s.length; t++)
                            xl(s[t], n[t], T);
                        const r = Ia([], n[y], n[(y + 1) % 4]);
                        Ra(r, r, .5),
                        xl(E, r, T)
                    }
                    for (const t of s)
                        ka(c, c, t),
                        Oa(l, l, t);
                    return c[2] = Math.min(v[2], x[2]),
                    ka(c, c, E),
                    Oa(l, l, E),
                    new ol(c,l)
                }
                function Tl({x: t, y: e, z: i}) {
                    const n = 1 / (1 << i)
                      , r = new Gl($l(t * n),Xl((e + 1) * n))
                      , o = new Gl($l((t + 1) * n),Xl(e * n));
                    return new ca(r,o)
                }
                function Sl(t) {
                    const e = w(t.getNorth())
                      , i = w(t.getSouth())
                      , n = Math.cos(e)
                      , r = Math.cos(i)
                      , o = Math.sin(e)
                      , s = Math.sin(i)
                      , a = t.getWest()
                      , l = t.getEast();
                    return [Cl(r, s, a), Cl(r, s, l), Cl(n, o, l), Cl(n, o, a)]
                }
                function Cl(t, e, i, n=ll) {
                    return i = w(i),
                    [t * Math.sin(i) * n, -e * n, t * Math.cos(i) * n]
                }
                function Al(t, e, i) {
                    return Cl(Math.cos(w(t)), Math.sin(w(t)), e, i)
                }
                function Il(t, e, i, n) {
                    const r = 1 << i.z
                      , o = (t / la + i.x) / r;
                    return Al(Xl((e / la + i.y) / r), $l(o), n)
                }
                function Ml({min: t, max: e}) {
                    return cl / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2])
                }
                const Pl = new Float64Array(16);
                function kl(t) {
                    const e = Ml(t)
                      , i = ba(Pl, [e, e, e]);
                    return _a(i, i, ((n = [])[0] = -(r = t.min)[0],
                    n[1] = -r[1],
                    n[2] = -r[2],
                    n));
                    var n, r
                }
                function Ol(t) {
                    const e = (n = t.min,
                    (i = Pl)[0] = 1,
                    i[1] = 0,
                    i[2] = 0,
                    i[3] = 0,
                    i[4] = 0,
                    i[5] = 1,
                    i[6] = 0,
                    i[7] = 0,
                    i[8] = 0,
                    i[9] = 0,
                    i[10] = 1,
                    i[11] = 0,
                    i[12] = n[0],
                    i[13] = n[1],
                    i[14] = n[2],
                    i[15] = 1,
                    i);
                    var i, n;
                    const r = 1 / Ml(t);
                    return ya(e, e, [r, r, r])
                }
                function Rl(t, e, i, n, r) {
                    const o = function(t) {
                        const e = la / (2 * Math.PI);
                        return t / (2 * Math.PI) / e
                    }(i)
                      , s = [t, e, -i / (2 * Math.PI)]
                      , a = pa(new Float64Array(16));
                    return _a(a, a, s),
                    ya(a, a, [o, o, o]),
                    va(a, a, w(-r)),
                    xa(a, a, w(-n)),
                    a
                }
                function Dl(t) {
                    return M(sl, al, t)
                }
                function Ll(t, e) {
                    const i = Al(e.lat, e.lng)
                      , n = function(t) {
                        const e = Al(t._center.lat, t._center.lng);
                        let i = za([], Aa(0, 1, 0), e);
                        const n = wa([], -t.angle, e);
                        i = Fa(i, i, n),
                        wa(n, -t._pitch, i);
                        const r = La([], e);
                        return Ra(r, r, ml(t.cameraToCenterDistance / t.pixelsPerMeter)),
                        Fa(r, r, n),
                        Ia([], e, r)
                    }(t);
                    return s = (r = Ma([], n, i))[0],
                    a = r[1],
                    l = r[2],
                    c = (o = i)[0],
                    h = o[1],
                    u = o[2],
                    f = (d = Math.sqrt(s * s + a * a + l * l) * Math.sqrt(c * c + h * h + u * u)) && Ba(r, o) / d,
                    Math.acos(Math.min(Math.max(f, -1), 1));
                    var r, o, s, a, l, c, h, u, d, f
                }
                function Bl(t, e) {
                    return Ll(t, e) > Math.PI / 2 * 1.01
                }
                const zl = w(85)
                  , Fl = Math.cos(zl)
                  , Nl = Math.sin(zl)
                  , jl = 6371008.8
                  , Ul = 2 * Math.PI * jl;
                class Vl {
                    constructor(t, e) {
                        if (isNaN(t) || isNaN(e))
                            throw new Error(`Invalid LngLat object: (${t}, ${e})`);
                        if (this.lng = +t,
                        this.lat = +e,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new Vl(P(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`
                    }
                    distanceTo(t) {
                        const e = Math.PI / 180
                          , i = this.lat * e
                          , n = t.lat * e
                          , r = Math.sin(i) * Math.sin(n) + Math.cos(i) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);
                        return jl * Math.acos(Math.min(r, 1))
                    }
                    toBounds(t=0) {
                        const e = 360 * t / 40075017
                          , i = e / Math.cos(Math.PI / 180 * this.lat);
                        return new ca(new Vl(this.lng - i,this.lat - e),new Vl(this.lng + i,this.lat + e))
                    }
                    toEcef(t) {
                        const e = ml(t);
                        return Al(this.lat, this.lng, ll + e)
                    }
                    static convert(t) {
                        if (t instanceof Vl)
                            return t;
                        if (Array.isArray(t) && (2 === t.length || 3 === t.length))
                            return new Vl(Number(t[0]),Number(t[1]));
                        if (!Array.isArray(t) && "object" == typeof t && null !== t)
                            return new Vl(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                var Gl = Vl;
                function Zl(t) {
                    return Ul * Math.cos(t * Math.PI / 180)
                }
                function ql(t) {
                    return (180 + t) / 360
                }
                function Wl(t) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360
                }
                function Hl(t, e) {
                    return t / Zl(e)
                }
                function $l(t) {
                    return 360 * t - 180
                }
                function Xl(t) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90
                }
                function Yl(t, e) {
                    return t * Zl(Xl(e))
                }
                const Kl = 85.051129;
                function Jl(t) {
                    return 1 / Math.cos(t * Math.PI / 180)
                }
                class Ql {
                    constructor(t, e, i=0) {
                        this.x = +t,
                        this.y = +e,
                        this.z = +i
                    }
                    static fromLngLat(t, e=0) {
                        const i = Gl.convert(t);
                        return new Ql(ql(i.lng),Wl(i.lat),Hl(e, i.lat))
                    }
                    toLngLat() {
                        return new Gl($l(this.x),Xl(this.y))
                    }
                    toAltitude() {
                        return Yl(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / Ul * Jl(Xl(this.y))
                    }
                }
                function tc(t, e, i, n, r, o, s, a, l) {
                    const c = (e + n) / 2
                      , h = (i + r) / 2
                      , u = new v(c,h);
                    a(u),
                    function(t, e, i, n, r, o) {
                        const s = i - r
                          , a = n - o;
                        return Math.abs((n - e) * s - (i - t) * a) / Math.hypot(s, a)
                    }(u.x, u.y, o.x, o.y, s.x, s.y) >= l ? (tc(t, e, i, c, h, o, u, a, l),
                    tc(t, c, h, n, r, u, s, a, l)) : t.push(s)
                }
                function ec(t, e, i) {
                    let n = t[0]
                      , r = n.x
                      , o = n.y;
                    e(n);
                    const s = [n];
                    for (let a = 1; a < t.length; a++) {
                        const l = t[a]
                          , {x: c, y: h} = l;
                        e(l),
                        tc(s, r, o, c, h, n, l, e, i),
                        r = c,
                        o = h,
                        n = l
                    }
                    return s
                }
                function ic(t, e, i, n) {
                    if (n(e, i)) {
                        const r = e.add(i)._mult(.5);
                        ic(t, e, r, n),
                        ic(t, r, i, n)
                    } else
                        t.push(i)
                }
                function nc(t, e) {
                    let i = t[0];
                    const n = [i];
                    for (let r = 1; r < t.length; r++) {
                        const o = t[r];
                        ic(n, i, o, e),
                        i = o
                    }
                    return n
                }
                const rc = Math.pow(2, 14) - 1
                  , oc = -rc - 1;
                function sc(t, e) {
                    const i = Math.round(t.x * e)
                      , n = Math.round(t.y * e);
                    return t.x = I(i, oc, rc),
                    t.y = I(n, oc, rc),
                    (i < t.x || i > t.x + 1 || n < t.y || n > t.y + 1) && q("Geometry exceeds allowed extent, reduce your vector tile buffer size"),
                    t
                }
                function ac(t, e, i) {
                    const n = t.loadGeometry()
                      , r = t.extent
                      , o = la / r;
                    if (e && i && i.projection.isReprojectedInTileSpace) {
                        const o = 1 << e.z
                          , {scale: s, x: a, y: l, projection: c} = i
                          , h = t => {
                            const i = $l((e.x + t.x / r) / o)
                              , n = Xl((e.y + t.y / r) / o)
                              , h = c.project(i, n);
                            t.x = (h.x * s - a) * r,
                            t.y = (h.y * s - l) * r
                        }
                        ;
                        for (let e = 0; e < n.length; e++)
                            if (1 !== t.type)
                                n[e] = ec(n[e], h, 1);
                            else {
                                const t = [];
                                for (const i of n[e])
                                    i.x < 0 || i.x >= r || i.y < 0 || i.y >= r || (h(i),
                                    t.push(i));
                                n[e] = t
                            }
                    }
                    for (const t of n)
                        for (const e of t)
                            sc(e, o);
                    return n
                }
                function lc(t, e) {
                    return {
                        type: t.type,
                        id: t.id,
                        properties: t.properties,
                        geometry: e ? ac(t) : []
                    }
                }
                function cc(t, e, i, n, r) {
                    t.emplaceBack(2 * e + (n + 1) / 2, 2 * i + (r + 1) / 2)
                }
                function hc(t, e, i) {
                    const n = 16384;
                    t.emplaceBack(e.x, e.y, e.z, i[0] * n, i[1] * n, i[2] * n)
                }
                class uc {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((t => t.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.projection = t.projection,
                        this.layoutVertexArray = new Vo,
                        this.indexArray = new rs,
                        this.segments = new aa,
                        this.programConfigurations = new Ks(t.layers,t.zoom),
                        this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id))
                    }
                    populate(t, e, i, n) {
                        const r = this.layers[0]
                          , o = [];
                        let s = null;
                        "circle" === r.type && (s = r.layout.get("circle-sort-key"));
                        for (const {feature: e, id: r, index: a, sourceLayerIndex: l} of t) {
                            const t = this.layers[0]._featureFilter.needGeometry
                              , c = lc(e, t);
                            if (!this.layers[0]._featureFilter.filter(new Eo(this.zoom), c, i))
                                continue;
                            const h = s ? s.evaluate(c, {}, i) : void 0
                              , u = {
                                id: r,
                                properties: e.properties,
                                type: e.type,
                                sourceLayerIndex: l,
                                index: a,
                                geometry: t ? c.geometry : ac(e, i, n),
                                patterns: {},
                                sortKey: h
                            };
                            o.push(u)
                        }
                        s && o.sort(( (t, e) => t.sortKey - e.sortKey));
                        let a = null;
                        "globe" === n.projection.name && (this.globeExtVertexArray = new Xo,
                        a = n.projection);
                        for (const n of o) {
                            const {geometry: r, index: o, sourceLayerIndex: s} = n
                              , l = t[o].feature;
                            this.addFeature(n, r, o, e.availableImages, i, a),
                            e.featureIndex.insert(l, r, o, s, this.index)
                        }
                    }
                    update(t, e, i, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, n)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, oa.members),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, sa.members))),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
                    }
                    addFeature(t, e, i, n, r, o) {
                        for (const i of e)
                            for (const e of i) {
                                const i = e.x
                                  , n = e.y;
                                if (i < 0 || i >= la || n < 0 || n >= la)
                                    continue;
                                if (o) {
                                    const t = o.projectTilePoint(i, n, r)
                                      , e = o.upVector(r, i, n)
                                      , s = this.globeExtVertexArray;
                                    hc(s, t, e),
                                    hc(s, t, e),
                                    hc(s, t, e),
                                    hc(s, t, e)
                                }
                                const s = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey)
                                  , a = s.vertexLength;
                                cc(this.layoutVertexArray, i, n, -1, -1),
                                cc(this.layoutVertexArray, i, n, 1, -1),
                                cc(this.layoutVertexArray, i, n, 1, 1),
                                cc(this.layoutVertexArray, i, n, -1, 1),
                                this.indexArray.emplaceBack(a, a + 1, a + 2),
                                this.indexArray.emplaceBack(a, a + 2, a + 3),
                                s.vertexLength += 4,
                                s.primitiveLength += 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, {}, n, r)
                    }
                }
                function dc(t, e) {
                    for (let i = 0; i < t.length; i++)
                        if (bc(e, t[i]))
                            return !0;
                    for (let i = 0; i < e.length; i++)
                        if (bc(t, e[i]))
                            return !0;
                    return !!gc(t, e)
                }
                function fc(t, e, i) {
                    return !!bc(t, e) || !!yc(e, t, i)
                }
                function pc(t, e) {
                    if (1 === t.length)
                        return xc(e, t[0]);
                    for (let i = 0; i < e.length; i++) {
                        const n = e[i];
                        for (let e = 0; e < n.length; e++)
                            if (bc(t, n[e]))
                                return !0
                    }
                    for (let i = 0; i < t.length; i++)
                        if (xc(e, t[i]))
                            return !0;
                    for (let i = 0; i < e.length; i++)
                        if (gc(t, e[i]))
                            return !0;
                    return !1
                }
                function mc(t, e, i) {
                    if (t.length > 1) {
                        if (gc(t, e))
                            return !0;
                        for (let n = 0; n < e.length; n++)
                            if (yc(e[n], t, i))
                                return !0
                    }
                    for (let n = 0; n < t.length; n++)
                        if (yc(t[n], e, i))
                            return !0;
                    return !1
                }
                function gc(t, e) {
                    if (0 === t.length || 0 === e.length)
                        return !1;
                    for (let i = 0; i < t.length - 1; i++) {
                        const n = t[i]
                          , r = t[i + 1];
                        for (let t = 0; t < e.length - 1; t++)
                            if (_c(n, r, e[t], e[t + 1]))
                                return !0
                    }
                    return !1
                }
                function _c(t, e, i, n) {
                    return W(t, i, n) !== W(e, i, n) && W(t, e, i) !== W(t, e, n)
                }
                function yc(t, e, i) {
                    const n = i * i;
                    if (1 === e.length)
                        return t.distSqr(e[0]) < n;
                    for (let i = 1; i < e.length; i++)
                        if (vc(t, e[i - 1], e[i]) < n)
                            return !0;
                    return !1
                }
                function vc(t, e, i) {
                    const n = e.distSqr(i);
                    if (0 === n)
                        return t.distSqr(e);
                    const r = ((t.x - e.x) * (i.x - e.x) + (t.y - e.y) * (i.y - e.y)) / n;
                    return t.distSqr(r < 0 ? e : r > 1 ? i : i.sub(e)._mult(r)._add(e))
                }
                function xc(t, e) {
                    let i, n, r, o = !1;
                    for (let s = 0; s < t.length; s++) {
                        i = t[s];
                        for (let t = 0, s = i.length - 1; t < i.length; s = t++)
                            n = i[t],
                            r = i[s],
                            n.y > e.y != r.y > e.y && e.x < (r.x - n.x) * (e.y - n.y) / (r.y - n.y) + n.x && (o = !o)
                    }
                    return o
                }
                function bc(t, e) {
                    let i = !1;
                    for (let n = 0, r = t.length - 1; n < t.length; r = n++) {
                        const o = t[n]
                          , s = t[r];
                        o.y > e.y != s.y > e.y && e.x < (s.x - o.x) * (e.y - o.y) / (s.y - o.y) + o.x && (i = !i)
                    }
                    return i
                }
                function wc(t, e, i, n, r) {
                    for (const o of t)
                        if (e <= o.x && i <= o.y && n >= o.x && r >= o.y)
                            return !0;
                    const o = [new v(e,i), new v(e,r), new v(n,r), new v(n,i)];
                    if (t.length > 2)
                        for (const e of o)
                            if (bc(t, e))
                                return !0;
                    for (let e = 0; e < t.length - 1; e++)
                        if (Ec(t[e], t[e + 1], o))
                            return !0;
                    return !1
                }
                function Ec(t, e, i) {
                    const n = i[0]
                      , r = i[2];
                    if (t.x < n.x && e.x < n.x || t.x > r.x && e.x > r.x || t.y < n.y && e.y < n.y || t.y > r.y && e.y > r.y)
                        return !1;
                    const o = W(t, e, i[0]);
                    return o !== W(t, e, i[1]) || o !== W(t, e, i[2]) || o !== W(t, e, i[3])
                }
                function Tc(t, e, i) {
                    const n = e.paint.get(t).value;
                    return "constant" === n.kind ? n.value : i.programConfigurations.get(e.id).getMaxValue(t)
                }
                function Sc(t) {
                    return Math.sqrt(t[0] * t[0] + t[1] * t[1])
                }
                function Cc(t, e, i, n, r) {
                    if (!e[0] && !e[1])
                        return t;
                    const o = v.convert(e)._mult(r);
                    "viewport" === i && o._rotate(-n);
                    const s = [];
                    for (let e = 0; e < t.length; e++)
                        s.push(t[e].sub(o));
                    return s
                }
                function Ac(t, e, i, n) {
                    const r = v.convert(t)._mult(n);
                    return "viewport" === e && r._rotate(-i),
                    r
                }
                Yr(uc, "CircleBucket", {
                    omit: ["layers"]
                });
                const Ic = new Lo({
                    "circle-sort-key": new Ro(ee.layout_circle["circle-sort-key"])
                });
                var Mc = {
                    paint: new Lo({
                        "circle-radius": new Ro(ee.paint_circle["circle-radius"]),
                        "circle-color": new Ro(ee.paint_circle["circle-color"]),
                        "circle-blur": new Ro(ee.paint_circle["circle-blur"]),
                        "circle-opacity": new Ro(ee.paint_circle["circle-opacity"]),
                        "circle-translate": new Oo(ee.paint_circle["circle-translate"]),
                        "circle-translate-anchor": new Oo(ee.paint_circle["circle-translate-anchor"]),
                        "circle-pitch-scale": new Oo(ee.paint_circle["circle-pitch-scale"]),
                        "circle-pitch-alignment": new Oo(ee.paint_circle["circle-pitch-alignment"]),
                        "circle-stroke-width": new Ro(ee.paint_circle["circle-stroke-width"]),
                        "circle-stroke-color": new Ro(ee.paint_circle["circle-stroke-color"]),
                        "circle-stroke-opacity": new Ro(ee.paint_circle["circle-stroke-opacity"])
                    }),
                    layout: Ic
                };
                function Pc(t, e, i, n, r, o, s, a, l) {
                    if (o && t.queryGeometry.isAboveHorizon)
                        return !1;
                    o && (l *= t.pixelToTileUnitsFactor);
                    const c = t.tileID.canonical
                      , h = i.projection.upVectorScale(c, i.center.lat, i.worldSize).metersToTile;
                    for (const u of e)
                        for (const e of u) {
                            const u = e.add(a)
                              , d = r && i.elevation ? i.elevation.exaggeration() * r.getElevationAt(u.x, u.y, !0) : 0
                              , f = i.projection.projectTilePoint(u.x, u.y, c);
                            if (d > 0) {
                                const t = i.projection.upVector(c, u.x, u.y);
                                f.x += t[0] * h * d,
                                f.y += t[1] * h * d,
                                f.z += t[2] * h * d
                            }
                            const p = o ? u : kc(f.x, f.y, f.z, n)
                              , m = o ? t.tilespaceRays.map((t => Dc(t, d))) : t.queryGeometry.screenGeometry
                              , g = Wa([], [f.x, f.y, f.z, 1], n);
                            if (!s && o ? l *= g[3] / i.cameraToCenterDistance : s && !o && (l *= i.cameraToCenterDistance / g[3]),
                            o) {
                                const t = Xl((e.y / la + c.y) / (1 << c.z));
                                l /= i.projection.pixelsPerMeter(t, 1) / Hl(1, t)
                            }
                            if (fc(m, p, l))
                                return !0
                        }
                    return !1
                }
                function kc(t, e, i, n) {
                    const r = Wa([], [t, e, i, 1], n);
                    return new v(r[0] / r[3],r[1] / r[3])
                }
                const Oc = Aa(0, 0, 0)
                  , Rc = Aa(0, 0, 1);
                function Dc(t, e) {
                    const i = Ta();
                    return Oc[2] = e,
                    t.intersectsPlane(Oc, Rc, i),
                    new v(i[0],i[1])
                }
                class Lc extends uc {
                }
                function Bc(t, {width: e, height: i}, n, r) {
                    if (r) {
                        if (r instanceof Uint8ClampedArray)
                            r = new Uint8Array(r.buffer);
                        else if (r.length !== e * i * n)
                            throw new RangeError("mismatched image size")
                    } else
                        r = new Uint8Array(e * i * n);
                    return t.width = e,
                    t.height = i,
                    t.data = r,
                    t
                }
                function zc(t, e, i) {
                    const {width: n, height: r} = e;
                    n === t.width && r === t.height || (Fc(t, e, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(t.width, n),
                        height: Math.min(t.height, r)
                    }, i),
                    t.width = n,
                    t.height = r,
                    t.data = e.data)
                }
                function Fc(t, e, i, n, r, o) {
                    if (0 === r.width || 0 === r.height)
                        return e;
                    if (r.width > t.width || r.height > t.height || i.x > t.width - r.width || i.y > t.height - r.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (r.width > e.width || r.height > e.height || n.x > e.width - r.width || n.y > e.height - r.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const s = t.data
                      , a = e.data;
                    for (let l = 0; l < r.height; l++) {
                        const c = ((i.y + l) * t.width + i.x) * o
                          , h = ((n.y + l) * e.width + n.x) * o;
                        for (let t = 0; t < r.width * o; t++)
                            a[h + t] = s[c + t]
                    }
                    return e
                }
                Yr(Lc, "HeatmapBucket", {
                    omit: ["layers"]
                });
                class Nc {
                    constructor(t, e) {
                        Bc(this, t, 1, e)
                    }
                    resize(t) {
                        zc(this, new Nc(t), 1)
                    }
                    clone() {
                        return new Nc({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, e, i, n, r) {
                        Fc(t, e, i, n, r, 1)
                    }
                }
                class jc {
                    constructor(t, e) {
                        Bc(this, t, 4, e)
                    }
                    resize(t) {
                        zc(this, new jc(t), 4)
                    }
                    replace(t, e) {
                        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
                    }
                    clone() {
                        return new jc({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, e, i, n, r) {
                        Fc(t, e, i, n, r, 4)
                    }
                }
                Yr(Nc, "AlphaImage"),
                Yr(jc, "RGBAImage");
                var Uc = {
                    paint: new Lo({
                        "heatmap-radius": new Ro(ee.paint_heatmap["heatmap-radius"]),
                        "heatmap-weight": new Ro(ee.paint_heatmap["heatmap-weight"]),
                        "heatmap-intensity": new Oo(ee.paint_heatmap["heatmap-intensity"]),
                        "heatmap-color": new Do(ee.paint_heatmap["heatmap-color"]),
                        "heatmap-opacity": new Oo(ee.paint_heatmap["heatmap-opacity"])
                    })
                };
                function Vc(t) {
                    const e = {}
                      , i = t.resolution || 256
                      , n = t.clips ? t.clips.length : 1
                      , r = t.image || new jc({
                        width: i,
                        height: n
                    })
                      , o = (i, n, o) => {
                        e[t.evaluationKey] = o;
                        const s = t.expression.evaluate(e);
                        r.data[i + n + 0] = Math.floor(255 * s.r / s.a),
                        r.data[i + n + 1] = Math.floor(255 * s.g / s.a),
                        r.data[i + n + 2] = Math.floor(255 * s.b / s.a),
                        r.data[i + n + 3] = Math.floor(255 * s.a)
                    }
                    ;
                    if (t.clips)
                        for (let e = 0, r = 0; e < n; ++e,
                        r += 4 * i)
                            for (let n = 0, s = 0; n < i; n++,
                            s += 4) {
                                const a = n / (i - 1)
                                  , {start: l, end: c} = t.clips[e];
                                o(r, s, l * (1 - a) + c * a)
                            }
                    else
                        for (let t = 0, e = 0; t < i; t++,
                        e += 4)
                            o(0, e, t / (i - 1));
                    return r
                }
                var Gc = {
                    paint: new Lo({
                        "hillshade-illumination-direction": new Oo(ee.paint_hillshade["hillshade-illumination-direction"]),
                        "hillshade-illumination-anchor": new Oo(ee.paint_hillshade["hillshade-illumination-anchor"]),
                        "hillshade-exaggeration": new Oo(ee.paint_hillshade["hillshade-exaggeration"]),
                        "hillshade-shadow-color": new Oo(ee.paint_hillshade["hillshade-shadow-color"]),
                        "hillshade-highlight-color": new Oo(ee.paint_hillshade["hillshade-highlight-color"]),
                        "hillshade-accent-color": new Oo(ee.paint_hillshade["hillshade-accent-color"])
                    })
                };
                const Zc = jo([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: qc} = Zc;
                var Wc = {
                    exports: {}
                };
                function Hc(t, e, i) {
                    i = i || 2;
                    var n, r, o, s, a, l, c, h = e && e.length, u = h ? e[0] * i : t.length, d = $c(t, 0, u, i, !0), f = [];
                    if (!d || d.next === d.prev)
                        return f;
                    if (h && (d = function(t, e, i, n) {
                        var r, o, s, a = [];
                        for (r = 0,
                        o = e.length; r < o; r++)
                            (s = $c(t, e[r] * n, r < o - 1 ? e[r + 1] * n : t.length, n, !1)) === s.next && (s.steiner = !0),
                            a.push(oh(s));
                        for (a.sort(eh),
                        r = 0; r < a.length; r++)
                            i = ih(a[r], i);
                        return i
                    }(t, e, d, i)),
                    t.length > 80 * i) {
                        n = o = t[0],
                        r = s = t[1];
                        for (var p = i; p < u; p += i)
                            (a = t[p]) < n && (n = a),
                            (l = t[p + 1]) < r && (r = l),
                            a > o && (o = a),
                            l > s && (s = l);
                        c = 0 !== (c = Math.max(o - n, s - r)) ? 32767 / c : 0
                    }
                    return Yc(d, f, i, n, r, c, 0),
                    f
                }
                function $c(t, e, i, n, r) {
                    var o, s;
                    if (r === yh(t, e, i, n) > 0)
                        for (o = e; o < i; o += n)
                            s = mh(o, t[o], t[o + 1], s);
                    else
                        for (o = i - n; o >= e; o -= n)
                            s = mh(o, t[o], t[o + 1], s);
                    return s && ch(s, s.next) && (gh(s),
                    s = s.next),
                    s
                }
                function Xc(t, e) {
                    if (!t)
                        return t;
                    e || (e = t);
                    var i, n = t;
                    do {
                        if (i = !1,
                        n.steiner || !ch(n, n.next) && 0 !== lh(n.prev, n, n.next))
                            n = n.next;
                        else {
                            if (gh(n),
                            (n = e = n.prev) === n.next)
                                break;
                            i = !0
                        }
                    } while (i || n !== e);
                    return e
                }
                function Yc(t, e, i, n, r, o, s) {
                    if (t) {
                        !s && o && function(t, e, i, n) {
                            var r = t;
                            do {
                                0 === r.z && (r.z = rh(r.x, r.y, e, i, n)),
                                r.prevZ = r.prev,
                                r.nextZ = r.next,
                                r = r.next
                            } while (r !== t);
                            r.prevZ.nextZ = null,
                            r.prevZ = null,
                            function(t) {
                                var e, i, n, r, o, s, a, l, c = 1;
                                do {
                                    for (i = t,
                                    t = null,
                                    o = null,
                                    s = 0; i; ) {
                                        for (s++,
                                        n = i,
                                        a = 0,
                                        e = 0; e < c && (a++,
                                        n = n.nextZ); e++)
                                            ;
                                        for (l = c; a > 0 || l > 0 && n; )
                                            0 !== a && (0 === l || !n || i.z <= n.z) ? (r = i,
                                            i = i.nextZ,
                                            a--) : (r = n,
                                            n = n.nextZ,
                                            l--),
                                            o ? o.nextZ = r : t = r,
                                            r.prevZ = o,
                                            o = r;
                                        i = n
                                    }
                                    o.nextZ = null,
                                    c *= 2
                                } while (s > 1)
                            }(r)
                        }(t, n, r, o);
                        for (var a, l, c = t; t.prev !== t.next; )
                            if (a = t.prev,
                            l = t.next,
                            o ? Jc(t, n, r, o) : Kc(t))
                                e.push(a.i / i | 0),
                                e.push(t.i / i | 0),
                                e.push(l.i / i | 0),
                                gh(t),
                                t = l.next,
                                c = l.next;
                            else if ((t = l) === c) {
                                s ? 1 === s ? Yc(t = Qc(Xc(t), e, i), e, i, n, r, o, 2) : 2 === s && th(t, e, i, n, r, o) : Yc(Xc(t), e, i, n, r, o, 1);
                                break
                            }
                    }
                }
                function Kc(t) {
                    var e = t.prev
                      , i = t
                      , n = t.next;
                    if (lh(e, i, n) >= 0)
                        return !1;
                    for (var r = e.x, o = i.x, s = n.x, a = e.y, l = i.y, c = n.y, h = r < o ? r < s ? r : s : o < s ? o : s, u = a < l ? a < c ? a : c : l < c ? l : c, d = r > o ? r > s ? r : s : o > s ? o : s, f = a > l ? a > c ? a : c : l > c ? l : c, p = n.next; p !== e; ) {
                        if (p.x >= h && p.x <= d && p.y >= u && p.y <= f && sh(r, a, o, l, s, c, p.x, p.y) && lh(p.prev, p, p.next) >= 0)
                            return !1;
                        p = p.next
                    }
                    return !0
                }
                function Jc(t, e, i, n) {
                    var r = t.prev
                      , o = t
                      , s = t.next;
                    if (lh(r, o, s) >= 0)
                        return !1;
                    for (var a = r.x, l = o.x, c = s.x, h = r.y, u = o.y, d = s.y, f = a < l ? a < c ? a : c : l < c ? l : c, p = h < u ? h < d ? h : d : u < d ? u : d, m = a > l ? a > c ? a : c : l > c ? l : c, g = h > u ? h > d ? h : d : u > d ? u : d, _ = rh(f, p, e, i, n), y = rh(m, g, e, i, n), v = t.prevZ, x = t.nextZ; v && v.z >= _ && x && x.z <= y; ) {
                        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== s && sh(a, h, l, u, c, d, v.x, v.y) && lh(v.prev, v, v.next) >= 0)
                            return !1;
                        if (v = v.prevZ,
                        x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== s && sh(a, h, l, u, c, d, x.x, x.y) && lh(x.prev, x, x.next) >= 0)
                            return !1;
                        x = x.nextZ
                    }
                    for (; v && v.z >= _; ) {
                        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== r && v !== s && sh(a, h, l, u, c, d, v.x, v.y) && lh(v.prev, v, v.next) >= 0)
                            return !1;
                        v = v.prevZ
                    }
                    for (; x && x.z <= y; ) {
                        if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== s && sh(a, h, l, u, c, d, x.x, x.y) && lh(x.prev, x, x.next) >= 0)
                            return !1;
                        x = x.nextZ
                    }
                    return !0
                }
                function Qc(t, e, i) {
                    var n = t;
                    do {
                        var r = n.prev
                          , o = n.next.next;
                        !ch(r, o) && hh(r, n, n.next, o) && fh(r, o) && fh(o, r) && (e.push(r.i / i | 0),
                        e.push(n.i / i | 0),
                        e.push(o.i / i | 0),
                        gh(n),
                        gh(n.next),
                        n = t = o),
                        n = n.next
                    } while (n !== t);
                    return Xc(n)
                }
                function th(t, e, i, n, r, o) {
                    var s = t;
                    do {
                        for (var a = s.next.next; a !== s.prev; ) {
                            if (s.i !== a.i && ah(s, a)) {
                                var l = ph(s, a);
                                return s = Xc(s, s.next),
                                l = Xc(l, l.next),
                                Yc(s, e, i, n, r, o, 0),
                                void Yc(l, e, i, n, r, o, 0)
                            }
                            a = a.next
                        }
                        s = s.next
                    } while (s !== t)
                }
                function eh(t, e) {
                    return t.x - e.x
                }
                function ih(t, e) {
                    var i = function(t, e) {
                        var i, n = e, r = t.x, o = t.y, s = -1 / 0;
                        do {
                            if (o <= n.y && o >= n.next.y && n.next.y !== n.y) {
                                var a = n.x + (o - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (a <= r && a > s && (s = a,
                                i = n.x < n.next.x ? n : n.next,
                                a === r))
                                    return i
                            }
                            n = n.next
                        } while (n !== e);
                        if (!i)
                            return null;
                        var l, c = i, h = i.x, u = i.y, d = 1 / 0;
                        n = i;
                        do {
                            r >= n.x && n.x >= h && r !== n.x && sh(o < u ? r : s, o, h, u, o < u ? s : r, o, n.x, n.y) && (l = Math.abs(o - n.y) / (r - n.x),
                            fh(n, t) && (l < d || l === d && (n.x > i.x || n.x === i.x && nh(i, n))) && (i = n,
                            d = l)),
                            n = n.next
                        } while (n !== c);
                        return i
                    }(t, e);
                    if (!i)
                        return e;
                    var n = ph(i, t);
                    return Xc(n, n.next),
                    Xc(i, i.next)
                }
                function nh(t, e) {
                    return lh(t.prev, t, e.prev) < 0 && lh(e.next, t, t.next) < 0
                }
                function rh(t, e, i, n, r) {
                    return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
                }
                function oh(t) {
                    var e = t
                      , i = t;
                    do {
                        (e.x < i.x || e.x === i.x && e.y < i.y) && (i = e),
                        e = e.next
                    } while (e !== t);
                    return i
                }
                function sh(t, e, i, n, r, o, s, a) {
                    return (r - s) * (e - a) >= (t - s) * (o - a) && (t - s) * (n - a) >= (i - s) * (e - a) && (i - s) * (o - a) >= (r - s) * (n - a)
                }
                function ah(t, e) {
                    return t.next.i !== e.i && t.prev.i !== e.i && !function(t, e) {
                        var i = t;
                        do {
                            if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && hh(i, i.next, t, e))
                                return !0;
                            i = i.next
                        } while (i !== t);
                        return !1
                    }(t, e) && (fh(t, e) && fh(e, t) && function(t, e) {
                        var i = t
                          , n = !1
                          , r = (t.x + e.x) / 2
                          , o = (t.y + e.y) / 2;
                        do {
                            i.y > o != i.next.y > o && i.next.y !== i.y && r < (i.next.x - i.x) * (o - i.y) / (i.next.y - i.y) + i.x && (n = !n),
                            i = i.next
                        } while (i !== t);
                        return n
                    }(t, e) && (lh(t.prev, t, e.prev) || lh(t, e.prev, e)) || ch(t, e) && lh(t.prev, t, t.next) > 0 && lh(e.prev, e, e.next) > 0)
                }
                function lh(t, e, i) {
                    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
                }
                function ch(t, e) {
                    return t.x === e.x && t.y === e.y
                }
                function hh(t, e, i, n) {
                    var r = dh(lh(t, e, i))
                      , o = dh(lh(t, e, n))
                      , s = dh(lh(i, n, t))
                      , a = dh(lh(i, n, e));
                    return r !== o && s !== a || !(0 !== r || !uh(t, i, e)) || !(0 !== o || !uh(t, n, e)) || !(0 !== s || !uh(i, t, n)) || !(0 !== a || !uh(i, e, n))
                }
                function uh(t, e, i) {
                    return e.x <= Math.max(t.x, i.x) && e.x >= Math.min(t.x, i.x) && e.y <= Math.max(t.y, i.y) && e.y >= Math.min(t.y, i.y)
                }
                function dh(t) {
                    return t > 0 ? 1 : t < 0 ? -1 : 0
                }
                function fh(t, e) {
                    return lh(t.prev, t, t.next) < 0 ? lh(t, e, t.next) >= 0 && lh(t, t.prev, e) >= 0 : lh(t, e, t.prev) < 0 || lh(t, t.next, e) < 0
                }
                function ph(t, e) {
                    var i = new _h(t.i,t.x,t.y)
                      , n = new _h(e.i,e.x,e.y)
                      , r = t.next
                      , o = e.prev;
                    return t.next = e,
                    e.prev = t,
                    i.next = r,
                    r.prev = i,
                    n.next = i,
                    i.prev = n,
                    o.next = n,
                    n.prev = o,
                    n
                }
                function mh(t, e, i, n) {
                    var r = new _h(t,e,i);
                    return n ? (r.next = n.next,
                    r.prev = n,
                    n.next.prev = r,
                    n.next = r) : (r.prev = r,
                    r.next = r),
                    r
                }
                function gh(t) {
                    t.next.prev = t.prev,
                    t.prev.next = t.next,
                    t.prevZ && (t.prevZ.nextZ = t.nextZ),
                    t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }
                function _h(t, e, i) {
                    this.i = t,
                    this.x = e,
                    this.y = i,
                    this.prev = null,
                    this.next = null,
                    this.z = 0,
                    this.prevZ = null,
                    this.nextZ = null,
                    this.steiner = !1
                }
                function yh(t, e, i, n) {
                    for (var r = 0, o = e, s = i - n; o < i; o += n)
                        r += (t[s] - t[o]) * (t[o + 1] + t[s + 1]),
                        s = o;
                    return r
                }
                Wc.exports = Hc,
                Wc.exports.default = Hc,
                Hc.deviation = function(t, e, i, n) {
                    var r = e && e.length
                      , o = Math.abs(yh(t, 0, r ? e[0] * i : t.length, i));
                    if (r)
                        for (var s = 0, a = e.length; s < a; s++)
                            o -= Math.abs(yh(t, e[s] * i, s < a - 1 ? e[s + 1] * i : t.length, i));
                    var l = 0;
                    for (s = 0; s < n.length; s += 3) {
                        var c = n[s] * i
                          , h = n[s + 1] * i
                          , u = n[s + 2] * i;
                        l += Math.abs((t[c] - t[u]) * (t[h + 1] - t[c + 1]) - (t[c] - t[h]) * (t[u + 1] - t[c + 1]))
                    }
                    return 0 === o && 0 === l ? 0 : Math.abs((l - o) / o)
                }
                ,
                Hc.flatten = function(t) {
                    for (var e = t[0][0].length, i = {
                        vertices: [],
                        holes: [],
                        dimensions: e
                    }, n = 0, r = 0; r < t.length; r++) {
                        for (var o = 0; o < t[r].length; o++)
                            for (var s = 0; s < e; s++)
                                i.vertices.push(t[r][o][s]);
                        r > 0 && i.holes.push(n += t[r - 1].length)
                    }
                    return i
                }
                ;
                var vh = f(Wc.exports);
                function xh(t, e, i, n, r) {
                    bh(t, e, i || 0, n || t.length - 1, r || Eh)
                }
                function bh(t, e, i, n, r) {
                    for (; n > i; ) {
                        if (n - i > 600) {
                            var o = n - i + 1
                              , s = e - i + 1
                              , a = Math.log(o)
                              , l = .5 * Math.exp(2 * a / 3)
                              , c = .5 * Math.sqrt(a * l * (o - l) / o) * (s - o / 2 < 0 ? -1 : 1);
                            bh(t, e, Math.max(i, Math.floor(e - s * l / o + c)), Math.min(n, Math.floor(e + (o - s) * l / o + c)), r)
                        }
                        var h = t[e]
                          , u = i
                          , d = n;
                        for (wh(t, i, e),
                        r(t[n], h) > 0 && wh(t, i, n); u < d; ) {
                            for (wh(t, u, d),
                            u++,
                            d--; r(t[u], h) < 0; )
                                u++;
                            for (; r(t[d], h) > 0; )
                                d--
                        }
                        0 === r(t[i], h) ? wh(t, i, d) : wh(t, ++d, n),
                        d <= e && (i = d + 1),
                        e <= d && (n = d - 1)
                    }
                }
                function wh(t, e, i) {
                    var n = t[e];
                    t[e] = t[i],
                    t[i] = n
                }
                function Eh(t, e) {
                    return t < e ? -1 : t > e ? 1 : 0
                }
                function Th(t, e) {
                    const i = t.length;
                    if (i <= 1)
                        return [t];
                    const n = [];
                    let r, o;
                    for (let e = 0; e < i; e++) {
                        const i = H(t[e]);
                        0 !== i && (t[e].area = Math.abs(i),
                        void 0 === o && (o = i < 0),
                        o === i < 0 ? (r && n.push(r),
                        r = [t[e]]) : r.push(t[e]))
                    }
                    if (r && n.push(r),
                    e > 1)
                        for (let t = 0; t < n.length; t++)
                            n[t].length <= e || (xh(n[t], e, 1, n[t].length - 1, Sh),
                            n[t] = n[t].slice(0, e));
                    return n
                }
                function Sh(t, e) {
                    return e.area - t.area
                }
                function Ch(t, e, i) {
                    const n = i.patternDependencies;
                    let r = !1;
                    for (const i of e) {
                        const e = i.paint.get(`${t}-pattern`);
                        e.isConstant() || (r = !0);
                        const o = e.constantOr(null);
                        o && (r = !0,
                        n[o] = !0)
                    }
                    return r
                }
                function Ah(t, e, i, n, r) {
                    const o = r.patternDependencies;
                    for (const s of e) {
                        const e = s.paint.get(`${t}-pattern`).value;
                        if ("constant" !== e.kind) {
                            let t = e.evaluate({
                                zoom: n
                            }, i, {}, r.availableImages);
                            t = t && t.name ? t.name : t,
                            o[t] = !0,
                            i.patterns[s.id] = t
                        }
                    }
                    return i
                }
                class Ih {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((t => t.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new Vo,
                        this.indexArray = new rs,
                        this.indexArray2 = new hs,
                        this.programConfigurations = new Ks(t.layers,t.zoom),
                        this.segments = new aa,
                        this.segments2 = new aa,
                        this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                        this.projection = t.projection
                    }
                    populate(t, e, i, n) {
                        this.hasPattern = Ch("fill", this.layers, e);
                        const r = this.layers[0].layout.get("fill-sort-key")
                          , o = [];
                        for (const {feature: s, id: a, index: l, sourceLayerIndex: c} of t) {
                            const t = this.layers[0]._featureFilter.needGeometry
                              , h = lc(s, t);
                            if (!this.layers[0]._featureFilter.filter(new Eo(this.zoom), h, i))
                                continue;
                            const u = r ? r.evaluate(h, {}, i, e.availableImages) : void 0
                              , d = {
                                id: a,
                                properties: s.properties,
                                type: s.type,
                                sourceLayerIndex: c,
                                index: l,
                                geometry: t ? h.geometry : ac(s, i, n),
                                patterns: {},
                                sortKey: u
                            };
                            o.push(d)
                        }
                        r && o.sort(( (t, e) => t.sortKey - e.sortKey));
                        for (const n of o) {
                            const {geometry: r, index: o, sourceLayerIndex: s} = n;
                            if (this.hasPattern) {
                                const t = Ah("fill", this.layers, n, this.zoom, e);
                                this.patternFeatures.push(t)
                            } else
                                this.addFeature(n, r, o, i, {}, e.availableImages);
                            e.featureIndex.insert(t[o].feature, r, o, s, this.index)
                        }
                    }
                    update(t, e, i, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, n)
                    }
                    addFeatures(t, e, i, n, r) {
                        for (const t of this.patternFeatures)
                            this.addFeature(t, t.geometry, t.index, e, i, n)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, qc),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(t, e, i, n, r, o=[]) {
                        for (const t of Th(e, 500)) {
                            let e = 0;
                            for (const i of t)
                                e += i.length;
                            const i = this.segments.prepareSegment(e, this.layoutVertexArray, this.indexArray)
                              , n = i.vertexLength
                              , r = []
                              , o = [];
                            for (const e of t) {
                                if (0 === e.length)
                                    continue;
                                e !== t[0] && o.push(r.length / 2);
                                const i = this.segments2.prepareSegment(e.length, this.layoutVertexArray, this.indexArray2)
                                  , n = i.vertexLength;
                                this.layoutVertexArray.emplaceBack(e[0].x, e[0].y),
                                this.indexArray2.emplaceBack(n + e.length - 1, n),
                                r.push(e[0].x),
                                r.push(e[0].y);
                                for (let t = 1; t < e.length; t++)
                                    this.layoutVertexArray.emplaceBack(e[t].x, e[t].y),
                                    this.indexArray2.emplaceBack(n + t - 1, n + t),
                                    r.push(e[t].x),
                                    r.push(e[t].y);
                                i.vertexLength += e.length,
                                i.primitiveLength += e.length
                            }
                            const s = vh(r, o);
                            for (let t = 0; t < s.length; t += 3)
                                this.indexArray.emplaceBack(n + s[t], n + s[t + 1], n + s[t + 2]);
                            i.vertexLength += e,
                            i.primitiveLength += s.length / 3
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, r, o, n)
                    }
                }
                Yr(Ih, "FillBucket", {
                    omit: ["layers", "patternFeatures"]
                });
                const Mh = new Lo({
                    "fill-sort-key": new Ro(ee.layout_fill["fill-sort-key"])
                });
                var Ph = {
                    paint: new Lo({
                        "fill-antialias": new Oo(ee.paint_fill["fill-antialias"]),
                        "fill-opacity": new Ro(ee.paint_fill["fill-opacity"]),
                        "fill-color": new Ro(ee.paint_fill["fill-color"]),
                        "fill-outline-color": new Ro(ee.paint_fill["fill-outline-color"]),
                        "fill-translate": new Oo(ee.paint_fill["fill-translate"]),
                        "fill-translate-anchor": new Oo(ee.paint_fill["fill-translate-anchor"]),
                        "fill-pattern": new Ro(ee.paint_fill["fill-pattern"])
                    }),
                    layout: Mh
                };
                const kh = jo([{
                    name: "a_pos_normal_ed",
                    components: 4,
                    type: "Int16"
                }])
                  , Oh = jo([{
                    name: "a_centroid_pos",
                    components: 2,
                    type: "Uint16"
                }])
                  , Rh = jo([{
                    name: "a_pos_3",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_pos_normal_3",
                    components: 3,
                    type: "Int16"
                }])
                  , {members: Dh} = kh;
                var Lh = {}
                  , Bh = _
                  , zh = Fh;
                function Fh(t, e, i, n, r) {
                    this.properties = {},
                    this.extent = i,
                    this.type = 0,
                    this._pbf = t,
                    this._geometry = -1,
                    this._keys = n,
                    this._values = r,
                    t.readFields(Nh, this, e)
                }
                function Nh(t, e, i) {
                    1 == t ? e.id = i.readVarint() : 2 == t ? function(t, e) {
                        for (var i = t.readVarint() + t.pos; t.pos < i; ) {
                            var n = e._keys[t.readVarint()]
                              , r = e._values[t.readVarint()];
                            e.properties[n] = r
                        }
                    }(i, e) : 3 == t ? e.type = i.readVarint() : 4 == t && (e._geometry = i.pos)
                }
                function jh(t) {
                    for (var e, i, n = 0, r = 0, o = t.length, s = o - 1; r < o; s = r++)
                        n += ((i = t[s]).x - (e = t[r]).x) * (e.y + i.y);
                    return n
                }
                Fh.types = ["Unknown", "Point", "LineString", "Polygon"],
                Fh.prototype.loadGeometry = function() {
                    var t = this._pbf;
                    t.pos = this._geometry;
                    for (var e, i = t.readVarint() + t.pos, n = 1, r = 0, o = 0, s = 0, a = []; t.pos < i; ) {
                        if (r <= 0) {
                            var l = t.readVarint();
                            n = 7 & l,
                            r = l >> 3
                        }
                        if (r--,
                        1 === n || 2 === n)
                            o += t.readSVarint(),
                            s += t.readSVarint(),
                            1 === n && (e && a.push(e),
                            e = []),
                            e.push(new Bh(o,s));
                        else {
                            if (7 !== n)
                                throw new Error("unknown command " + n);
                            e && e.push(e[0].clone())
                        }
                    }
                    return e && a.push(e),
                    a
                }
                ,
                Fh.prototype.bbox = function() {
                    var t = this._pbf;
                    t.pos = this._geometry;
                    for (var e = t.readVarint() + t.pos, i = 1, n = 0, r = 0, o = 0, s = 1 / 0, a = -1 / 0, l = 1 / 0, c = -1 / 0; t.pos < e; ) {
                        if (n <= 0) {
                            var h = t.readVarint();
                            i = 7 & h,
                            n = h >> 3
                        }
                        if (n--,
                        1 === i || 2 === i)
                            (r += t.readSVarint()) < s && (s = r),
                            r > a && (a = r),
                            (o += t.readSVarint()) < l && (l = o),
                            o > c && (c = o);
                        else if (7 !== i)
                            throw new Error("unknown command " + i)
                    }
                    return [s, l, a, c]
                }
                ,
                Fh.prototype.toGeoJSON = function(t, e, i) {
                    var n, r, o = this.extent * Math.pow(2, i), s = this.extent * t, a = this.extent * e, l = this.loadGeometry(), c = Fh.types[this.type];
                    function h(t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e];
                            t[e] = [360 * (i.x + s) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (i.y + a) / o) * Math.PI / 180)) - 90]
                        }
                    }
                    switch (this.type) {
                    case 1:
                        var u = [];
                        for (n = 0; n < l.length; n++)
                            u[n] = l[n][0];
                        h(l = u);
                        break;
                    case 2:
                        for (n = 0; n < l.length; n++)
                            h(l[n]);
                        break;
                    case 3:
                        for (l = function(t) {
                            var e = t.length;
                            if (e <= 1)
                                return [t];
                            for (var i, n, r = [], o = 0; o < e; o++) {
                                var s = jh(t[o]);
                                0 !== s && (void 0 === n && (n = s < 0),
                                n === s < 0 ? (i && r.push(i),
                                i = [t[o]]) : i.push(t[o]))
                            }
                            return i && r.push(i),
                            r
                        }(l),
                        n = 0; n < l.length; n++)
                            for (r = 0; r < l[n].length; r++)
                                h(l[n][r])
                    }
                    1 === l.length ? l = l[0] : c = "Multi" + c;
                    var d = {
                        type: "Feature",
                        geometry: {
                            type: c,
                            coordinates: l
                        },
                        properties: this.properties
                    };
                    return "id"in this && (d.id = this.id),
                    d
                }
                ;
                var Uh = zh
                  , Vh = Gh;
                function Gh(t, e) {
                    this.version = 1,
                    this.name = null,
                    this.extent = 4096,
                    this.length = 0,
                    this._pbf = t,
                    this._keys = [],
                    this._values = [],
                    this._features = [],
                    t.readFields(Zh, this, e),
                    this.length = this._features.length
                }
                function Zh(t, e, i) {
                    15 === t ? e.version = i.readVarint() : 1 === t ? e.name = i.readString() : 5 === t ? e.extent = i.readVarint() : 2 === t ? e._features.push(i.pos) : 3 === t ? e._keys.push(i.readString()) : 4 === t && e._values.push(function(t) {
                        for (var e = null, i = t.readVarint() + t.pos; t.pos < i; ) {
                            var n = t.readVarint() >> 3;
                            e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null
                        }
                        return e
                    }(i))
                }
                Gh.prototype.feature = function(t) {
                    if (t < 0 || t >= this._features.length)
                        throw new Error("feature index out of bounds");
                    this._pbf.pos = this._features[t];
                    var e = this._pbf.readVarint() + this._pbf.pos;
                    return new Uh(this._pbf,e,this.extent,this._keys,this._values)
                }
                ;
                var qh = Vh;
                function Wh(t, e, i) {
                    if (3 === t) {
                        var n = new qh(i,i.readVarint() + i.pos);
                        n.length && (e[n.name] = n)
                    }
                }
                var Hh = Lh.VectorTile = function(t, e) {
                    this.layers = t.readFields(Wh, {}, e)
                }
                  , $h = Lh.VectorTileFeature = zh;
                function Xh(t, e, i, n) {
                    const r = []
                      , o = 0 === n ? (t, e, i, n, r, o) => {
                        t.push(new v(o,i + (o - e) / (n - e) * (r - i)))
                    }
                    : (t, e, i, n, r, o) => {
                        t.push(new v(e + (o - i) / (r - i) * (n - e),o))
                    }
                    ;
                    for (const s of t) {
                        const t = [];
                        for (const r of s) {
                            if (r.length <= 2)
                                continue;
                            const s = [];
                            for (let t = 0; t < r.length - 1; t++) {
                                const a = r[t].x
                                  , l = r[t].y
                                  , c = r[t + 1].x
                                  , h = r[t + 1].y
                                  , u = 0 === n ? a : l
                                  , d = 0 === n ? c : h;
                                u < e ? d > e && o(s, a, l, c, h, e) : u > i ? d < i && o(s, a, l, c, h, i) : s.push(r[t]),
                                d < e && u >= e && o(s, a, l, c, h, e),
                                d > i && u <= i && o(s, a, l, c, h, i)
                            }
                            let a = r[r.length - 1];
                            const l = 0 === n ? a.x : a.y;
                            l >= e && l <= i && s.push(a),
                            s.length && (a = s[s.length - 1],
                            s[0].x === a.x && s[0].y === a.y || s.push(s[0]),
                            t.push(s))
                        }
                        t.length && r.push(t)
                    }
                    return r
                }
                Lh.VectorTileLayer = Vh;
                const Yh = $h.types
                  , Kh = Math.pow(2, 13);
                function Jh(t, e, i, n, r, o, s, a) {
                    t.emplaceBack((e << 1) + s, (i << 1) + o, (Math.floor(n * Kh) << 1) + r, Math.round(a))
                }
                function Qh(t, e, i) {
                    const n = 16384;
                    t.emplaceBack(e.x, e.y, e.z, i[0] * n, i[1] * n, i[2] * n)
                }
                class tu {
                    constructor() {
                        this.acc = new v(0,0),
                        this.polyCount = []
                    }
                    startRing(t) {
                        this.currentPolyCount = {
                            edges: 0,
                            top: 0
                        },
                        this.polyCount.push(this.currentPolyCount),
                        this.min || (this.min = new v(t.x,t.y),
                        this.max = new v(t.x,t.y))
                    }
                    append(t, e) {
                        this.currentPolyCount.edges++,
                        this.acc._add(t);
                        const i = this.min
                          , n = this.max;
                        t.x < i.x ? i.x = t.x : t.x > n.x && (n.x = t.x),
                        t.y < i.y ? i.y = t.y : t.y > n.y && (n.y = t.y),
                        ((0 === t.x || t.x === la) && t.x === e.x) != ((0 === t.y || t.y === la) && t.y === e.y) && this.processBorderOverlap(t, e),
                        e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Oi(e.y, t.y, (0 - e.x) / (t.x - e.x))),
                        e.x > la != t.x > la && this.addBorderIntersection(1, Oi(e.y, t.y, (la - e.x) / (t.x - e.x))),
                        e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Oi(e.x, t.x, (0 - e.y) / (t.y - e.y))),
                        e.y > la != t.y > la && this.addBorderIntersection(3, Oi(e.x, t.x, (la - e.y) / (t.y - e.y)))
                    }
                    addBorderIntersection(t, e) {
                        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
                        const i = this.borders[t];
                        e < i[0] && (i[0] = e),
                        e > i[1] && (i[1] = e)
                    }
                    processBorderOverlap(t, e) {
                        if (t.x === e.x) {
                            if (t.y === e.y)
                                return;
                            const i = 0 === t.x ? 0 : 1;
                            this.addBorderIntersection(i, e.y),
                            this.addBorderIntersection(i, t.y)
                        } else {
                            const i = 0 === t.y ? 2 : 3;
                            this.addBorderIntersection(i, e.x),
                            this.addBorderIntersection(i, t.x)
                        }
                    }
                    centroid() {
                        const t = this.polyCount.reduce(( (t, e) => t + e.edges), 0);
                        return 0 !== t ? this.acc.div(t)._round() : new v(0,0)
                    }
                    span() {
                        return new v(this.max.x - this.min.x,this.max.y - this.min.y)
                    }
                    intersectsCount() {
                        return this.borders.reduce(( (t, e) => t + +(e[0] !== Number.MAX_VALUE)), 0)
                    }
                }
                class eu {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.canonical = t.canonical,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((t => t.id)),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.edgeRadius = 0,
                        this.projection = t.projection,
                        this.layoutVertexArray = new Zo,
                        this.centroidVertexArray = new Es,
                        this.indexArray = new rs,
                        this.programConfigurations = new Ks(t.layers,t.zoom),
                        this.segments = new aa,
                        this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                        this.enableTerrain = t.enableTerrain
                    }
                    populate(t, e, i, n) {
                        this.features = [],
                        this.hasPattern = Ch("fill-extrusion", this.layers, e),
                        this.featuresOnBorder = [],
                        this.borders = [[], [], [], []],
                        this.borderDoneWithNeighborZ = [-1, -1, -1, -1],
                        this.tileToMeter = function(t) {
                            const e = Math.exp(Math.PI * (1 - t.y / (1 << t.z) * 2));
                            return 80150034 * e / (e * e + 1) / la / (1 << t.z)
                        }(i),
                        this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter;
                        for (const {feature: r, id: o, index: s, sourceLayerIndex: a} of t) {
                            const t = this.layers[0]._featureFilter.needGeometry
                              , l = lc(r, t);
                            if (!this.layers[0]._featureFilter.filter(new Eo(this.zoom), l, i))
                                continue;
                            const c = {
                                id: o,
                                sourceLayerIndex: a,
                                index: s,
                                geometry: t ? l.geometry : ac(r, i, n),
                                properties: r.properties,
                                type: r.type,
                                patterns: {}
                            }
                              , h = this.layoutVertexArray.length;
                            this.hasPattern ? this.features.push(Ah("fill-extrusion", this.layers, c, this.zoom, e)) : this.addFeature(c, c.geometry, s, i, {}, e.availableImages, n),
                            e.featureIndex.insert(r, c.geometry, s, a, this.index, h)
                        }
                        this.sortBorders()
                    }
                    addFeatures(t, e, i, n, r) {
                        for (const t of this.features) {
                            const {geometry: o} = t;
                            this.addFeature(t, o, t.index, e, i, n, r)
                        }
                        this.sortBorders()
                    }
                    update(t, e, i, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, n)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Dh),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Rh.members, !0))),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    uploadCentroid(t) {
                        0 !== this.centroidVertexArray.length && (this.centroidVertexBuffer ? this.needsCentroidUpdate && this.centroidVertexBuffer.updateData(this.centroidVertexArray) : this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Oh.members, !0),
                        this.needsCentroidUpdate = !1)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(),
                        this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(t, e, i, n, r, o, s) {
                        const a = [new v(0,0), new v(la,la)]
                          , l = s.projection
                          , c = "globe" === l.name
                          , h = this.enableTerrain && !c ? new tu : null
                          , u = "Polygon" === Yh[t.type];
                        c && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Xo);
                        const d = Th(e, 500);
                        for (let t = d.length - 1; t >= 0; t--) {
                            const e = d[t];
                            (0 === e.length || (f = e[0]).every((t => t.x <= 0)) || f.every((t => t.x >= la)) || f.every((t => t.y <= 0)) || f.every((t => t.y >= la))) && d.splice(t, 1)
                        }
                        var f;
                        let p;
                        if (c)
                            p = cu(d, a, n);
                        else {
                            p = [];
                            for (const t of d)
                                p.push({
                                    polygon: t,
                                    bounds: a
                                })
                        }
                        const m = u ? this.edgeRadius : 0;
                        for (const {polygon: t, bounds: e} of p) {
                            let i = 0
                              , r = 0;
                            for (const e of t)
                                u && !e[0].equals(e[e.length - 1]) && e.push(e[0]),
                                r += u ? e.length - 1 : e.length;
                            const o = this.segments.prepareSegment((u ? 5 : 4) * r, this.layoutVertexArray, this.indexArray);
                            if (u) {
                                const e = []
                                  , r = [];
                                i = o.vertexLength;
                                for (const i of t) {
                                    let s, a;
                                    i.length && i !== t[0] && r.push(e.length / 2),
                                    s = i[1].sub(i[0])._perp()._unit();
                                    for (let t = 1; t < i.length; t++) {
                                        const r = i[t]
                                          , h = i[t === i.length - 1 ? 1 : t + 1];
                                        let {x: u, y: d} = r;
                                        if (m) {
                                            a = h.sub(r)._perp()._unit();
                                            const t = s.add(a)._unit()
                                              , e = m * Math.min(4, 1 / (s.x * t.x + s.y * t.y));
                                            u += e * t.x,
                                            d += e * t.y,
                                            s = a
                                        }
                                        Jh(this.layoutVertexArray, u, d, 0, 0, 1, 1, 0),
                                        o.vertexLength++,
                                        e.push(r.x, r.y),
                                        c && Qh(this.layoutVertexExtArray, l.projectTilePoint(u, d, n), l.upVector(n, u, d))
                                    }
                                }
                                const s = vh(e, r);
                                for (let t = 0; t < s.length; t += 3)
                                    this.indexArray.emplaceBack(i + s[t], i + s[t + 2], i + s[t + 1]),
                                    o.primitiveLength++
                            }
                            for (const r of t) {
                                h && r.length && h.startRing(r[0]);
                                let t, s, a, d = r.length > 4 && su(r[r.length - 2], r[0], r[1]), f = m ? nu(r[r.length - 2], r[0], r[1], m) : 0;
                                s = r[1].sub(r[0])._perp()._unit();
                                let p = !0;
                                for (let g = 1, _ = 0; g < r.length; g++) {
                                    let y = r[g - 1]
                                      , v = r[g];
                                    const x = r[g === r.length - 1 ? 1 : g + 1];
                                    if (h && u && h.currentPolyCount.top++,
                                    ou(v, y, e)) {
                                        m && (s = x.sub(v)._perp()._unit(),
                                        p = !p);
                                        continue
                                    }
                                    h && h.append(v, y);
                                    const b = v.sub(y)._perp()
                                      , w = b.x / (Math.abs(b.x) + Math.abs(b.y))
                                      , E = b.y > 0 ? 1 : 0
                                      , T = y.dist(v);
                                    if (_ + T > 32768 && (_ = 0),
                                    m) {
                                        a = x.sub(v)._perp()._unit();
                                        let t = ru(y, v, x, iu(s, a), m);
                                        isNaN(t) && (t = 0);
                                        const e = v.sub(y)._unit();
                                        y = y.add(e.mult(f))._round(),
                                        v = v.add(e.mult(-t))._round(),
                                        f = t,
                                        s = a
                                    }
                                    const S = o.vertexLength
                                      , C = r.length > 4 && su(y, v, x);
                                    let A = au(_, d, p);
                                    if (Jh(this.layoutVertexArray, y.x, y.y, w, E, 0, 0, A),
                                    Jh(this.layoutVertexArray, y.x, y.y, w, E, 0, 1, A),
                                    _ += T,
                                    A = au(_, C, !p),
                                    d = C,
                                    Jh(this.layoutVertexArray, v.x, v.y, w, E, 0, 0, A),
                                    Jh(this.layoutVertexArray, v.x, v.y, w, E, 0, 1, A),
                                    o.vertexLength += 4,
                                    this.indexArray.emplaceBack(S + 0, S + 1, S + 2),
                                    this.indexArray.emplaceBack(S + 1, S + 3, S + 2),
                                    o.primitiveLength += 2,
                                    m) {
                                        const n = i + (1 === g ? r.length - 2 : g - 2)
                                          , s = 1 === g ? i : n + 1;
                                        if (this.indexArray.emplaceBack(S + 1, n, S + 3),
                                        this.indexArray.emplaceBack(n, s, S + 3),
                                        o.primitiveLength += 2,
                                        void 0 === t && (t = S),
                                        !ou(x, r[g], e)) {
                                            const e = g === r.length - 1 ? t : o.vertexLength;
                                            this.indexArray.emplaceBack(S + 2, S + 3, e),
                                            this.indexArray.emplaceBack(S + 3, e + 1, e),
                                            this.indexArray.emplaceBack(S + 3, s, e + 1),
                                            o.primitiveLength += 3
                                        }
                                        p = !p
                                    }
                                    if (c) {
                                        const t = this.layoutVertexExtArray
                                          , e = l.projectTilePoint(y.x, y.y, n)
                                          , i = l.projectTilePoint(v.x, v.y, n)
                                          , r = l.upVector(n, y.x, y.y)
                                          , o = l.upVector(n, v.x, v.y);
                                        Qh(t, e, r),
                                        Qh(t, e, r),
                                        Qh(t, i, o),
                                        Qh(t, i, o)
                                    }
                                }
                                u && (i += r.length - 1)
                            }
                        }
                        if (h && h.polyCount.length > 0) {
                            if (h.borders) {
                                h.vertexArrayOffset = this.centroidVertexArray.length;
                                const t = h.borders
                                  , e = this.featuresOnBorder.push(h) - 1;
                                for (let i = 0; i < 4; i++)
                                    t[i][0] !== Number.MAX_VALUE && this.borders[i].push(e)
                            }
                            this.encodeCentroid(h.borders ? void 0 : h.centroid(), h)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, r, o, n)
                    }
                    sortBorders() {
                        for (let t = 0; t < 4; t++)
                            this.borders[t].sort(( (e, i) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[i].borders[t][0]))
                    }
                    encodeCentroid(t, e, i=!0) {
                        let n, r;
                        if (t)
                            if (0 !== t.y) {
                                const i = e.span()._mult(this.tileToMeter);
                                n = (Math.max(t.x, 1) << 3) + Math.min(7, Math.round(i.x / 10)),
                                r = (Math.max(t.y, 1) << 3) + Math.min(7, Math.round(i.y / 10))
                            } else
                                n = Math.ceil(7 * (t.x + 450)),
                                r = 0;
                        else
                            n = 0,
                            r = +i;
                        let o = i ? this.centroidVertexArray.length : e.vertexArrayOffset;
                        for (const t of e.polyCount) {
                            i && this.centroidVertexArray.resize(this.centroidVertexArray.length + 4 * t.edges + t.top);
                            for (let e = 0; e < t.top; e++)
                                this.centroidVertexArray.emplace(o++, n, r);
                            for (let e = 0; e < 2 * t.edges; e++)
                                this.centroidVertexArray.emplace(o++, 0, r),
                                this.centroidVertexArray.emplace(o++, n, r)
                        }
                    }
                }
                function iu(t, e) {
                    const i = t.add(e)._unit();
                    return t.x * i.x + t.y * i.y
                }
                function nu(t, e, i, n) {
                    const r = e.sub(t)._perp()._unit()
                      , o = i.sub(e)._perp()._unit();
                    return ru(t, e, i, iu(r, o), n)
                }
                function ru(t, e, i, n, r) {
                    const o = Math.sqrt(1 - n * n);
                    return Math.min(t.dist(e) / 3, e.dist(i) / 3, r * o / n)
                }
                function ou(t, e, i) {
                    return t.x < i[0].x && e.x < i[0].x || t.x > i[1].x && e.x > i[1].x || t.y < i[0].y && e.y < i[0].y || t.y > i[1].y && e.y > i[1].y
                }
                function su(t, e, i) {
                    if (t.x < 0 || t.x >= la || e.x < 0 || e.x >= la || i.x < 0 || i.x >= la)
                        return !1;
                    const n = i.sub(e)
                      , r = n.perp()
                      , o = t.sub(e);
                    return (n.x * o.x + n.y * o.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (o.x * o.x + o.y * o.y)) > -.866 && r.x * o.x + r.y * o.y < 0
                }
                function au(t, e, i) {
                    const n = e ? 2 | t : -3 & t;
                    return i ? 1 | n : -2 & n
                }
                function lu() {
                    const t = Math.PI / 32
                      , e = Math.tan(t)
                      , i = jl;
                    return i * Math.sqrt(1 + 2 * e * e) - i
                }
                function cu(t, e, i) {
                    const n = 1 << i.z
                      , r = $l(i.x / n)
                      , o = $l((i.x + 1) / n)
                      , s = Xl(i.y / n)
                      , a = Xl((i.y + 1) / n);
                    return function(t, e, i, n, r=0, o) {
                        const s = [];
                        if (!t.length || !i || !n)
                            return s;
                        const a = (t, e) => {
                            for (const i of t)
                                s.push({
                                    polygon: i,
                                    bounds: e
                                })
                        }
                          , l = Math.ceil(Math.log2(i))
                          , c = Math.ceil(Math.log2(n))
                          , h = l - c
                          , u = [];
                        for (let t = 0; t < Math.abs(h); t++)
                            u.push(h > 0 ? 0 : 1);
                        for (let t = 0; t < Math.min(l, c); t++)
                            u.push(0),
                            u.push(1);
                        let d = t;
                        if (d = Xh(d, e[0].y - r, e[1].y + r, 1),
                        d = Xh(d, e[0].x - r, e[1].x + r, 0),
                        !d.length)
                            return s;
                        const f = [];
                        for (u.length ? f.push({
                            polygons: d,
                            bounds: e,
                            depth: 0
                        }) : a(d, e); f.length; ) {
                            const t = f.pop()
                              , e = t.depth
                              , i = u[e]
                              , n = t.bounds[0]
                              , s = t.bounds[1]
                              , l = 0 === i ? n.x : n.y
                              , c = 0 === i ? s.x : s.y
                              , h = o ? o(i, l, c) : .5 * (l + c)
                              , d = Xh(t.polygons, l - r, h + r, i)
                              , p = Xh(t.polygons, h - r, c + r, i);
                            if (d.length) {
                                const t = [n, new v(0 === i ? h : s.x,1 === i ? h : s.y)];
                                u.length > e + 1 ? f.push({
                                    polygons: d,
                                    bounds: t,
                                    depth: e + 1
                                }) : a(d, t)
                            }
                            if (p.length) {
                                const t = [new v(0 === i ? h : n.x,1 === i ? h : n.y), s];
                                u.length > e + 1 ? f.push({
                                    polygons: p,
                                    bounds: t,
                                    depth: e + 1
                                }) : a(p, t)
                            }
                        }
                        return s
                    }(t, e, Math.ceil((o - r) / 11.25), Math.ceil((s - a) / 11.25), 1, ( (t, e, r) => {
                        if (0 === t)
                            return .5 * (e + r);
                        {
                            const t = Xl((i.y + e / la) / n);
                            return (Wl(.5 * (Xl((i.y + r / la) / n) + t)) * n - i.y) * la
                        }
                    }
                    ))
                }
                Yr(eu, "FillExtrusionBucket", {
                    omit: ["layers", "features"]
                }),
                Yr(tu, "PartMetadata");
                const hu = new Lo({
                    "fill-extrusion-edge-radius": new Oo(ee["layout_fill-extrusion"]["fill-extrusion-edge-radius"])
                });
                var uu = {
                    paint: new Lo({
                        "fill-extrusion-opacity": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                        "fill-extrusion-color": new Ro(ee["paint_fill-extrusion"]["fill-extrusion-color"]),
                        "fill-extrusion-translate": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-translate"]),
                        "fill-extrusion-translate-anchor": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                        "fill-extrusion-pattern": new Ro(ee["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                        "fill-extrusion-height": new Ro(ee["paint_fill-extrusion"]["fill-extrusion-height"]),
                        "fill-extrusion-base": new Ro(ee["paint_fill-extrusion"]["fill-extrusion-base"]),
                        "fill-extrusion-vertical-gradient": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]),
                        "fill-extrusion-ambient-occlusion-intensity": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]),
                        "fill-extrusion-ambient-occlusion-radius": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]),
                        "fill-extrusion-rounded-roof": new Oo(ee["paint_fill-extrusion"]["fill-extrusion-rounded-roof"])
                    }),
                    layout: hu
                };
                function du(t, e, i) {
                    var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, i);
                    return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2]
                }
                class fu {
                    constructor(t, e, i) {
                        this.z = t,
                        this.x = e,
                        this.y = i,
                        this.key = gu(0, t, t, e, i)
                    }
                    equals(t) {
                        return this.z === t.z && this.x === t.x && this.y === t.y
                    }
                    url(t, e) {
                        const i = function(t, e, i) {
                            var n = du(256 * t, 256 * (e = Math.pow(2, i) - e - 1), i)
                              , r = du(256 * (t + 1), 256 * (e + 1), i);
                            return n[0] + "," + n[1] + "," + r[0] + "," + r[1]
                        }(this.x, this.y, this.z)
                          , n = function(t, e, i) {
                            let n, r = "";
                            for (let o = t; o > 0; o--)
                                n = 1 << o - 1,
                                r += (e & n ? 1 : 0) + (i & n ? 2 : 0);
                            return r
                        }(this.z, this.x, this.y);
                        return t[(this.x + this.y) % t.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n).replace("{bbox-epsg-3857}", i)
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`
                    }
                }
                class pu {
                    constructor(t, e) {
                        this.wrap = t,
                        this.canonical = e,
                        this.key = gu(t, e.z, e.z, e.x, e.y)
                    }
                }
                class mu {
                    constructor(t, e, i, n, r) {
                        this.overscaledZ = t,
                        this.wrap = e,
                        this.canonical = new fu(i,+n,+r),
                        this.key = 0 === e && t === i ? this.canonical.key : gu(e, t, i, n, r)
                    }
                    equals(t) {
                        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
                    }
                    scaledTo(t) {
                        const e = this.canonical.z - t;
                        return t > this.canonical.z ? new mu(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new mu(t,this.wrap,t,this.canonical.x >> e,this.canonical.y >> e)
                    }
                    calculateScaledKey(t, e=!0) {
                        if (this.overscaledZ === t && e)
                            return this.key;
                        if (t > this.canonical.z)
                            return gu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);
                        {
                            const i = this.canonical.z - t;
                            return gu(this.wrap * +e, t, t, this.canonical.x >> i, this.canonical.y >> i)
                        }
                    }
                    isChildOf(t) {
                        if (t.wrap !== this.wrap)
                            return !1;
                        const e = this.canonical.z - t.canonical.z;
                        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e
                    }
                    children(t) {
                        if (this.overscaledZ >= t)
                            return [new mu(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const e = this.canonical.z + 1
                          , i = 2 * this.canonical.x
                          , n = 2 * this.canonical.y;
                        return [new mu(e,this.wrap,e,i,n), new mu(e,this.wrap,e,i + 1,n), new mu(e,this.wrap,e,i,n + 1), new mu(e,this.wrap,e,i + 1,n + 1)]
                    }
                    isLessThan(t) {
                        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
                    }
                    wrapped() {
                        return new mu(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(t) {
                        return new mu(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new pu(this.wrap,this.canonical)
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                    }
                }
                function gu(t, e, i, n, r) {
                    const o = 1 << Math.min(i, 22);
                    let s = o * (r % o) + n % o;
                    return t && i < 22 && (s += o * o * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - i)))),
                    16 * (32 * s + i) + (e - i)
                }
                Yr(fu, "CanonicalTileID"),
                Yr(mu, "OverscaledTileID", {
                    omit: ["projMatrix"]
                });
                class _u extends v {
                    constructor(t, e, i) {
                        super(t, e),
                        this.z = i
                    }
                }
                function yu(t, e) {
                    return t.x * e.x + t.y * e.y
                }
                function vu(t, e) {
                    if (1 === t.length) {
                        let i = 0;
                        const n = e[i++];
                        let r;
                        for (; !r || n.equals(r); )
                            if (r = e[i++],
                            !r)
                                return 1 / 0;
                        for (; i < e.length; i++) {
                            const o = e[i]
                              , s = t[0]
                              , a = r.sub(n)
                              , l = o.sub(n)
                              , c = s.sub(n)
                              , h = yu(a, a)
                              , u = yu(a, l)
                              , d = yu(l, l)
                              , f = yu(c, a)
                              , p = yu(c, l)
                              , m = h * d - u * u
                              , g = (d * f - u * p) / m
                              , _ = (h * p - u * f) / m
                              , y = n.z * (1 - g - _) + r.z * g + o.z * _;
                            if (isFinite(y))
                                return y
                        }
                        return 1 / 0
                    }
                    {
                        let t = 1 / 0;
                        for (const i of e)
                            t = Math.min(t, i.z);
                        return t
                    }
                }
                function xu(t, e, i, n, r, o, s, a) {
                    const l = s * r.getElevationAt(t, e, !0, !0)
                      , c = 0 !== o[0]
                      , h = c ? 0 === o[1] ? s * (o[0] / 7 - 450) : s * function(t, e, i) {
                        const n = Math.floor(e[0] / 8)
                          , r = Math.floor(e[1] / 8)
                          , o = 10 * (e[0] - 8 * n)
                          , s = 10 * (e[1] - 8 * r)
                          , a = t.getElevationAt(n, r, !0, !0)
                          , l = t.getMeterToDEM(i)
                          , c = Math.floor(.5 * (o * l - 1))
                          , h = Math.floor(.5 * (s * l - 1))
                          , u = t.tileCoordToPixel(n, r)
                          , d = 2 * c + 1
                          , f = 2 * h + 1
                          , p = function(t, e, i, n, r) {
                            return [t.getElevationAtPixel(e, i, !0), t.getElevationAtPixel(e + r, i, !0), t.getElevationAtPixel(e, i + r, !0), t.getElevationAtPixel(e + n, i + r, !0)]
                        }(t, u.x - c, u.y - h, d, f)
                          , m = Math.abs(p[0] - p[1])
                          , g = Math.abs(p[2] - p[3])
                          , _ = Math.abs(p[0] - p[2]) + Math.abs(p[1] - p[3])
                          , y = Math.min(.25, .5 * l * (m + g) / d)
                          , v = Math.min(.25, .5 * l * _ / f);
                        return a + Math.max(y * o, v * s)
                    }(r, o, a) : l;
                    return {
                        base: l + (0 === i) ? -1 : i,
                        top: c ? Math.max(h + n, l + i + 2) : l + n
                    }
                }
                const bu = jo([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }, {
                    name: "a_linesofar",
                    components: 1,
                    type: "Float32"
                }], 4)
                  , {members: wu} = bu
                  , Eu = jo([{
                    name: "a_packed",
                    components: 4,
                    type: "Float32"
                }])
                  , {members: Tu} = Eu
                  , Su = $h.types
                  , Cu = Math.cos(Math.PI / 180 * 37.5);
                class Au {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((t => t.id)),
                        this.index = t.index,
                        this.projection = t.projection,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach((t => {
                            this.gradients[t.id] = {}
                        }
                        )),
                        this.layoutVertexArray = new qo,
                        this.layoutVertexArray2 = new Wo,
                        this.indexArray = new rs,
                        this.programConfigurations = new Ks(t.layers,t.zoom),
                        this.segments = new aa,
                        this.maxLineLength = 0,
                        this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id))
                    }
                    populate(t, e, i, n) {
                        this.hasPattern = Ch("line", this.layers, e);
                        const r = this.layers[0].layout.get("line-sort-key")
                          , o = [];
                        for (const {feature: e, id: s, index: a, sourceLayerIndex: l} of t) {
                            const t = this.layers[0]._featureFilter.needGeometry
                              , c = lc(e, t);
                            if (!this.layers[0]._featureFilter.filter(new Eo(this.zoom), c, i))
                                continue;
                            const h = r ? r.evaluate(c, {}, i) : void 0
                              , u = {
                                id: s,
                                properties: e.properties,
                                type: e.type,
                                sourceLayerIndex: l,
                                index: a,
                                geometry: t ? c.geometry : ac(e, i, n),
                                patterns: {},
                                sortKey: h
                            };
                            o.push(u)
                        }
                        r && o.sort(( (t, e) => t.sortKey - e.sortKey));
                        const {lineAtlas: s, featureIndex: a} = e
                          , l = this.addConstantDashes(s);
                        for (const n of o) {
                            const {geometry: r, index: o, sourceLayerIndex: c} = n;
                            if (l && this.addFeatureDashes(n, s),
                            this.hasPattern) {
                                const t = Ah("line", this.layers, n, this.zoom, e);
                                this.patternFeatures.push(t)
                            } else
                                this.addFeature(n, r, o, i, s.positions, e.availableImages);
                            a.insert(t[o].feature, r, o, c, this.index)
                        }
                    }
                    addConstantDashes(t) {
                        let e = !1;
                        for (const i of this.layers) {
                            const n = i.paint.get("line-dasharray").value
                              , r = i.layout.get("line-cap").value;
                            if ("constant" !== n.kind || "constant" !== r.kind)
                                e = !0;
                            else {
                                const e = r.value
                                  , i = n.value;
                                if (!i)
                                    continue;
                                t.addDash(i, e)
                            }
                        }
                        return e
                    }
                    addFeatureDashes(t, e) {
                        const i = this.zoom;
                        for (const n of this.layers) {
                            const r = n.paint.get("line-dasharray").value
                              , o = n.layout.get("line-cap").value;
                            if ("constant" === r.kind && "constant" === o.kind)
                                continue;
                            let s, a;
                            if ("constant" === r.kind) {
                                if (s = r.value,
                                !s)
                                    continue
                            } else
                                s = r.evaluate({
                                    zoom: i
                                }, t);
                            a = "constant" === o.kind ? o.value : o.evaluate({
                                zoom: i
                            }, t),
                            e.addDash(s, a),
                            t.patterns[n.id] = e.getKey(s, a)
                        }
                    }
                    update(t, e, i, n) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, e, this.stateDependentLayers, i, n)
                    }
                    addFeatures(t, e, i, n, r) {
                        for (const t of this.patternFeatures)
                            this.addFeature(t, t.geometry, t.index, e, i, n)
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Tu)),
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, wu),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(t) {
                        if (t.properties && t.properties.hasOwnProperty("mapbox_clip_start") && t.properties.hasOwnProperty("mapbox_clip_end"))
                            return {
                                start: +t.properties.mapbox_clip_start,
                                end: +t.properties.mapbox_clip_end
                            }
                    }
                    addFeature(t, e, i, n, r, o) {
                        const s = this.layers[0].layout
                          , a = s.get("line-join").evaluate(t, {})
                          , l = s.get("line-cap").evaluate(t, {})
                          , c = s.get("line-miter-limit")
                          , h = s.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(t);
                        for (const i of e)
                            this.addLine(i, t, a, l, c, h);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, i, r, o, n)
                    }
                    addLine(t, e, i, n, r, o) {
                        if (this.distance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        this.lineSoFar = 0,
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let e = 0; e < t.length - 1; e++)
                                this.totalDistance += t[e].dist(t[e + 1]);
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const s = "Polygon" === Su[e.type];
                        let a = t.length;
                        for (; a >= 2 && t[a - 1].equals(t[a - 2]); )
                            a--;
                        let l = 0;
                        for (; l < a - 1 && t[l].equals(t[l + 1]); )
                            l++;
                        if (a < (s ? 3 : 2))
                            return;
                        "bevel" === i && (r = 1.05);
                        const c = this.overscaling <= 16 ? 15 * la / (512 * this.overscaling) : 0
                          , h = this.segments.prepareSegment(10 * a, this.layoutVertexArray, this.indexArray);
                        let u, d, f, p, m;
                        this.e1 = this.e2 = -1,
                        s && (u = t[a - 2],
                        m = t[l].sub(u)._unit()._perp());
                        for (let e = l; e < a; e++) {
                            if (f = e === a - 1 ? s ? t[l + 1] : void 0 : t[e + 1],
                            f && t[e].equals(f))
                                continue;
                            m && (p = m),
                            u && (d = u),
                            u = t[e],
                            m = f ? f.sub(u)._unit()._perp() : p,
                            p = p || m;
                            let g = p.add(m);
                            0 === g.x && 0 === g.y || g._unit();
                            const _ = p.x * m.x + p.y * m.y
                              , y = g.x * m.x + g.y * m.y
                              , v = 0 !== y ? 1 / y : 1 / 0
                              , x = 2 * Math.sqrt(2 - 2 * y)
                              , b = y < Cu && d && f
                              , w = p.x * m.y - p.y * m.x > 0;
                            if (b && e > l) {
                                const t = u.dist(d);
                                if (t > 2 * c) {
                                    const e = u.sub(u.sub(d)._mult(c / t)._round());
                                    this.updateDistance(d, e),
                                    this.addCurrentVertex(e, p, 0, 0, h),
                                    d = e
                                }
                            }
                            const E = d && f;
                            let T = E ? i : s ? "butt" : n;
                            if (E && "round" === T && (v < o ? T = "miter" : v <= 2 && (T = "fakeround")),
                            "miter" === T && v > r && (T = "bevel"),
                            "bevel" === T && (v > 2 && (T = "flipbevel"),
                            v < r && (T = "miter")),
                            d && this.updateDistance(d, u),
                            "miter" === T)
                                g._mult(v),
                                this.addCurrentVertex(u, g, 0, 0, h);
                            else if ("flipbevel" === T) {
                                if (v > 100)
                                    g = m.mult(-1);
                                else {
                                    const t = v * p.add(m).mag() / p.sub(m).mag();
                                    g._perp()._mult(t * (w ? -1 : 1))
                                }
                                this.addCurrentVertex(u, g, 0, 0, h),
                                this.addCurrentVertex(u, g.mult(-1), 0, 0, h)
                            } else if ("bevel" === T || "fakeround" === T) {
                                const t = -Math.sqrt(v * v - 1)
                                  , e = w ? t : 0
                                  , i = w ? 0 : t;
                                if (d && this.addCurrentVertex(u, p, e, i, h),
                                "fakeround" === T) {
                                    const t = Math.round(180 * x / Math.PI / 20);
                                    for (let e = 1; e < t; e++) {
                                        let i = e / t;
                                        if (.5 !== i) {
                                            const t = i - .5;
                                            i += i * t * (i - 1) * ((1.0904 + _ * (_ * (3.55645 - 1.43519 * _) - 3.2452)) * t * t + (.848013 + _ * (.215638 * _ - 1.06021)))
                                        }
                                        const n = m.sub(p)._mult(i)._add(p)._unit()._mult(w ? -1 : 1);
                                        this.addHalfVertex(u, n.x, n.y, !1, w, 0, h)
                                    }
                                }
                                f && this.addCurrentVertex(u, m, -e, -i, h)
                            } else if ("butt" === T)
                                this.addCurrentVertex(u, g, 0, 0, h);
                            else if ("square" === T) {
                                const t = d ? 1 : -1;
                                d || this.addCurrentVertex(u, g, t, t, h),
                                this.addCurrentVertex(u, g, 0, 0, h),
                                d && this.addCurrentVertex(u, g, t, t, h)
                            } else
                                "round" === T && (d && (this.addCurrentVertex(u, p, 0, 0, h),
                                this.addCurrentVertex(u, p, 1, 1, h, !0)),
                                f && (this.addCurrentVertex(u, m, -1, -1, h, !0),
                                this.addCurrentVertex(u, m, 0, 0, h)));
                            if (b && e < a - 1) {
                                const t = u.dist(f);
                                if (t > 2 * c) {
                                    const e = u.add(f.sub(u)._mult(c / t)._round());
                                    this.updateDistance(u, e),
                                    this.addCurrentVertex(e, m, 0, 0, h),
                                    u = e
                                }
                            }
                        }
                    }
                    addCurrentVertex(t, e, i, n, r, o=!1) {
                        const s = e.y * n - e.x
                          , a = -e.y - e.x * n;
                        this.addHalfVertex(t, e.x + e.y * i, e.y - e.x * i, o, !1, i, r),
                        this.addHalfVertex(t, s, a, o, !0, -n, r)
                    }
                    addHalfVertex({x: t, y: e}, i, n, r, o, s, a) {
                        this.layoutVertexArray.emplaceBack((t << 1) + (r ? 1 : 0), (e << 1) + (o ? 1 : 0), Math.round(63 * i) + 128, Math.round(63 * n) + 128, 1 + (0 === s ? 0 : s < 0 ? -1 : 1), 0, this.lineSoFar),
                        this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
                        const l = a.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, l),
                        a.primitiveLength++),
                        o ? this.e2 = l : this.e1 = l
                    }
                    updateScaledDistance() {
                        if (this.lineClips) {
                            const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
                            this.scaledDistance = this.distance / this.totalDistance,
                            this.lineSoFar = t * this.lineClips.start + this.distance
                        } else
                            this.lineSoFar = this.distance
                    }
                    updateDistance(t, e) {
                        this.distance += t.dist(e),
                        this.updateScaledDistance()
                    }
                }
                Yr(Au, "LineBucket", {
                    omit: ["layers", "patternFeatures"]
                });
                const Iu = new Lo({
                    "line-cap": new Ro(ee.layout_line["line-cap"]),
                    "line-join": new Ro(ee.layout_line["line-join"]),
                    "line-miter-limit": new Oo(ee.layout_line["line-miter-limit"]),
                    "line-round-limit": new Oo(ee.layout_line["line-round-limit"]),
                    "line-sort-key": new Ro(ee.layout_line["line-sort-key"])
                });
                var Mu = {
                    paint: new Lo({
                        "line-opacity": new Ro(ee.paint_line["line-opacity"]),
                        "line-color": new Ro(ee.paint_line["line-color"]),
                        "line-translate": new Oo(ee.paint_line["line-translate"]),
                        "line-translate-anchor": new Oo(ee.paint_line["line-translate-anchor"]),
                        "line-width": new Ro(ee.paint_line["line-width"]),
                        "line-gap-width": new Ro(ee.paint_line["line-gap-width"]),
                        "line-offset": new Ro(ee.paint_line["line-offset"]),
                        "line-blur": new Ro(ee.paint_line["line-blur"]),
                        "line-dasharray": new Ro(ee.paint_line["line-dasharray"]),
                        "line-pattern": new Ro(ee.paint_line["line-pattern"]),
                        "line-gradient": new Do(ee.paint_line["line-gradient"]),
                        "line-trim-offset": new Oo(ee.paint_line["line-trim-offset"])
                    }),
                    layout: Iu
                };
                const Pu = new class extends Ro {
                    possiblyEvaluate(t, e) {
                        return e = new Eo(Math.floor(e.zoom),{
                            now: e.now,
                            fadeDuration: e.fadeDuration,
                            transition: e.transition
                        }),
                        super.possiblyEvaluate(t, e)
                    }
                    evaluate(t, e, i, n) {
                        return e = R({}, e, {
                            zoom: Math.floor(e.zoom)
                        }),
                        super.evaluate(t, e, i, n)
                    }
                }
                (Mu.paint.properties["line-width"].specification);
                function ku(t, e) {
                    return e > 0 ? e + 2 * t : t
                }
                Pu.useIntegerZoom = !0;
                const Ou = jo([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_tex_size",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , Ru = jo([{
                    name: "a_globe_anchor",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_globe_normal",
                    components: 3,
                    type: "Float32"
                }], 4)
                  , Du = jo([{
                    name: "a_projected_pos",
                    components: 4,
                    type: "Float32"
                }], 4);
                jo([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const Lu = jo([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }])
                  , Bu = jo([{
                    name: "a_size_scale",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_padding",
                    components: 2,
                    type: "Float32"
                }]);
                jo([{
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Int16",
                    name: "tileAnchorX"
                }, {
                    type: "Int16",
                    name: "tileAnchorY"
                }, {
                    type: "Float32",
                    name: "x1"
                }, {
                    type: "Float32",
                    name: "y1"
                }, {
                    type: "Float32",
                    name: "x2"
                }, {
                    type: "Float32",
                    name: "y2"
                }, {
                    type: "Int16",
                    name: "padding"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const zu = jo([{
                    name: "a_pos",
                    components: 3,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , Fu = jo([{
                    name: "a_pos_2f",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                jo([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                jo([{
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Float32",
                    name: "tileAnchorX"
                }, {
                    type: "Float32",
                    name: "tileAnchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }, {
                    type: "Uint8",
                    name: "flipState"
                }]),
                jo([{
                    type: "Int16",
                    name: "projectedAnchorX"
                }, {
                    type: "Int16",
                    name: "projectedAnchorY"
                }, {
                    type: "Int16",
                    name: "projectedAnchorZ"
                }, {
                    type: "Float32",
                    name: "tileAnchorX"
                }, {
                    type: "Float32",
                    name: "tileAnchorY"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }]),
                jo([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                jo([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }]);
                var Nu = 24;
                const ju = 128;
                function Uu(t, e) {
                    const {expression: i} = e;
                    if ("constant" === i.kind)
                        return {
                            kind: "constant",
                            layoutSize: i.evaluate(new Eo(t + 1))
                        };
                    if ("source" === i.kind)
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: e, interpolationType: n} = i;
                        let r = 0;
                        for (; r < e.length && e[r] <= t; )
                            r++;
                        r = Math.max(0, r - 1);
                        let o = r;
                        for (; o < e.length && e[o] < t + 1; )
                            o++;
                        o = Math.min(e.length - 1, o);
                        const s = e[r]
                          , a = e[o];
                        return "composite" === i.kind ? {
                            kind: "composite",
                            minZoom: s,
                            maxZoom: a,
                            interpolationType: n
                        } : {
                            kind: "camera",
                            minZoom: s,
                            maxZoom: a,
                            minSize: i.evaluate(new Eo(s)),
                            maxSize: i.evaluate(new Eo(a)),
                            interpolationType: n
                        }
                    }
                }
                function Vu(t, {uSize: e, uSizeT: i}, {lowerSize: n, upperSize: r}) {
                    return "source" === t.kind ? n / ju : "composite" === t.kind ? Oi(n / ju, r / ju, i) : e
                }
                function Gu(t, e) {
                    let i = 0
                      , n = 0;
                    if ("constant" === t.kind)
                        n = t.layoutSize;
                    else if ("source" !== t.kind) {
                        const {interpolationType: r, minZoom: o, maxZoom: s} = t
                          , a = r ? I(tn.interpolationFactor(r, e, o, s), 0, 1) : 0;
                        "camera" === t.kind ? n = Oi(t.minSize, t.maxSize, a) : i = a
                    }
                    return {
                        uSizeT: i,
                        uSize: n
                    }
                }
                var Zu = Object.freeze({
                    __proto__: null,
                    SIZE_PACK_FACTOR: ju,
                    evaluateSizeForFeature: Vu,
                    evaluateSizeForZoom: Gu,
                    getSizeData: Uu
                });
                function qu(t, e, i) {
                    return t.sections.forEach((t => {
                        t.text = function(t, e, i) {
                            const n = e.layout.get("text-transform").evaluate(i, {});
                            return "uppercase" === n ? t = t.toLocaleUpperCase() : "lowercase" === n && (t = t.toLocaleLowerCase()),
                            wo.applyArabicShaping && (t = wo.applyArabicShaping(t)),
                            t
                        }(t.text, e, i)
                    }
                    )),
                    t
                }
                const Wu = {
                    "!": "",
                    "#": "",
                    $: "",
                    "%": "",
                    "&": "",
                    "(": "",
                    ")": "",
                    "*": "",
                    "+": "",
                    ",": "",
                    "-": "",
                    ".": "",
                    "/": "",
                    ":": "",
                    ";": "",
                    "<": "",
                    "=": "",
                    ">": "",
                    "?": "",
                    "@": "",
                    "[": "",
                    "\\": "",
                    "]": "",
                    "^": "",
                    _: "",
                    "`": "",
                    "{": "",
                    "|": "",
                    "}": "",
                    "~": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": "",
                    "": ""
                };
                function Hu(t) {
                    return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t
                }
                function $u(t) {
                    return "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t || "" === t
                }
                var Xu = Ju
                  , Yu = function(t, e, i, n, r) {
                    var o, s, a = 8 * r - n - 1, l = (1 << a) - 1, c = l >> 1, h = -7, u = i ? r - 1 : 0, d = i ? -1 : 1, f = t[e + u];
                    for (u += d,
                    o = f & (1 << -h) - 1,
                    f >>= -h,
                    h += a; h > 0; o = 256 * o + t[e + u],
                    u += d,
                    h -= 8)
                        ;
                    for (s = o & (1 << -h) - 1,
                    o >>= -h,
                    h += n; h > 0; s = 256 * s + t[e + u],
                    u += d,
                    h -= 8)
                        ;
                    if (0 === o)
                        o = 1 - c;
                    else {
                        if (o === l)
                            return s ? NaN : 1 / 0 * (f ? -1 : 1);
                        s += Math.pow(2, n),
                        o -= c
                    }
                    return (f ? -1 : 1) * s * Math.pow(2, o - n)
                }
                  , Ku = function(t, e, i, n, r, o) {
                    var s, a, l, c = 8 * o - r - 1, h = (1 << c) - 1, u = h >> 1, d = 23 === r ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = n ? 0 : o - 1, p = n ? 1 : -1, m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
                    for (e = Math.abs(e),
                    isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0,
                    s = h) : (s = Math.floor(Math.log(e) / Math.LN2),
                    e * (l = Math.pow(2, -s)) < 1 && (s--,
                    l *= 2),
                    (e += s + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 && (s++,
                    l /= 2),
                    s + u >= h ? (a = 0,
                    s = h) : s + u >= 1 ? (a = (e * l - 1) * Math.pow(2, r),
                    s += u) : (a = e * Math.pow(2, u - 1) * Math.pow(2, r),
                    s = 0)); r >= 8; t[i + f] = 255 & a,
                    f += p,
                    a /= 256,
                    r -= 8)
                        ;
                    for (s = s << r | a,
                    c += r; c > 0; t[i + f] = 255 & s,
                    f += p,
                    s /= 256,
                    c -= 8)
                        ;
                    t[i + f - p] |= 128 * m
                };
                function Ju(t) {
                    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0),
                    this.pos = 0,
                    this.type = 0,
                    this.length = this.buf.length
                }
                Ju.Varint = 0,
                Ju.Fixed64 = 1,
                Ju.Bytes = 2,
                Ju.Fixed32 = 5;
                var Qu = 4294967296
                  , td = 1 / Qu
                  , ed = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
                function id(t) {
                    return t.type === Ju.Bytes ? t.readVarint() + t.pos : t.pos + 1
                }
                function nd(t, e, i) {
                    return i ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0)
                }
                function rd(t, e, i) {
                    var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));
                    i.realloc(n);
                    for (var r = i.pos - 1; r >= t; r--)
                        i.buf[r + n] = i.buf[r]
                }
                function od(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeVarint(t[i])
                }
                function sd(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeSVarint(t[i])
                }
                function ad(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeFloat(t[i])
                }
                function ld(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeDouble(t[i])
                }
                function cd(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeBoolean(t[i])
                }
                function hd(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeFixed32(t[i])
                }
                function ud(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeSFixed32(t[i])
                }
                function dd(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeFixed64(t[i])
                }
                function fd(t, e) {
                    for (var i = 0; i < t.length; i++)
                        e.writeSFixed64(t[i])
                }
                function pd(t, e) {
                    return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3]
                }
                function md(t, e, i) {
                    t[i] = e,
                    t[i + 1] = e >>> 8,
                    t[i + 2] = e >>> 16,
                    t[i + 3] = e >>> 24
                }
                function gd(t, e) {
                    return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24)
                }
                Ju.prototype = {
                    destroy: function() {
                        this.buf = null
                    },
                    readFields: function(t, e, i) {
                        for (i = i || this.length; this.pos < i; ) {
                            var n = this.readVarint()
                              , r = n >> 3
                              , o = this.pos;
                            this.type = 7 & n,
                            t(r, e, this),
                            this.pos === o && this.skip(n)
                        }
                        return e
                    },
                    readMessage: function(t, e) {
                        return this.readFields(t, e, this.readVarint() + this.pos)
                    },
                    readFixed32: function() {
                        var t = pd(this.buf, this.pos);
                        return this.pos += 4,
                        t
                    },
                    readSFixed32: function() {
                        var t = gd(this.buf, this.pos);
                        return this.pos += 4,
                        t
                    },
                    readFixed64: function() {
                        var t = pd(this.buf, this.pos) + pd(this.buf, this.pos + 4) * Qu;
                        return this.pos += 8,
                        t
                    },
                    readSFixed64: function() {
                        var t = pd(this.buf, this.pos) + gd(this.buf, this.pos + 4) * Qu;
                        return this.pos += 8,
                        t
                    },
                    readFloat: function() {
                        var t = Yu(this.buf, this.pos, !0, 23, 4);
                        return this.pos += 4,
                        t
                    },
                    readDouble: function() {
                        var t = Yu(this.buf, this.pos, !0, 52, 8);
                        return this.pos += 8,
                        t
                    },
                    readVarint: function(t) {
                        var e, i, n = this.buf;
                        return e = 127 & (i = n[this.pos++]),
                        i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 7,
                        i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 14,
                        i < 128 ? e : (e |= (127 & (i = n[this.pos++])) << 21,
                        i < 128 ? e : function(t, e, i) {
                            var n, r, o = i.buf;
                            if (n = (112 & (r = o[i.pos++])) >> 4,
                            r < 128)
                                return nd(t, n, e);
                            if (n |= (127 & (r = o[i.pos++])) << 3,
                            r < 128)
                                return nd(t, n, e);
                            if (n |= (127 & (r = o[i.pos++])) << 10,
                            r < 128)
                                return nd(t, n, e);
                            if (n |= (127 & (r = o[i.pos++])) << 17,
                            r < 128)
                                return nd(t, n, e);
                            if (n |= (127 & (r = o[i.pos++])) << 24,
                            r < 128)
                                return nd(t, n, e);
                            if (n |= (1 & (r = o[i.pos++])) << 31,
                            r < 128)
                                return nd(t, n, e);
                            throw new Error("Expected varint not more than 10 bytes")
                        }(e |= (15 & (i = n[this.pos])) << 28, t, this))))
                    },
                    readVarint64: function() {
                        return this.readVarint(!0)
                    },
                    readSVarint: function() {
                        var t = this.readVarint();
                        return t % 2 == 1 ? (t + 1) / -2 : t / 2
                    },
                    readBoolean: function() {
                        return Boolean(this.readVarint())
                    },
                    readString: function() {
                        var t = this.readVarint() + this.pos
                          , e = this.pos;
                        return this.pos = t,
                        t - e >= 12 && ed ? function(t, e, i) {
                            return ed.decode(t.subarray(e, i))
                        }(this.buf, e, t) : function(t, e, i) {
                            for (var n = "", r = e; r < i; ) {
                                var o, s, a, l = t[r], c = null, h = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;
                                if (r + h > i)
                                    break;
                                1 === h ? l < 128 && (c = l) : 2 === h ? 128 == (192 & (o = t[r + 1])) && (c = (31 & l) << 6 | 63 & o) <= 127 && (c = null) : 3 === h ? (s = t[r + 2],
                                128 == (192 & (o = t[r + 1])) && 128 == (192 & s) && ((c = (15 & l) << 12 | (63 & o) << 6 | 63 & s) <= 2047 || c >= 55296 && c <= 57343) && (c = null)) : 4 === h && (s = t[r + 2],
                                a = t[r + 3],
                                128 == (192 & (o = t[r + 1])) && 128 == (192 & s) && 128 == (192 & a) && ((c = (15 & l) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) <= 65535 || c >= 1114112) && (c = null)),
                                null === c ? (c = 65533,
                                h = 1) : c > 65535 && (c -= 65536,
                                n += String.fromCharCode(c >>> 10 & 1023 | 55296),
                                c = 56320 | 1023 & c),
                                n += String.fromCharCode(c),
                                r += h
                            }
                            return n
                        }(this.buf, e, t)
                    },
                    readBytes: function() {
                        var t = this.readVarint() + this.pos
                          , e = this.buf.subarray(this.pos, t);
                        return this.pos = t,
                        e
                    },
                    readPackedVarint: function(t, e) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readVarint(e));
                        var i = id(this);
                        for (t = t || []; this.pos < i; )
                            t.push(this.readVarint(e));
                        return t
                    },
                    readPackedSVarint: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readSVarint());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readSVarint());
                        return t
                    },
                    readPackedBoolean: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readBoolean());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readBoolean());
                        return t
                    },
                    readPackedFloat: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readFloat());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readFloat());
                        return t
                    },
                    readPackedDouble: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readDouble());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readDouble());
                        return t
                    },
                    readPackedFixed32: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readFixed32());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readFixed32());
                        return t
                    },
                    readPackedSFixed32: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readSFixed32());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readSFixed32());
                        return t
                    },
                    readPackedFixed64: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readFixed64());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readFixed64());
                        return t
                    },
                    readPackedSFixed64: function(t) {
                        if (this.type !== Ju.Bytes)
                            return t.push(this.readSFixed64());
                        var e = id(this);
                        for (t = t || []; this.pos < e; )
                            t.push(this.readSFixed64());
                        return t
                    },
                    skip: function(t) {
                        var e = 7 & t;
                        if (e === Ju.Varint)
                            for (; this.buf[this.pos++] > 127; )
                                ;
                        else if (e === Ju.Bytes)
                            this.pos = this.readVarint() + this.pos;
                        else if (e === Ju.Fixed32)
                            this.pos += 4;
                        else {
                            if (e !== Ju.Fixed64)
                                throw new Error("Unimplemented type: " + e);
                            this.pos += 8
                        }
                    },
                    writeTag: function(t, e) {
                        this.writeVarint(t << 3 | e)
                    },
                    realloc: function(t) {
                        for (var e = this.length || 16; e < this.pos + t; )
                            e *= 2;
                        if (e !== this.length) {
                            var i = new Uint8Array(e);
                            i.set(this.buf),
                            this.buf = i,
                            this.length = e
                        }
                    },
                    finish: function() {
                        return this.length = this.pos,
                        this.pos = 0,
                        this.buf.subarray(0, this.length)
                    },
                    writeFixed32: function(t) {
                        this.realloc(4),
                        md(this.buf, t, this.pos),
                        this.pos += 4
                    },
                    writeSFixed32: function(t) {
                        this.realloc(4),
                        md(this.buf, t, this.pos),
                        this.pos += 4
                    },
                    writeFixed64: function(t) {
                        this.realloc(8),
                        md(this.buf, -1 & t, this.pos),
                        md(this.buf, Math.floor(t * td), this.pos + 4),
                        this.pos += 8
                    },
                    writeSFixed64: function(t) {
                        this.realloc(8),
                        md(this.buf, -1 & t, this.pos),
                        md(this.buf, Math.floor(t * td), this.pos + 4),
                        this.pos += 8
                    },
                    writeVarint: function(t) {
                        (t = +t || 0) > 268435455 || t < 0 ? function(t, e) {
                            var i, n;
                            if (t >= 0 ? (i = t % 4294967296 | 0,
                            n = t / 4294967296 | 0) : (n = ~(-t / 4294967296),
                            4294967295 ^ (i = ~(-t % 4294967296)) ? i = i + 1 | 0 : (i = 0,
                            n = n + 1 | 0)),
                            t >= 0x10000000000000000 || t < -0x10000000000000000)
                                throw new Error("Given varint doesn't fit into 10 bytes");
                            e.realloc(10),
                            function(t, e, i) {
                                i.buf[i.pos++] = 127 & t | 128,
                                t >>>= 7,
                                i.buf[i.pos++] = 127 & t | 128,
                                t >>>= 7,
                                i.buf[i.pos++] = 127 & t | 128,
                                t >>>= 7,
                                i.buf[i.pos++] = 127 & t | 128,
                                i.buf[i.pos] = 127 & (t >>>= 7)
                            }(i, 0, e),
                            function(t, e) {
                                var i = (7 & t) << 4;
                                e.buf[e.pos++] |= i | ((t >>>= 3) ? 128 : 0),
                                t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                                t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                                t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                                t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0),
                                t && (e.buf[e.pos++] = 127 & t)))))
                            }(n, e)
                        }(t, this) : (this.realloc(4),
                        this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0),
                        t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))))
                    },
                    writeSVarint: function(t) {
                        this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t)
                    },
                    writeBoolean: function(t) {
                        this.writeVarint(Boolean(t))
                    },
                    writeString: function(t) {
                        t = String(t),
                        this.realloc(4 * t.length),
                        this.pos++;
                        var e = this.pos;
                        this.pos = function(t, e, i) {
                            for (var n, r, o = 0; o < e.length; o++) {
                                if ((n = e.charCodeAt(o)) > 55295 && n < 57344) {
                                    if (!r) {
                                        n > 56319 || o + 1 === e.length ? (t[i++] = 239,
                                        t[i++] = 191,
                                        t[i++] = 189) : r = n;
                                        continue
                                    }
                                    if (n < 56320) {
                                        t[i++] = 239,
                                        t[i++] = 191,
                                        t[i++] = 189,
                                        r = n;
                                        continue
                                    }
                                    n = r - 55296 << 10 | n - 56320 | 65536,
                                    r = null
                                } else
                                    r && (t[i++] = 239,
                                    t[i++] = 191,
                                    t[i++] = 189,
                                    r = null);
                                n < 128 ? t[i++] = n : (n < 2048 ? t[i++] = n >> 6 | 192 : (n < 65536 ? t[i++] = n >> 12 | 224 : (t[i++] = n >> 18 | 240,
                                t[i++] = n >> 12 & 63 | 128),
                                t[i++] = n >> 6 & 63 | 128),
                                t[i++] = 63 & n | 128)
                            }
                            return i
                        }(this.buf, t, this.pos);
                        var i = this.pos - e;
                        i >= 128 && rd(e, i, this),
                        this.pos = e - 1,
                        this.writeVarint(i),
                        this.pos += i
                    },
                    writeFloat: function(t) {
                        this.realloc(4),
                        Ku(this.buf, t, this.pos, !0, 23, 4),
                        this.pos += 4
                    },
                    writeDouble: function(t) {
                        this.realloc(8),
                        Ku(this.buf, t, this.pos, !0, 52, 8),
                        this.pos += 8
                    },
                    writeBytes: function(t) {
                        var e = t.length;
                        this.writeVarint(e),
                        this.realloc(e);
                        for (var i = 0; i < e; i++)
                            this.buf[this.pos++] = t[i]
                    },
                    writeRawMessage: function(t, e) {
                        this.pos++;
                        var i = this.pos;
                        t(e, this);
                        var n = this.pos - i;
                        n >= 128 && rd(i, n, this),
                        this.pos = i - 1,
                        this.writeVarint(n),
                        this.pos += n
                    },
                    writeMessage: function(t, e, i) {
                        this.writeTag(t, Ju.Bytes),
                        this.writeRawMessage(e, i)
                    },
                    writePackedVarint: function(t, e) {
                        e.length && this.writeMessage(t, od, e)
                    },
                    writePackedSVarint: function(t, e) {
                        e.length && this.writeMessage(t, sd, e)
                    },
                    writePackedBoolean: function(t, e) {
                        e.length && this.writeMessage(t, cd, e)
                    },
                    writePackedFloat: function(t, e) {
                        e.length && this.writeMessage(t, ad, e)
                    },
                    writePackedDouble: function(t, e) {
                        e.length && this.writeMessage(t, ld, e)
                    },
                    writePackedFixed32: function(t, e) {
                        e.length && this.writeMessage(t, hd, e)
                    },
                    writePackedSFixed32: function(t, e) {
                        e.length && this.writeMessage(t, ud, e)
                    },
                    writePackedFixed64: function(t, e) {
                        e.length && this.writeMessage(t, dd, e)
                    },
                    writePackedSFixed64: function(t, e) {
                        e.length && this.writeMessage(t, fd, e)
                    },
                    writeBytesField: function(t, e) {
                        this.writeTag(t, Ju.Bytes),
                        this.writeBytes(e)
                    },
                    writeFixed32Field: function(t, e) {
                        this.writeTag(t, Ju.Fixed32),
                        this.writeFixed32(e)
                    },
                    writeSFixed32Field: function(t, e) {
                        this.writeTag(t, Ju.Fixed32),
                        this.writeSFixed32(e)
                    },
                    writeFixed64Field: function(t, e) {
                        this.writeTag(t, Ju.Fixed64),
                        this.writeFixed64(e)
                    },
                    writeSFixed64Field: function(t, e) {
                        this.writeTag(t, Ju.Fixed64),
                        this.writeSFixed64(e)
                    },
                    writeVarintField: function(t, e) {
                        this.writeTag(t, Ju.Varint),
                        this.writeVarint(e)
                    },
                    writeSVarintField: function(t, e) {
                        this.writeTag(t, Ju.Varint),
                        this.writeSVarint(e)
                    },
                    writeStringField: function(t, e) {
                        this.writeTag(t, Ju.Bytes),
                        this.writeString(e)
                    },
                    writeFloatField: function(t, e) {
                        this.writeTag(t, Ju.Fixed32),
                        this.writeFloat(e)
                    },
                    writeDoubleField: function(t, e) {
                        this.writeTag(t, Ju.Fixed64),
                        this.writeDouble(e)
                    },
                    writeBooleanField: function(t, e) {
                        this.writeVarintField(t, Boolean(e))
                    }
                };
                var _d = f(Xu);
                const yd = 3;
                function vd(t, e, i) {
                    e.glyphs = [],
                    1 === t && i.readMessage(xd, e)
                }
                function xd(t, e, i) {
                    if (3 === t) {
                        const {id: t, bitmap: n, width: r, height: o, left: s, top: a, advance: l} = i.readMessage(bd, {});
                        e.glyphs.push({
                            id: t,
                            bitmap: new Nc({
                                width: r + 2 * yd,
                                height: o + 2 * yd
                            },n),
                            metrics: {
                                width: r,
                                height: o,
                                left: s,
                                top: a,
                                advance: l
                            }
                        })
                    } else
                        4 === t ? e.ascender = i.readSVarint() : 5 === t && (e.descender = i.readSVarint())
                }
                function bd(t, e, i) {
                    1 === t ? e.id = i.readVarint() : 2 === t ? e.bitmap = i.readBytes() : 3 === t ? e.width = i.readVarint() : 4 === t ? e.height = i.readVarint() : 5 === t ? e.left = i.readSVarint() : 6 === t ? e.top = i.readSVarint() : 7 === t && (e.advance = i.readVarint())
                }
                const wd = yd;
                function Ed(t) {
                    let e = 0
                      , i = 0;
                    for (const n of t)
                        e += n.w * n.h,
                        i = Math.max(i, n.w);
                    t.sort(( (t, e) => e.h - t.h));
                    const n = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(e / .95)), i),
                        h: 1 / 0
                    }];
                    let r = 0
                      , o = 0;
                    for (const e of t)
                        for (let t = n.length - 1; t >= 0; t--) {
                            const i = n[t];
                            if (!(e.w > i.w || e.h > i.h)) {
                                if (e.x = i.x,
                                e.y = i.y,
                                o = Math.max(o, e.y + e.h),
                                r = Math.max(r, e.x + e.w),
                                e.w === i.w && e.h === i.h) {
                                    const e = n.pop();
                                    t < n.length && (n[t] = e)
                                } else
                                    e.h === i.h ? (i.x += e.w,
                                    i.w -= e.w) : e.w === i.w ? (i.y += e.h,
                                    i.h -= e.h) : (n.push({
                                        x: i.x + e.w,
                                        y: i.y,
                                        w: i.w - e.w,
                                        h: e.h
                                    }),
                                    i.y += e.h,
                                    i.h -= e.h);
                                break
                            }
                        }
                    return {
                        w: r,
                        h: o,
                        fill: e / (r * o) || 0
                    }
                }
                const Td = 1;
                class Sd {
                    constructor(t, {pixelRatio: e, version: i, stretchX: n, stretchY: r, content: o}) {
                        this.paddedRect = t,
                        this.pixelRatio = e,
                        this.stretchX = n,
                        this.stretchY = r,
                        this.content = o,
                        this.version = i
                    }
                    get tl() {
                        return [this.paddedRect.x + Td, this.paddedRect.y + Td]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - Td, this.paddedRect.y + this.paddedRect.h - Td]
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2 * Td) / this.pixelRatio, (this.paddedRect.h - 2 * Td) / this.pixelRatio]
                    }
                }
                class Cd {
                    constructor(t, e) {
                        const i = {}
                          , n = {};
                        this.haveRenderCallbacks = [];
                        const r = [];
                        this.addImages(t, i, r),
                        this.addImages(e, n, r);
                        const {w: o, h: s} = Ed(r)
                          , a = new jc({
                            width: o || 1,
                            height: s || 1
                        });
                        for (const e in t) {
                            const n = t[e]
                              , r = i[e].paddedRect;
                            jc.copy(n.data, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: r.x + Td,
                                y: r.y + Td
                            }, n.data)
                        }
                        for (const t in e) {
                            const i = e[t]
                              , r = n[t].paddedRect
                              , o = r.x + Td
                              , s = r.y + Td
                              , l = i.data.width
                              , c = i.data.height;
                            jc.copy(i.data, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: o,
                                y: s
                            }, i.data),
                            jc.copy(i.data, a, {
                                x: 0,
                                y: c - 1
                            }, {
                                x: o,
                                y: s - 1
                            }, {
                                width: l,
                                height: 1
                            }),
                            jc.copy(i.data, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: o,
                                y: s + c
                            }, {
                                width: l,
                                height: 1
                            }),
                            jc.copy(i.data, a, {
                                x: l - 1,
                                y: 0
                            }, {
                                x: o - 1,
                                y: s
                            }, {
                                width: 1,
                                height: c
                            }),
                            jc.copy(i.data, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: o + l,
                                y: s
                            }, {
                                width: 1,
                                height: c
                            })
                        }
                        this.image = a,
                        this.iconPositions = i,
                        this.patternPositions = n
                    }
                    addImages(t, e, i) {
                        for (const n in t) {
                            const r = t[n]
                              , o = {
                                x: 0,
                                y: 0,
                                w: r.data.width + 2 * Td,
                                h: r.data.height + 2 * Td
                            };
                            i.push(o),
                            e[n] = new Sd(o,r),
                            r.hasRenderCallback && this.haveRenderCallbacks.push(n)
                        }
                    }
                    patchUpdatedImages(t, e) {
                        this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e => t.hasImage(e))),
                        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const i in t.updatedImages)
                            this.patchUpdatedImage(this.iconPositions[i], t.getImage(i), e),
                            this.patchUpdatedImage(this.patternPositions[i], t.getImage(i), e)
                    }
                    patchUpdatedImage(t, e, i) {
                        if (!t || !e)
                            return;
                        if (t.version === e.version)
                            return;
                        t.version = e.version;
                        const [n,r] = t.tl;
                        i.update(e.data, void 0, {
                            x: n,
                            y: r
                        })
                    }
                }
                Yr(Sd, "ImagePosition"),
                Yr(Cd, "ImageAtlas");
                const Ad = {
                    horizontal: 1,
                    vertical: 2,
                    horizontalOnly: 3
                }
                  , Id = -17;
                class Md {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.imageName = null
                    }
                    static forText(t, e) {
                        const i = new Md;
                        return i.scale = t || 1,
                        i.fontStack = e,
                        i
                    }
                    static forImage(t) {
                        const e = new Md;
                        return e.imageName = t,
                        e
                    }
                }
                class Pd {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(t, e) {
                        const i = new Pd;
                        for (let n = 0; n < t.sections.length; n++) {
                            const r = t.sections[n];
                            r.image ? i.addImageSection(r) : i.addTextSection(r, e)
                        }
                        return i
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(t) {
                        return this.sections[this.sectionIndex[t]]
                    }
                    getSections() {
                        return this.sections
                    }
                    getSectionIndex(t) {
                        return this.sectionIndex[t]
                    }
                    getCharCode(t) {
                        return this.text.charCodeAt(t)
                    }
                    verticalizePunctuation(t) {
                        this.text = function(t, e) {
                            let i = "";
                            for (let n = 0; n < t.length; n++) {
                                const r = t.charCodeAt(n + 1) || null
                                  , o = t.charCodeAt(n - 1) || null;
                                i += !e && (r && so(r) && !Wu[t[n + 1]] || o && so(o) && !Wu[t[n - 1]]) || !Wu[t[n]] ? t[n] : Wu[t[n]]
                            }
                            return i
                        }(this.text, t)
                    }
                    trim() {
                        let t = 0;
                        for (let e = 0; e < this.text.length && Od[this.text.charCodeAt(e)]; e++)
                            t++;
                        let e = this.text.length;
                        for (let i = this.text.length - 1; i >= 0 && i >= t && Od[this.text.charCodeAt(i)]; i--)
                            e--;
                        this.text = this.text.substring(t, e),
                        this.sectionIndex = this.sectionIndex.slice(t, e)
                    }
                    substring(t, e) {
                        const i = new Pd;
                        return i.text = this.text.substring(t, e),
                        i.sectionIndex = this.sectionIndex.slice(t, e),
                        i.sections = this.sections,
                        i
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce(( (t, e) => Math.max(t, this.sections[e].scale)), 0)
                    }
                    addTextSection(t, e) {
                        this.text += t.text,
                        this.sections.push(Md.forText(t.scale, t.fontStack || e));
                        const i = this.sections.length - 1;
                        for (let e = 0; e < t.text.length; ++e)
                            this.sectionIndex.push(i)
                    }
                    addImageSection(t) {
                        const e = t.image ? t.image.name : "";
                        if (0 === e.length)
                            return void q("Can't add FormattedSection with an empty image.");
                        const i = this.getNextImageSectionCharCode();
                        i ? (this.text += String.fromCharCode(i),
                        this.sections.push(Md.forImage(e)),
                        this.sectionIndex.push(this.sections.length - 1)) : q("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function kd(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p) {
                    const m = Pd.fromFeature(t, r);
                    u === Ad.vertical && m.verticalizePunctuation(d);
                    let g = [];
                    const _ = function(t, e, i, n, r, o) {
                        if (!t)
                            return [];
                        const s = []
                          , a = function(t, e, i, n, r, o) {
                            let s = 0;
                            for (let i = 0; i < t.length(); i++) {
                                const a = t.getSection(i);
                                s += Dd(t.getCharCode(i), a, n, r, e, o)
                            }
                            return s / Math.max(1, Math.ceil(s / i))
                        }(t, e, i, n, r, o)
                          , l = t.text.indexOf("") >= 0;
                        let c = 0;
                        for (let i = 0; i < t.length(); i++) {
                            const u = t.getSection(i)
                              , d = t.getCharCode(i);
                            if (Od[d] || (c += Dd(d, u, n, r, e, o)),
                            i < t.length() - 1) {
                                const e = !((h = d) < 11904 || !(eo["Bopomofo Extended"](h) || eo.Bopomofo(h) || eo["CJK Compatibility Forms"](h) || eo["CJK Compatibility Ideographs"](h) || eo["CJK Compatibility"](h) || eo["CJK Radicals Supplement"](h) || eo["CJK Strokes"](h) || eo["CJK Symbols and Punctuation"](h) || eo["CJK Unified Ideographs Extension A"](h) || eo["CJK Unified Ideographs"](h) || eo["Enclosed CJK Letters and Months"](h) || eo["Halfwidth and Fullwidth Forms"](h) || eo.Hiragana(h) || eo["Ideographic Description Characters"](h) || eo["Kangxi Radicals"](h) || eo["Katakana Phonetic Extensions"](h) || eo.Katakana(h) || eo["Vertical Forms"](h) || eo["Yi Radicals"](h) || eo["Yi Syllables"](h)));
                                (Rd[d] || e || u.imageName) && s.push(zd(i + 1, c, a, s, Bd(d, t.getCharCode(i + 1), e && l), !1))
                            }
                        }
                        var h;
                        return Fd(zd(t.length(), c, a, s, 0, !0))
                    }(m, c, o, e, n, f)
                      , {processBidirectionalText: y, processStyledBidirectionalText: v} = wo;
                    if (y && 1 === m.sections.length) {
                        const t = y(m.toString(), _);
                        for (const e of t) {
                            const t = new Pd;
                            t.text = e,
                            t.sections = m.sections;
                            for (let i = 0; i < e.length; i++)
                                t.sectionIndex.push(0);
                            g.push(t)
                        }
                    } else if (v) {
                        const t = v(m.text, m.sectionIndex, _);
                        for (const e of t) {
                            const t = new Pd;
                            t.text = e[0],
                            t.sectionIndex = e[1],
                            t.sections = m.sections,
                            g.push(t)
                        }
                    } else
                        g = function(t, e) {
                            const i = []
                              , n = t.text;
                            let r = 0;
                            for (const n of e)
                                i.push(t.substring(r, n)),
                                r = n;
                            return r < n.length && i.push(t.substring(r, n.length)),
                            i
                        }(m, _);
                    const x = []
                      , b = {
                        positionedLines: x,
                        text: m.toString(),
                        top: h[1],
                        bottom: h[1],
                        left: h[0],
                        right: h[0],
                        writingMode: u,
                        iconsInText: !1,
                        verticalizable: !1,
                        hasBaseline: !1
                    };
                    return function(t, e, i, n, r, o, s, a, l, c, h, u) {
                        let d = 0
                          , f = 0
                          , p = 0;
                        const m = "right" === a ? 1 : "left" === a ? 0 : .5;
                        let g = !1;
                        for (const t of r) {
                            const i = t.getSections();
                            for (const t of i) {
                                if (t.imageName)
                                    continue;
                                const i = e[t.fontStack];
                                if (i && (g = void 0 !== i.ascender && void 0 !== i.descender,
                                !g))
                                    break
                            }
                            if (!g)
                                break
                        }
                        let _ = 0;
                        for (const s of r) {
                            s.trim();
                            const r = s.getMaxScale()
                              , a = (r - 1) * Nu
                              , v = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            t.positionedLines[_] = v;
                            const x = v.positionedGlyphs;
                            let b = 0;
                            if (!s.length()) {
                                f += o,
                                ++_;
                                continue
                            }
                            let w = 0
                              , E = 0;
                            for (let o = 0; o < s.length(); o++) {
                                const a = s.getSection(o)
                                  , p = s.getSectionIndex(o)
                                  , m = s.getCharCode(o);
                                let _ = a.scale
                                  , v = null
                                  , T = null
                                  , S = null
                                  , C = Nu
                                  , A = 0;
                                const I = !(l === Ad.horizontal || !h && !oo(m) || h && (Od[m] || (y = m,
                                eo.Arabic(y) || eo["Arabic Supplement"](y) || eo["Arabic Extended-A"](y) || eo["Arabic Presentation Forms-A"](y) || eo["Arabic Presentation Forms-B"](y))));
                                if (a.imageName) {
                                    const e = n[a.imageName];
                                    if (!e)
                                        continue;
                                    S = a.imageName,
                                    t.iconsInText = t.iconsInText || !0,
                                    T = e.paddedRect;
                                    const i = e.displaySize;
                                    _ = _ * Nu / u,
                                    v = {
                                        width: i[0],
                                        height: i[1],
                                        left: Td,
                                        top: -wd,
                                        advance: I ? i[1] : i[0],
                                        localGlyph: !1
                                    },
                                    A = g ? -v.height * _ : Id + r * Nu - i[1] * _,
                                    C = v.advance;
                                    const o = (I ? i[0] : i[1]) * _ - Nu * r;
                                    o > 0 && o > b && (b = o)
                                } else {
                                    const t = i[a.fontStack];
                                    if (!t)
                                        continue;
                                    t[m] && (T = t[m]);
                                    const n = e[a.fontStack];
                                    if (!n)
                                        continue;
                                    const o = n.glyphs[m];
                                    if (!o)
                                        continue;
                                    if (v = o.metrics,
                                    C = 8203 !== m ? Nu : 0,
                                    g) {
                                        const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0
                                          , e = void 0 !== n.descender ? Math.abs(n.descender) : 0
                                          , i = (t + e) * _;
                                        w < i && (w = i,
                                        E = (t - e) / 2 * _),
                                        A = -t * _
                                    } else
                                        A = Id + (r - _) * Nu
                                }
                                I ? (t.verticalizable = !0,
                                x.push({
                                    glyph: m,
                                    imageName: S,
                                    x: d,
                                    y: f + A,
                                    vertical: I,
                                    scale: _,
                                    localGlyph: v.localGlyph,
                                    fontStack: a.fontStack,
                                    sectionIndex: p,
                                    metrics: v,
                                    rect: T
                                }),
                                d += C * _ + c) : (x.push({
                                    glyph: m,
                                    imageName: S,
                                    x: d,
                                    y: f + A,
                                    vertical: I,
                                    scale: _,
                                    localGlyph: v.localGlyph,
                                    fontStack: a.fontStack,
                                    sectionIndex: p,
                                    metrics: v,
                                    rect: T
                                }),
                                d += v.advance * _ + c)
                            }
                            0 !== x.length && (p = Math.max(d - c, p),
                            g ? jd(x, m, b, E, o * r / 2) : jd(x, m, b, 0, o / 2)),
                            d = 0;
                            const T = o * r + b;
                            v.lineOffset = Math.max(b, a),
                            f += T,
                            ++_
                        }
                        var y;
                        const v = f
                          , {horizontalAlign: x, verticalAlign: b} = Nd(s);
                        (function(t, e, i, n, r, o) {
                            const s = (e - i) * r
                              , a = -o * n;
                            for (const e of t)
                                for (const t of e.positionedGlyphs)
                                    t.x += s,
                                    t.y += a
                        }
                        )(t.positionedLines, m, x, b, p, v),
                        t.top += -b * v,
                        t.bottom = t.top + v,
                        t.left += -x * p,
                        t.right = t.left + p,
                        t.hasBaseline = g
                    }(b, e, i, n, g, s, a, l, u, c, d, p),
                    !function(t) {
                        for (const e of t)
                            if (0 !== e.positionedGlyphs.length)
                                return !1;
                        return !0
                    }(x) && b
                }
                const Od = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , Rd = {
                    10: !0,
                    32: !0,
                    38: !0,
                    40: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                };
                function Dd(t, e, i, n, r, o) {
                    if (e.imageName) {
                        const t = n[e.imageName];
                        return t ? t.displaySize[0] * e.scale * Nu / o + r : 0
                    }
                    {
                        const n = i[e.fontStack]
                          , o = n && n.glyphs[t];
                        return o ? o.metrics.advance * e.scale + r : 0
                    }
                }
                function Ld(t, e, i, n) {
                    const r = Math.pow(t - e, 2);
                    return n ? t < e ? r / 2 : 2 * r : r + Math.abs(i) * i
                }
                function Bd(t, e, i) {
                    let n = 0;
                    return 10 === t && (n -= 1e4),
                    i && (n += 150),
                    40 !== t && 65288 !== t || (n += 50),
                    41 !== e && 65289 !== e || (n += 50),
                    n
                }
                function zd(t, e, i, n, r, o) {
                    let s = null
                      , a = Ld(e, i, r, o);
                    for (const t of n) {
                        const n = Ld(e - t.x, i, r, o) + t.badness;
                        n <= a && (s = t,
                        a = n)
                    }
                    return {
                        index: t,
                        x: e,
                        priorBreak: s,
                        badness: a
                    }
                }
                function Fd(t) {
                    return t ? Fd(t.priorBreak).concat(t.index) : []
                }
                function Nd(t) {
                    let e = .5
                      , i = .5;
                    switch (t) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        e = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        e = 0
                    }
                    switch (t) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        i = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        i = 0
                    }
                    return {
                        horizontalAlign: e,
                        verticalAlign: i
                    }
                }
                function jd(t, e, i, n, r) {
                    if (!(e || i || n || r))
                        return;
                    const o = t.length - 1
                      , s = t[o]
                      , a = (s.x + s.metrics.advance * s.scale) * e;
                    for (let e = 0; e <= o; e++)
                        t[e].x -= a,
                        t[e].y += i + n + r
                }
                function Ud(t, e, i) {
                    const {horizontalAlign: n, verticalAlign: r} = Nd(i)
                      , o = e[0] - t.displaySize[0] * n
                      , s = e[1] - t.displaySize[1] * r;
                    return {
                        image: t,
                        top: s,
                        bottom: s + t.displaySize[1],
                        left: o,
                        right: o + t.displaySize[0]
                    }
                }
                function Vd(t, e, i, n, r, o) {
                    const s = t.image;
                    let a;
                    if (s.content) {
                        const t = s.content
                          , e = s.pixelRatio || 1;
                        a = [t[0] / e, t[1] / e, s.displaySize[0] - t[2] / e, s.displaySize[1] - t[3] / e]
                    }
                    const l = e.left * o
                      , c = e.right * o;
                    let h, u, d, f;
                    "width" === i || "both" === i ? (f = r[0] + l - n[3],
                    u = r[0] + c + n[1]) : (f = r[0] + (l + c - s.displaySize[0]) / 2,
                    u = f + s.displaySize[0]);
                    const p = e.top * o
                      , m = e.bottom * o;
                    return "height" === i || "both" === i ? (h = r[1] + p - n[0],
                    d = r[1] + m + n[2]) : (h = r[1] + (p + m - s.displaySize[1]) / 2,
                    d = h + s.displaySize[1]),
                    {
                        image: s,
                        top: h,
                        right: u,
                        bottom: d,
                        left: f,
                        collisionPadding: a
                    }
                }
                class Gd extends v {
                    constructor(t, e, i, n, r) {
                        super(t, e),
                        this.angle = n,
                        this.z = i,
                        void 0 !== r && (this.segment = r)
                    }
                    clone() {
                        return new Gd(this.x,this.y,this.z,this.angle,this.segment)
                    }
                }
                function Zd(t, e, i, n, r) {
                    if (void 0 === e.segment)
                        return !0;
                    let o = e
                      , s = e.segment + 1
                      , a = 0;
                    for (; a > -i / 2; ) {
                        if (s--,
                        s < 0)
                            return !1;
                        a -= t[s].dist(o),
                        o = t[s]
                    }
                    a += t[s].dist(t[s + 1]),
                    s++;
                    const l = [];
                    let c = 0;
                    for (; a < i / 2; ) {
                        const e = t[s]
                          , i = t[s + 1];
                        if (!i)
                            return !1;
                        let o = t[s - 1].angleTo(e) - e.angleTo(i);
                        for (o = Math.abs((o + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        l.push({
                            distance: a,
                            angleDelta: o
                        }),
                        c += o; a - l[0].distance > n; )
                            c -= l.shift().angleDelta;
                        if (c > r)
                            return !1;
                        s++,
                        a += e.dist(i)
                    }
                    return !0
                }
                function qd(t) {
                    let e = 0;
                    for (let i = 0; i < t.length - 1; i++)
                        e += t[i].dist(t[i + 1]);
                    return e
                }
                function Wd(t, e, i) {
                    return t ? .6 * e * i : 0
                }
                function Hd(t, e) {
                    return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0)
                }
                function $d(t, e, i, n, r, o) {
                    const s = Wd(i, r, o)
                      , a = Hd(i, n) * o;
                    let l = 0;
                    const c = qd(t) / 2;
                    for (let i = 0; i < t.length - 1; i++) {
                        const n = t[i]
                          , r = t[i + 1]
                          , o = n.dist(r);
                        if (l + o > c) {
                            const h = (c - l) / o
                              , u = Oi(n.x, r.x, h)
                              , d = Oi(n.y, r.y, h)
                              , f = new Gd(u,d,0,r.angleTo(n),i);
                            return !s || Zd(t, f, a, s, e) ? f : void 0
                        }
                        l += o
                    }
                }
                function Xd(t, e, i, n, r, o, s, a, l) {
                    const c = Wd(n, o, s)
                      , h = Hd(n, r)
                      , u = h * s
                      , d = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;
                    return e - u < e / 4 && (e = u + e / 4),
                    Yd(t, d ? e / 2 * a % e : (h / 2 + 2 * o) * s * a % e, e, c, i, u, d, !1, l)
                }
                function Yd(t, e, i, n, r, o, s, a, l) {
                    const c = o / 2
                      , h = qd(t);
                    let u = 0
                      , d = e - i
                      , f = [];
                    for (let e = 0; e < t.length - 1; e++) {
                        const s = t[e]
                          , a = t[e + 1]
                          , p = s.dist(a)
                          , m = a.angleTo(s);
                        for (; d + i < u + p; ) {
                            d += i;
                            const g = (d - u) / p
                              , _ = Oi(s.x, a.x, g)
                              , y = Oi(s.y, a.y, g);
                            if (_ >= 0 && _ < l && y >= 0 && y < l && d - c >= 0 && d + c <= h) {
                                const i = new Gd(_,y,0,m,e);
                                i._round(),
                                n && !Zd(t, i, o, n, r) || f.push(i)
                            }
                        }
                        u += p
                    }
                    return a || f.length || s || (f = Yd(t, u / 2, i, n, r, o, s, !0, l)),
                    f
                }
                function Kd(t, e, i, n, r) {
                    const o = [];
                    for (let s = 0; s < t.length; s++) {
                        const a = t[s];
                        let l;
                        for (let t = 0; t < a.length - 1; t++) {
                            let s = a[t]
                              , c = a[t + 1];
                            s.x < e && c.x < e || (s.x < e ? s = new v(e,s.y + (e - s.x) / (c.x - s.x) * (c.y - s.y))._round() : c.x < e && (c = new v(e,s.y + (e - s.x) / (c.x - s.x) * (c.y - s.y))._round()),
                            s.y < i && c.y < i || (s.y < i ? s = new v(s.x + (i - s.y) / (c.y - s.y) * (c.x - s.x),i)._round() : c.y < i && (c = new v(s.x + (i - s.y) / (c.y - s.y) * (c.x - s.x),i)._round()),
                            s.x >= n && c.x >= n || (s.x >= n ? s = new v(n,s.y + (n - s.x) / (c.x - s.x) * (c.y - s.y))._round() : c.x >= n && (c = new v(n,s.y + (n - s.x) / (c.x - s.x) * (c.y - s.y))._round()),
                            s.y >= r && c.y >= r || (s.y >= r ? s = new v(s.x + (r - s.y) / (c.y - s.y) * (c.x - s.x),r)._round() : c.y >= r && (c = new v(s.x + (r - s.y) / (c.y - s.y) * (c.x - s.x),r)._round()),
                            l && s.equals(l[l.length - 1]) || (l = [s],
                            o.push(l)),
                            l.push(c)))))
                        }
                    }
                    return o
                }
                Yr(Gd, "Anchor");
                const Jd = 1e20;
                function Qd(t, e, i, n, r, o, s, a, l) {
                    for (let c = e; c < e + n; c++)
                        tf(t, i * o + c, o, r, s, a, l);
                    for (let c = i; c < i + r; c++)
                        tf(t, c * o + e, 1, n, s, a, l)
                }
                function tf(t, e, i, n, r, o, s) {
                    o[0] = 0,
                    s[0] = -Jd,
                    s[1] = Jd,
                    r[0] = t[e];
                    for (let a = 1, l = 0, c = 0; a < n; a++) {
                        r[a] = t[e + a * i];
                        const n = a * a;
                        do {
                            const t = o[l];
                            c = (r[a] - r[t] + n - t * t) / (a - t) / 2
                        } while (c <= s[l] && --l > -1);
                        l++,
                        o[l] = a,
                        s[l] = c,
                        s[l + 1] = Jd
                    }
                    for (let a = 0, l = 0; a < n; a++) {
                        for (; s[l + 1] < a; )
                            l++;
                        const n = o[l]
                          , c = a - n;
                        t[e + a * i] = r[n] + c * c
                    }
                }
                const ef = 2
                  , nf = {
                    none: 0,
                    ideographs: 1,
                    all: 2
                };
                class rf {
                    constructor(t, e, i) {
                        this.requestManager = t,
                        this.localGlyphMode = e,
                        this.localFontFamily = i,
                        this.entries = {},
                        this.localGlyphs = {
                            200: {},
                            400: {},
                            500: {},
                            900: {}
                        }
                    }
                    setURL(t) {
                        this.url = t
                    }
                    getGlyphs(t, e) {
                        const i = [];
                        for (const e in t)
                            for (const n of t[e])
                                i.push({
                                    stack: e,
                                    id: n
                                });
                        k(i, ( ({stack: t, id: e}, i) => {
                            let n = this.entries[t];
                            n || (n = this.entries[t] = {
                                glyphs: {},
                                requests: {},
                                ranges: {},
                                ascender: void 0,
                                descender: void 0
                            });
                            let r = n.glyphs[e];
                            if (void 0 !== r)
                                return void i(null, {
                                    stack: t,
                                    id: e,
                                    glyph: r
                                });
                            if (r = this._tinySDF(n, t, e),
                            r)
                                return n.glyphs[e] = r,
                                void i(null, {
                                    stack: t,
                                    id: e,
                                    glyph: r
                                });
                            const o = Math.floor(e / 256);
                            if (256 * o > 65535)
                                return void i(new Error("glyphs > 65535 not supported"));
                            if (n.ranges[o])
                                return void i(null, {
                                    stack: t,
                                    id: e,
                                    glyph: r
                                });
                            let s = n.requests[o];
                            s || (s = n.requests[o] = [],
                            rf.loadGlyphRange(t, o, this.url, this.requestManager, ( (t, e) => {
                                if (e) {
                                    n.ascender = e.ascender,
                                    n.descender = e.descender;
                                    for (const t in e.glyphs)
                                        this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);
                                    n.ranges[o] = !0
                                }
                                for (const i of s)
                                    i(t, e);
                                delete n.requests[o]
                            }
                            ))),
                            s.push(( (n, r) => {
                                n ? i(n) : r && i(null, {
                                    stack: t,
                                    id: e,
                                    glyph: r.glyphs[e] || null
                                })
                            }
                            ))
                        }
                        ), ( (t, i) => {
                            if (t)
                                e(t);
                            else if (i) {
                                const t = {};
                                for (const {stack: e, id: n, glyph: r} of i)
                                    void 0 === t[e] && (t[e] = {}),
                                    void 0 === t[e].glyphs && (t[e].glyphs = {}),
                                    t[e].glyphs[n] = r && {
                                        id: r.id,
                                        bitmap: r.bitmap.clone(),
                                        metrics: r.metrics
                                    },
                                    t[e].ascender = this.entries[e].ascender,
                                    t[e].descender = this.entries[e].descender;
                                e(null, t)
                            }
                        }
                        ))
                    }
                    _doesCharSupportLocalGlyph(t) {
                        return this.localGlyphMode !== nf.none && (this.localGlyphMode === nf.all ? !!this.localFontFamily : !!this.localFontFamily && (eo["CJK Unified Ideographs"](t) || eo["Hangul Syllables"](t) || eo.Hiragana(t) || eo.Katakana(t) || eo["CJK Symbols and Punctuation"](t)))
                    }
                    _tinySDF(t, e, i) {
                        const n = this.localFontFamily;
                        if (!n || !this._doesCharSupportLocalGlyph(i))
                            return;
                        let r = t.tinySDF;
                        if (!r) {
                            let i = "400";
                            /bold/i.test(e) ? i = "900" : /medium/i.test(e) ? i = "500" : /light/i.test(e) && (i = "200"),
                            r = t.tinySDF = new rf.TinySDF({
                                fontFamily: n,
                                fontWeight: i,
                                fontSize: 24 * ef,
                                buffer: 3 * ef,
                                radius: 8 * ef
                            }),
                            r.fontWeight = i
                        }
                        if (this.localGlyphs[r.fontWeight][i])
                            return this.localGlyphs[r.fontWeight][i];
                        const o = String.fromCharCode(i)
                          , {data: s, width: a, height: l, glyphWidth: c, glyphHeight: h, glyphLeft: u, glyphTop: d, glyphAdvance: f} = r.draw(o);
                        return this.localGlyphs[r.fontWeight][i] = {
                            id: i,
                            bitmap: new Nc({
                                width: a,
                                height: l
                            },s),
                            metrics: {
                                width: c / ef,
                                height: h / ef,
                                left: u / ef,
                                top: d / ef - 27,
                                advance: f / ef,
                                localGlyph: !0
                            }
                        }
                    }
                }
                rf.loadGlyphRange = function(t, e, i, n, r) {
                    const o = 256 * e
                      , s = o + 255
                      , a = n.transformRequest(n.normalizeGlyphsURL(i).replace("{fontstack}", t).replace("{range}", `${o}-${s}`), ct.Glyphs);
                    ft(a, ( (t, e) => {
                        if (t)
                            r(t);
                        else if (e) {
                            const t = {}
                              , i = function(t) {
                                return new _d(t).readFields(vd, {})
                            }(e);
                            for (const e of i.glyphs)
                                t[e.id] = e;
                            r(null, {
                                glyphs: t,
                                ascender: i.ascender,
                                descender: i.descender
                            })
                        }
                    }
                    ))
                }
                ,
                rf.TinySDF = class {
                    constructor({fontSize: t=24, buffer: e=3, radius: i=8, cutoff: n=.25, fontFamily: r="sans-serif", fontWeight: o="normal", fontStyle: s="normal"}={}) {
                        this.buffer = e,
                        this.cutoff = n,
                        this.radius = i;
                        const a = this.size = t + 4 * e
                          , l = this._createCanvas(a)
                          , c = this.ctx = l.getContext("2d", {
                            willReadFrequently: !0
                        });
                        c.font = `${s} ${o} ${t}px ${r}`,
                        c.textBaseline = "alphabetic",
                        c.textAlign = "left",
                        c.fillStyle = "black",
                        this.gridOuter = new Float64Array(a * a),
                        this.gridInner = new Float64Array(a * a),
                        this.f = new Float64Array(a),
                        this.z = new Float64Array(a + 1),
                        this.v = new Uint16Array(a)
                    }
                    _createCanvas(t) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = t,
                        e
                    }
                    draw(t) {
                        const {width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: n, actualBoundingBoxLeft: r, actualBoundingBoxRight: o} = this.ctx.measureText(t)
                          , s = Math.ceil(i)
                          , a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - r)))
                          , l = Math.min(this.size - this.buffer, s + Math.ceil(n))
                          , c = a + 2 * this.buffer
                          , h = l + 2 * this.buffer
                          , u = Math.max(c * h, 0)
                          , d = new Uint8ClampedArray(u)
                          , f = {
                            data: d,
                            width: c,
                            height: h,
                            glyphWidth: a,
                            glyphHeight: l,
                            glyphTop: s,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                        if (0 === a || 0 === l)
                            return f;
                        const {ctx: p, buffer: m, gridInner: g, gridOuter: _} = this;
                        p.clearRect(m, m, a, l),
                        p.fillText(t, m, m + s);
                        const y = p.getImageData(m, m, a, l);
                        _.fill(Jd, 0, u),
                        g.fill(0, 0, u);
                        for (let t = 0; t < l; t++)
                            for (let e = 0; e < a; e++) {
                                const i = y.data[4 * (t * a + e) + 3] / 255;
                                if (0 === i)
                                    continue;
                                const n = (t + m) * c + e + m;
                                if (1 === i)
                                    _[n] = 0,
                                    g[n] = Jd;
                                else {
                                    const t = .5 - i;
                                    _[n] = t > 0 ? t * t : 0,
                                    g[n] = t < 0 ? t * t : 0
                                }
                            }
                        Qd(_, 0, 0, c, h, c, this.f, this.v, this.z),
                        Qd(g, m, m, a, l, c, this.f, this.v, this.z);
                        for (let t = 0; t < u; t++) {
                            const e = Math.sqrt(_[t]) - Math.sqrt(g[t]);
                            d[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff))
                        }
                        return f
                    }
                }
                ;
                const of = Td;
                function sf(t, e, i, n) {
                    const r = []
                      , o = t.image
                      , s = o.pixelRatio
                      , a = o.paddedRect.w - 2 * of
                      , l = o.paddedRect.h - 2 * of
                      , c = t.right - t.left
                      , h = t.bottom - t.top
                      , u = o.stretchX || [[0, a]]
                      , d = o.stretchY || [[0, l]]
                      , f = (t, e) => t + e[1] - e[0]
                      , p = u.reduce(f, 0)
                      , m = d.reduce(f, 0)
                      , g = a - p
                      , _ = l - m;
                    let y = 0
                      , x = p
                      , b = 0
                      , w = m
                      , E = 0
                      , T = g
                      , S = 0
                      , C = _;
                    if (o.content && n) {
                        const t = o.content;
                        y = af(u, 0, t[0]),
                        b = af(d, 0, t[1]),
                        x = af(u, t[0], t[2]),
                        w = af(d, t[1], t[3]),
                        E = t[0] - y,
                        S = t[1] - b,
                        T = t[2] - t[0] - x,
                        C = t[3] - t[1] - w
                    }
                    const A = (n, r, a, l) => {
                        const u = cf(n.stretch - y, x, c, t.left)
                          , d = hf(n.fixed - E, T, n.stretch, p)
                          , f = cf(r.stretch - b, w, h, t.top)
                          , g = hf(r.fixed - S, C, r.stretch, m)
                          , _ = cf(a.stretch - y, x, c, t.left)
                          , A = hf(a.fixed - E, T, a.stretch, p)
                          , I = cf(l.stretch - b, w, h, t.top)
                          , M = hf(l.fixed - S, C, l.stretch, m)
                          , P = new v(u,f)
                          , k = new v(_,f)
                          , O = new v(_,I)
                          , R = new v(u,I)
                          , D = new v(d / s,g / s)
                          , L = new v(A / s,M / s)
                          , B = e * Math.PI / 180;
                        if (B) {
                            const t = Math.sin(B)
                              , e = Math.cos(B)
                              , i = [e, -t, t, e];
                            P._matMult(i),
                            k._matMult(i),
                            R._matMult(i),
                            O._matMult(i)
                        }
                        const z = n.stretch + n.fixed
                          , F = r.stretch + r.fixed;
                        return {
                            tl: P,
                            tr: k,
                            bl: R,
                            br: O,
                            tex: {
                                x: o.paddedRect.x + of + z,
                                y: o.paddedRect.y + of + F,
                                w: a.stretch + a.fixed - z,
                                h: l.stretch + l.fixed - F
                            },
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: D,
                            pixelOffsetBR: L,
                            minFontScaleX: T / s / c,
                            minFontScaleY: C / s / h,
                            isSDF: i
                        }
                    }
                    ;
                    if (n && (o.stretchX || o.stretchY)) {
                        const t = lf(u, g, p)
                          , e = lf(d, _, m);
                        for (let i = 0; i < t.length - 1; i++) {
                            const n = t[i]
                              , o = t[i + 1];
                            for (let t = 0; t < e.length - 1; t++)
                                r.push(A(n, e[t], o, e[t + 1]))
                        }
                    } else
                        r.push(A({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: a + 1
                        }, {
                            fixed: 0,
                            stretch: l + 1
                        }));
                    return r
                }
                function af(t, e, i) {
                    let n = 0;
                    for (const r of t)
                        n += Math.max(e, Math.min(i, r[1])) - Math.max(e, Math.min(i, r[0]));
                    return n
                }
                function lf(t, e, i) {
                    const n = [{
                        fixed: -of,
                        stretch: 0
                    }];
                    for (const [e,i] of t) {
                        const t = n[n.length - 1];
                        n.push({
                            fixed: e - t.stretch,
                            stretch: t.stretch
                        }),
                        n.push({
                            fixed: e - t.stretch,
                            stretch: t.stretch + (i - e)
                        })
                    }
                    return n.push({
                        fixed: e + of,
                        stretch: i
                    }),
                    n
                }
                function cf(t, e, i, n) {
                    return t / e * i + n
                }
                function hf(t, e, i, n) {
                    return t - e * i / n
                }
                function uf(t, e, i, n) {
                    const r = e + t.positionedLines[n].lineOffset;
                    return 0 === n ? i + r / 2 : i + (r + (e + t.positionedLines[n - 1].lineOffset)) / 2
                }
                class df {
                    constructor(t=[], e=ff) {
                        if (this.data = t,
                        this.length = this.data.length,
                        this.compare = e,
                        this.length > 0)
                            for (let t = (this.length >> 1) - 1; t >= 0; t--)
                                this._down(t)
                    }
                    push(t) {
                        this.data.push(t),
                        this.length++,
                        this._up(this.length - 1)
                    }
                    pop() {
                        if (0 === this.length)
                            return;
                        const t = this.data[0]
                          , e = this.data.pop();
                        return this.length--,
                        this.length > 0 && (this.data[0] = e,
                        this._down(0)),
                        t
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(t) {
                        const {data: e, compare: i} = this
                          , n = e[t];
                        for (; t > 0; ) {
                            const r = t - 1 >> 1
                              , o = e[r];
                            if (i(n, o) >= 0)
                                break;
                            e[t] = o,
                            t = r
                        }
                        e[t] = n
                    }
                    _down(t) {
                        const {data: e, compare: i} = this
                          , n = this.length >> 1
                          , r = e[t];
                        for (; t < n; ) {
                            let n = 1 + (t << 1)
                              , o = e[n];
                            const s = n + 1;
                            if (s < this.length && i(e[s], o) < 0 && (n = s,
                            o = e[s]),
                            i(o, r) >= 0)
                                break;
                            e[t] = o,
                            t = n
                        }
                        e[t] = r
                    }
                }
                function ff(t, e) {
                    return t < e ? -1 : t > e ? 1 : 0
                }
                function pf(t, e=1, i=!1) {
                    let n = 1 / 0
                      , r = 1 / 0
                      , o = -1 / 0
                      , s = -1 / 0;
                    const a = t[0];
                    for (let t = 0; t < a.length; t++) {
                        const e = a[t];
                        (!t || e.x < n) && (n = e.x),
                        (!t || e.y < r) && (r = e.y),
                        (!t || e.x > o) && (o = e.x),
                        (!t || e.y > s) && (s = e.y)
                    }
                    const l = Math.min(o - n, s - r);
                    let c = l / 2;
                    const h = new df([],mf);
                    if (0 === l)
                        return new v(n,r);
                    for (let e = n; e < o; e += l)
                        for (let i = r; i < s; i += l)
                            h.push(new gf(e + c,i + c,c,t));
                    let u = function(t) {
                        let e = 0
                          , i = 0
                          , n = 0;
                        const r = t[0];
                        for (let t = 0, o = r.length, s = o - 1; t < o; s = t++) {
                            const o = r[t]
                              , a = r[s]
                              , l = o.x * a.y - a.x * o.y;
                            i += (o.x + a.x) * l,
                            n += (o.y + a.y) * l,
                            e += 3 * l
                        }
                        return new gf(i / e,n / e,0,t)
                    }(t)
                      , d = h.length;
                    for (; h.length; ) {
                        const n = h.pop();
                        (n.d > u.d || !u.d) && (u = n,
                        i && Math.round(1e4 * n.d)),
                        n.max - u.d <= e || (c = n.h / 2,
                        h.push(new gf(n.p.x - c,n.p.y - c,c,t)),
                        h.push(new gf(n.p.x + c,n.p.y - c,c,t)),
                        h.push(new gf(n.p.x - c,n.p.y + c,c,t)),
                        h.push(new gf(n.p.x + c,n.p.y + c,c,t)),
                        d += 4)
                    }
                    return i && u.d,
                    u.p
                }
                function mf(t, e) {
                    return e.max - t.max
                }
                class gf {
                    constructor(t, e, i, n) {
                        this.p = new v(t,e),
                        this.h = i,
                        this.d = function(t, e) {
                            let i = !1
                              , n = 1 / 0;
                            for (let r = 0; r < e.length; r++) {
                                const o = e[r];
                                for (let e = 0, r = o.length, s = r - 1; e < r; s = e++) {
                                    const r = o[e]
                                      , a = o[s];
                                    r.y > t.y != a.y > t.y && t.x < (a.x - r.x) * (t.y - r.y) / (a.y - r.y) + r.x && (i = !i),
                                    n = Math.min(n, vc(t, r, a))
                                }
                            }
                            return (i ? 1 : -1) * Math.sqrt(n)
                        }(this.p, n),
                        this.max = this.d + this.h * Math.SQRT2
                    }
                }
                const _f = 7
                  , yf = Number.POSITIVE_INFINITY
                  , vf = Math.sqrt(2);
                function xf(t, [e,i]) {
                    let n = 0
                      , r = 0;
                    if (i === yf) {
                        e < 0 && (e = 0);
                        const i = e / vf;
                        switch (t) {
                        case "top-right":
                        case "top-left":
                            r = i - _f;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            r = -i + _f;
                            break;
                        case "bottom":
                            r = -e + _f;
                            break;
                        case "top":
                            r = e - _f
                        }
                        switch (t) {
                        case "top-right":
                        case "bottom-right":
                            n = -i;
                            break;
                        case "top-left":
                        case "bottom-left":
                            n = i;
                            break;
                        case "left":
                            n = e;
                            break;
                        case "right":
                            n = -e
                        }
                    } else {
                        switch (e = Math.abs(e),
                        i = Math.abs(i),
                        t) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            r = i - _f;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            r = -i + _f
                        }
                        switch (t) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            n = -e;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            n = e
                        }
                    }
                    return [n, r]
                }
                function bf(t, e, i, n, r, o, s, a, l, c) {
                    t.createArrays(),
                    t.tilePixelRatio = la / (512 * t.overscaling),
                    t.compareText = {},
                    t.iconsNeedLinear = !1;
                    const h = t.layers[0].layout
                      , u = t.layers[0]._unevaluatedLayout._values
                      , d = {};
                    if ("composite" === t.textSizeData.kind) {
                        const {minZoom: e, maxZoom: i} = t.textSizeData;
                        d.compositeTextSizes = [u["text-size"].possiblyEvaluate(new Eo(e), a), u["text-size"].possiblyEvaluate(new Eo(i), a)]
                    }
                    if ("composite" === t.iconSizeData.kind) {
                        const {minZoom: e, maxZoom: i} = t.iconSizeData;
                        d.compositeIconSizes = [u["icon-size"].possiblyEvaluate(new Eo(e), a), u["icon-size"].possiblyEvaluate(new Eo(i), a)]
                    }
                    d.layoutTextSize = u["text-size"].possiblyEvaluate(new Eo(l + 1), a),
                    d.layoutIconSize = u["icon-size"].possiblyEvaluate(new Eo(l + 1), a),
                    d.textMaxSize = u["text-size"].possiblyEvaluate(new Eo(18), a);
                    const f = "map" === h.get("text-rotation-alignment") && "point" !== h.get("symbol-placement")
                      , p = h.get("text-size");
                    for (const o of t.features) {
                        const l = h.get("text-font").evaluate(o, {}, a).join(",")
                          , u = p.evaluate(o, {}, a)
                          , m = d.layoutTextSize.evaluate(o, {}, a)
                          , g = (d.layoutIconSize.evaluate(o, {}, a),
                        {
                            horizontal: {},
                            vertical: void 0
                        })
                          , _ = o.text;
                        let y, v = [0, 0];
                        if (_) {
                            const n = _.toString()
                              , s = h.get("text-letter-spacing").evaluate(o, {}, a) * Nu
                              , c = h.get("text-line-height").evaluate(o, {}, a) * Nu
                              , d = no(n) ? s : 0
                              , p = h.get("text-anchor").evaluate(o, {}, a)
                              , y = h.get("text-variable-anchor");
                            if (!y) {
                                const t = h.get("text-radial-offset").evaluate(o, {}, a);
                                v = t ? xf(p, [t * Nu, yf]) : h.get("text-offset").evaluate(o, {}, a).map((t => t * Nu))
                            }
                            let x = f ? "center" : h.get("text-justify").evaluate(o, {}, a);
                            const b = "point" === h.get("symbol-placement")
                              , w = b ? h.get("text-max-width").evaluate(o, {}, a) * Nu : 1 / 0
                              , E = o => {
                                t.allowVerticalPlacement && io(n) && (g.vertical = kd(_, e, i, r, l, w, c, p, o, d, v, Ad.vertical, !0, m, u))
                            }
                            ;
                            if (!f && y) {
                                const t = "auto" === x ? y.map((t => wf(t))) : [x];
                                let n = !1;
                                for (let o = 0; o < t.length; o++) {
                                    const s = t[o];
                                    if (!g.horizontal[s])
                                        if (n)
                                            g.horizontal[s] = g.horizontal[0];
                                        else {
                                            const t = kd(_, e, i, r, l, w, c, "center", s, d, v, Ad.horizontal, !1, m, u);
                                            t && (g.horizontal[s] = t,
                                            n = 1 === t.positionedLines.length)
                                        }
                                }
                                E("left")
                            } else {
                                if ("auto" === x && (x = wf(p)),
                                b || h.get("text-writing-mode").indexOf("horizontal") >= 0 || !io(n)) {
                                    const t = kd(_, e, i, r, l, w, c, p, x, d, v, Ad.horizontal, !1, m, u);
                                    t && (g.horizontal[x] = t)
                                }
                                E(b ? "left" : x)
                            }
                        }
                        let x = !1;
                        if (o.icon && o.icon.name) {
                            const e = n[o.icon.name];
                            e && (y = Ud(r[o.icon.name], h.get("icon-offset").evaluate(o, {}, a), h.get("icon-anchor").evaluate(o, {}, a)),
                            x = e.sdf,
                            void 0 === t.sdfIcons ? t.sdfIcons = e.sdf : t.sdfIcons !== e.sdf && q("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (e.pixelRatio !== t.pixelRatio || 0 !== h.get("icon-rotate").constantOr(1)) && (t.iconsNeedLinear = !0))
                        }
                        const b = Af(g.horizontal) || g.vertical;
                        t.iconsInText || (t.iconsInText = !!b && b.iconsInText),
                        (b || y) && Ef(t, o, g, y, n, d, m, 0, v, x, s, a, c)
                    }
                    o && t.generateCollisionDebugBuffers(l, t.collisionBoxArray)
                }
                function wf(t) {
                    switch (t) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function Ef(t, e, i, n, r, o, s, a, l, c, h, u, d) {
                    let f = o.textMaxSize.evaluate(e, {}, u);
                    void 0 === f && (f = s);
                    const p = t.layers[0].layout
                      , m = p.get("icon-offset").evaluate(e, {}, u)
                      , g = Af(i.horizontal) || i.vertical
                      , _ = "globe" === d.name
                      , y = Nu
                      , v = s / y
                      , x = t.tilePixelRatio * f / y
                      , b = (P = t.overscaling,
                    t.zoom > 18 && P > 2 && (P >>= 1),
                    Math.max(la / (512 * P), 1) * p.get("symbol-spacing"))
                      , E = p.get("text-padding") * t.tilePixelRatio
                      , T = p.get("icon-padding") * t.tilePixelRatio
                      , S = w(p.get("text-max-angle"))
                      , C = "map" === p.get("text-rotation-alignment") && "point" !== p.get("symbol-placement")
                      , A = "map" === p.get("icon-rotation-alignment") && "point" !== p.get("symbol-placement")
                      , I = p.get("symbol-placement")
                      , M = b / 2;
                    var P;
                    const k = p.get("icon-text-fit");
                    let O;
                    n && "none" !== k && (t.allowVerticalPlacement && i.vertical && (O = Vd(n, i.vertical, k, p.get("icon-text-fit-padding"), m, v)),
                    g && (n = Vd(n, g, k, p.get("icon-text-fit-padding"), m, v)));
                    const R = (s, a, f) => {
                        if (a.x < 0 || a.x >= la || a.y < 0 || a.y >= la)
                            return;
                        let p = null;
                        if (_) {
                            const {x: t, y: e, z: i} = d.projectTilePoint(a.x, a.y, f);
                            p = {
                                anchor: new Gd(t,e,i,0,void 0),
                                up: d.upVector(f, a.x, a.y)
                            }
                        }
                        !function(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v, x, b, w, E, T) {
                            const S = t.addToLineVertexArray(e, n);
                            let C, A, I, M, P, k, O, R = 0, D = 0, L = 0, B = 0, z = -1, F = -1;
                            const N = {};
                            let j = Os("");
                            const U = i ? i.anchor : e;
                            let V = 0
                              , G = 0;
                            if (void 0 === l._unevaluatedLayout.getValue("text-radial-offset") ? [V,G] = l.layout.get("text-offset").evaluate(x, {}, T).map((t => t * Nu)) : (V = l.layout.get("text-radial-offset").evaluate(x, {}, T) * Nu,
                            G = yf),
                            t.allowVerticalPlacement && r.vertical) {
                                const t = r.vertical;
                                if (p)
                                    k = Mf(t),
                                    a && (O = Mf(a));
                                else {
                                    const i = l.layout.get("text-rotate").evaluate(x, {}, T) + 90;
                                    I = If(c, U, e, h, u, d, t, f, i, m),
                                    a && (M = If(c, U, e, h, u, d, a, _, i))
                                }
                            }
                            if (o) {
                                const n = l.layout.get("icon-rotate").evaluate(x, {}, T)
                                  , r = "none" !== l.layout.get("icon-text-fit")
                                  , s = sf(o, n, w, r)
                                  , f = a ? sf(a, n, w, r) : void 0;
                                A = If(c, U, e, h, u, d, o, _, n),
                                R = 4 * s.length;
                                const p = t.iconSizeData;
                                let m = null;
                                "source" === p.kind ? (m = [ju * l.layout.get("icon-size").evaluate(x, {}, T)],
                                m[0] > Sf && q(`${t.layerIds[0]}: Value for "icon-size" is >= ${Tf}. Reduce your "icon-size".`)) : "composite" === p.kind && (m = [ju * b.compositeIconSizes[0].evaluate(x, {}, T), ju * b.compositeIconSizes[1].evaluate(x, {}, T)],
                                (m[0] > Sf || m[1] > Sf) && q(`${t.layerIds[0]}: Value for "icon-size" is >= ${Tf}. Reduce your "icon-size".`)),
                                t.addSymbols(t.icon, s, m, v, y, x, !1, i, e, S.lineStartIndex, S.lineLength, -1, E, T),
                                z = t.icon.placedSymbolArray.length - 1,
                                f && (D = 4 * f.length,
                                t.addSymbols(t.icon, f, m, v, y, x, Ad.vertical, i, e, S.lineStartIndex, S.lineLength, -1, E, T),
                                F = t.icon.placedSymbolArray.length - 1)
                            }
                            for (const n in r.horizontal) {
                                const o = r.horizontal[n];
                                C || (j = Os(o.text),
                                p ? P = Mf(o) : C = If(c, U, e, h, u, d, o, f, l.layout.get("text-rotate").evaluate(x, {}, T), m));
                                const a = 1 === o.positionedLines.length;
                                if (L += Cf(t, i, e, o, s, l, p, x, m, S, r.vertical ? Ad.horizontal : Ad.horizontalOnly, a ? Object.keys(r.horizontal) : [n], N, z, b, E, T),
                                a)
                                    break
                            }
                            r.vertical && (B += Cf(t, i, e, r.vertical, s, l, p, x, m, S, Ad.vertical, ["vertical"], N, F, b, E, T));
                            let Z = -1;
                            const W = (t, e) => t ? Math.max(t, e) : e;
                            Z = W(P, Z),
                            Z = W(k, Z),
                            Z = W(O, Z);
                            const H = Z > -1 ? 1 : 0;
                            t.glyphOffsetArray.length >= lp.MAX_GLYPHS && q("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            void 0 !== x.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, x.sortKey),
                            t.symbolInstances.emplaceBack(U.x, U.y, U.z, e.x, e.y, N.right >= 0 ? N.right : -1, N.center >= 0 ? N.center : -1, N.left >= 0 ? N.left : -1, N.vertical >= 0 ? N.vertical : -1, z, F, j, void 0 !== C ? C : t.collisionBoxArray.length, void 0 !== C ? C + 1 : t.collisionBoxArray.length, void 0 !== I ? I : t.collisionBoxArray.length, void 0 !== I ? I + 1 : t.collisionBoxArray.length, void 0 !== A ? A : t.collisionBoxArray.length, void 0 !== A ? A + 1 : t.collisionBoxArray.length, M || t.collisionBoxArray.length, M ? M + 1 : t.collisionBoxArray.length, h, L, B, R, D, H, 0, V, G, Z)
                        }(t, a, p, s, i, n, r, O, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, E, C, l, 0, T, A, m, e, o, c, h, u)
                    }
                    ;
                    if ("line" === I)
                        for (const r of Kd(e.geometry, 0, 0, la, la)) {
                            const e = Xd(r, b, S, i.vertical || g, n, y, x, t.overscaling, la);
                            for (const i of e)
                                g && Pf(t, g.text, M, i) || R(r, i, u)
                        }
                    else if ("line-center" === I) {
                        for (const t of e.geometry)
                            if (t.length > 1) {
                                const e = $d(t, S, i.vertical || g, n, y, x);
                                e && R(t, e, u)
                            }
                    } else if ("Polygon" === e.type)
                        for (const t of Th(e.geometry, 0)) {
                            const e = pf(t, 16);
                            R(t[0], new Gd(e.x,e.y,0,0,void 0), u)
                        }
                    else if ("LineString" === e.type)
                        for (const t of e.geometry)
                            R(t, new Gd(t[0].x,t[0].y,0,0,void 0), u);
                    else if ("Point" === e.type)
                        for (const t of e.geometry)
                            for (const e of t)
                                R([e], new Gd(e.x,e.y,0,0,void 0), u)
                }
                const Tf = 255
                  , Sf = Tf * ju;
                function Cf(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g) {
                    const _ = function(t, e, i, n, r, o, s, a) {
                        const l = [];
                        if (0 === e.positionedLines.length)
                            return l;
                        const c = n.layout.get("text-rotate").evaluate(o, {}) * Math.PI / 180
                          , h = function(t) {
                            const e = t[0]
                              , i = t[1]
                              , n = e * i;
                            return n > 0 ? [e, -i] : n < 0 ? [-e, i] : 0 === e ? [i, e] : [i, -e]
                        }(i);
                        let u = Math.abs(e.top - e.bottom);
                        for (const t of e.positionedLines)
                            u -= t.lineOffset;
                        const d = e.positionedLines.length
                          , f = u / d;
                        let p = e.top - i[1];
                        for (let t = 0; t < d; ++t) {
                            const n = e.positionedLines[t];
                            p = uf(e, f, p, t);
                            for (const t of n.positionedGlyphs) {
                                if (!t.rect)
                                    continue;
                                const n = t.rect || {};
                                let o = wd + 1
                                  , u = !0
                                  , d = 1
                                  , f = 0;
                                if (t.imageName) {
                                    const e = s[t.imageName];
                                    if (!e)
                                        continue;
                                    if (e.sdf) {
                                        q("SDF images are not supported in formatted text and will be ignored.");
                                        continue
                                    }
                                    u = !1,
                                    d = e.pixelRatio,
                                    o = Td / d
                                }
                                const m = (r || a) && t.vertical
                                  , g = t.metrics.advance * t.scale / 2
                                  , _ = t.metrics
                                  , y = t.rect;
                                if (null === y)
                                    continue;
                                a && e.verticalizable && (f = t.imageName ? g - t.metrics.width * t.scale / 2 : 0);
                                const x = r ? [t.x + g, t.y] : [0, 0];
                                let b = [0, 0]
                                  , w = [0, 0]
                                  , E = !1;
                                r || (m ? (w = [t.x + g + h[0], t.y + h[1] - f],
                                E = !0) : b = [t.x + g + i[0], t.y + i[1] - f]);
                                const T = y.w * t.scale / (d * (t.localGlyph ? ef : 1))
                                  , S = y.h * t.scale / (d * (t.localGlyph ? ef : 1));
                                let C, A, I, M;
                                if (m) {
                                    const e = t.y - p
                                      , i = new v(-g,g - e)
                                      , n = -Math.PI / 2
                                      , r = new v(...w);
                                    C = new v(-g + b[0],b[1]),
                                    C._rotateAround(n, i)._add(r),
                                    C.x += -e + g,
                                    C.y -= (_.left - o) * t.scale;
                                    const s = t.imageName ? _.advance * t.scale : Nu * t.scale
                                      , a = String.fromCharCode(t.glyph);
                                    Hu(a) ? C.x += (1 - o) * t.scale : $u(a) ? C.x += s - _.height * t.scale + (-o - 1) * t.scale : C.x += t.imageName || _.width + 2 * o === y.w && _.height + 2 * o === y.h ? (s - S) / 2 : (s - (_.height + 2 * o) * t.scale) / 2,
                                    A = new v(C.x,C.y - T),
                                    I = new v(C.x + S,C.y),
                                    M = new v(C.x + S,C.y - T)
                                } else {
                                    const e = (_.left - o) * t.scale - g + b[0]
                                      , i = (-_.top - o) * t.scale + b[1]
                                      , n = e + T
                                      , r = i + S;
                                    C = new v(e,i),
                                    A = new v(n,i),
                                    I = new v(e,r),
                                    M = new v(n,r)
                                }
                                if (c) {
                                    let t;
                                    t = r ? new v(0,0) : E ? new v(h[0],h[1]) : new v(i[0],i[1]),
                                    C._rotateAround(c, t),
                                    A._rotateAround(c, t),
                                    I._rotateAround(c, t),
                                    M._rotateAround(c, t)
                                }
                                const P = new v(0,0)
                                  , k = new v(0,0);
                                l.push({
                                    tl: C,
                                    tr: A,
                                    bl: I,
                                    br: M,
                                    tex: n,
                                    writingMode: e.writingMode,
                                    glyphOffset: x,
                                    sectionIndex: t.sectionIndex,
                                    isSDF: u,
                                    pixelOffsetTL: P,
                                    pixelOffsetBR: k,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        }
                        return l
                    }(0, n, l, o, s, a, r, t.allowVerticalPlacement)
                      , y = t.textSizeData;
                    let x = null;
                    "source" === y.kind ? (x = [ju * o.layout.get("text-size").evaluate(a, {}, g)],
                    x[0] > Sf && q(`${t.layerIds[0]}: Value for "text-size" is >= ${Tf}. Reduce your "text-size".`)) : "composite" === y.kind && (x = [ju * p.compositeTextSizes[0].evaluate(a, {}, g), ju * p.compositeTextSizes[1].evaluate(a, {}, g)],
                    (x[0] > Sf || x[1] > Sf) && q(`${t.layerIds[0]}: Value for "text-size" is >= ${Tf}. Reduce your "text-size".`)),
                    t.addSymbols(t.text, _, x, l, s, a, h, e, i, c.lineStartIndex, c.lineLength, f, m, g);
                    for (const e of u)
                        d[e] = t.text.placedSymbolArray.length - 1;
                    return 4 * _.length
                }
                function Af(t) {
                    for (const e in t)
                        return t[e];
                    return null
                }
                function If(t, e, i, n, r, o, s, a, l, c) {
                    let h = s.top
                      , u = s.bottom
                      , d = s.left
                      , f = s.right;
                    const p = s.collisionPadding;
                    if (p && (d -= p[0],
                    h -= p[1],
                    f += p[2],
                    u += p[3]),
                    l) {
                        const t = new v(d,h)
                          , e = new v(f,h)
                          , i = new v(d,u)
                          , n = new v(f,u)
                          , r = w(l);
                        let o = new v(0,0);
                        c && (o = new v(c[0],c[1])),
                        t._rotateAround(r, o),
                        e._rotateAround(r, o),
                        i._rotateAround(r, o),
                        n._rotateAround(r, o),
                        d = Math.min(t.x, e.x, i.x, n.x),
                        f = Math.max(t.x, e.x, i.x, n.x),
                        h = Math.min(t.y, e.y, i.y, n.y),
                        u = Math.max(t.y, e.y, i.y, n.y)
                    }
                    return t.emplaceBack(e.x, e.y, e.z, i.x, i.y, d, h, f, u, a, n, r, o),
                    t.length - 1
                }
                function Mf(t) {
                    t.collisionPadding && (t.top -= t.collisionPadding[1],
                    t.bottom += t.collisionPadding[3]);
                    const e = t.bottom - t.top;
                    return e > 0 ? Math.max(10, e) : null
                }
                function Pf(t, e, i, n) {
                    const r = t.compareText;
                    if (e in r) {
                        const t = r[e];
                        for (let e = t.length - 1; e >= 0; e--)
                            if (n.dist(t[e]) < i)
                                return !0
                    } else
                        r[e] = [];
                    return r[e].push(n),
                    !1
                }
                function kf(t, e) {
                    const i = t.fovAboveCenter
                      , n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0
                      , r = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch)
                      , o = Math.sin(i) * r / Math.sin(Math.max(Math.PI / 2 - t._pitch - i, .01))
                      , s = Math.sin(t._pitch) * o + r;
                    return Math.min(1.01 * s, r * (1 / t._horizonShift))
                }
                function Of(t, e) {
                    if (!e.isReprojectedInTileSpace)
                        return {
                            scale: 1 << t.z,
                            x: t.x,
                            y: t.y,
                            x2: t.x + 1,
                            y2: t.y + 1,
                            projection: e
                        };
                    const i = Math.pow(2, -t.z)
                      , n = t.x * i
                      , r = (t.x + 1) * i
                      , o = t.y * i
                      , s = (t.y + 1) * i
                      , a = $l(n)
                      , l = $l(r)
                      , c = Xl(o)
                      , h = Xl(s)
                      , u = e.project(a, c)
                      , d = e.project(l, c)
                      , f = e.project(l, h)
                      , p = e.project(a, h);
                    let m = Math.min(u.x, d.x, f.x, p.x)
                      , g = Math.min(u.y, d.y, f.y, p.y)
                      , _ = Math.max(u.x, d.x, f.x, p.x)
                      , y = Math.max(u.y, d.y, f.y, p.y);
                    const v = i / 16;
                    function x(t, i, n, r, o, s) {
                        const a = (n + o) / 2
                          , l = (r + s) / 2
                          , c = e.project($l(a), Xl(l))
                          , h = Math.max(0, m - c.x, g - c.y, c.x - _, c.y - y);
                        m = Math.min(m, c.x),
                        _ = Math.max(_, c.x),
                        g = Math.min(g, c.y),
                        y = Math.max(y, c.y),
                        h > v && (x(t, c, n, r, a, l),
                        x(c, i, a, l, o, s))
                    }
                    x(u, d, n, o, r, o),
                    x(d, f, r, o, r, s),
                    x(f, p, r, s, n, s),
                    x(p, u, n, s, n, o),
                    m -= v,
                    g -= v,
                    _ += v,
                    y += v;
                    const b = 1 / Math.max(_ - m, y - g);
                    return {
                        scale: b,
                        x: m * b,
                        y: g * b,
                        x2: _ * b,
                        y2: y * b,
                        projection: e
                    }
                }
                const Rf = pa(new Float32Array(16));
                class Df {
                    constructor(t) {
                        this.spec = t,
                        this.name = t.name,
                        this.wrap = !1,
                        this.requiresDraping = !1,
                        this.supportsWorldCopies = !1,
                        this.supportsTerrain = !1,
                        this.supportsFog = !1,
                        this.supportsFreeCamera = !1,
                        this.zAxisUnit = "meters",
                        this.isReprojectedInTileSpace = !0,
                        this.unsupportedLayers = ["custom"],
                        this.center = [0, 0],
                        this.range = [3.5, 7]
                    }
                    project(t, e) {
                        return {
                            x: 0,
                            y: 0,
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        return new Gl(0,0)
                    }
                    projectTilePoint(t, e, i) {
                        return {
                            x: t,
                            y: e,
                            z: 0
                        }
                    }
                    locationPoint(t, e, i=!0) {
                        return t._coordinatePoint(t.locationCoordinate(e), i)
                    }
                    pixelsPerMeter(t, e) {
                        return Hl(1, t) * e
                    }
                    pixelSpaceConversion(t, e, i) {
                        return 1
                    }
                    farthestPixelDistance(t) {
                        return kf(t, t.pixelsPerMeter)
                    }
                    pointCoordinate(t, e, i, n) {
                        const r = t.horizonLineFromTop(!1)
                          , o = new v(e,Math.max(r, i));
                        return t.rayIntersectionCoordinate(t.pointRayIntersection(o, n))
                    }
                    pointCoordinate3D(t, e, i) {
                        const n = new v(e,i);
                        if (t.elevation)
                            return t.elevation.pointCoordinate(n);
                        {
                            const e = this.pointCoordinate(t, n.x, n.y, 0);
                            return [e.x, e.y, e.z]
                        }
                    }
                    isPointAboveHorizon(t, e) {
                        if (t.elevation)
                            return !this.pointCoordinate3D(t, e.x, e.y);
                        const i = t.horizonLineFromTop();
                        return e.y < i
                    }
                    createInversionMatrix(t, e) {
                        return Rf
                    }
                    createTileMatrix(t, e, i) {
                        let n, r, o;
                        const s = i.canonical
                          , a = pa(new Float64Array(16));
                        if (this.isReprojectedInTileSpace) {
                            const l = Of(s, this);
                            n = 1,
                            r = l.x + i.wrap * l.scale,
                            o = l.y,
                            ya(a, a, [n / l.scale, n / l.scale, t.pixelsPerMeter / e])
                        } else
                            n = e / t.zoomScale(s.z),
                            r = (s.x + Math.pow(2, s.z) * i.wrap) * n,
                            o = s.y * n;
                        return _a(a, a, [r, o, 0]),
                        ya(a, a, [n / la, n / la, 1]),
                        a
                    }
                    upVector(t, e, i) {
                        return [0, 0, 1]
                    }
                    upVectorScale(t, e, i) {
                        return {
                            metersToTile: 1
                        }
                    }
                }
                class Lf extends Df {
                    constructor(t) {
                        super(t),
                        this.range = [4, 7],
                        this.center = t.center || [-96, 37.5];
                        const [e,i] = this.parallels = t.parallels || [29.5, 45.5]
                          , n = Math.sin(w(e));
                        this.n = (n + Math.sin(w(i))) / 2,
                        this.c = 1 + n * (2 * this.n - n),
                        this.r0 = Math.sqrt(this.c) / this.n
                    }
                    project(t, e) {
                        const {n: i, c: n, r0: r} = this
                          , o = w(t - this.center[0])
                          , s = w(e)
                          , a = Math.sqrt(n - 2 * i * Math.sin(s)) / i;
                        return {
                            x: a * Math.sin(o * i),
                            y: a * Math.cos(o * i) - r,
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        const {n: i, c: n, r0: r} = this
                          , o = r + e;
                        let s = Math.atan2(t, Math.abs(o)) * Math.sign(o);
                        o * i < 0 && (s -= Math.PI * Math.sign(t) * Math.sign(o));
                        const a = w(this.center[0]) * i;
                        s = P(s, -Math.PI - a, Math.PI - a);
                        const l = I(E(s / i) + this.center[0], -180, 180)
                          , c = Math.asin(I((n - (t * t + o * o) * i * i) / (2 * i), -1, 1))
                          , h = I(E(c), -Kl, Kl);
                        return new Gl(l,h)
                    }
                }
                const Bf = 1.340264
                  , zf = -.081106
                  , Ff = 893e-6
                  , Nf = .003796
                  , jf = Math.sqrt(3) / 2;
                class Uf extends Df {
                    project(t, e) {
                        e = e / 180 * Math.PI,
                        t = t / 180 * Math.PI;
                        const i = Math.asin(jf * Math.sin(e))
                          , n = i * i
                          , r = n * n * n;
                        return {
                            x: .5 * (t * Math.cos(i) / (jf * (Bf + 3 * zf * n + r * (7 * Ff + 9 * Nf * n))) / Math.PI + .5),
                            y: 1 - .5 * (i * (Bf + zf * n + r * (Ff + Nf * n)) / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        t = (2 * t - .5) * Math.PI;
                        let i = e = (2 * (1 - e) - 1) * Math.PI
                          , n = i * i
                          , r = n * n * n;
                        for (let t, o, s, a = 0; a < 12 && (o = i * (Bf + zf * n + r * (Ff + Nf * n)) - e,
                        s = Bf + 3 * zf * n + r * (7 * Ff + 9 * Nf * n),
                        t = o / s,
                        i = I(i - t, -Math.PI / 3, Math.PI / 3),
                        n = i * i,
                        r = n * n * n,
                        !(Math.abs(t) < 1e-12)); ++a)
                            ;
                        const o = jf * t * (Bf + 3 * zf * n + r * (7 * Ff + 9 * Nf * n)) / Math.cos(i)
                          , s = Math.asin(Math.sin(i) / jf)
                          , a = I(180 * o / Math.PI, -180, 180)
                          , l = I(180 * s / Math.PI, -Kl, Kl);
                        return new Gl(a,l)
                    }
                }
                class Vf extends Df {
                    constructor(t) {
                        super(t),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0
                    }
                    project(t, e) {
                        return {
                            x: .5 + t / 360,
                            y: .5 - e / 360,
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        const i = 360 * (t - .5)
                          , n = I(360 * (.5 - e), -Kl, Kl);
                        return new Gl(i,n)
                    }
                }
                const Gf = Math.PI / 2;
                function Zf(t) {
                    return Math.tan((Gf + t) / 2)
                }
                class qf extends Df {
                    constructor(t) {
                        super(t),
                        this.center = t.center || [0, 30];
                        const [e,i] = this.parallels = t.parallels || [30, 30];
                        let n = w(e)
                          , r = w(i);
                        this.southernCenter = n + r < 0,
                        this.southernCenter && (n = -n,
                        r = -r);
                        const o = Math.cos(n)
                          , s = Zf(n);
                        this.n = n === r ? Math.sin(n) : Math.log(o / Math.cos(r)) / Math.log(Zf(r) / s),
                        this.f = o * Math.pow(Zf(n), this.n) / this.n
                    }
                    project(t, e) {
                        e = w(e),
                        this.southernCenter && (e = -e),
                        t = w(t - this.center[0]);
                        const i = 1e-6
                          , {n: n, f: r} = this;
                        r > 0 ? e < -Gf + i && (e = -Gf + i) : e > Gf - i && (e = Gf - i);
                        const o = r / Math.pow(Zf(e), n);
                        let s = o * Math.sin(n * t)
                          , a = r - o * Math.cos(n * t);
                        return s = .5 * (s / Math.PI + .5),
                        a = .5 * (a / Math.PI + .5),
                        {
                            x: s,
                            y: this.southernCenter ? a : 1 - a,
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        t = (2 * t - .5) * Math.PI,
                        this.southernCenter && (e = 1 - e),
                        e = (2 * (1 - e) - .5) * Math.PI;
                        const {n: i, f: n} = this
                          , r = n - e
                          , o = Math.sign(r)
                          , s = Math.sign(i) * Math.sqrt(t * t + r * r);
                        let a = Math.atan2(t, Math.abs(r)) * o;
                        r * i < 0 && (a -= Math.PI * Math.sign(t) * o);
                        const l = I(E(a / i) + this.center[0], -180, 180)
                          , c = I(E(2 * Math.atan(Math.pow(n / s, 1 / i)) - Gf), -Kl, Kl);
                        return new Gl(l,this.southernCenter ? -c : c)
                    }
                }
                class Wf extends Df {
                    constructor(t) {
                        super(t),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0,
                        this.supportsTerrain = !0,
                        this.supportsFog = !0,
                        this.supportsFreeCamera = !0,
                        this.isReprojectedInTileSpace = !1,
                        this.unsupportedLayers = [],
                        this.range = null
                    }
                    project(t, e) {
                        return {
                            x: ql(t),
                            y: Wl(e),
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        const i = $l(t)
                          , n = Xl(e);
                        return new Gl(i,n)
                    }
                }
                const Hf = w(Kl);
                class $f extends Df {
                    project(t, e) {
                        const i = (e = w(e)) * e
                          , n = i * i;
                        return {
                            x: .5 * ((t = w(t)) * (.8707 - .131979 * i + n * (n * (.003971 * i - .001529 * n) - .013791)) / Math.PI + .5),
                            y: 1 - .5 * (e * (1.007226 + i * (.015085 + n * (.028874 * i - .044475 - .005916 * n))) / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        t = (2 * t - .5) * Math.PI;
                        let i = e = (2 * (1 - e) - 1) * Math.PI
                          , n = 25
                          , r = 0
                          , o = i * i;
                        do {
                            o = i * i;
                            const t = o * o;
                            r = (i * (1.007226 + o * (.015085 + t * (.028874 * o - .044475 - .005916 * t))) - e) / (1.007226 + o * (.045255 + t * (.259866 * o - .311325 - .005916 * 11 * t))),
                            i = I(i - r, -Hf, Hf)
                        } while (Math.abs(r) > 1e-6 && --n > 0);
                        o = i * i;
                        const s = I(E(t / (.8707 + o * (o * (o * o * o * (.003971 - .001529 * o) - .013791) - .131979))), -180, 180)
                          , a = E(i);
                        return new Gl(s,a)
                    }
                }
                const Xf = w(Kl);
                class Yf extends Df {
                    project(t, e) {
                        e = w(e),
                        t = w(t);
                        const i = Math.cos(e)
                          , n = 2 / Math.PI
                          , r = Math.acos(i * Math.cos(t / 2))
                          , o = Math.sin(r) / r
                          , s = .5 * (t * n + 2 * i * Math.sin(t / 2) / o) || 0
                          , a = .5 * (e + Math.sin(e) / o) || 0;
                        return {
                            x: .5 * (s / Math.PI + .5),
                            y: 1 - .5 * (a / Math.PI + 1),
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        let i = t = (2 * t - .5) * Math.PI
                          , n = e = (2 * (1 - e) - 1) * Math.PI
                          , r = 25;
                        const o = 1e-6;
                        let s = 0
                          , a = 0;
                        do {
                            const r = Math.cos(n)
                              , o = Math.sin(n)
                              , l = 2 * o * r
                              , c = o * o
                              , h = r * r
                              , u = Math.cos(i / 2)
                              , d = Math.sin(i / 2)
                              , f = 2 * u * d
                              , p = d * d
                              , m = 1 - h * u * u
                              , g = m ? 1 / m : 0
                              , _ = m ? Math.acos(r * u) * Math.sqrt(1 / m) : 0
                              , y = .5 * (2 * _ * r * d + 2 * i / Math.PI) - t
                              , v = .5 * (_ * o + n) - e
                              , x = .5 * g * (h * p + _ * r * u * c) + 1 / Math.PI
                              , b = g * (f * l / 4 - _ * o * d)
                              , w = .125 * g * (l * d - _ * o * h * f)
                              , E = .5 * g * (c * u + _ * p * r) + .5
                              , T = b * w - E * x;
                            s = (v * b - y * E) / T,
                            a = (y * w - v * x) / T,
                            i = I(i - s, -Math.PI, Math.PI),
                            n = I(n - a, -Xf, Xf)
                        } while ((Math.abs(s) > o || Math.abs(a) > o) && --r > 0);
                        return new Gl(E(i),E(n))
                    }
                }
                class Kf extends Df {
                    constructor(t) {
                        super(t),
                        this.center = t.center || [0, 0],
                        this.parallels = t.parallels || [0, 0],
                        this.cosPhi = Math.max(.01, Math.cos(w(this.parallels[0]))),
                        this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)),
                        this.wrap = !0,
                        this.supportsWorldCopies = !0
                    }
                    project(t, e) {
                        const {scale: i, cosPhi: n} = this;
                        return {
                            x: w(t) * n * i + .5,
                            y: -Math.sin(w(e)) / n * i + .5,
                            z: 0
                        }
                    }
                    unproject(t, e) {
                        const {scale: i, cosPhi: n} = this
                          , r = -(e - .5) / i
                          , o = I(E((t - .5) / i) / n, -180, 180)
                          , s = Math.asin(I(r * n, -1, 1))
                          , a = I(E(s), -Kl, Kl);
                        return new Gl(o,a)
                    }
                }
                class Jf extends Wf {
                    constructor(t) {
                        super(t),
                        this.requiresDraping = !0,
                        this.supportsWorldCopies = !1,
                        this.supportsFog = !0,
                        this.zAxisUnit = "pixels",
                        this.unsupportedLayers = ["debug"],
                        this.range = [3, 5]
                    }
                    projectTilePoint(t, e, i) {
                        const n = Il(t, e, i);
                        return Fa(n, n, kl(vl(i))),
                        {
                            x: n[0],
                            y: n[1],
                            z: n[2]
                        }
                    }
                    locationPoint(t, e) {
                        const i = Al(e.lat, e.lng)
                          , n = La([], i)
                          , r = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude;
                        Da(i, i, n, Hl(1, 0) * la * r);
                        const o = pa(new Float64Array(16));
                        return ga(o, t.pixelMatrix, t.globeMatrix),
                        Fa(i, i, o),
                        new v(i[0],i[1])
                    }
                    pixelsPerMeter(t, e) {
                        return Hl(1, 0) * e
                    }
                    pixelSpaceConversion(t, e, i) {
                        const n = Hl(1, t) * e
                          , r = Oi(Hl(1, 45) * e, n, i);
                        return this.pixelsPerMeter(t, e) / r
                    }
                    createTileMatrix(t, e, i) {
                        const n = Ol(vl(i.canonical));
                        return ga(new Float64Array(16), t.globeMatrix, n)
                    }
                    createInversionMatrix(t, e) {
                        const {center: i} = t
                          , n = kl(vl(e));
                        return xa(n, n, w(i.lng)),
                        va(n, n, w(i.lat)),
                        ya(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]),
                        Float32Array.from(n)
                    }
                    pointCoordinate(t, e, i, n) {
                        return gl(t, e, i, !0) || new Ql(0,0)
                    }
                    pointCoordinate3D(t, e, i) {
                        const n = this.pointCoordinate(t, e, i, 0);
                        return [n.x, n.y, n.z]
                    }
                    isPointAboveHorizon(t, e) {
                        return !gl(t, e.x, e.y, !1)
                    }
                    farthestPixelDistance(t) {
                        const e = function(t, e) {
                            const i = t.cameraToCenterDistance
                              , n = t._centerAltitude * e
                              , r = t._camera
                              , o = t._camera.forward()
                              , s = Ia([], Ra([], o, -i), [0, 0, n])
                              , a = t.worldSize / (2 * Math.PI)
                              , l = [0, 0, -a]
                              , c = t.width / t.height
                              , h = Math.tan(t.fovAboveCenter)
                              , u = Ra([], r.up(), h)
                              , d = Ra([], r.right(), h * c)
                              , f = La([], Ia([], Ia([], o, u), d))
                              , p = [];
                            let m;
                            if (new il(s,f).closestPointOnSphere(l, a, p)) {
                                const e = Ia([], p, l)
                                  , i = Ua([], e, s);
                                m = Math.cos(t.fovAboveCenter) * Ca(i)
                            } else {
                                const t = Ua([], s, l)
                                  , e = Ua([], l, s);
                                La(e, e);
                                const i = Ca(t) - a;
                                m = Math.sqrt(i * (i + 2 * a));
                                const n = Math.acos(m / (a + i)) - Math.acos(Ba(o, e));
                                m *= Math.cos(n)
                            }
                            return 1.01 * m
                        }(t, this.pixelsPerMeter(t.center.lat, t.worldSize))
                          , i = Dl(t.zoom);
                        if (i > 0) {
                            const n = kf(t, Hl(1, t.center.lat) * t.worldSize)
                              , r = t.worldSize / (2 * Math.PI)
                              , o = Math.max(t.width, t.height) / t.worldSize * Math.PI;
                            return Oi(e, n + r * (1 - Math.cos(o)), Math.pow(i, 10))
                        }
                        return e
                    }
                    upVector(t, e, i) {
                        return Il(e, i, t, 1)
                    }
                    upVectorScale(t) {
                        return {
                            metersToTile: ml(Ml(vl(t)))
                        }
                    }
                }
                function Qf(t) {
                    const e = t.parallels
                      , i = !!e && Math.abs(e[0] + e[1]) < .01;
                    switch (t.name) {
                    case "mercator":
                        return new Wf(t);
                    case "equirectangular":
                        return new Vf(t);
                    case "naturalEarth":
                        return new $f(t);
                    case "equalEarth":
                        return new Uf(t);
                    case "winkelTripel":
                        return new Yf(t);
                    case "albers":
                        return i ? new Kf(t) : new Lf(t);
                    case "lambertConformalConic":
                        return i ? new Kf(t) : new qf(t);
                    case "globe":
                        return new Jf(t)
                    }
                    throw new Error(`Invalid projection name: ${t.name}`)
                }
                const tp = $h.types
                  , ep = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function ip(t, e, i, n, r, o, s, a, l, c, h, u, d) {
                    const f = a ? Math.min(Sf, Math.round(a[0])) : 0
                      , p = a ? Math.min(Sf, Math.round(a[1])) : 0;
                    t.emplaceBack(e, i, Math.round(32 * n), Math.round(32 * r), o, s, (f << 1) + (l ? 1 : 0), p, 16 * c, 16 * h, 256 * u, 256 * d)
                }
                function np(t, e, i, n, r, o, s) {
                    t.emplaceBack(e, i, n, r, o, s)
                }
                function rp(t, e, i, n, r) {
                    t.emplaceBack(e, i, n, r),
                    t.emplaceBack(e, i, n, r),
                    t.emplaceBack(e, i, n, r),
                    t.emplaceBack(e, i, n, r)
                }
                function op(t) {
                    for (const e of t.sections)
                        if (co(e.text))
                            return !0;
                    return !1
                }
                class sp {
                    constructor(t) {
                        this.layoutVertexArray = new Yo,
                        this.indexArray = new rs,
                        this.programConfigurations = t,
                        this.segments = new aa,
                        this.dynamicLayoutVertexArray = new Wo,
                        this.opacityVertexArray = new Jo,
                        this.placedSymbolArray = new gs,
                        this.globeExtVertexArray = new Ko
                    }
                    isEmpty() {
                        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length
                    }
                    upload(t, e, i, n) {
                        this.isEmpty() || (i && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Ou.members),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray, e),
                        this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Du.members, !0),
                        this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, ep, !0),
                        this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, Ru.members, !0)),
                        this.opacityVertexBuffer.itemSize = 1),
                        (i || n) && this.programConfigurations.upload(t))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy(),
                        this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy())
                    }
                }
                Yr(sp, "SymbolBuffers");
                class ap {
                    constructor(t, e, i) {
                        this.layoutVertexArray = new t,
                        this.layoutAttributes = e,
                        this.indexArray = new i,
                        this.segments = new aa,
                        this.collisionVertexArray = new is,
                        this.collisionVertexArrayExt = new ns
                    }
                    upload(t) {
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Lu.members, !0),
                        this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, Bu.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy(),
                        this.collisionVertexBufferExt.destroy())
                    }
                }
                Yr(ap, "CollisionBuffers");
                class lp {
                    constructor(t) {
                        this.collisionBoxArray = t.collisionBoxArray,
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map((t => t.id)),
                        this.index = t.index,
                        this.pixelRatio = t.pixelRatio,
                        this.sourceLayerIndex = t.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.fullyClipped = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [],
                        this.placementInvProjMatrix = pa([]),
                        this.placementViewportMatrix = pa([]);
                        const e = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = Uu(this.zoom, e["text-size"]),
                        this.iconSizeData = Uu(this.zoom, e["icon-size"]);
                        const i = this.layers[0].layout
                          , n = i.get("symbol-sort-key")
                          , r = i.get("symbol-z-order");
                        this.canOverlap = i.get("text-allow-overlap") || i.get("icon-allow-overlap") || i.get("text-ignore-placement") || i.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = "viewport-y" !== r && void 0 !== n.constantOr(1),
                        this.sortFeaturesByY = ("viewport-y" === r || "auto" === r && !this.sortFeaturesByKey) && this.canOverlap,
                        this.writingModes = i.get("text-writing-mode").map((t => Ad[t])),
                        this.stateDependentLayerIds = this.layers.filter((t => t.isStateDependent())).map((t => t.id)),
                        this.sourceID = t.sourceID,
                        this.projection = t.projection
                    }
                    createArrays() {
                        this.text = new sp(new Ks(this.layers,this.zoom,(t => /^text/.test(t)))),
                        this.icon = new sp(new Ks(this.layers,this.zoom,(t => /^icon/.test(t)))),
                        this.glyphOffsetArray = new vs,
                        this.lineVertexArray = new xs,
                        this.symbolInstances = new ys
                    }
                    calculateGlyphDependencies(t, e, i, n, r) {
                        for (let i = 0; i < t.length; i++)
                            if (e[t.charCodeAt(i)] = !0,
                            n && r) {
                                const n = Wu[t.charAt(i)];
                                n && (e[n.charCodeAt(0)] = !0)
                            }
                    }
                    populate(t, e, i, n) {
                        const r = this.layers[0]
                          , o = r.layout
                          , s = "globe" === this.projection.name
                          , a = o.get("text-font")
                          , l = o.get("text-field")
                          , c = o.get("icon-image")
                          , h = ("constant" !== l.value.kind || l.value.value instanceof Le && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && ("constant" !== a.value.kind || a.value.value.length > 0)
                          , u = "constant" !== c.value.kind || !!c.value.value || Object.keys(c.parameters).length > 0
                          , d = o.get("symbol-sort-key");
                        if (this.features = [],
                        !h && !u)
                            return;
                        const f = e.iconDependencies
                          , p = e.glyphDependencies
                          , m = e.availableImages
                          , g = new Eo(this.zoom);
                        for (const {feature: e, id: l, index: c, sourceLayerIndex: _} of t) {
                            const t = r._featureFilter.needGeometry
                              , y = lc(e, t);
                            if (!r._featureFilter.filter(g, y, i))
                                continue;
                            if (t || (y.geometry = ac(e, i, n)),
                            s && 1 !== e.type && i.z <= 5) {
                                const t = y.geometry
                                  , e = .98078528056
                                  , n = (t, n) => Ba(Il(t.x, t.y, i, 1), Il(n.x, n.y, i, 1)) < e;
                                for (let e = 0; e < t.length; e++)
                                    t[e] = nc(t[e], n)
                            }
                            let v, x;
                            if (h) {
                                const t = r.getValueAndResolveTokens("text-field", y, i, m)
                                  , e = Le.factory(t);
                                op(e) && (this.hasRTLText = !0),
                                (!this.hasRTLText || "unavailable" === xo() || this.hasRTLText && wo.isParsed()) && (v = qu(e, r, y))
                            }
                            if (u) {
                                const t = r.getValueAndResolveTokens("icon-image", y, i, m);
                                x = t instanceof Be ? t : Be.fromString(t)
                            }
                            if (!v && !x)
                                continue;
                            const b = this.sortFeaturesByKey ? d.evaluate(y, {}, i) : void 0;
                            if (this.features.push({
                                id: l,
                                text: v,
                                icon: x,
                                index: c,
                                sourceLayerIndex: _,
                                geometry: y.geometry,
                                properties: e.properties,
                                type: tp[e.type],
                                sortKey: b
                            }),
                            x && (f[x.name] = !0),
                            v) {
                                const t = a.evaluate(y, {}, i).join(",")
                                  , e = "map" === o.get("text-rotation-alignment") && "point" !== o.get("symbol-placement");
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Ad.vertical) >= 0;
                                for (const i of v.sections)
                                    if (i.image)
                                        f[i.image.name] = !0;
                                    else {
                                        const n = io(v.toString())
                                          , r = i.fontStack || t
                                          , o = p[r] = p[r] || {};
                                        this.calculateGlyphDependencies(i.text, o, e, this.allowVerticalPlacement, n)
                                    }
                            }
                        }
                        "line" === o.get("symbol-placement") && (this.features = function(t) {
                            const e = {}
                              , i = {}
                              , n = [];
                            let r = 0;
                            function o(e) {
                                n.push(t[e]),
                                r++
                            }
                            function s(t, e, r) {
                                const o = i[t];
                                return delete i[t],
                                i[e] = o,
                                n[o].geometry[0].pop(),
                                n[o].geometry[0] = n[o].geometry[0].concat(r[0]),
                                o
                            }
                            function a(t, i, r) {
                                const o = e[i];
                                return delete e[i],
                                e[t] = o,
                                n[o].geometry[0].shift(),
                                n[o].geometry[0] = r[0].concat(n[o].geometry[0]),
                                o
                            }
                            function l(t, e, i) {
                                const n = i ? e[0][e[0].length - 1] : e[0][0];
                                return `${t}:${n.x}:${n.y}`
                            }
                            for (let c = 0; c < t.length; c++) {
                                const h = t[c]
                                  , u = h.geometry
                                  , d = h.text ? h.text.toString() : null;
                                if (!d) {
                                    o(c);
                                    continue
                                }
                                const f = l(d, u)
                                  , p = l(d, u, !0);
                                if (f in i && p in e && i[f] !== e[p]) {
                                    const t = a(f, p, u)
                                      , r = s(f, p, n[t].geometry);
                                    delete e[f],
                                    delete i[p],
                                    i[l(d, n[r].geometry, !0)] = r,
                                    n[t].geometry = null
                                } else
                                    f in i ? s(f, p, u) : p in e ? a(f, p, u) : (o(c),
                                    e[f] = r - 1,
                                    i[p] = r - 1)
                            }
                            return n.filter((t => t.geometry))
                        }(this.features)),
                        this.sortFeaturesByKey && this.features.sort(( (t, e) => t.sortKey - e.sortKey))
                    }
                    update(t, e, i, n) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, e, this.layers, i, n),
                        this.icon.programConfigurations.updatePaintArrays(t, e, this.layers, i, n))
                    }
                    isEmpty() {
                        return 0 === this.symbolInstances.length && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(t) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                        this.iconCollisionBox.upload(t)),
                        this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                        this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    getProjection() {
                        return this.projectionInstance || (this.projectionInstance = Qf(this.projection)),
                        this.projectionInstance
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(t, e) {
                        const i = this.lineVertexArray.length;
                        if (void 0 !== t.segment)
                            for (const {x: t, y: i} of e)
                                this.lineVertexArray.emplaceBack(t, i);
                        return {
                            lineStartIndex: i,
                            lineLength: this.lineVertexArray.length - i
                        }
                    }
                    addSymbols(t, e, i, n, r, o, s, a, l, c, h, u, d, f) {
                        const p = t.indexArray
                          , m = t.layoutVertexArray
                          , g = t.globeExtVertexArray
                          , _ = t.segments.prepareSegment(4 * e.length, m, p, this.canOverlap ? o.sortKey : void 0)
                          , y = this.glyphOffsetArray.length
                          , v = _.vertexLength
                          , x = this.allowVerticalPlacement && s === Ad.vertical ? Math.PI / 2 : 0
                          , b = o.text && o.text.sections;
                        for (let n = 0; n < e.length; n++) {
                            const {tl: r, tr: s, bl: c, br: h, tex: u, pixelOffsetTL: y, pixelOffsetBR: v, minFontScaleX: w, minFontScaleY: E, glyphOffset: T, isSDF: S, sectionIndex: C} = e[n]
                              , A = _.vertexLength
                              , I = T[1];
                            if (ip(m, l.x, l.y, r.x, I + r.y, u.x, u.y, i, S, y.x, y.y, w, E),
                            ip(m, l.x, l.y, s.x, I + s.y, u.x + u.w, u.y, i, S, v.x, y.y, w, E),
                            ip(m, l.x, l.y, c.x, I + c.y, u.x, u.y + u.h, i, S, y.x, v.y, w, E),
                            ip(m, l.x, l.y, h.x, I + h.y, u.x + u.w, u.y + u.h, i, S, v.x, v.y, w, E),
                            a) {
                                const {x: e, y: i, z: n} = a.anchor
                                  , [r,o,s] = a.up;
                                np(g, e, i, n, r, o, s),
                                np(g, e, i, n, r, o, s),
                                np(g, e, i, n, r, o, s),
                                np(g, e, i, n, r, o, s),
                                rp(t.dynamicLayoutVertexArray, e, i, n, x)
                            } else
                                rp(t.dynamicLayoutVertexArray, l.x, l.y, l.z, x);
                            p.emplaceBack(A, A + 1, A + 2),
                            p.emplaceBack(A + 1, A + 2, A + 3),
                            _.vertexLength += 4,
                            _.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(T[0]),
                            n !== e.length - 1 && C === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(m.length, o, o.index, {}, d, f, b && b[C])
                        }
                        const w = a ? a.anchor : l;
                        t.placedSymbolArray.emplaceBack(w.x, w.y, w.z, l.x, l.y, y, this.glyphOffsetArray.length - y, v, c, h, l.segment, i ? i[0] : 0, i ? i[1] : 0, n[0], n[1], s, 0, !1, 0, u, 0)
                    }
                    _commitLayoutVertex(t, e, i, n, r, o, s) {
                        t.emplaceBack(e, i, n, r, o, Math.round(s.x), Math.round(s.y))
                    }
                    _addCollisionDebugVertices(t, e, i, n, r, o, s) {
                        const a = i.segments.prepareSegment(4, i.layoutVertexArray, i.indexArray)
                          , l = a.vertexLength
                          , c = s.tileAnchorX
                          , h = s.tileAnchorY;
                        for (let t = 0; t < 4; t++)
                            i.collisionVertexArray.emplaceBack(0, 0, 0, 0);
                        i.collisionVertexArrayExt.emplaceBack(e, -t.padding, -t.padding),
                        i.collisionVertexArrayExt.emplaceBack(e, t.padding, -t.padding),
                        i.collisionVertexArrayExt.emplaceBack(e, t.padding, t.padding),
                        i.collisionVertexArrayExt.emplaceBack(e, -t.padding, t.padding),
                        this._commitLayoutVertex(i.layoutVertexArray, n, r, o, c, h, new v(t.x1,t.y1)),
                        this._commitLayoutVertex(i.layoutVertexArray, n, r, o, c, h, new v(t.x2,t.y1)),
                        this._commitLayoutVertex(i.layoutVertexArray, n, r, o, c, h, new v(t.x2,t.y2)),
                        this._commitLayoutVertex(i.layoutVertexArray, n, r, o, c, h, new v(t.x1,t.y2)),
                        a.vertexLength += 4;
                        const u = i.indexArray;
                        u.emplaceBack(l, l + 1),
                        u.emplaceBack(l + 1, l + 2),
                        u.emplaceBack(l + 2, l + 3),
                        u.emplaceBack(l + 3, l),
                        a.primitiveLength += 4
                    }
                    _addTextDebugCollisionBoxes(t, e, i, n, r, o) {
                        for (let s = n; s < r; s++) {
                            const n = i.get(s)
                              , r = this.getSymbolInstanceTextSize(t, o, e, s);
                            this._addCollisionDebugVertices(n, r, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, o)
                        }
                    }
                    _addIconDebugCollisionBoxes(t, e, i, n, r, o) {
                        for (let s = n; s < r; s++) {
                            const n = i.get(s)
                              , r = this.getSymbolInstanceIconSize(t, e, o.placedIconSymbolIndex);
                            this._addCollisionDebugVertices(n, r, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, o)
                        }
                    }
                    generateCollisionDebugBuffers(t, e) {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new ap(ts,zu.members,hs),
                        this.iconCollisionBox = new ap(ts,zu.members,hs);
                        const i = Gu(this.iconSizeData, t)
                          , n = Gu(this.textSizeData, t);
                        for (let r = 0; r < this.symbolInstances.length; r++) {
                            const o = this.symbolInstances.get(r);
                            this._addTextDebugCollisionBoxes(n, t, e, o.textBoxStartIndex, o.textBoxEndIndex, o),
                            this._addTextDebugCollisionBoxes(n, t, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o),
                            this._addIconDebugCollisionBoxes(i, t, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o),
                            this._addIconDebugCollisionBoxes(i, t, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o)
                        }
                    }
                    getSymbolInstanceTextSize(t, e, i, n) {
                        const r = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n)
                          , o = Vu(this.textSizeData, t, r) / Nu;
                        return this.tilePixelRatio * o
                    }
                    getSymbolInstanceIconSize(t, e, i) {
                        const n = this.icon.placedSymbolArray.get(i)
                          , r = Vu(this.iconSizeData, t, n);
                        return this.tilePixelRatio * r
                    }
                    _commitDebugCollisionVertexUpdate(t, e, i) {
                        t.emplaceBack(e, -i, -i),
                        t.emplaceBack(e, i, -i),
                        t.emplaceBack(e, i, i),
                        t.emplaceBack(e, -i, i)
                    }
                    _updateTextDebugCollisionBoxes(t, e, i, n, r, o) {
                        for (let s = n; s < r; s++) {
                            const n = i.get(s)
                              , r = this.getSymbolInstanceTextSize(t, o, e, s);
                            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, r, n.padding)
                        }
                    }
                    _updateIconDebugCollisionBoxes(t, e, i, n, r, o) {
                        for (let s = n; s < r; s++) {
                            const n = i.get(s)
                              , r = this.getSymbolInstanceIconSize(t, e, o);
                            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, r, n.padding)
                        }
                    }
                    updateCollisionDebugBuffers(t, e) {
                        if (!this.hasDebugData())
                            return;
                        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(),
                        this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
                        const i = Gu(this.iconSizeData, t)
                          , n = Gu(this.textSizeData, t);
                        for (let r = 0; r < this.symbolInstances.length; r++) {
                            const o = this.symbolInstances.get(r);
                            this._updateTextDebugCollisionBoxes(n, t, e, o.textBoxStartIndex, o.textBoxEndIndex, o),
                            this._updateTextDebugCollisionBoxes(n, t, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o),
                            this._updateIconDebugCollisionBoxes(i, t, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o.placedIconSymbolIndex),
                            this._updateIconDebugCollisionBoxes(i, t, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o.placedIconSymbolIndex)
                        }
                        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt),
                        this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt)
                    }
                    _deserializeCollisionBoxesForSymbol(t, e, i, n, r, o, s, a, l) {
                        const c = {};
                        if (e < i) {
                            const {x1: i, y1: n, x2: r, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: h, tileAnchorX: u, tileAnchorY: d, featureIndex: f} = t.get(e);
                            c.textBox = {
                                x1: i,
                                y1: n,
                                x2: r,
                                y2: o,
                                padding: s,
                                projectedAnchorX: a,
                                projectedAnchorY: l,
                                projectedAnchorZ: h,
                                tileAnchorX: u,
                                tileAnchorY: d
                            },
                            c.textFeatureIndex = f
                        }
                        if (n < r) {
                            const {x1: e, y1: i, x2: r, y2: o, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: h, tileAnchorX: u, tileAnchorY: d, featureIndex: f} = t.get(n);
                            c.verticalTextBox = {
                                x1: e,
                                y1: i,
                                x2: r,
                                y2: o,
                                padding: s,
                                projectedAnchorX: a,
                                projectedAnchorY: l,
                                projectedAnchorZ: h,
                                tileAnchorX: u,
                                tileAnchorY: d
                            },
                            c.verticalTextFeatureIndex = f
                        }
                        if (o < s) {
                            const {x1: e, y1: i, x2: n, y2: r, padding: s, projectedAnchorX: a, projectedAnchorY: l, projectedAnchorZ: h, tileAnchorX: u, tileAnchorY: d, featureIndex: f} = t.get(o);
                            c.iconBox = {
                                x1: e,
                                y1: i,
                                x2: n,
                                y2: r,
                                padding: s,
                                projectedAnchorX: a,
                                projectedAnchorY: l,
                                projectedAnchorZ: h,
                                tileAnchorX: u,
                                tileAnchorY: d
                            },
                            c.iconFeatureIndex = f
                        }
                        if (a < l) {
                            const {x1: e, y1: i, x2: n, y2: r, padding: o, projectedAnchorX: s, projectedAnchorY: l, projectedAnchorZ: h, tileAnchorX: u, tileAnchorY: d, featureIndex: f} = t.get(a);
                            c.verticalIconBox = {
                                x1: e,
                                y1: i,
                                x2: n,
                                y2: r,
                                padding: o,
                                projectedAnchorX: s,
                                projectedAnchorY: l,
                                projectedAnchorZ: h,
                                tileAnchorX: u,
                                tileAnchorY: d
                            },
                            c.verticalIconFeatureIndex = f
                        }
                        return c
                    }
                    deserializeCollisionBoxes(t) {
                        this.collisionArrays = [];
                        for (let e = 0; e < this.symbolInstances.length; e++) {
                            const i = this.symbolInstances.get(e);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, i.textBoxStartIndex, i.textBoxEndIndex, i.verticalTextBoxStartIndex, i.verticalTextBoxEndIndex, i.iconBoxStartIndex, i.iconBoxEndIndex, i.verticalIconBoxStartIndex, i.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    addIndicesForPlacedSymbol(t, e) {
                        const i = t.placedSymbolArray.get(e)
                          , n = i.vertexStartIndex + 4 * i.numGlyphs;
                        for (let e = i.vertexStartIndex; e < n; e += 4)
                            t.indexArray.emplaceBack(e, e + 1, e + 2),
                            t.indexArray.emplaceBack(e + 1, e + 2, e + 3)
                    }
                    getSortedSymbolIndexes(t) {
                        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes)
                            return this.symbolInstanceIndexes;
                        const e = Math.sin(t)
                          , i = Math.cos(t)
                          , n = []
                          , r = []
                          , o = [];
                        for (let t = 0; t < this.symbolInstances.length; ++t) {
                            o.push(t);
                            const s = this.symbolInstances.get(t);
                            n.push(0 | Math.round(e * s.tileAnchorX + i * s.tileAnchorY)),
                            r.push(s.featureIndex)
                        }
                        return o.sort(( (t, e) => n[t] - n[e] || r[e] - r[t])),
                        o
                    }
                    addToSortKeyRanges(t, e) {
                        const i = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        i && i.sortKey === e ? i.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                            sortKey: e,
                            symbolInstanceStart: t,
                            symbolInstanceEnd: t + 1
                        })
                    }
                    sortFeatures(t) {
                        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                            this.sortedAngle = t,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const t of this.symbolInstanceIndexes) {
                                const e = this.symbolInstances.get(t);
                                this.featureSortOrder.push(e.featureIndex);
                                const {rightJustifiedTextSymbolIndex: i, centerJustifiedTextSymbolIndex: n, leftJustifiedTextSymbolIndex: r, verticalPlacedTextSymbolIndex: o, placedIconSymbolIndex: s, verticalPlacedIconSymbolIndex: a} = e;
                                i >= 0 && this.addIndicesForPlacedSymbol(this.text, i),
                                n >= 0 && n !== i && this.addIndicesForPlacedSymbol(this.text, n),
                                r >= 0 && r !== n && r !== i && this.addIndicesForPlacedSymbol(this.text, r),
                                o >= 0 && this.addIndicesForPlacedSymbol(this.text, o),
                                s >= 0 && this.addIndicesForPlacedSymbol(this.icon, s),
                                a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                Yr(lp, "SymbolBucket", {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                lp.MAX_GLYPHS = 65535,
                lp.addDynamicAttributes = rp;
                const cp = new Lo({
                    "symbol-placement": new Oo(ee.layout_symbol["symbol-placement"]),
                    "symbol-spacing": new Oo(ee.layout_symbol["symbol-spacing"]),
                    "symbol-avoid-edges": new Oo(ee.layout_symbol["symbol-avoid-edges"]),
                    "symbol-sort-key": new Ro(ee.layout_symbol["symbol-sort-key"]),
                    "symbol-z-order": new Oo(ee.layout_symbol["symbol-z-order"]),
                    "icon-allow-overlap": new Oo(ee.layout_symbol["icon-allow-overlap"]),
                    "icon-ignore-placement": new Oo(ee.layout_symbol["icon-ignore-placement"]),
                    "icon-optional": new Oo(ee.layout_symbol["icon-optional"]),
                    "icon-rotation-alignment": new Oo(ee.layout_symbol["icon-rotation-alignment"]),
                    "icon-size": new Ro(ee.layout_symbol["icon-size"]),
                    "icon-text-fit": new Oo(ee.layout_symbol["icon-text-fit"]),
                    "icon-text-fit-padding": new Oo(ee.layout_symbol["icon-text-fit-padding"]),
                    "icon-image": new Ro(ee.layout_symbol["icon-image"]),
                    "icon-rotate": new Ro(ee.layout_symbol["icon-rotate"]),
                    "icon-padding": new Oo(ee.layout_symbol["icon-padding"]),
                    "icon-keep-upright": new Oo(ee.layout_symbol["icon-keep-upright"]),
                    "icon-offset": new Ro(ee.layout_symbol["icon-offset"]),
                    "icon-anchor": new Ro(ee.layout_symbol["icon-anchor"]),
                    "icon-pitch-alignment": new Oo(ee.layout_symbol["icon-pitch-alignment"]),
                    "text-pitch-alignment": new Oo(ee.layout_symbol["text-pitch-alignment"]),
                    "text-rotation-alignment": new Oo(ee.layout_symbol["text-rotation-alignment"]),
                    "text-field": new Ro(ee.layout_symbol["text-field"]),
                    "text-font": new Ro(ee.layout_symbol["text-font"]),
                    "text-size": new Ro(ee.layout_symbol["text-size"]),
                    "text-max-width": new Ro(ee.layout_symbol["text-max-width"]),
                    "text-line-height": new Ro(ee.layout_symbol["text-line-height"]),
                    "text-letter-spacing": new Ro(ee.layout_symbol["text-letter-spacing"]),
                    "text-justify": new Ro(ee.layout_symbol["text-justify"]),
                    "text-radial-offset": new Ro(ee.layout_symbol["text-radial-offset"]),
                    "text-variable-anchor": new Oo(ee.layout_symbol["text-variable-anchor"]),
                    "text-anchor": new Ro(ee.layout_symbol["text-anchor"]),
                    "text-max-angle": new Oo(ee.layout_symbol["text-max-angle"]),
                    "text-writing-mode": new Oo(ee.layout_symbol["text-writing-mode"]),
                    "text-rotate": new Ro(ee.layout_symbol["text-rotate"]),
                    "text-padding": new Oo(ee.layout_symbol["text-padding"]),
                    "text-keep-upright": new Oo(ee.layout_symbol["text-keep-upright"]),
                    "text-transform": new Ro(ee.layout_symbol["text-transform"]),
                    "text-offset": new Ro(ee.layout_symbol["text-offset"]),
                    "text-allow-overlap": new Oo(ee.layout_symbol["text-allow-overlap"]),
                    "text-ignore-placement": new Oo(ee.layout_symbol["text-ignore-placement"]),
                    "text-optional": new Oo(ee.layout_symbol["text-optional"])
                });
                var hp = {
                    paint: new Lo({
                        "icon-opacity": new Ro(ee.paint_symbol["icon-opacity"]),
                        "icon-color": new Ro(ee.paint_symbol["icon-color"]),
                        "icon-halo-color": new Ro(ee.paint_symbol["icon-halo-color"]),
                        "icon-halo-width": new Ro(ee.paint_symbol["icon-halo-width"]),
                        "icon-halo-blur": new Ro(ee.paint_symbol["icon-halo-blur"]),
                        "icon-translate": new Oo(ee.paint_symbol["icon-translate"]),
                        "icon-translate-anchor": new Oo(ee.paint_symbol["icon-translate-anchor"]),
                        "text-opacity": new Ro(ee.paint_symbol["text-opacity"]),
                        "text-color": new Ro(ee.paint_symbol["text-color"],{
                            runtimeType: fe,
                            getOverride: t => t.textColor,
                            hasOverride: t => !!t.textColor
                        }),
                        "text-halo-color": new Ro(ee.paint_symbol["text-halo-color"]),
                        "text-halo-width": new Ro(ee.paint_symbol["text-halo-width"]),
                        "text-halo-blur": new Ro(ee.paint_symbol["text-halo-blur"]),
                        "text-translate": new Oo(ee.paint_symbol["text-translate"]),
                        "text-translate-anchor": new Oo(ee.paint_symbol["text-translate-anchor"])
                    }),
                    layout: cp
                };
                class up {
                    constructor(t) {
                        this.type = t.property.overrides ? t.property.overrides.runtimeType : ce,
                        this.defaultValue = t
                    }
                    evaluate(t) {
                        if (t.formattedSection) {
                            const e = this.defaultValue.property.overrides;
                            if (e && e.hasOverride(t.formattedSection))
                                return e.getOverride(t.formattedSection)
                        }
                        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(t) {
                        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Yr(up, "FormatSectionOverride", {
                    omit: ["defaultValue"]
                });
                class dp extends ra {
                    constructor(t) {
                        super(t, hp)
                    }
                    recalculate(t, e) {
                        super.recalculate(t, e),
                        "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                        "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"),
                        "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")),
                        "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
                        const i = this.layout.get("text-writing-mode");
                        if (i) {
                            const t = [];
                            for (const e of i)
                                t.indexOf(e) < 0 && t.push(e);
                            this.layout._values["text-writing-mode"] = t
                        } else
                            this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
                        this._setPaintOverrides()
                    }
                    getValueAndResolveTokens(t, e, i, n) {
                        const r = this.layout.get(t).evaluate(e, {}, i, n)
                          , o = this._unevaluatedLayout._values[t];
                        return o.isDataDriven() || Yn(o.value) || !r ? r : function(t, e) {
                            return e.replace(/{([^{}]+)}/g, ( (e, i) => i in t ? String(t[i]) : ""))
                        }(e.properties, r)
                    }
                    createBucket(t) {
                        return new lp(t)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    _setPaintOverrides() {
                        for (const t of hp.paint.overridableProperties) {
                            if (!dp.hasPaintOverride(this.layout, t))
                                continue;
                            const e = this.paint.get(t)
                              , i = new up(e)
                              , n = new Xn(i,e.property.specification);
                            let r = null;
                            r = "constant" === e.value.kind || "source" === e.value.kind ? new Jn("source",n) : new Qn("composite",n,e.value.zoomStops,e.value._interpolationType),
                            this.paint._values[t] = new Po(e.property,r,e.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(t, e, i) {
                        return !(!this.layout || e.isDataDriven() || i.isDataDriven()) && dp.hasPaintOverride(this.layout, t)
                    }
                    static hasPaintOverride(t, e) {
                        const i = t.get("text-field")
                          , n = hp.paint.properties[e];
                        let r = !1;
                        const o = t => {
                            for (const e of t)
                                if (n.overrides && n.overrides.hasOverride(e))
                                    return void (r = !0)
                        }
                        ;
                        if ("constant" === i.value.kind && i.value.value instanceof Le)
                            o(i.value.value.sections);
                        else if ("source" === i.value.kind) {
                            const t = e => {
                                r || (e instanceof Ve && Ne(e.value) === _e ? o(e.value.sections) : e instanceof He ? o(e.sections) : e.eachChild(t))
                            }
                              , e = i.value;
                            e._styleExpression && t(e._styleExpression.expression)
                        }
                        return r
                    }
                    getProgramConfiguration(t) {
                        return new Ys(this,t)
                    }
                }
                var fp = {
                    paint: new Lo({
                        "background-color": new Oo(ee.paint_background["background-color"]),
                        "background-pattern": new Oo(ee.paint_background["background-pattern"]),
                        "background-opacity": new Oo(ee.paint_background["background-opacity"])
                    })
                }
                  , pp = {
                    paint: new Lo({
                        "raster-opacity": new Oo(ee.paint_raster["raster-opacity"]),
                        "raster-hue-rotate": new Oo(ee.paint_raster["raster-hue-rotate"]),
                        "raster-brightness-min": new Oo(ee.paint_raster["raster-brightness-min"]),
                        "raster-brightness-max": new Oo(ee.paint_raster["raster-brightness-max"]),
                        "raster-saturation": new Oo(ee.paint_raster["raster-saturation"]),
                        "raster-contrast": new Oo(ee.paint_raster["raster-contrast"]),
                        "raster-resampling": new Oo(ee.paint_raster["raster-resampling"]),
                        "raster-fade-duration": new Oo(ee.paint_raster["raster-fade-duration"])
                    })
                };
                class mp extends ra {
                    constructor(t) {
                        super(t, {}),
                        this.implementation = t
                    }
                    is3D() {
                        return "3d" === this.implementation.renderingMode
                    }
                    hasOffscreenPass() {
                        return void 0 !== this.implementation.prerender
                    }
                    isLayerDraped() {
                        return void 0 !== this.implementation.renderToTile
                    }
                    shouldRedrape() {
                        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles()
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {}
                    onAdd(t) {
                        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl)
                    }
                    onRemove(t) {
                        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl)
                    }
                }
                var gp = {
                    paint: new Lo({
                        "sky-type": new Oo(ee.paint_sky["sky-type"]),
                        "sky-atmosphere-sun": new Oo(ee.paint_sky["sky-atmosphere-sun"]),
                        "sky-atmosphere-sun-intensity": new Oo(ee.paint_sky["sky-atmosphere-sun-intensity"]),
                        "sky-gradient-center": new Oo(ee.paint_sky["sky-gradient-center"]),
                        "sky-gradient-radius": new Oo(ee.paint_sky["sky-gradient-radius"]),
                        "sky-gradient": new Do(ee.paint_sky["sky-gradient"]),
                        "sky-atmosphere-halo-color": new Oo(ee.paint_sky["sky-atmosphere-halo-color"]),
                        "sky-atmosphere-color": new Oo(ee.paint_sky["sky-atmosphere-color"]),
                        "sky-opacity": new Oo(ee.paint_sky["sky-opacity"])
                    })
                };
                function _p(t, e, i) {
                    const n = [0, 0, 1]
                      , r = $a([]);
                    return Ya(r, r, i ? -w(t) + Math.PI : w(t)),
                    Xa(r, r, -w(e)),
                    Na(n, n, r),
                    La(n, n)
                }
                const yp = {
                    circle: class extends ra {
                        constructor(t) {
                            super(t, Mc)
                        }
                        createBucket(t) {
                            return new uc(t)
                        }
                        queryRadius(t) {
                            const e = t;
                            return Tc("circle-radius", this, e) + Tc("circle-stroke-width", this, e) + Sc(this.paint.get("circle-translate"))
                        }
                        queryIntersectsFeature(t, e, i, n, r, o, s, a) {
                            const l = Ac(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                              , c = this.paint.get("circle-radius").evaluate(e, i) + this.paint.get("circle-stroke-width").evaluate(e, i);
                            return Pc(t, n, o, s, a, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l, c)
                        }
                        getProgramIds() {
                            return ["circle"]
                        }
                        getProgramConfiguration(t) {
                            return new Ys(this,t)
                        }
                    }
                    ,
                    heatmap: class extends ra {
                        createBucket(t) {
                            return new Lc(t)
                        }
                        constructor(t) {
                            super(t, Uc),
                            this._updateColorRamp()
                        }
                        _handleSpecialPaintPropertyUpdate(t) {
                            "heatmap-color" === t && this._updateColorRamp()
                        }
                        _updateColorRamp() {
                            this.colorRamp = Vc({
                                expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                                evaluationKey: "heatmapDensity",
                                image: this.colorRamp
                            }),
                            this.colorRampTexture = null
                        }
                        resize() {
                            this.heatmapFbo && (this.heatmapFbo.destroy(),
                            this.heatmapFbo = null)
                        }
                        queryRadius(t) {
                            return Tc("heatmap-radius", this, t)
                        }
                        queryIntersectsFeature(t, e, i, n, r, o, s, a) {
                            const l = this.paint.get("heatmap-radius").evaluate(e, i);
                            return Pc(t, n, o, s, a, !0, !0, new v(0,0), l)
                        }
                        hasOffscreenPass() {
                            return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility
                        }
                        getProgramIds() {
                            return ["heatmap", "heatmapTexture"]
                        }
                        getProgramConfiguration(t) {
                            return new Ys(this,t)
                        }
                    }
                    ,
                    hillshade: class extends ra {
                        constructor(t) {
                            super(t, Gc)
                        }
                        hasOffscreenPass() {
                            return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility
                        }
                        getProgramIds() {
                            return ["hillshade", "hillshadePrepare"]
                        }
                    }
                    ,
                    fill: class extends ra {
                        constructor(t) {
                            super(t, Ph)
                        }
                        getProgramIds() {
                            const t = this.paint.get("fill-pattern")
                              , e = t && t.constantOr(1)
                              , i = [e ? "fillPattern" : "fill"];
                            return this.paint.get("fill-antialias") && i.push(e && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"),
                            i
                        }
                        getProgramConfiguration(t) {
                            return new Ys(this,t)
                        }
                        recalculate(t, e) {
                            super.recalculate(t, e);
                            const i = this.paint._values["fill-outline-color"];
                            "constant" === i.value.kind && void 0 === i.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                        }
                        createBucket(t) {
                            return new Ih(t)
                        }
                        queryRadius() {
                            return Sc(this.paint.get("fill-translate"))
                        }
                        queryIntersectsFeature(t, e, i, n, r, o) {
                            return !t.queryGeometry.isAboveHorizon && pc(Cc(t.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), o.angle, t.pixelToTileUnitsFactor), n)
                        }
                        isTileClipped() {
                            return !0
                        }
                    }
                    ,
                    "fill-extrusion": class extends ra {
                        constructor(t) {
                            super(t, uu)
                        }
                        createBucket(t) {
                            return new eu(t)
                        }
                        queryRadius() {
                            return Sc(this.paint.get("fill-extrusion-translate"))
                        }
                        is3D() {
                            return !0
                        }
                        getProgramIds() {
                            return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"]
                        }
                        getProgramConfiguration(t) {
                            return new Ys(this,t)
                        }
                        queryIntersectsFeature(t, e, i, n, r, o, s, a, l) {
                            const c = Ac(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                              , h = this.paint.get("fill-extrusion-height").evaluate(e, i)
                              , u = this.paint.get("fill-extrusion-base").evaluate(e, i)
                              , d = [0, 0]
                              , f = a && o.elevation
                              , p = o.elevation ? o.elevation.exaggeration() : 1
                              , m = t.tile.getBucket(this);
                            if (f && m instanceof eu) {
                                const t = m.centroidVertexArray
                                  , e = l + 1;
                                e < t.length && (d[0] = t.geta_centroid_pos0(e),
                                d[1] = t.geta_centroid_pos1(e))
                            }
                            if (0 === d[0] && 1 === d[1])
                                return !1;
                            "globe" === o.projection.name && (n = cu([n], [new v(0,0), new v(la,la)], t.tileID.canonical).map((t => t.polygon)).flat());
                            const g = f ? a : null
                              , [_,y] = function(t, e, i, n, r, o, s, a, l, c, h) {
                                return "globe" === t.projection.name ? function(t, e, i, n, r, o, s, a, l, c, h) {
                                    const u = []
                                      , d = []
                                      , f = t.projection.upVectorScale(h, t.center.lat, t.worldSize).metersToTile
                                      , p = [0, 0, 0, 1]
                                      , m = [0, 0, 0, 1]
                                      , g = (t, e, i, n) => {
                                        t[0] = e,
                                        t[1] = i,
                                        t[2] = n,
                                        t[3] = 1
                                    }
                                      , _ = lu();
                                    i > 0 && (i += _),
                                    n += _;
                                    for (const _ of e) {
                                        const e = []
                                          , y = [];
                                        for (const u of _) {
                                            const d = u.x + r.x
                                              , _ = u.y + r.y
                                              , v = t.projection.projectTilePoint(d, _, h)
                                              , x = t.projection.upVector(h, u.x, u.y);
                                            let b = i
                                              , w = n;
                                            if (s) {
                                                const t = xu(d, _, i, n, s, a, l, c);
                                                b += t.base,
                                                w += t.top
                                            }
                                            0 !== i ? g(p, v.x + x[0] * f * b, v.y + x[1] * f * b, v.z + x[2] * f * b) : g(p, v.x, v.y, v.z),
                                            g(m, v.x + x[0] * f * w, v.y + x[1] * f * w, v.z + x[2] * f * w),
                                            Fa(p, p, o),
                                            Fa(m, m, o),
                                            e.push(new _u(p[0],p[1],p[2])),
                                            y.push(new _u(m[0],m[1],m[2]))
                                        }
                                        u.push(e),
                                        d.push(y)
                                    }
                                    return [u, d]
                                }(t, e, i, n, r, o, s, a, l, c, h) : s ? function(t, e, i, n, r, o, s, a, l) {
                                    const c = []
                                      , h = []
                                      , u = [0, 0, 0, 1];
                                    for (const d of t) {
                                        const t = []
                                          , f = [];
                                        for (const c of d) {
                                            const h = c.x + n.x
                                              , d = c.y + n.y
                                              , p = xu(h, d, e, i, o, s, a, l);
                                            u[0] = h,
                                            u[1] = d,
                                            u[2] = p.base,
                                            u[3] = 1,
                                            Wa(u, u, r),
                                            u[3] = Math.max(u[3], 1e-5);
                                            const m = new _u(u[0] / u[3],u[1] / u[3],u[2] / u[3]);
                                            u[0] = h,
                                            u[1] = d,
                                            u[2] = p.top,
                                            u[3] = 1,
                                            Wa(u, u, r),
                                            u[3] = Math.max(u[3], 1e-5);
                                            const g = new _u(u[0] / u[3],u[1] / u[3],u[2] / u[3]);
                                            t.push(m),
                                            f.push(g)
                                        }
                                        c.push(t),
                                        h.push(f)
                                    }
                                    return [c, h]
                                }(e, i, n, r, o, s, a, l, c) : function(t, e, i, n, r) {
                                    const o = []
                                      , s = []
                                      , a = r[8] * e
                                      , l = r[9] * e
                                      , c = r[10] * e
                                      , h = r[11] * e
                                      , u = r[8] * i
                                      , d = r[9] * i
                                      , f = r[10] * i
                                      , p = r[11] * i;
                                    for (const e of t) {
                                        const t = []
                                          , i = [];
                                        for (const o of e) {
                                            const e = o.x + n.x
                                              , s = o.y + n.y
                                              , m = r[0] * e + r[4] * s + r[12]
                                              , g = r[1] * e + r[5] * s + r[13]
                                              , _ = r[2] * e + r[6] * s + r[14]
                                              , y = r[3] * e + r[7] * s + r[15]
                                              , v = m + a
                                              , x = g + l
                                              , b = _ + c
                                              , w = Math.max(y + h, 1e-5)
                                              , E = m + u
                                              , T = g + d
                                              , S = _ + f
                                              , C = Math.max(y + p, 1e-5);
                                            t.push(new _u(v / w,x / w,b / w)),
                                            i.push(new _u(E / C,T / C,S / C))
                                        }
                                        o.push(t),
                                        s.push(i)
                                    }
                                    return [o, s]
                                }(e, i, n, r, o)
                            }(o, n, u, h, c, s, g, d, p, o.center.lat, t.tileID.canonical)
                              , x = t.queryGeometry;
                            return function(t, e, i) {
                                let n = 1 / 0;
                                pc(i, e) && (n = vu(i, e[0]));
                                for (let r = 0; r < e.length; r++) {
                                    const o = e[r]
                                      , s = t[r];
                                    for (let t = 0; t < o.length - 1; t++) {
                                        const e = o[t]
                                          , r = [e, o[t + 1], s[t + 1], s[t], e];
                                        dc(i, r) && (n = Math.min(n, vu(i, r)))
                                    }
                                }
                                return n !== 1 / 0 && n
                            }(_, y, x.isPointQuery() ? x.screenBounds : x.screenGeometry)
                        }
                    }
                    ,
                    line: class extends ra {
                        constructor(t) {
                            super(t, Mu),
                            this.gradientVersion = 0
                        }
                        _handleSpecialPaintPropertyUpdate(t) {
                            if ("line-gradient" === t) {
                                const t = this._transitionablePaint._values["line-gradient"].value.expression;
                                this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof ki,
                                this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                            }
                        }
                        gradientExpression() {
                            return this._transitionablePaint._values["line-gradient"].value.expression
                        }
                        widthExpression() {
                            return this._transitionablePaint._values["line-width"].value.expression
                        }
                        recalculate(t, e) {
                            super.recalculate(t, e),
                            this.paint._values["line-floorwidth"] = Pu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                        }
                        createBucket(t) {
                            return new Au(t)
                        }
                        getProgramIds() {
                            return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"]
                        }
                        getProgramConfiguration(t) {
                            return new Ys(this,t)
                        }
                        queryRadius(t) {
                            const e = t
                              , i = ku(Tc("line-width", this, e), Tc("line-gap-width", this, e))
                              , n = Tc("line-offset", this, e);
                            return i / 2 + Math.abs(n) + Sc(this.paint.get("line-translate"))
                        }
                        queryIntersectsFeature(t, e, i, n, r, o) {
                            if (t.queryGeometry.isAboveHorizon)
                                return !1;
                            const s = Cc(t.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o.angle, t.pixelToTileUnitsFactor)
                              , a = t.pixelToTileUnitsFactor / 2 * ku(this.paint.get("line-width").evaluate(e, i), this.paint.get("line-gap-width").evaluate(e, i))
                              , l = this.paint.get("line-offset").evaluate(e, i);
                            return l && (n = function(t, e) {
                                const i = []
                                  , n = new v(0,0);
                                for (let r = 0; r < t.length; r++) {
                                    const o = t[r]
                                      , s = [];
                                    for (let t = 0; t < o.length; t++) {
                                        const i = o[t]
                                          , r = o[t + 1]
                                          , a = 0 === t ? n : i.sub(o[t - 1])._unit()._perp()
                                          , l = t === o.length - 1 ? n : r.sub(i)._unit()._perp()
                                          , c = a._add(l)._unit();
                                        c._mult(1 / (c.x * l.x + c.y * l.y)),
                                        s.push(c._mult(e)._add(i))
                                    }
                                    i.push(s)
                                }
                                return i
                            }(n, l * t.pixelToTileUnitsFactor)),
                            function(t, e, i) {
                                for (let n = 0; n < e.length; n++) {
                                    const r = e[n];
                                    if (t.length >= 3)
                                        for (let e = 0; e < r.length; e++)
                                            if (bc(t, r[e]))
                                                return !0;
                                    if (mc(t, r, i))
                                        return !0
                                }
                                return !1
                            }(s, n, a)
                        }
                        isTileClipped() {
                            return !0
                        }
                    }
                    ,
                    symbol: dp,
                    background: class extends ra {
                        constructor(t) {
                            super(t, fp)
                        }
                        getProgramIds() {
                            return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"]
                        }
                    }
                    ,
                    raster: class extends ra {
                        constructor(t) {
                            super(t, pp)
                        }
                        getProgramIds() {
                            return ["raster"]
                        }
                    }
                    ,
                    sky: class extends ra {
                        constructor(t) {
                            super(t, gp),
                            this._updateColorRamp()
                        }
                        _handleSpecialPaintPropertyUpdate(t) {
                            "sky-gradient" === t ? this._updateColorRamp() : "sky-atmosphere-sun" !== t && "sky-atmosphere-halo-color" !== t && "sky-atmosphere-color" !== t && "sky-atmosphere-sun-intensity" !== t || (this._skyboxInvalidated = !0)
                        }
                        _updateColorRamp() {
                            this.colorRamp = Vc({
                                expression: this._transitionablePaint._values["sky-gradient"].value.expression,
                                evaluationKey: "skyRadialProgress"
                            }),
                            this.colorRampTexture && (this.colorRampTexture.destroy(),
                            this.colorRampTexture = null)
                        }
                        needsSkyboxCapture(t) {
                            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry)
                                return !0;
                            if (!this.paint.get("sky-atmosphere-sun")) {
                                const e = t.style.light.properties.get("position");
                                return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar
                            }
                            return !1
                        }
                        getCenter(t, e) {
                            if ("atmosphere" === this.paint.get("sky-type")) {
                                const i = this.paint.get("sky-atmosphere-sun")
                                  , n = !i
                                  , r = t.style.light
                                  , o = r.properties.get("position");
                                return n && "viewport" === r.properties.get("anchor") && q("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."),
                                n ? _p(o.azimuthal, 90 - o.polar, e) : _p(i[0], 90 - i[1], e)
                            }
                            const i = this.paint.get("sky-gradient-center");
                            return _p(i[0], 90 - i[1], e)
                        }
                        is3D() {
                            return !1
                        }
                        isSky() {
                            return !0
                        }
                        markSkyboxValid(t) {
                            this._skyboxInvalidated = !1,
                            this._lightPosition = t.style.light.properties.get("position")
                        }
                        hasOffscreenPass() {
                            return !0
                        }
                        getProgramIds() {
                            const t = this.paint.get("sky-type");
                            return "atmosphere" === t ? ["skyboxCapture", "skybox"] : "gradient" === t ? ["skyboxGradient"] : null
                        }
                    }
                };
                class vp {
                    constructor(t, e, i, n) {
                        this.context = t,
                        this.format = i,
                        this.texture = t.gl.createTexture(),
                        this.update(e, n)
                    }
                    update(t, i, n) {
                        const {width: r, height: o} = t
                          , {context: s} = this
                          , {gl: a} = s
                          , {HTMLImageElement: l, HTMLCanvasElement: c, HTMLVideoElement: h, ImageData: u, ImageBitmap: d} = e;
                        if (a.bindTexture(a.TEXTURE_2D, this.texture),
                        s.pixelStoreUnpackFlipY.set(!1),
                        s.pixelStoreUnpack.set(1),
                        s.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!i || !1 !== i.premultiply)),
                        n || this.size && this.size[0] === r && this.size[1] === o) {
                            const {x: e, y: i} = n || {
                                x: 0,
                                y: 0
                            };
                            t instanceof l || t instanceof c || t instanceof h || t instanceof u || d && t instanceof d ? a.texSubImage2D(a.TEXTURE_2D, 0, e, i, a.RGBA, a.UNSIGNED_BYTE, t) : a.texSubImage2D(a.TEXTURE_2D, 0, e, i, r, o, a.RGBA, a.UNSIGNED_BYTE, t.data)
                        } else
                            this.size = [r, o],
                            t instanceof l || t instanceof c || t instanceof h || t instanceof u || d && t instanceof d ? a.texImage2D(a.TEXTURE_2D, 0, this.format, this.format, a.UNSIGNED_BYTE, t) : a.texImage2D(a.TEXTURE_2D, 0, this.format, r, o, 0, this.format, a.UNSIGNED_BYTE, t.data);
                        this.useMipmap = Boolean(i && i.useMipmap && this.isSizePowerOfTwo()),
                        this.useMipmap && a.generateMipmap(a.TEXTURE_2D)
                    }
                    bind(t, e) {
                        const {context: i} = this
                          , {gl: n} = i;
                        n.bindTexture(n.TEXTURE_2D, this.texture),
                        t !== this.filter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST : t),
                        this.filter = t),
                        e !== this.wrap && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e),
                        n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e),
                        this.wrap = e)
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                    }
                    destroy() {
                        const {gl: t} = this.context;
                        t.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                class xp {
                    constructor(t) {
                        this._callback = t,
                        this._triggered = !1,
                        "undefined" != typeof MessageChannel && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._callback()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout(( () => {
                            this._triggered = !1,
                            this._callback()
                        }
                        ), 0))
                    }
                    remove() {
                        this._channel = void 0,
                        this._callback = () => {}
                    }
                }
                class bp {
                    constructor() {
                        this.tasks = {},
                        this.taskQueue = [],
                        N(["process"], this),
                        this.invoker = new xp(this.process),
                        this.nextId = 0
                    }
                    add(t, e) {
                        const i = this.nextId++
                          , n = function({type: t, isSymbolTile: e, zoom: i}) {
                            return i = i || 0,
                            "message" === t ? 0 : "maybePrepare" !== t || e ? "parseTile" !== t || e ? "parseTile" === t && e ? 300 - i : "maybePrepare" === t && e ? 400 - i : 500 : 200 - i : 100 - i
                        }(e);
                        if (0 === n) {
                            $();
                            try {
                                t()
                            } finally {}
                            return {
                                cancel: () => {}
                            }
                        }
                        return this.tasks[i] = {
                            fn: t,
                            metadata: e,
                            priority: n,
                            id: i
                        },
                        this.taskQueue.push(i),
                        this.invoker.trigger(),
                        {
                            cancel: () => {
                                delete this.tasks[i]
                            }
                        }
                    }
                    process() {
                        $();
                        try {
                            if (this.taskQueue = this.taskQueue.filter((t => !!this.tasks[t])),
                            !this.taskQueue.length)
                                return;
                            const t = this.pick();
                            if (null === t)
                                return;
                            const e = this.tasks[t];
                            if (delete this.tasks[t],
                            this.taskQueue.length && this.invoker.trigger(),
                            !e)
                                return;
                            e.fn()
                        } finally {}
                    }
                    pick() {
                        let t = null
                          , e = 1 / 0;
                        for (let i = 0; i < this.taskQueue.length; i++) {
                            const n = this.tasks[this.taskQueue[i]];
                            n.priority < e && (e = n.priority,
                            t = i)
                        }
                        if (null === t)
                            return null;
                        const i = this.taskQueue[t];
                        return this.taskQueue.splice(t, 1),
                        i
                    }
                    remove() {
                        this.invoker.remove()
                    }
                }
                class wp {
                    constructor(t) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            this._stringToNumber[i] = e,
                            this._numberToString[e] = i
                        }
                    }
                    encode(t) {
                        return this._stringToNumber[t]
                    }
                    decode(t) {
                        return this._numberToString[t]
                    }
                }
                const Ep = ["tile", "layer", "source", "sourceLayer", "state"];
                class Tp {
                    constructor(t, e, i, n, r) {
                        this.type = "Feature",
                        this._vectorTileFeature = t,
                        this._z = e,
                        this._x = i,
                        this._y = n,
                        this.properties = t.properties,
                        this.id = r
                    }
                    get geometry() {
                        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry),
                        this._geometry
                    }
                    set geometry(t) {
                        this._geometry = t
                    }
                    toJSON() {
                        const t = {
                            type: "Feature",
                            state: void 0,
                            geometry: this.geometry,
                            properties: this.properties
                        };
                        void 0 !== this.id && (t.id = this.id);
                        for (const e of Ep)
                            void 0 !== this[e] && (t[e] = this[e]);
                        return t
                    }
                }
                const Sp = 32
                  , Cp = 33
                  , Ap = new Uint16Array(8184);
                for (let t = 0; t < 2046; t++) {
                    let e = t + 2
                      , i = 0
                      , n = 0
                      , r = 0
                      , o = 0
                      , s = 0
                      , a = 0;
                    for (1 & e ? r = o = s = Sp : i = n = a = Sp; (e >>= 1) > 1; ) {
                        const t = i + r >> 1
                          , l = n + o >> 1;
                        1 & e ? (r = i,
                        o = n,
                        i = s,
                        n = a) : (i = r,
                        n = o,
                        r = s,
                        o = a),
                        s = t,
                        a = l
                    }
                    const l = 4 * t;
                    Ap[l + 0] = i,
                    Ap[l + 1] = n,
                    Ap[l + 2] = r,
                    Ap[l + 3] = o
                }
                const Ip = new Uint16Array(2178)
                  , Mp = new Uint8Array(1089)
                  , Pp = new Uint16Array(1089);
                function kp(t) {
                    return 0 === t ? -.03125 : 32 === t ? .03125 : 0
                }
                var Op = jo([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                const Rp = {
                    type: 2,
                    extent: la,
                    loadGeometry: () => [[new v(0,0), new v(la + 1,0), new v(la + 1,la + 1), new v(0,la + 1), new v(0,0)]]
                };
                class Dp {
                    constructor(t, e, i, n, r) {
                        this.tileID = t,
                        this.uid = L(),
                        this.uses = 0,
                        this.tileSize = e,
                        this.tileZoom = i,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.isRaster = r,
                        this.expiredRequestCount = 0,
                        this.state = "loading",
                        n && n.transform && (this.projection = n.transform.projection)
                    }
                    registerFadeDuration(t) {
                        const e = t + this.timeAdded;
                        e < Xt.now() || this.fadeEndTime && e < this.fadeEndTime || (this.fadeEndTime = e)
                    }
                    wasRequested() {
                        return "errored" === this.state || "loaded" === this.state || "reloading" === this.state
                    }
                    get tileTransform() {
                        return this._tileTransform || (this._tileTransform = Of(this.tileID.canonical, this.projection)),
                        this._tileTransform
                    }
                    loadVectorData(t, e, i) {
                        if (this.unloadVectorData(),
                        this.state = "loaded",
                        t) {
                            t.featureIndex && (this.latestFeatureIndex = t.featureIndex,
                            t.rawTileData ? (this.latestRawTileData = t.rawTileData,
                            this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = t.collisionBoxArray,
                            this.buckets = function(t, e) {
                                const i = {};
                                if (!e)
                                    return i;
                                for (const n of t) {
                                    const t = n.layerIds.map((t => e.getLayer(t))).filter(Boolean);
                                    if (0 !== t.length) {
                                        n.layers = t,
                                        n.stateDependentLayerIds && (n.stateDependentLayers = n.stateDependentLayerIds.map((e => t.filter((t => t.id === e))[0])));
                                        for (const e of t)
                                            i[e.id] = n
                                    }
                                }
                                return i
                            }(t.buckets, e.style),
                            this.hasSymbolBuckets = !1;
                            for (const t in this.buckets) {
                                const e = this.buckets[t];
                                if (e instanceof lp) {
                                    if (this.hasSymbolBuckets = !0,
                                    !i)
                                        break;
                                    e.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const t in this.buckets) {
                                    const e = this.buckets[t];
                                    if (e instanceof lp && e.hasRTLText) {
                                        this.hasRTLText = !0,
                                        wo.isLoading() || wo.isLoaded() || "deferred" !== xo() || bo();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const t in this.buckets) {
                                const i = this.buckets[t];
                                this.queryPadding = Math.max(this.queryPadding, e.style.getLayer(t).queryRadius(i))
                            }
                            t.imageAtlas && (this.imageAtlas = t.imageAtlas),
                            t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage),
                            t.lineAtlas && (this.lineAtlas = t.lineAtlas)
                        } else
                            this.collisionBoxArray = new ps
                    }
                    unloadVectorData() {
                        if (this.hasData()) {
                            for (const t in this.buckets)
                                this.buckets[t].destroy();
                            this.buckets = {},
                            this.imageAtlas && (this.imageAtlas = null),
                            this.lineAtlas && (this.lineAtlas = null),
                            this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                            this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                            this.lineAtlasTexture && this.lineAtlasTexture.destroy(),
                            this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(),
                            this._tileBoundsIndexBuffer.destroy(),
                            this._tileBoundsSegments.destroy(),
                            this._tileBoundsBuffer = null),
                            this._tileDebugBuffer && (this._tileDebugBuffer.destroy(),
                            this._tileDebugSegments.destroy(),
                            this._tileDebugBuffer = null),
                            this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(),
                            this._tileDebugIndexBuffer = null),
                            this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(),
                            this._globeTileDebugBorderBuffer = null),
                            this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(),
                            this._tileDebugTextSegments.destroy(),
                            this._tileDebugTextIndexBuffer.destroy(),
                            this._tileDebugTextBuffer = null),
                            this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(),
                            this._globeTileDebugTextBuffer = null),
                            this.latestFeatureIndex = null,
                            this.state = "unloaded"
                        }
                    }
                    getBucket(t) {
                        return this.buckets[t.id]
                    }
                    upload(t) {
                        for (const e in this.buckets) {
                            const i = this.buckets[e];
                            i.uploadPending() && i.upload(t)
                        }
                        const e = t.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new vp(t,this.imageAtlas.image,e.RGBA),
                        this.imageAtlas.uploaded = !0),
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new vp(t,this.glyphAtlasImage,e.ALPHA),
                        this.glyphAtlasImage = null),
                        this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new vp(t,this.lineAtlas.image,e.ALPHA),
                        this.lineAtlas.uploaded = !0)
                    }
                    prepare(t) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture)
                    }
                    queryRenderedFeatures(t, e, i, n, r, o, s, a) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                            tileResult: n,
                            pixelPosMatrix: s,
                            transform: o,
                            params: r,
                            tileTransform: this.tileTransform
                        }, t, e, i) : {}
                    }
                    querySourceFeatures(t, e) {
                        const i = this.latestFeatureIndex;
                        if (!i || !i.rawTileData)
                            return;
                        const n = i.loadVTLayers()
                          , r = e ? e.sourceLayer : ""
                          , o = n._geojsonTileLayer || n[r];
                        if (!o)
                            return;
                        const s = dr(e && e.filter)
                          , {z: a, x: l, y: c} = this.tileID.canonical
                          , h = {
                            z: a,
                            x: l,
                            y: c
                        };
                        for (let e = 0; e < o.length; e++) {
                            const n = o.feature(e);
                            if (s.needGeometry) {
                                const t = lc(n, !0);
                                if (!s.filter(new Eo(this.tileID.overscaledZ), t, this.tileID.canonical))
                                    continue
                            } else if (!s.filter(new Eo(this.tileID.overscaledZ), n))
                                continue;
                            const u = i.getId(n, r)
                              , d = new Tp(n,a,l,c,u);
                            d.tile = h,
                            t.push(d)
                        }
                    }
                    hasData() {
                        return "loaded" === this.state || "reloading" === this.state || "expired" === this.state
                    }
                    patternsLoaded() {
                        return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(t) {
                        const e = this.expirationTime;
                        if (t.cacheControl) {
                            const e = X(t.cacheControl);
                            e["max-age"] && (this.expirationTime = Date.now() + 1e3 * e["max-age"])
                        } else
                            t.expires && (this.expirationTime = new Date(t.expires).getTime());
                        if (this.expirationTime) {
                            const t = Date.now();
                            let i = !1;
                            if (this.expirationTime > t)
                                i = !1;
                            else if (e)
                                if (this.expirationTime < e)
                                    i = !0;
                                else {
                                    const n = this.expirationTime - e;
                                    n ? this.expirationTime = t + Math.max(n, 3e4) : i = !0
                                }
                            else
                                i = !0;
                            i ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (new Date).getTime(), Math.pow(2, 31) - 1)
                    }
                    setFeatureState(t, e) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t).length || !e)
                            return;
                        const i = this.latestFeatureIndex.loadVTLayers()
                          , n = e.style.listImages();
                        for (const r in this.buckets) {
                            if (!e.style.hasLayer(r))
                                continue;
                            const o = this.buckets[r]
                              , s = o.layers[0].sourceLayer || "_geojsonTileLayer"
                              , a = i[s]
                              , l = t[s];
                            if (!a || !l || 0 === Object.keys(l).length)
                                continue;
                            if (o.update(l, a, n, this.imageAtlas && this.imageAtlas.patternPositions || {}),
                            o instanceof Au || o instanceof Ih) {
                                const t = e.style._getSourceCache(o.layers[0].source);
                                e._terrain && e._terrain.enabled && t && o.programConfigurations.needsUpload && e._terrain._clearRenderCacheForTile(t.id, this.tileID)
                            }
                            const c = e && e.style && e.style.getLayer(r);
                            c && (this.queryPadding = Math.max(this.queryPadding, c.queryRadius(o)))
                        }
                    }
                    holdingForFade() {
                        return void 0 !== this.symbolFadeHoldUntil
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < Xt.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(t) {
                        this.symbolFadeHoldUntil = Xt.now() + t
                    }
                    setTexture(t, e) {
                        const i = e.context
                          , n = i.gl;
                        this.texture = this.texture || e.getTileTexture(t.width),
                        this.texture ? this.texture.update(t, {
                            useMipmap: !0
                        }) : (this.texture = new vp(i,t,n.RGBA,{
                            useMipmap: !0
                        }),
                        this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE))
                    }
                    setDependencies(t, e) {
                        const i = {};
                        for (const t of e)
                            i[t] = !0;
                        this.dependencies[t] = i
                    }
                    hasDependency(t, e) {
                        for (const i of t) {
                            const t = this.dependencies[i];
                            if (t)
                                for (const i of e)
                                    if (t[i])
                                        return !0
                        }
                        return !1
                    }
                    clearQueryDebugViz() {}
                    _makeDebugTileBoundsBuffers(t, e) {
                        if (!e || "mercator" === e.name || this._tileDebugBuffer)
                            return;
                        const i = ac(Rp, this.tileID.canonical, this.tileTransform)[0]
                          , n = new Vo
                          , r = new us;
                        for (let t = 0; t < i.length; t++) {
                            const {x: e, y: o} = i[t];
                            n.emplaceBack(e, o),
                            r.emplaceBack(t)
                        }
                        r.emplaceBack(0),
                        this._tileDebugIndexBuffer = t.createIndexBuffer(r),
                        this._tileDebugBuffer = t.createVertexBuffer(n, el.members),
                        this._tileDebugSegments = aa.simpleSegment(0, 0, n.length, r.length)
                    }
                    _makeTileBoundsBuffers(t, e) {
                        if (this._tileBoundsBuffer || !e || "mercator" === e.name)
                            return;
                        const i = ac(Rp, this.tileID.canonical, this.tileTransform)[0];
                        let n, r;
                        if (this.isRaster) {
                            const t = function(t, e) {
                                const i = Of(t, e)
                                  , n = Math.pow(2, t.z);
                                for (let r = 0; r < Cp; r++)
                                    for (let o = 0; o < Cp; o++) {
                                        const s = $l((t.x + (o + kp(o)) / Sp) / n)
                                          , a = Xl((t.y + (r + kp(r)) / Sp) / n)
                                          , l = e.project(s, a)
                                          , c = r * Cp + o;
                                        Ip[2 * c + 0] = Math.round((l.x * i.scale - i.x) * la),
                                        Ip[2 * c + 1] = Math.round((l.y * i.scale - i.y) * la)
                                    }
                                Mp.fill(0),
                                Pp.fill(0);
                                for (let t = 2045; t >= 0; t--) {
                                    const e = 4 * t
                                      , i = Ap[e + 0]
                                      , n = Ap[e + 1]
                                      , r = Ap[e + 2]
                                      , o = Ap[e + 3]
                                      , s = i + r >> 1
                                      , a = n + o >> 1
                                      , l = s + a - n
                                      , c = a + i - s
                                      , h = n * Cp + i
                                      , u = o * Cp + r
                                      , d = a * Cp + s
                                      , f = Math.hypot((Ip[2 * h + 0] + Ip[2 * u + 0]) / 2 - Ip[2 * d + 0], (Ip[2 * h + 1] + Ip[2 * u + 1]) / 2 - Ip[2 * d + 1]) >= 16;
                                    Mp[d] = Mp[d] || (f ? 1 : 0),
                                    t < 1022 && (Mp[d] = Mp[d] || Mp[(n + c >> 1) * Cp + (i + l >> 1)] || Mp[(o + c >> 1) * Cp + (r + l >> 1)])
                                }
                                const r = new Zo
                                  , o = new rs;
                                let s = 0;
                                function a(t, e) {
                                    const i = e * Cp + t;
                                    return 0 === Pp[i] && (r.emplaceBack(Ip[2 * i + 0], Ip[2 * i + 1], t * la / Sp, e * la / Sp),
                                    Pp[i] = ++s),
                                    Pp[i] - 1
                                }
                                function l(t, e, i, n, r, s) {
                                    const c = t + i >> 1
                                      , h = e + n >> 1;
                                    if (Math.abs(t - r) + Math.abs(e - s) > 1 && Mp[h * Cp + c])
                                        l(r, s, t, e, c, h),
                                        l(i, n, r, s, c, h);
                                    else {
                                        const l = a(t, e)
                                          , c = a(i, n)
                                          , h = a(r, s);
                                        o.emplaceBack(l, c, h)
                                    }
                                }
                                return l(0, 0, Sp, Sp, Sp, 0),
                                l(Sp, Sp, 0, 0, 0, Sp),
                                {
                                    vertices: r,
                                    indices: o
                                }
                            }(this.tileID.canonical, e);
                            n = t.vertices,
                            r = t.indices
                        } else {
                            n = new Zo,
                            r = new rs;
                            for (const {x: t, y: e} of i)
                                n.emplaceBack(t, e, 0, 0);
                            const t = vh(n.int16, void 0, 4);
                            for (let e = 0; e < t.length; e += 3)
                                r.emplaceBack(t[e], t[e + 1], t[e + 2])
                        }
                        this._tileBoundsBuffer = t.createVertexBuffer(n, Op.members),
                        this._tileBoundsIndexBuffer = t.createIndexBuffer(r),
                        this._tileBoundsSegments = aa.simpleSegment(0, 0, n.length, r.length)
                    }
                    _makeGlobeTileDebugBuffers(t, e) {
                        const i = e.projection;
                        if (!i || "globe" !== i.name || e.freezeTileCoverage)
                            return;
                        const n = this.tileID.canonical
                          , r = kl(bl(n, e))
                          , o = Dl(e.zoom);
                        let s;
                        o > 0 && (s = ma(new Float64Array(16), e.globeMatrix)),
                        this._makeGlobeTileDebugBorderBuffer(t, n, e, r, s, o),
                        this._makeGlobeTileDebugTextBuffer(t, n, e, r, s, o)
                    }
                    _globePoint(t, e, i, n, r, o, s) {
                        let a = Il(t, e, i);
                        if (o) {
                            const r = 1 << i.z
                              , l = ql(n.center.lng)
                              , c = Wl(n.center.lat)
                              , h = (i.x + .5) / r - l;
                            let u = 0;
                            h > .5 ? u = -1 : h < -.5 && (u = 1);
                            let d = (t / la + i.x) / r + u
                              , f = (e / la + i.y) / r;
                            d = (d - l) * n._pixelsPerMercatorPixel + l,
                            f = (f - c) * n._pixelsPerMercatorPixel + c;
                            const p = [d * n.worldSize, f * n.worldSize, 0];
                            Fa(p, p, o),
                            a = xl(a, p, s)
                        }
                        return Fa(a, a, r)
                    }
                    _makeGlobeTileDebugBorderBuffer(t, e, i, n, r, o) {
                        const s = new Vo
                          , a = new us
                          , l = new Go
                          , c = (t, c, h, u, d) => {
                            const f = (h - t) / (d - 1)
                              , p = (u - c) / (d - 1)
                              , m = s.length;
                            for (let h = 0; h < d; h++) {
                                const u = t + h * f
                                  , d = c + h * p;
                                s.emplaceBack(u, d);
                                const g = this._globePoint(u, d, e, i, n, r, o);
                                l.emplaceBack(g[0], g[1], g[2]),
                                a.emplaceBack(m + h)
                            }
                        }
                          , h = la;
                        c(0, 0, h, 0, 16),
                        c(h, 0, h, h, 16),
                        c(h, h, 0, h, 16),
                        c(0, h, 0, 0, 16),
                        this._tileDebugIndexBuffer = t.createIndexBuffer(a),
                        this._tileDebugBuffer = t.createVertexBuffer(s, el.members),
                        this._globeTileDebugBorderBuffer = t.createVertexBuffer(l, tl.members),
                        this._tileDebugSegments = aa.simpleSegment(0, 0, s.length, a.length)
                    }
                    _makeGlobeTileDebugTextBuffer(t, e, i, n, r, o) {
                        const s = la / 4
                          , a = new Vo
                          , l = new rs
                          , c = new Go
                          , h = 25;
                        l.reserve(32),
                        a.reserve(h),
                        c.reserve(h);
                        const u = (t, e) => h * t + e;
                        for (let t = 0; t < h; t++) {
                            const l = t * s;
                            for (let t = 0; t < h; t++) {
                                const h = t * s;
                                a.emplaceBack(h, l);
                                const u = this._globePoint(h, l, e, i, n, r, o);
                                c.emplaceBack(u[0], u[1], u[2])
                            }
                        }
                        for (let t = 0; t < 4; t++)
                            for (let e = 0; e < 4; e++) {
                                const i = u(t, e)
                                  , n = u(t, e + 1)
                                  , r = u(t + 1, e)
                                  , o = u(t + 1, e + 1);
                                l.emplaceBack(i, n, r),
                                l.emplaceBack(r, n, o)
                            }
                        this._tileDebugTextIndexBuffer = t.createIndexBuffer(l),
                        this._tileDebugTextBuffer = t.createVertexBuffer(a, el.members),
                        this._globeTileDebugTextBuffer = t.createVertexBuffer(c, tl.members),
                        this._tileDebugTextSegments = aa.simpleSegment(0, 0, h, 32)
                    }
                }
                class Lp {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(t, e, i) {
                        const n = String(e);
                        if (this.stateChanges[t] = this.stateChanges[t] || {},
                        this.stateChanges[t][n] = this.stateChanges[t][n] || {},
                        R(this.stateChanges[t][n], i),
                        null === this.deletedStates[t]) {
                            this.deletedStates[t] = {};
                            for (const e in this.state[t])
                                e !== n && (this.deletedStates[t][e] = null)
                        } else if (this.deletedStates[t] && null === this.deletedStates[t][n]) {
                            this.deletedStates[t][n] = {};
                            for (const e in this.state[t][n])
                                i[e] || (this.deletedStates[t][n][e] = null)
                        } else
                            for (const e in i)
                                this.deletedStates[t] && this.deletedStates[t][n] && null === this.deletedStates[t][n][e] && delete this.deletedStates[t][n][e]
                    }
                    removeFeatureState(t, e, i) {
                        if (null === this.deletedStates[t])
                            return;
                        const n = String(e);
                        if (this.deletedStates[t] = this.deletedStates[t] || {},
                        i && void 0 !== e)
                            null !== this.deletedStates[t][n] && (this.deletedStates[t][n] = this.deletedStates[t][n] || {},
                            this.deletedStates[t][n][i] = null);
                        else if (void 0 !== e)
                            if (this.stateChanges[t] && this.stateChanges[t][n])
                                for (i in this.deletedStates[t][n] = {},
                                this.stateChanges[t][n])
                                    this.deletedStates[t][n][i] = null;
                            else
                                this.deletedStates[t][n] = null;
                        else
                            this.deletedStates[t] = null
                    }
                    getState(t, e) {
                        const i = String(e)
                          , n = R({}, (this.state[t] || {})[i], (this.stateChanges[t] || {})[i]);
                        if (null === this.deletedStates[t])
                            return {};
                        if (this.deletedStates[t]) {
                            const i = this.deletedStates[t][e];
                            if (null === i)
                                return {};
                            for (const t in i)
                                delete n[t]
                        }
                        return n
                    }
                    initializeTileState(t, e) {
                        t.setFeatureState(this.state, e)
                    }
                    coalesceChanges(t, e) {
                        const i = {};
                        for (const t in this.stateChanges) {
                            this.state[t] = this.state[t] || {};
                            const e = {};
                            for (const i in this.stateChanges[t])
                                this.state[t][i] || (this.state[t][i] = {}),
                                R(this.state[t][i], this.stateChanges[t][i]),
                                e[i] = this.state[t][i];
                            i[t] = e
                        }
                        for (const t in this.deletedStates) {
                            this.state[t] = this.state[t] || {};
                            const e = {};
                            if (null === this.deletedStates[t])
                                for (const i in this.state[t])
                                    e[i] = {},
                                    this.state[t][i] = {};
                            else
                                for (const i in this.deletedStates[t]) {
                                    if (null === this.deletedStates[t][i])
                                        this.state[t][i] = {};
                                    else if (this.state[t][i])
                                        for (const e of Object.keys(this.deletedStates[t][i]))
                                            delete this.state[t][i][e];
                                    e[i] = this.state[t][i]
                                }
                            i[t] = i[t] || {},
                            R(i[t], e)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        0 !== Object.keys(i).length)
                            for (const n in t)
                                t[n].setFeatureState(i, e)
                    }
                }
                class Bp {
                    constructor(t) {
                        this.size = t,
                        this.minimums = [],
                        this.maximums = [],
                        this.leaves = []
                    }
                    getElevation(t, e) {
                        const i = this.toIdx(t, e);
                        return {
                            min: this.minimums[i],
                            max: this.maximums[i]
                        }
                    }
                    isLeaf(t, e) {
                        return this.leaves[this.toIdx(t, e)]
                    }
                    toIdx(t, e) {
                        return e * this.size + t
                    }
                }
                function zp(t, e, i, n) {
                    let r = 0
                      , o = Number.MAX_VALUE;
                    for (let s = 0; s < 3; s++)
                        if (Math.abs(n[s]) < 1e-15) {
                            if (i[s] < t[s] || i[s] > e[s])
                                return null
                        } else {
                            const a = 1 / n[s];
                            let l = (t[s] - i[s]) * a
                              , c = (e[s] - i[s]) * a;
                            if (l > c) {
                                const t = l;
                                l = c,
                                c = t
                            }
                            if (l > r && (r = l),
                            c < o && (o = c),
                            r > o)
                                return null
                        }
                    return r
                }
                function Fp(t, e, i, n, r, o, s, a, l, c, h) {
                    const u = n - t
                      , d = r - e
                      , f = o - i
                      , p = s - t
                      , m = a - e
                      , g = l - i
                      , _ = h[1] * g - h[2] * m
                      , y = h[2] * p - h[0] * g
                      , v = h[0] * m - h[1] * p
                      , x = u * _ + d * y + f * v;
                    if (Math.abs(x) < 1e-15)
                        return null;
                    const b = 1 / x
                      , w = c[0] - t
                      , E = c[1] - e
                      , T = c[2] - i
                      , S = (w * _ + E * y + T * v) * b;
                    if (S < 0 || S > 1)
                        return null;
                    const C = E * f - T * d
                      , A = T * u - w * f
                      , I = w * d - E * u
                      , M = (h[0] * C + h[1] * A + h[2] * I) * b;
                    return M < 0 || S + M > 1 ? null : (p * C + m * A + g * I) * b
                }
                function Np(t, e, i) {
                    return (t - e) / (i - e)
                }
                function jp(t, e, i, n, r, o, s, a, l) {
                    const c = 1 << i
                      , h = o - n
                      , u = s - r
                      , d = (t + 1) / c * h + n
                      , f = (e + 0) / c * u + r
                      , p = (e + 1) / c * u + r;
                    a[0] = (t + 0) / c * h + n,
                    a[1] = f,
                    l[0] = d,
                    l[1] = p
                }
                class Up {
                    constructor(t) {
                        if (this.maximums = [],
                        this.minimums = [],
                        this.leaves = [],
                        this.childOffsets = [],
                        this.nodeCount = 0,
                        this.dem = t,
                        this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]],
                        !this.dem)
                            return;
                        const e = function(t) {
                            const e = Math.ceil(Math.log2(t.dim / 8))
                              , i = [];
                            let n = Math.ceil(Math.pow(2, e));
                            const r = 1 / n
                              , o = (t, e, i, n, r) => {
                                const o = n ? 1 : 0
                                  , s = (t + 1) * i - o
                                  , a = e * i
                                  , l = (e + 1) * i - o;
                                r[0] = t * i,
                                r[1] = a,
                                r[2] = s,
                                r[3] = l
                            }
                            ;
                            let s = new Bp(n);
                            const a = [];
                            for (let e = 0; e < n * n; e++) {
                                o(e % n, Math.floor(e / n), r, !1, a);
                                const i = Gp(a[0], a[1], t)
                                  , l = Gp(a[2], a[1], t)
                                  , c = Gp(a[2], a[3], t)
                                  , h = Gp(a[0], a[3], t);
                                s.minimums.push(Math.min(i, l, c, h)),
                                s.maximums.push(Math.max(i, l, c, h)),
                                s.leaves.push(1)
                            }
                            for (i.push(s),
                            n /= 2; n >= 1; n /= 2) {
                                const t = i[i.length - 1];
                                s = new Bp(n);
                                for (let e = 0; e < n * n; e++) {
                                    o(e % n, Math.floor(e / n), 2, !0, a);
                                    const i = t.getElevation(a[0], a[1])
                                      , r = t.getElevation(a[2], a[1])
                                      , l = t.getElevation(a[2], a[3])
                                      , c = t.getElevation(a[0], a[3])
                                      , h = t.isLeaf(a[0], a[1])
                                      , u = t.isLeaf(a[2], a[1])
                                      , d = t.isLeaf(a[2], a[3])
                                      , f = t.isLeaf(a[0], a[3])
                                      , p = Math.min(i.min, r.min, l.min, c.min)
                                      , m = Math.max(i.max, r.max, l.max, c.max)
                                      , g = h && u && d && f;
                                    s.maximums.push(m),
                                    s.minimums.push(p),
                                    s.leaves.push(m - p <= 5 && g ? 1 : 0)
                                }
                                i.push(s)
                            }
                            return i
                        }(this.dem)
                          , i = e.length - 1
                          , n = e[i];
                        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]),
                        this._construct(e, 0, 0, i, 0)
                    }
                    raycastRoot(t, e, i, n, r, o, s=1) {
                        return zp([t, e, -100], [i, n, this.maximums[0] * s], r, o)
                    }
                    raycast(t, e, i, n, r, o, s=1) {
                        if (!this.nodeCount)
                            return null;
                        const a = this.raycastRoot(t, e, i, n, r, o, s);
                        if (null == a)
                            return null;
                        const l = []
                          , c = []
                          , h = []
                          , u = []
                          , d = [{
                            idx: 0,
                            t: a,
                            nodex: 0,
                            nodey: 0,
                            depth: 0
                        }];
                        for (; d.length > 0; ) {
                            const {idx: a, t: f, nodex: p, nodey: m, depth: g} = d.pop();
                            if (this.leaves[a]) {
                                jp(p, m, g, t, e, i, n, h, u);
                                const a = 1 << g
                                  , l = (p + 0) / a
                                  , c = (p + 1) / a
                                  , d = (m + 0) / a
                                  , _ = (m + 1) / a
                                  , y = Gp(l, d, this.dem) * s
                                  , v = Gp(c, d, this.dem) * s
                                  , x = Gp(c, _, this.dem) * s
                                  , b = Gp(l, _, this.dem) * s
                                  , w = Fp(h[0], h[1], y, u[0], h[1], v, u[0], u[1], x, r, o)
                                  , E = Fp(u[0], u[1], x, h[0], u[1], b, h[0], h[1], y, r, o)
                                  , T = Math.min(null !== w ? w : Number.MAX_VALUE, null !== E ? E : Number.MAX_VALUE);
                                if (T !== Number.MAX_VALUE)
                                    return T;
                                {
                                    const t = Da([], r, o, f);
                                    if (Vp(y, v, b, x, Np(t[0], h[0], u[0]), Np(t[1], h[1], u[1])) >= t[2])
                                        return f
                                }
                                continue
                            }
                            let _ = 0;
                            for (let d = 0; d < this._siblingOffset.length; d++) {
                                jp((p << 1) + this._siblingOffset[d][0], (m << 1) + this._siblingOffset[d][1], g + 1, t, e, i, n, h, u),
                                h[2] = -100,
                                u[2] = this.maximums[this.childOffsets[a] + d] * s;
                                const f = zp(h, u, r, o);
                                if (null != f) {
                                    const t = f;
                                    l[d] = t;
                                    let e = !1;
                                    for (let i = 0; i < _ && !e; i++)
                                        t >= l[c[i]] && (c.splice(i, 0, d),
                                        e = !0);
                                    e || (c[_] = d),
                                    _++
                                }
                            }
                            for (let t = 0; t < _; t++) {
                                const e = c[t];
                                d.push({
                                    idx: this.childOffsets[a] + e,
                                    t: l[e],
                                    nodex: (p << 1) + this._siblingOffset[e][0],
                                    nodey: (m << 1) + this._siblingOffset[e][1],
                                    depth: g + 1
                                })
                            }
                        }
                        return null
                    }
                    _addNode(t, e, i) {
                        return this.minimums.push(t),
                        this.maximums.push(e),
                        this.leaves.push(i),
                        this.childOffsets.push(0),
                        this.nodeCount++
                    }
                    _construct(t, e, i, n, r) {
                        if (1 === t[n].isLeaf(e, i))
                            return;
                        this.childOffsets[r] || (this.childOffsets[r] = this.nodeCount);
                        const o = n - 1
                          , s = t[o];
                        let a = 0
                          , l = 0;
                        for (let t = 0; t < this._siblingOffset.length; t++) {
                            const n = 2 * e + this._siblingOffset[t][0]
                              , r = 2 * i + this._siblingOffset[t][1]
                              , o = s.getElevation(n, r)
                              , c = s.isLeaf(n, r)
                              , h = this._addNode(o.min, o.max, c);
                            c && (a |= 1 << t),
                            l || (l = h)
                        }
                        for (let n = 0; n < this._siblingOffset.length; n++)
                            a & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * i + this._siblingOffset[n][1], o, l + n)
                    }
                }
                function Vp(t, e, i, n, r, o) {
                    return Oi(Oi(t, i, o), Oi(e, n, o), r)
                }
                function Gp(t, e, i) {
                    const n = i.dim
                      , r = I(t * n - .5, 0, n - 1)
                      , o = I(e * n - .5, 0, n - 1)
                      , s = Math.floor(r)
                      , a = Math.floor(o)
                      , l = Math.min(s + 1, n - 1)
                      , c = Math.min(a + 1, n - 1);
                    return Vp(i.get(s, a), i.get(l, a), i.get(s, c), i.get(l, c), r - s, o - a)
                }
                const Zp = {
                    mapbox: [6553.6, 25.6, .1, 1e4],
                    terrarium: [256, 1, 1 / 256, 32768]
                };
                function qp(t, e, i) {
                    return (256 * t * 256 + 256 * e + i) / 10 - 1e4
                }
                function Wp(t, e, i) {
                    return 256 * t + e + i / 256 - 32768
                }
                class Hp {
                    get tree() {
                        return this._tree || this._buildQuadTree(),
                        this._tree
                    }
                    constructor(t, e, i, n=!1, r=!1) {
                        if (this.uid = t,
                        e.height !== e.width)
                            throw new RangeError("DEM tiles must be square");
                        if (i && "mapbox" !== i && "terrarium" !== i)
                            return q(`"${i}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
                        this.stride = e.height;
                        const o = this.dim = e.height - 2
                          , s = new Uint32Array(e.data.buffer);
                        if (this.pixels = new Uint8Array(e.data.buffer),
                        this.encoding = i || "mapbox",
                        this.borderReady = n,
                        !n) {
                            for (let t = 0; t < o; t++)
                                s[this._idx(-1, t)] = s[this._idx(0, t)],
                                s[this._idx(o, t)] = s[this._idx(o - 1, t)],
                                s[this._idx(t, -1)] = s[this._idx(t, 0)],
                                s[this._idx(t, o)] = s[this._idx(t, o - 1)];
                            s[this._idx(-1, -1)] = s[this._idx(0, 0)],
                            s[this._idx(o, -1)] = s[this._idx(o - 1, 0)],
                            s[this._idx(-1, o)] = s[this._idx(0, o - 1)],
                            s[this._idx(o, o)] = s[this._idx(o - 1, o - 1)],
                            r && this._buildQuadTree()
                        }
                    }
                    _buildQuadTree() {
                        this._tree = new Up(this)
                    }
                    get(t, e, i=!1) {
                        i && (t = I(t, -1, this.dim),
                        e = I(e, -1, this.dim));
                        const n = 4 * this._idx(t, e);
                        return ("terrarium" === this.encoding ? Wp : qp)(this.pixels[n], this.pixels[n + 1], this.pixels[n + 2])
                    }
                    static getUnpackVector(t) {
                        return Zp[t]
                    }
                    get unpackVector() {
                        return Zp[this.encoding]
                    }
                    _idx(t, e) {
                        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (e + 1) * this.stride + (t + 1)
                    }
                    static pack(t, e) {
                        const i = [0, 0, 0, 0]
                          , n = Hp.getUnpackVector(e);
                        let r = Math.floor((t + n[3]) / n[2]);
                        return i[2] = r % 256,
                        r = Math.floor(r / 256),
                        i[1] = r % 256,
                        r = Math.floor(r / 256),
                        i[0] = r,
                        i
                    }
                    getPixels() {
                        return new jc({
                            width: this.stride,
                            height: this.stride
                        },this.pixels)
                    }
                    backfillBorder(t, e, i) {
                        if (this.dim !== t.dim)
                            throw new Error("dem dimension mismatch");
                        let n = e * this.dim
                          , r = e * this.dim + this.dim
                          , o = i * this.dim
                          , s = i * this.dim + this.dim;
                        switch (e) {
                        case -1:
                            n = r - 1;
                            break;
                        case 1:
                            r = n + 1
                        }
                        switch (i) {
                        case -1:
                            o = s - 1;
                            break;
                        case 1:
                            s = o + 1
                        }
                        const a = -e * this.dim
                          , l = -i * this.dim;
                        for (let e = o; e < s; e++)
                            for (let i = n; i < r; i++) {
                                const n = 4 * this._idx(i, e)
                                  , r = 4 * this._idx(i + a, e + l);
                                this.pixels[n + 0] = t.pixels[r + 0],
                                this.pixels[n + 1] = t.pixels[r + 1],
                                this.pixels[n + 2] = t.pixels[r + 2],
                                this.pixels[n + 3] = t.pixels[r + 3]
                            }
                    }
                    onDeserialize() {
                        this._tree && (this._tree.dem = this)
                    }
                }
                Yr(Hp, "DEMData"),
                Yr(Up, "DemMinMaxQuadTree", {
                    omit: ["dem"]
                });
                class $p {
                    constructor(t, e) {
                        this.max = t,
                        this.onRemove = e,
                        this.reset()
                    }
                    reset() {
                        for (const t in this.data)
                            for (const e of this.data[t])
                                e.timeout && clearTimeout(e.timeout),
                                this.onRemove(e.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(t, e, i) {
                        const n = t.wrapped().key;
                        void 0 === this.data[n] && (this.data[n] = []);
                        const r = {
                            value: e,
                            timeout: void 0
                        };
                        if (void 0 !== i && (r.timeout = setTimeout(( () => {
                            this.remove(t, r)
                        }
                        ), i)),
                        this.data[n].push(r),
                        this.order.push(n),
                        this.order.length > this.max) {
                            const t = this._getAndRemoveByKey(this.order[0]);
                            t && this.onRemove(t)
                        }
                        return this
                    }
                    has(t) {
                        return t.wrapped().key in this.data
                    }
                    getAndRemove(t) {
                        return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null
                    }
                    _getAndRemoveByKey(t) {
                        const e = this.data[t].shift();
                        return e.timeout && clearTimeout(e.timeout),
                        0 === this.data[t].length && delete this.data[t],
                        this.order.splice(this.order.indexOf(t), 1),
                        e.value
                    }
                    getByKey(t) {
                        const e = this.data[t];
                        return e ? e[0].value : null
                    }
                    get(t) {
                        return this.has(t) ? this.data[t.wrapped().key][0].value : null
                    }
                    remove(t, e) {
                        if (!this.has(t))
                            return this;
                        const i = t.wrapped().key
                          , n = void 0 === e ? 0 : this.data[i].indexOf(e)
                          , r = this.data[i][n];
                        return this.data[i].splice(n, 1),
                        r.timeout && clearTimeout(r.timeout),
                        0 === this.data[i].length && delete this.data[i],
                        this.onRemove(r.value),
                        this.order.splice(this.order.indexOf(i), 1),
                        this
                    }
                    setMaxSize(t) {
                        for (this.max = t; this.order.length > this.max; ) {
                            const t = this._getAndRemoveByKey(this.order[0]);
                            t && this.onRemove(t)
                        }
                        return this
                    }
                    filter(t) {
                        const e = [];
                        for (const i in this.data)
                            for (const n of this.data[i])
                                t(n.value) || e.push(n);
                        for (const t of e)
                            this.remove(t.value.tileID, t)
                    }
                }
                class Xp {
                    constructor(t, e, i) {
                        this.func = t,
                        this.mask = e,
                        this.range = i
                    }
                }
                Xp.ReadOnly = !1,
                Xp.ReadWrite = !0,
                Xp.disabled = new Xp(519,Xp.ReadOnly,[0, 1]);
                const Yp = 7680;
                class Kp {
                    constructor(t, e, i, n, r, o) {
                        this.test = t,
                        this.ref = e,
                        this.mask = i,
                        this.fail = n,
                        this.depthFail = r,
                        this.pass = o
                    }
                }
                Kp.disabled = new Kp({
                    func: 519,
                    mask: 0
                },0,0,Yp,Yp,Yp);
                class Jp {
                    constructor(t, e, i) {
                        this.blendFunction = t,
                        this.blendColor = e,
                        this.mask = i
                    }
                }
                Jp.Replace = [1, 0],
                Jp.disabled = new Jp(Jp.Replace,Oe.transparent,[!1, !1, !1, !1]),
                Jp.unblended = new Jp(Jp.Replace,Oe.transparent,[!0, !0, !0, !0]),
                Jp.alphaBlended = new Jp([1, 771],Oe.transparent,[!0, !0, !0, !0]);
                const Qp = 1029
                  , tm = 2305;
                class em {
                    constructor(t, e, i) {
                        this.enable = t,
                        this.mode = e,
                        this.frontFace = i
                    }
                }
                em.disabled = new em(!1,Qp,tm),
                em.backCCW = new em(!0,Qp,tm),
                em.backCW = new em(!0,Qp,2304),
                em.frontCW = new em(!0,1028,2304),
                em.frontCCW = new em(!0,1028,tm);
                class im extends te {
                    constructor(t, e, i) {
                        super(),
                        this.id = t,
                        this._onlySymbols = i,
                        e.on("data", (t => {
                            "source" === t.dataType && "metadata" === t.sourceDataType && (this._sourceLoaded = !0),
                            this._sourceLoaded && !this._paused && "source" === t.dataType && "content" === t.sourceDataType && (this.reload(),
                            this.transform && this.update(this.transform))
                        }
                        )),
                        e.on("error", ( () => {
                            this._sourceErrored = !0
                        }
                        )),
                        this._source = e,
                        this._tiles = {},
                        this._cache = new $p(0,this._unloadTile.bind(this)),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._minTileCacheSize = e.minTileCacheSize,
                        this._maxTileCacheSize = e.maxTileCacheSize,
                        this._loadedParentTiles = {},
                        this._coveredTiles = {},
                        this._state = new Lp,
                        this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType
                    }
                    onAdd(t) {
                        this.map = t,
                        this._minTileCacheSize = void 0 === this._minTileCacheSize && t ? t._minTileCacheSize : this._minTileCacheSize,
                        this._maxTileCacheSize = void 0 === this._maxTileCacheSize && t ? t._maxTileCacheSize : this._maxTileCacheSize
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded)
                            return !1;
                        if (!this._source.loaded())
                            return !1;
                        for (const t in this._tiles) {
                            const e = this._tiles[t];
                            if ("loaded" !== e.state && "errored" !== e.state)
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const t = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        t && this.reload(),
                        this.transform && this.update(this.transform)
                    }
                    _loadTile(t, e) {
                        return t.isSymbolTile = this._onlySymbols,
                        this._source.loadTile(t, e)
                    }
                    _unloadTile(t) {
                        if (this._source.unloadTile)
                            return this._source.unloadTile(t, ( () => {}
                            ))
                    }
                    _abortTile(t) {
                        if (this._source.abortTile)
                            return this._source.abortTile(t, ( () => {}
                            ))
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(t) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const e in this._tiles) {
                            const i = this._tiles[e];
                            i.upload(t),
                            i.prepare(this.map.style.imageManager)
                        }
                    }
                    getIds() {
                        return O(this._tiles).map((t => t.tileID)).sort(nm).map((t => t.key))
                    }
                    getRenderableIds(t) {
                        const e = [];
                        for (const i in this._tiles)
                            this._isIdRenderable(+i, t) && e.push(this._tiles[i]);
                        return t ? e.sort(( (t, e) => {
                            const i = t.tileID
                              , n = e.tileID
                              , r = new v(i.canonical.x,i.canonical.y)._rotate(this.transform.angle)
                              , o = new v(n.canonical.x,n.canonical.y)._rotate(this.transform.angle);
                            return i.overscaledZ - n.overscaledZ || o.y - r.y || o.x - r.x
                        }
                        )).map((t => t.tileID.key)) : e.map((t => t.tileID)).sort(nm).map((t => t.key))
                    }
                    hasRenderableParent(t) {
                        const e = this.findLoadedParent(t, 0);
                        return !!e && this._isIdRenderable(e.tileID.key)
                    }
                    _isIdRenderable(t, e) {
                        return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (e || !this._tiles[t].holdingForFade())
                    }
                    reload() {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const t in this._tiles)
                                "errored" !== this._tiles[t].state && this._reloadTile(+t, "reloading")
                        }
                    }
                    _reloadTile(t, e) {
                        const i = this._tiles[t];
                        i && ("loading" !== i.state && (i.state = e),
                        this._loadTile(i, this._tileLoaded.bind(this, i, t, e)))
                    }
                    _tileLoaded(t, e, i, n) {
                        if (n)
                            if (t.state = "errored",
                            404 !== n.status)
                                this._source.fire(new Qt(n,{
                                    tile: t
                                }));
                            else if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                                const t = this.map.painter.terrain;
                                this.update(this.transform, t.getScaledDemTileSize(), !0),
                                t.resetTileLookupCache(this.id)
                            } else
                                this.update(this.transform);
                        else
                            t.timeAdded = Xt.now(),
                            "expired" === i && (t.refreshedUponExpiration = !0),
                            this._setTileReloadTimer(e, t),
                            "raster-dem" === this._source.type && t.dem && this._backfillDEM(t),
                            this._state.initializeTileState(t, this.map ? this.map.painter : null),
                            this._source.fire(new Jt("data",{
                                dataType: "source",
                                tile: t,
                                coord: t.tileID,
                                sourceCacheId: this.id
                            }))
                    }
                    _backfillDEM(t) {
                        const e = this.getRenderableIds();
                        for (let n = 0; n < e.length; n++) {
                            const r = e[n];
                            if (t.neighboringTiles && t.neighboringTiles[r]) {
                                const e = this.getTileByID(r);
                                i(t, e),
                                i(e, t)
                            }
                        }
                        function i(t, e) {
                            if (!t.dem || t.dem.borderReady)
                                return;
                            t.needsHillshadePrepare = !0,
                            t.needsDEMTextureUpload = !0;
                            let i = e.tileID.canonical.x - t.tileID.canonical.x;
                            const n = e.tileID.canonical.y - t.tileID.canonical.y
                              , r = Math.pow(2, t.tileID.canonical.z)
                              , o = e.tileID.key;
                            0 === i && 0 === n || Math.abs(n) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + r) ? i += r : 1 === Math.abs(i - r) && (i -= r)),
                            e.dem && t.dem && (t.dem.backfillBorder(e.dem, i, n),
                            t.neighboringTiles && t.neighboringTiles[o] && (t.neighboringTiles[o].backfilled = !0)))
                        }
                    }
                    getTile(t) {
                        return this.getTileByID(t.key)
                    }
                    getTileByID(t) {
                        return this._tiles[t]
                    }
                    _retainLoadedChildren(t, e, i, n) {
                        for (const r in this._tiles) {
                            let o = this._tiles[r];
                            if (n[r] || !o.hasData() || o.tileID.overscaledZ <= e || o.tileID.overscaledZ > i)
                                continue;
                            let s = o.tileID;
                            for (; o && o.tileID.overscaledZ > e + 1; ) {
                                const t = o.tileID.scaledTo(o.tileID.overscaledZ - 1);
                                o = this._tiles[t.key],
                                o && o.hasData() && (s = t)
                            }
                            let a = s;
                            for (; a.overscaledZ > e; )
                                if (a = a.scaledTo(a.overscaledZ - 1),
                                t[a.key]) {
                                    n[s.key] = s;
                                    break
                                }
                        }
                    }
                    findLoadedParent(t, e) {
                        if (t.key in this._loadedParentTiles) {
                            const i = this._loadedParentTiles[t.key];
                            return i && i.tileID.overscaledZ >= e ? i : null
                        }
                        for (let i = t.overscaledZ - 1; i >= e; i--) {
                            const e = t.scaledTo(i)
                              , n = this._getLoadedTile(e);
                            if (n)
                                return n
                        }
                    }
                    _getLoadedTile(t) {
                        const e = this._tiles[t.key];
                        return e && e.hasData() ? e : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key)
                    }
                    updateCacheSize(t, e) {
                        e = e || this._source.tileSize;
                        const i = Math.ceil(t.width / e) + 1
                          , n = Math.ceil(t.height / e) + 1
                          , r = Math.floor(i * n * 5)
                          , o = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, r) : r
                          , s = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o) : o;
                        this._cache.setMaxSize(s)
                    }
                    handleWrapJump(t) {
                        const e = Math.round((t - (void 0 === this._prevLng ? t : this._prevLng)) / 360);
                        if (this._prevLng = t,
                        e) {
                            const t = {};
                            for (const i in this._tiles) {
                                const n = this._tiles[i];
                                n.tileID = n.tileID.unwrapTo(n.tileID.wrap + e),
                                t[n.tileID.key] = n
                            }
                            this._tiles = t;
                            for (const t in this._timers)
                                clearTimeout(this._timers[t]),
                                delete this._timers[t];
                            for (const t in this._tiles)
                                this._setTileReloadTimer(+t, this._tiles[t])
                        }
                    }
                    update(t, e, i) {
                        if (this.transform = t,
                        !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage)
                            return;
                        if (this.usedForTerrain && !i)
                            return;
                        let n;
                        this.updateCacheSize(t, e),
                        "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng),
                        this._coveredTiles = {},
                        this.used || this.usedForTerrain ? this._source.tileID ? n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((t => new mu(t.canonical.z,t.wrap,t.canonical.z,t.canonical.x,t.canonical.y))) : (n = t.coveringTiles({
                            tileSize: e || this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom && !i,
                            reparseOverscaled: this._source.reparseOverscaled,
                            isTerrainDEM: this.usedForTerrain
                        }),
                        this._source.hasTile && (n = n.filter((t => this._source.hasTile(t))))) : n = [];
                        const r = this._updateRetainedTiles(n);
                        if (rm(this._source.type) && 0 !== n.length) {
                            const t = {}
                              , e = {}
                              , i = Object.keys(r);
                            for (const n of i) {
                                const i = r[n]
                                  , o = this._tiles[n];
                                if (!o || o.fadeEndTime && o.fadeEndTime <= Xt.now())
                                    continue;
                                const s = this.findLoadedParent(i, Math.max(i.overscaledZ - im.maxOverzooming, this._source.minzoom));
                                s && (this._addTile(s.tileID),
                                t[s.tileID.key] = s.tileID),
                                e[n] = i
                            }
                            const o = n[n.length - 1].overscaledZ;
                            for (const t in this._tiles) {
                                const i = this._tiles[t];
                                if (r[t] || !i.hasData())
                                    continue;
                                let n = i.tileID;
                                for (; n.overscaledZ > o; ) {
                                    n = n.scaledTo(n.overscaledZ - 1);
                                    const o = this._tiles[n.key];
                                    if (o && o.hasData() && e[n.key]) {
                                        r[t] = i.tileID;
                                        break
                                    }
                                }
                            }
                            for (const e in t)
                                r[e] || (this._coveredTiles[e] = !0,
                                r[e] = t[e])
                        }
                        for (const t in r)
                            this._tiles[t].clearFadeHold();
                        const o = function(t, e) {
                            const i = [];
                            for (const n in t)
                                n in e || i.push(n);
                            return i
                        }(this._tiles, r);
                        for (const t of o) {
                            const e = this._tiles[t];
                            e.hasSymbolBuckets && !e.holdingForFade() ? e.setHoldDuration(this.map._fadeDuration) : e.hasSymbolBuckets && !e.symbolFadeFinished() || this._removeTile(+t)
                        }
                        this._updateLoadedParentTileCache(),
                        this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate()
                    }
                    releaseSymbolFadeTiles() {
                        for (const t in this._tiles)
                            this._tiles[t].holdingForFade() && this._removeTile(+t)
                    }
                    _updateRetainedTiles(t) {
                        const e = {};
                        if (0 === t.length)
                            return e;
                        const i = {}
                          , n = t.reduce(( (t, e) => Math.min(t, e.overscaledZ)), 1 / 0)
                          , r = t[0].overscaledZ
                          , o = Math.max(r - im.maxOverzooming, this._source.minzoom)
                          , s = Math.max(r + im.maxUnderzooming, this._source.minzoom)
                          , a = {};
                        for (const i of t) {
                            const t = this._addTile(i);
                            e[i.key] = i,
                            t.hasData() || n < this._source.maxzoom && (a[i.key] = i)
                        }
                        this._retainLoadedChildren(a, n, s, e);
                        for (const n of t) {
                            let t = this._tiles[n.key];
                            if (t.hasData())
                                continue;
                            if (n.canonical.z >= this._source.maxzoom) {
                                const t = n.children(this._source.maxzoom)[0]
                                  , i = this.getTile(t);
                                if (i && i.hasData()) {
                                    e[t.key] = t;
                                    continue
                                }
                            } else {
                                const t = n.children(this._source.maxzoom);
                                if (e[t[0].key] && e[t[1].key] && e[t[2].key] && e[t[3].key])
                                    continue
                            }
                            let r = t.wasRequested();
                            for (let s = n.overscaledZ - 1; s >= o; --s) {
                                const o = n.scaledTo(s);
                                if (i[o.key])
                                    break;
                                if (i[o.key] = !0,
                                t = this.getTile(o),
                                !t && r && (t = this._addTile(o)),
                                t && (e[o.key] = o,
                                r = t.wasRequested(),
                                t.hasData()))
                                    break
                            }
                        }
                        return e
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const t in this._tiles) {
                            const e = [];
                            let i, n = this._tiles[t].tileID;
                            for (; n.overscaledZ > 0; ) {
                                if (n.key in this._loadedParentTiles) {
                                    i = this._loadedParentTiles[n.key];
                                    break
                                }
                                e.push(n.key);
                                const t = n.scaledTo(n.overscaledZ - 1);
                                if (i = this._getLoadedTile(t),
                                i)
                                    break;
                                n = t
                            }
                            for (const t of e)
                                this._loadedParentTiles[t] = i
                        }
                    }
                    _addTile(t) {
                        let e = this._tiles[t.key];
                        if (e)
                            return e;
                        e = this._cache.getAndRemove(t),
                        e && (this._setTileReloadTimer(t.key, e),
                        e.tileID = t,
                        this._state.initializeTileState(e, this.map ? this.map.painter : null),
                        this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]),
                        delete this._cacheTimers[t.key],
                        this._setTileReloadTimer(t.key, e)));
                        const i = Boolean(e);
                        if (!i) {
                            const i = this.map ? this.map.painter : null;
                            e = new Dp(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,i,this._isRaster),
                            this._loadTile(e, this._tileLoaded.bind(this, e, t.key, e.state))
                        }
                        return e ? (e.uses++,
                        this._tiles[t.key] = e,
                        i || this._source.fire(new Jt("dataloading",{
                            tile: e,
                            coord: e.tileID,
                            dataType: "source"
                        })),
                        e) : null
                    }
                    _setTileReloadTimer(t, e) {
                        t in this._timers && (clearTimeout(this._timers[t]),
                        delete this._timers[t]);
                        const i = e.getExpiryTimeout();
                        i && (this._timers[t] = setTimeout(( () => {
                            this._reloadTile(t, "expired"),
                            delete this._timers[t]
                        }
                        ), i))
                    }
                    _removeTile(t) {
                        const e = this._tiles[t];
                        e && (e.uses--,
                        delete this._tiles[t],
                        this._timers[t] && (clearTimeout(this._timers[t]),
                        delete this._timers[t]),
                        e.uses > 0 || (e.hasData() && "reloading" !== e.state ? this._cache.add(e.tileID, e, e.getExpiryTimeout()) : (e.aborted = !0,
                        this._abortTile(e),
                        this._unloadTile(e))))
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const t in this._tiles)
                            this._removeTile(+t);
                        this._source._clear && this._source._clear(),
                        this._cache.reset(),
                        this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id)
                    }
                    tilesIn(t, e, i) {
                        const n = []
                          , r = this.transform;
                        if (!r)
                            return n;
                        const o = "globe" === r.projection.name
                          , s = ql(r.center.lng);
                        for (const a in this._tiles) {
                            const l = this._tiles[a];
                            if (i && l.clearQueryDebugViz(),
                            l.holdingForFade())
                                continue;
                            let c;
                            if (o) {
                                const t = l.tileID.canonical;
                                if (0 === t.z) {
                                    const e = [Math.abs(I(s, ...om(t, -1)) - s), Math.abs(I(s, ...om(t, 1)) - s)];
                                    c = [0, 2 * e.indexOf(Math.min(...e)) - 1]
                                } else {
                                    const e = [Math.abs(I(s, ...om(t, -1)) - s), Math.abs(I(s, ...om(t, 0)) - s), Math.abs(I(s, ...om(t, 1)) - s)];
                                    c = [e.indexOf(Math.min(...e)) - 1]
                                }
                            } else
                                c = [0];
                            for (const i of c) {
                                const o = t.containsTile(l, r, e, i);
                                o && n.push(o)
                            }
                        }
                        return n
                    }
                    getVisibleCoordinates(t) {
                        const e = this.getRenderableIds(t).map((t => this._tiles[t].tileID));
                        for (const t of e)
                            t.projMatrix = this.transform.calculateProjMatrix(t.toUnwrapped());
                        return e
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if (rm(this._source.type))
                            for (const t in this._tiles) {
                                const e = this._tiles[t];
                                if (void 0 !== e.fadeEndTime && e.fadeEndTime >= Xt.now())
                                    return !0
                            }
                        return !1
                    }
                    setFeatureState(t, e, i) {
                        this._state.updateState(t = t || "_geojsonTileLayer", e, i)
                    }
                    removeFeatureState(t, e, i) {
                        this._state.removeFeatureState(t = t || "_geojsonTileLayer", e, i)
                    }
                    getFeatureState(t, e) {
                        return this._state.getState(t = t || "_geojsonTileLayer", e)
                    }
                    setDependencies(t, e, i) {
                        const n = this._tiles[t];
                        n && n.setDependencies(e, i)
                    }
                    reloadTilesForDependencies(t, e) {
                        for (const i in this._tiles)
                            this._tiles[i].hasDependency(t, e) && this._reloadTile(+i, "reloading");
                        this._cache.filter((i => !i.hasDependency(t, e)))
                    }
                    _preloadTiles(t, e) {
                        if (!this._sourceLoaded) {
                            const i = () => {
                                this._sourceLoaded && (this._source.off("data", i),
                                this._preloadTiles(t, e))
                            }
                            ;
                            return void this._source.on("data", i)
                        }
                        const i = new Map
                          , n = Array.isArray(t) ? t : [t]
                          , r = this.map.painter.terrain
                          , o = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;
                        for (const t of n) {
                            const e = t.coveringTiles({
                                tileSize: o,
                                minzoom: this._source.minzoom,
                                maxzoom: this._source.maxzoom,
                                roundZoom: this._source.roundZoom && !this.usedForTerrain,
                                reparseOverscaled: this._source.reparseOverscaled,
                                isTerrainDEM: this.usedForTerrain
                            });
                            for (const t of e)
                                i.set(t.key, t);
                            this.usedForTerrain && t.updateElevation(!1)
                        }
                        k(Array.from(i.values()), ( (t, e) => {
                            const i = new Dp(t,this._source.tileSize * t.overscaleFactor(),this.transform.tileZoom,this.map.painter,this._isRaster);
                            this._loadTile(i, (t => {
                                "raster-dem" === this._source.type && i.dem && this._backfillDEM(i),
                                e(t, i)
                            }
                            ))
                        }
                        ), e)
                    }
                }
                function nm(t, e) {
                    const i = Math.abs(2 * t.wrap) - +(t.wrap < 0)
                      , n = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                    return t.overscaledZ - e.overscaledZ || n - i || e.canonical.y - t.canonical.y || e.canonical.x - t.canonical.x
                }
                function rm(t) {
                    return "raster" === t || "image" === t || "video" === t || "custom" === t
                }
                function om(t, e) {
                    const i = 1 << t.z;
                    return [t.x / i + e, (t.x + 1) / i + e]
                }
                im.maxOverzooming = 10,
                im.maxUnderzooming = 3;
                class sm {
                    constructor(t, e, i) {
                        this._demTile = t,
                        this._dem = this._demTile.dem,
                        this._scale = e,
                        this._offset = i
                    }
                    static create(t, e, i) {
                        const n = i || t.findDEMTileFor(e);
                        if (!n || !n.dem)
                            return;
                        const r = n.dem
                          , o = n.tileID
                          , s = 1 << e.canonical.z - o.canonical.z;
                        return new sm(n,n.tileSize / la / s,[(e.canonical.x / s - o.canonical.x) * r.dim, (e.canonical.y / s - o.canonical.y) * r.dim])
                    }
                    tileCoordToPixel(t, e) {
                        const i = e * this._scale + this._offset[1]
                          , n = Math.floor(t * this._scale + this._offset[0])
                          , r = Math.floor(i);
                        return new v(n,r)
                    }
                    getElevationAt(t, e, i, n) {
                        const r = t * this._scale + this._offset[0]
                          , o = e * this._scale + this._offset[1]
                          , s = Math.floor(r)
                          , a = Math.floor(o)
                          , l = this._dem;
                        return n = !!n,
                        i ? Oi(Oi(l.get(s, a, n), l.get(s, a + 1, n), o - a), Oi(l.get(s + 1, a, n), l.get(s + 1, a + 1, n), o - a), r - s) : l.get(s, a, n)
                    }
                    getElevationAtPixel(t, e, i) {
                        return this._dem.get(t, e, !!i)
                    }
                    getMeterToDEM(t) {
                        return (1 << this._demTile.tileID.canonical.z) * Hl(1, t) * this._dem.stride
                    }
                }
                class am {
                    constructor(t, e) {
                        this.tileID = t,
                        this.x = t.canonical.x,
                        this.y = t.canonical.y,
                        this.z = t.canonical.z,
                        this.grid = new $r(la,16,0),
                        this.featureIndexArray = new ws,
                        this.promoteId = e
                    }
                    insert(t, e, i, n, r, o=0) {
                        const s = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(i, n, r, o);
                        const a = this.grid;
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t]
                              , n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let t = 0; t < i.length; t++) {
                                const e = i[t];
                                n[0] = Math.min(n[0], e.x),
                                n[1] = Math.min(n[1], e.y),
                                n[2] = Math.max(n[2], e.x),
                                n[3] = Math.max(n[3], e.y)
                            }
                            n[0] < la && n[1] < la && n[2] >= 0 && n[3] >= 0 && a.insert(s, n[0], n[1], n[2], n[3])
                        }
                    }
                    loadVTLayers() {
                        if (!this.vtLayers) {
                            this.vtLayers = new Hh(new _d(this.rawTileData)).layers,
                            this.sourceLayerCoder = new wp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]),
                            this.vtFeatures = {};
                            for (const t in this.vtLayers)
                                this.vtFeatures[t] = []
                        }
                        return this.vtLayers
                    }
                    query(t, e, i, n) {
                        this.loadVTLayers();
                        const r = t.params || {}
                          , o = dr(r.filter)
                          , s = t.tileResult
                          , a = t.transform
                          , l = s.bufferedTilespaceBounds
                          , c = this.grid.query(l.min.x, l.min.y, l.max.x, l.max.y, ( (t, e, i, n) => wc(s.bufferedTilespaceGeometry, t, e, i, n)));
                        c.sort(cm);
                        let h = null;
                        a.elevation && c.length > 0 && (h = sm.create(a.elevation, this.tileID));
                        const u = {};
                        let d;
                        for (let a = 0; a < c.length; a++) {
                            const l = c[a];
                            if (l === d)
                                continue;
                            d = l;
                            const f = this.featureIndexArray.get(l);
                            let p = null;
                            this.loadMatchingFeature(u, f, o, r.layers, r.availableImages, e, i, n, ( (e, i, n, r=0) => (p || (p = ac(e, this.tileID.canonical, t.tileTransform)),
                            i.queryIntersectsFeature(s, e, n, p, this.z, t.transform, t.pixelPosMatrix, h, r))))
                        }
                        return u
                    }
                    loadMatchingFeature(t, e, i, n, r, o, s, a, l) {
                        const {featureIndex: c, bucketIndex: h, sourceLayerIndex: u, layoutVertexArrayOffset: d} = e
                          , f = this.bucketLayerIDs[h];
                        if (n && !function(t, e) {
                            for (let i = 0; i < t.length; i++)
                                if (e.indexOf(t[i]) >= 0)
                                    return !0;
                            return !1
                        }(n, f))
                            return;
                        const p = this.sourceLayerCoder.decode(u)
                          , m = this.vtLayers[p].feature(c);
                        if (i.needGeometry) {
                            const t = lc(m, !0);
                            if (!i.filter(new Eo(this.tileID.overscaledZ), t, this.tileID.canonical))
                                return
                        } else if (!i.filter(new Eo(this.tileID.overscaledZ), m))
                            return;
                        const g = this.getId(m, p);
                        for (let e = 0; e < f.length; e++) {
                            const i = f[e];
                            if (n && n.indexOf(i) < 0)
                                continue;
                            const h = o[i];
                            if (!h)
                                continue;
                            let u = {};
                            void 0 !== g && a && (u = a.getState(h.sourceLayer || "_geojsonTileLayer", g));
                            const p = R({}, s[i]);
                            p.paint = lm(p.paint, h.paint, m, u, r),
                            p.layout = lm(p.layout, h.layout, m, u, r);
                            const _ = !l || l(m, h, u, d);
                            if (!_)
                                continue;
                            const y = new Tp(m,this.z,this.x,this.y,g);
                            y.layer = p;
                            let v = t[i];
                            void 0 === v && (v = t[i] = []),
                            v.push({
                                featureIndex: c,
                                feature: y,
                                intersectionZ: _
                            })
                        }
                    }
                    lookupSymbolFeatures(t, e, i, n, r, o, s, a) {
                        const l = {};
                        this.loadVTLayers();
                        const c = dr(r);
                        for (const r of t)
                            this.loadMatchingFeature(l, {
                                bucketIndex: i,
                                sourceLayerIndex: n,
                                featureIndex: r,
                                layoutVertexArrayOffset: 0
                            }, c, o, s, a, e);
                        return l
                    }
                    loadFeature(t) {
                        const {featureIndex: e, sourceLayerIndex: i} = t;
                        this.loadVTLayers();
                        const n = this.sourceLayerCoder.decode(i)
                          , r = this.vtFeatures[n];
                        if (r[e])
                            return r[e];
                        const o = this.vtLayers[n].feature(e);
                        return r[e] = o,
                        o
                    }
                    hasLayer(t) {
                        for (const e of this.bucketLayerIDs)
                            for (const i of e)
                                if (t === i)
                                    return !0;
                        return !1
                    }
                    getId(t, e) {
                        let i = t.id;
                        if (this.promoteId) {
                            const n = "string" == typeof this.promoteId ? this.promoteId : this.promoteId[e];
                            null != n && (i = t.properties[n]),
                            "boolean" == typeof i && (i = Number(i))
                        }
                        return i
                    }
                }
                function lm(t, e, i, n, r) {
                    return U(t, ( (t, o) => {
                        const s = e instanceof ko ? e.get(o) : null;
                        return s && s.evaluate ? s.evaluate(i, n, r) : s
                    }
                    ))
                }
                function cm(t, e) {
                    return e - t
                }
                Yr(am, "FeatureIndex", {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                class hm {
                    constructor(t, e) {
                        this.width = t,
                        this.height = e,
                        this.nextRow = 0,
                        this.image = new Nc({
                            width: t,
                            height: e
                        }),
                        this.positions = {},
                        this.uploaded = !1
                    }
                    getDash(t, e) {
                        const i = this.getKey(t, e);
                        return this.positions[i]
                    }
                    trim() {
                        const t = this.width
                          , e = this.height = z(this.nextRow);
                        this.image.resize({
                            width: t,
                            height: e
                        })
                    }
                    getKey(t, e) {
                        return t.join(",") + e
                    }
                    getDashRanges(t, e, i) {
                        const n = [];
                        let r = t.length % 2 == 1 ? -t[t.length - 1] * i : 0
                          , o = t[0] * i
                          , s = !0;
                        n.push({
                            left: r,
                            right: o,
                            isDash: s,
                            zeroLength: 0 === t[0]
                        });
                        let a = t[0];
                        for (let e = 1; e < t.length; e++) {
                            s = !s;
                            const l = t[e];
                            r = a * i,
                            a += l,
                            o = a * i,
                            n.push({
                                left: r,
                                right: o,
                                isDash: s,
                                zeroLength: 0 === l
                            })
                        }
                        return n
                    }
                    addRoundDash(t, e, i) {
                        const n = e / 2;
                        for (let e = -i; e <= i; e++) {
                            const r = this.width * (this.nextRow + i + e);
                            let o = 0
                              , s = t[o];
                            for (let a = 0; a < this.width; a++) {
                                a / s.right > 1 && (s = t[++o]);
                                const l = Math.abs(a - s.left)
                                  , c = Math.abs(a - s.right)
                                  , h = Math.min(l, c);
                                let u;
                                const d = e / i * (n + 1);
                                if (s.isDash) {
                                    const t = n - Math.abs(d);
                                    u = Math.sqrt(h * h + t * t)
                                } else
                                    u = n - Math.sqrt(h * h + d * d);
                                this.image.data[r + a] = Math.max(0, Math.min(255, u + 128))
                            }
                        }
                    }
                    addRegularDash(t, e) {
                        for (let e = t.length - 1; e >= 0; --e) {
                            const i = t[e]
                              , n = t[e + 1];
                            i.zeroLength ? t.splice(e, 1) : n && n.isDash === i.isDash && (n.left = i.left,
                            t.splice(e, 1))
                        }
                        const i = t[0]
                          , n = t[t.length - 1];
                        i.isDash === n.isDash && (i.left = n.left - this.width,
                        n.right = i.right + this.width);
                        const r = this.width * this.nextRow;
                        let o = 0
                          , s = t[o];
                        for (let i = 0; i < this.width; i++) {
                            i / s.right > 1 && (s = t[++o]);
                            const n = Math.abs(i - s.left)
                              , a = Math.abs(i - s.right)
                              , l = Math.min(n, a);
                            this.image.data[r + i] = Math.max(0, Math.min(255, (s.isDash ? l : -l) + e + 128))
                        }
                    }
                    addDash(t, e) {
                        const i = this.getKey(t, e);
                        if (this.positions[i])
                            return this.positions[i];
                        const n = "round" === e
                          , r = n ? 7 : 0
                          , o = 2 * r + 1;
                        if (this.nextRow + o > this.height)
                            return q("LineAtlas out of space"),
                            null;
                        0 === t.length && t.push(1);
                        let s = 0;
                        for (let e = 0; e < t.length; e++)
                            t[e] < 0 && (q("Negative value is found in line dasharray, replacing values with 0"),
                            t[e] = 0),
                            s += t[e];
                        if (0 !== s) {
                            const i = this.width / s
                              , o = this.getDashRanges(t, this.width, i);
                            n ? this.addRoundDash(o, i, r) : this.addRegularDash(o, "square" === e ? .5 * i : 0)
                        }
                        const a = this.nextRow + r;
                        this.nextRow += o;
                        const l = {
                            tl: [a, r],
                            br: [s, 0]
                        };
                        return this.positions[i] = l,
                        l
                    }
                }
                Yr(hm, "LineAtlas");
                const um = 1 * ef;
                class dm {
                    constructor(t) {
                        const e = {}
                          , i = [];
                        for (const n in t) {
                            const r = t[n]
                              , o = e[n] = {};
                            for (const t in r.glyphs) {
                                const e = r.glyphs[+t];
                                if (!e || 0 === e.bitmap.width || 0 === e.bitmap.height)
                                    continue;
                                const n = e.metrics.localGlyph ? um : 1
                                  , s = {
                                    x: 0,
                                    y: 0,
                                    w: e.bitmap.width + 2 * n,
                                    h: e.bitmap.height + 2 * n
                                };
                                i.push(s),
                                o[t] = s
                            }
                        }
                        const {w: n, h: r} = Ed(i)
                          , o = new Nc({
                            width: n || 1,
                            height: r || 1
                        });
                        for (const i in t) {
                            const n = t[i];
                            for (const t in n.glyphs) {
                                const r = n.glyphs[+t];
                                if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height)
                                    continue;
                                const s = e[i][t]
                                  , a = r.metrics.localGlyph ? um : 1;
                                Nc.copy(r.bitmap, o, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: s.x + a,
                                    y: s.y + a
                                }, r.bitmap)
                            }
                        }
                        this.image = o,
                        this.positions = e
                    }
                }
                Yr(dm, "GlyphAtlas");
                class fm {
                    constructor(t) {
                        this.tileID = new mu(t.tileID.overscaledZ,t.tileID.wrap,t.tileID.canonical.z,t.tileID.canonical.x,t.tileID.canonical.y),
                        this.tileZoom = t.tileZoom,
                        this.uid = t.uid,
                        this.zoom = t.zoom,
                        this.canonical = t.tileID.canonical,
                        this.pixelRatio = t.pixelRatio,
                        this.tileSize = t.tileSize,
                        this.source = t.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = t.showCollisionBoxes,
                        this.collectResourceTiming = !!t.collectResourceTiming,
                        this.returnDependencies = !!t.returnDependencies,
                        this.promoteId = t.promoteId,
                        this.enableTerrain = !!t.enableTerrain,
                        this.isSymbolTile = t.isSymbolTile,
                        this.tileTransform = Of(t.tileID.canonical, t.projection),
                        this.projection = t.projection
                    }
                    parse(t, e, i, n, r) {
                        this.status = "parsing",
                        this.data = t,
                        this.collisionBoxArray = new ps;
                        const o = new wp(Object.keys(t.layers).sort())
                          , s = new am(this.tileID,this.promoteId);
                        s.bucketLayerIDs = [];
                        const a = {}
                          , l = new hm(256,256)
                          , c = {
                            featureIndex: s,
                            iconDependencies: {},
                            patternDependencies: {},
                            glyphDependencies: {},
                            lineAtlas: l,
                            availableImages: i
                        }
                          , h = e.familiesBySource[this.source];
                        for (const e in h) {
                            const n = t.layers[e];
                            if (!n)
                                continue;
                            let r = !1
                              , l = !1;
                            for (const t of h[e])
                                "symbol" === t[0].type ? r = !0 : l = !0;
                            if (!0 === this.isSymbolTile && !r)
                                continue;
                            if (!1 === this.isSymbolTile && !l)
                                continue;
                            1 === n.version && q(`Vector tile source "${this.source}" layer "${e}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                            const u = o.encode(e)
                              , d = [];
                            for (let t = 0; t < n.length; t++) {
                                const i = n.feature(t)
                                  , r = s.getId(i, e);
                                d.push({
                                    feature: i,
                                    id: r,
                                    index: t,
                                    sourceLayerIndex: u
                                })
                            }
                            for (const t of h[e]) {
                                const e = t[0];
                                void 0 !== this.isSymbolTile && "symbol" === e.type !== this.isSymbolTile || e.minzoom && this.zoom < Math.floor(e.minzoom) || e.maxzoom && this.zoom >= e.maxzoom || "none" !== e.visibility && (pm(t, this.zoom, i),
                                (a[e.id] = e.createBucket({
                                    index: s.bucketLayerIDs.length,
                                    layers: t,
                                    zoom: this.zoom,
                                    canonical: this.canonical,
                                    pixelRatio: this.pixelRatio,
                                    overscaling: this.overscaling,
                                    collisionBoxArray: this.collisionBoxArray,
                                    sourceLayerIndex: u,
                                    sourceID: this.source,
                                    enableTerrain: this.enableTerrain,
                                    projection: this.projection.spec,
                                    availableImages: i
                                })).populate(d, c, this.tileID.canonical, this.tileTransform),
                                s.bucketLayerIDs.push(t.map((t => t.id))))
                            }
                        }
                        let u, d, f, p;
                        l.trim();
                        const m = {
                            type: "maybePrepare",
                            isSymbolTile: this.isSymbolTile,
                            zoom: this.zoom
                        }
                          , g = () => {
                            if (u)
                                return r(u);
                            if (d && f && p) {
                                const t = new dm(d)
                                  , e = new Cd(f,p);
                                for (const n in a) {
                                    const r = a[n];
                                    r instanceof lp ? (pm(r.layers, this.zoom, i),
                                    bf(r, d, t.positions, f, e.iconPositions, this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection)) : r.hasPattern && (r instanceof Au || r instanceof Ih || r instanceof eu) && (pm(r.layers, this.zoom, i),
                                    r.addFeatures(c, this.tileID.canonical, e.patternPositions, i, this.tileTransform))
                                }
                                this.status = "done",
                                r(null, {
                                    buckets: O(a).filter((t => !t.isEmpty())),
                                    featureIndex: s,
                                    collisionBoxArray: this.collisionBoxArray,
                                    glyphAtlasImage: t.image,
                                    lineAtlas: l,
                                    imageAtlas: e,
                                    glyphMap: this.returnDependencies ? d : null,
                                    iconMap: this.returnDependencies ? f : null,
                                    glyphPositions: this.returnDependencies ? t.positions : null
                                })
                            }
                        }
                          , _ = U(c.glyphDependencies, (t => Object.keys(t).map(Number)));
                        Object.keys(_).length ? n.send("getGlyphs", {
                            uid: this.uid,
                            stacks: _
                        }, ( (t, e) => {
                            u || (u = t,
                            d = e,
                            g())
                        }
                        ), void 0, !1, m) : d = {};
                        const y = Object.keys(c.iconDependencies);
                        y.length ? n.send("getImages", {
                            icons: y,
                            source: this.source,
                            tileID: this.tileID,
                            type: "icons"
                        }, ( (t, e) => {
                            u || (u = t,
                            f = e,
                            g())
                        }
                        ), void 0, !1, m) : f = {};
                        const v = Object.keys(c.patternDependencies);
                        v.length ? n.send("getImages", {
                            icons: v,
                            source: this.source,
                            tileID: this.tileID,
                            type: "patterns"
                        }, ( (t, e) => {
                            u || (u = t,
                            p = e,
                            g())
                        }
                        ), void 0, !1, m) : p = {},
                        g()
                    }
                }
                function pm(t, e, i) {
                    const n = new Eo(e);
                    for (const e of t)
                        e.recalculate(n, i)
                }
                class mm {
                    constructor(t) {
                        this.entries = {},
                        this.scheduler = t
                    }
                    request(t, e, i, n) {
                        const r = this.entries[t] = this.entries[t] || {
                            callbacks: []
                        };
                        if (r.result) {
                            const [t,i] = r.result;
                            return this.scheduler ? this.scheduler.add(( () => {
                                n(t, i)
                            }
                            ), e) : n(t, i),
                            () => {}
                        }
                        return r.callbacks.push(n),
                        r.cancel || (r.cancel = i(( (i, n) => {
                            r.result = [i, n];
                            for (const t of r.callbacks)
                                this.scheduler ? this.scheduler.add(( () => {
                                    t(i, n)
                                }
                                ), e) : t(i, n);
                            setTimeout(( () => delete this.entries[t]), 3e3)
                        }
                        ))),
                        () => {
                            r.result || (r.callbacks = r.callbacks.filter((t => t !== n)),
                            r.callbacks.length || (r.cancel(),
                            delete this.entries[t]))
                        }
                    }
                }
                function gm(t, e, i) {
                    const n = JSON.stringify(t.request);
                    return t.data && (this.deduped.entries[n] = {
                        result: [null, t.data]
                    }),
                    this.deduped.request(n, {
                        type: "parseTile",
                        isSymbolTile: t.isSymbolTile,
                        zoom: t.tileZoom
                    }, (e => {
                        const n = ft(t.request, ( (t, n, r, o) => {
                            t ? e(t) : n && e(null, {
                                vectorTile: i ? void 0 : new Hh(new _d(n)),
                                rawData: n,
                                cacheControl: r,
                                expires: o
                            })
                        }
                        ));
                        return () => {
                            n.cancel(),
                            e()
                        }
                    }
                    ), e)
                }
                const _m = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class ym {
                    static from(t) {
                        if (!(t instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [e,i] = new Uint8Array(t,0,2);
                        if (219 !== e)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const n = i >> 4;
                        if (1 !== n)
                            throw new Error(`Got v${n} data when expected v1.`);
                        const r = _m[15 & i];
                        if (!r)
                            throw new Error("Unrecognized array type.");
                        const [o] = new Uint16Array(t,2,1)
                          , [s] = new Uint32Array(t,4,1);
                        return new ym(s,o,r,t)
                    }
                    constructor(t, e=64, i=Float64Array, n) {
                        if (isNaN(t) || t < 0)
                            throw new Error(`Unpexpected numItems value: ${t}.`);
                        this.numItems = +t,
                        this.nodeSize = Math.min(Math.max(+e, 2), 65535),
                        this.ArrayType = i,
                        this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                        const r = _m.indexOf(this.ArrayType)
                          , o = 2 * t * this.ArrayType.BYTES_PER_ELEMENT
                          , s = t * this.IndexArrayType.BYTES_PER_ELEMENT
                          , a = (8 - s % 8) % 8;
                        if (r < 0)
                            throw new Error(`Unexpected typed array class: ${i}.`);
                        n && n instanceof ArrayBuffer ? (this.data = n,
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + s + a,2 * t),
                        this._pos = 2 * t,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + o + s + a),
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + s + a,2 * t),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + r]),
                        new Uint16Array(this.data,2,1)[0] = e,
                        new Uint32Array(this.data,4,1)[0] = t)
                    }
                    add(t, e) {
                        const i = this._pos >> 1;
                        return this.ids[i] = i,
                        this.coords[this._pos++] = t,
                        this.coords[this._pos++] = e,
                        i
                    }
                    finish() {
                        const t = this._pos >> 1;
                        if (t !== this.numItems)
                            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                        return vm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(t, e, i, n) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: r, coords: o, nodeSize: s} = this
                          , a = [0, r.length - 1, 0]
                          , l = [];
                        for (; a.length; ) {
                            const c = a.pop() || 0
                              , h = a.pop() || 0
                              , u = a.pop() || 0;
                            if (h - u <= s) {
                                for (let s = u; s <= h; s++) {
                                    const a = o[2 * s]
                                      , c = o[2 * s + 1];
                                    a >= t && a <= i && c >= e && c <= n && l.push(r[s])
                                }
                                continue
                            }
                            const d = u + h >> 1
                              , f = o[2 * d]
                              , p = o[2 * d + 1];
                            f >= t && f <= i && p >= e && p <= n && l.push(r[d]),
                            (0 === c ? t <= f : e <= p) && (a.push(u),
                            a.push(d - 1),
                            a.push(1 - c)),
                            (0 === c ? i >= f : n >= p) && (a.push(d + 1),
                            a.push(h),
                            a.push(1 - c))
                        }
                        return l
                    }
                    within(t, e, i) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: n, coords: r, nodeSize: o} = this
                          , s = [0, n.length - 1, 0]
                          , a = []
                          , l = i * i;
                        for (; s.length; ) {
                            const c = s.pop() || 0
                              , h = s.pop() || 0
                              , u = s.pop() || 0;
                            if (h - u <= o) {
                                for (let i = u; i <= h; i++)
                                    Em(r[2 * i], r[2 * i + 1], t, e) <= l && a.push(n[i]);
                                continue
                            }
                            const d = u + h >> 1
                              , f = r[2 * d]
                              , p = r[2 * d + 1];
                            Em(f, p, t, e) <= l && a.push(n[d]),
                            (0 === c ? t - i <= f : e - i <= p) && (s.push(u),
                            s.push(d - 1),
                            s.push(1 - c)),
                            (0 === c ? t + i >= f : e + i >= p) && (s.push(d + 1),
                            s.push(h),
                            s.push(1 - c))
                        }
                        return a
                    }
                }
                function vm(t, e, i, n, r, o) {
                    if (r - n <= i)
                        return;
                    const s = n + r >> 1;
                    xm(t, e, s, n, r, o),
                    vm(t, e, i, n, s - 1, 1 - o),
                    vm(t, e, i, s + 1, r, 1 - o)
                }
                function xm(t, e, i, n, r, o) {
                    for (; r > n; ) {
                        if (r - n > 600) {
                            const s = r - n + 1
                              , a = i - n + 1
                              , l = Math.log(s)
                              , c = .5 * Math.exp(2 * l / 3)
                              , h = .5 * Math.sqrt(l * c * (s - c) / s) * (a - s / 2 < 0 ? -1 : 1);
                            xm(t, e, i, Math.max(n, Math.floor(i - a * c / s + h)), Math.min(r, Math.floor(i + (s - a) * c / s + h)), o)
                        }
                        const s = e[2 * i + o];
                        let a = n
                          , l = r;
                        for (bm(t, e, n, i),
                        e[2 * r + o] > s && bm(t, e, n, r); a < l; ) {
                            for (bm(t, e, a, l),
                            a++,
                            l--; e[2 * a + o] < s; )
                                a++;
                            for (; e[2 * l + o] > s; )
                                l--
                        }
                        e[2 * n + o] === s ? bm(t, e, n, l) : (l++,
                        bm(t, e, l, r)),
                        l <= i && (n = l + 1),
                        i <= l && (r = l - 1)
                    }
                }
                function bm(t, e, i, n) {
                    wm(t, i, n),
                    wm(e, 2 * i, 2 * n),
                    wm(e, 2 * i + 1, 2 * n + 1)
                }
                function wm(t, e, i) {
                    const n = t[e];
                    t[e] = t[i],
                    t[i] = n
                }
                function Em(t, e, i, n) {
                    const r = t - i
                      , o = e - n;
                    return r * r + o * o
                }
                t.ARRAY_TYPE = ua,
                t.AUTH_ERR_MSG = vt,
                t.Aabb = ol,
                t.Actor = class {
                    constructor(t, i, n) {
                        this.target = t,
                        this.parent = i,
                        this.mapId = n,
                        this.callbacks = {},
                        this.cancelCallbacks = {},
                        N(["receive"], this),
                        this.target.addEventListener("message", this.receive, !1),
                        this.globalScope = $() ? t : e,
                        this.scheduler = new bp
                    }
                    send(t, e, i, n, r=!1, o) {
                        const s = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
                        i && (i.metadata = o,
                        this.callbacks[s] = i);
                        const a = K(this.globalScope) ? void 0 : [];
                        return this.target.postMessage({
                            id: s,
                            type: t,
                            hasCallback: !!i,
                            targetMapId: n,
                            mustQueue: r,
                            sourceMapId: this.mapId,
                            data: Qr(e, a)
                        }, a),
                        {
                            cancel: () => {
                                i && delete this.callbacks[s],
                                this.target.postMessage({
                                    id: s,
                                    type: "<cancel>",
                                    targetMapId: n,
                                    sourceMapId: this.mapId
                                })
                            }
                        }
                    }
                    receive(t) {
                        const e = t.data
                          , i = e.id;
                        if (i && (!e.targetMapId || this.mapId === e.targetMapId))
                            if ("<cancel>" === e.type) {
                                const t = this.cancelCallbacks[i];
                                delete this.cancelCallbacks[i],
                                t && t.cancel()
                            } else if (e.mustQueue || $()) {
                                const t = this.callbacks[i];
                                this.cancelCallbacks[i] = this.scheduler.add(( () => this.processTask(i, e)), t && t.metadata || {
                                    type: "message"
                                })
                            } else
                                this.processTask(i, e)
                    }
                    processTask(t, e) {
                        if ("<response>" === e.type) {
                            const i = this.callbacks[t];
                            delete this.callbacks[t],
                            i && (e.error ? i(to(e.error)) : i(null, to(e.data)))
                        } else {
                            const i = K(this.globalScope) ? void 0 : []
                              , n = e.hasCallback ? (e, n) => {
                                delete this.cancelCallbacks[t],
                                this.target.postMessage({
                                    id: t,
                                    type: "<response>",
                                    sourceMapId: this.mapId,
                                    error: e ? Qr(e) : null,
                                    data: Qr(n, i)
                                }, i)
                            }
                            : t => {}
                              , r = to(e.data);
                            if (this.parent[e.type])
                                this.parent[e.type](e.sourceMapId, r, n);
                            else if (this.parent.getWorkerSource) {
                                const t = e.type.split(".");
                                this.parent.getWorkerSource(e.sourceMapId, t[0], r.source)[t[1]](r, n)
                            } else
                                n(new Error(`Could not find function ${e.type}`))
                        }
                    }
                    remove() {
                        this.scheduler.remove(),
                        this.target.removeEventListener("message", this.receive, !1)
                    }
                }
                ,
                t.CanonicalTileID = fu,
                t.Color = Oe,
                t.ColorMode = Jp,
                t.CullFaceMode = em,
                t.DEMData = Hp,
                t.DataConstantProperty = Oo,
                t.DedupedRequest = mm,
                t.DepthMode = Xp,
                t.EXTENT = la,
                t.Elevation = class {
                    isDataAvailableAtPoint(t) {
                        const e = this._source();
                        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1)
                            return !1;
                        const i = e.getSource().maxzoom
                          , n = 1 << i
                          , r = Math.floor(t.x)
                          , o = Math.floor((t.x - r) * n)
                          , s = Math.floor(t.y * n)
                          , a = this.findDEMTileFor(new mu(i,r,i,o,s));
                        return !(!a || !a.dem)
                    }
                    getAtPointOrZero(t, e=0) {
                        return this.getAtPoint(t, e) || 0
                    }
                    getAtPoint(t, e, i=!0) {
                        if (this.isUsingMockSource())
                            return null;
                        null == e && (e = null);
                        const n = this._source();
                        if (!n)
                            return e;
                        if (t.y < 0 || t.y > 1)
                            return e;
                        const r = n.getSource().maxzoom
                          , o = 1 << r
                          , s = Math.floor(t.x)
                          , a = t.x - s
                          , l = new mu(r,s,r,Math.floor(a * o),Math.floor(t.y * o))
                          , c = this.findDEMTileFor(l);
                        if (!c || !c.dem)
                            return e;
                        const h = c.dem
                          , u = 1 << c.tileID.canonical.z
                          , d = (a * u - c.tileID.canonical.x) * h.dim
                          , f = (t.y * u - c.tileID.canonical.y) * h.dim
                          , p = Math.floor(d)
                          , m = Math.floor(f);
                        return (i ? this.exaggeration() : 1) * Oi(Oi(h.get(p, m), h.get(p, m + 1), f - m), Oi(h.get(p + 1, m), h.get(p + 1, m + 1), f - m), d - p)
                    }
                    getAtTileOffset(t, e, i) {
                        const n = 1 << t.canonical.z;
                        return this.getAtPointOrZero(new Ql(t.wrap + (t.canonical.x + e / la) / n,(t.canonical.y + i / la) / n))
                    }
                    getAtTileOffsetFunc(t, e, i, n) {
                        return r => {
                            const o = this.getAtTileOffset(t, r.x, r.y)
                              , s = n.upVector(t.canonical, r.x, r.y);
                            return Ra(s, s, o * n.upVectorScale(t.canonical, e, i).metersToTile),
                            s
                        }
                    }
                    getForTilePoints(t, e, i, n) {
                        if (this.isUsingMockSource())
                            return !1;
                        const r = sm.create(this, t, n);
                        return !!r && (e.forEach((t => {
                            t[2] = this.exaggeration() * r.getElevationAt(t[0], t[1], i)
                        }
                        )),
                        !0)
                    }
                    getMinMaxForTile(t) {
                        if (this.isUsingMockSource())
                            return null;
                        const e = this.findDEMTileFor(t);
                        if (!e || !e.dem)
                            return null;
                        const i = e.dem.tree
                          , n = e.tileID
                          , r = 1 << t.canonical.z - n.canonical.z;
                        let o = t.canonical.x / r - n.canonical.x
                          , s = t.canonical.y / r - n.canonical.y
                          , a = 0;
                        for (let e = 0; e < t.canonical.z - n.canonical.z && !i.leaves[a]; e++) {
                            o *= 2,
                            s *= 2;
                            const t = 2 * Math.floor(s) + Math.floor(o);
                            a = i.childOffsets[a] + t,
                            o %= 1,
                            s %= 1
                        }
                        return {
                            min: this.exaggeration() * i.minimums[a],
                            max: this.exaggeration() * i.maximums[a]
                        }
                    }
                    getMinElevationBelowMSL() {
                        throw new Error("Pure virtual method called.")
                    }
                    raycast(t, e, i) {
                        throw new Error("Pure virtual method called.")
                    }
                    pointCoordinate(t) {
                        throw new Error("Pure virtual method called.")
                    }
                    _source() {
                        throw new Error("Pure virtual method called.")
                    }
                    isUsingMockSource() {
                        throw new Error("Pure virtual method called.")
                    }
                    exaggeration() {
                        throw new Error("Pure virtual method called.")
                    }
                    findDEMTileFor(t) {
                        throw new Error("Pure virtual method called.")
                    }
                    get visibleDemTiles() {
                        throw new Error("Getter must be implemented in subclass.")
                    }
                }
                ,
                t.ErrorEvent = Qt,
                t.EvaluationParameters = Eo,
                t.Event = Jt,
                t.Evented = te,
                t.FillExtrusionBucket = eu,
                t.Frustum = rl,
                t.FrustumCorners = nl,
                t.GLOBE_RADIUS = ll,
                t.GLOBE_SCALE_MATCH_LATITUDE = 45,
                t.GLOBE_ZOOM_THRESHOLD_MAX = al,
                t.GLOBE_ZOOM_THRESHOLD_MIN = sl,
                t.GlobeSharedBuffers = class {
                    constructor(t) {
                        this._createGrid(t),
                        this._createPoles(t)
                    }
                    destroy() {
                        this._poleIndexBuffer.destroy(),
                        this._gridBuffer.destroy(),
                        this._gridIndexBuffer.destroy(),
                        this._poleNorthVertexBuffer.destroy(),
                        this._poleSouthVertexBuffer.destroy();
                        for (const t of this._poleSegments)
                            t.destroy();
                        for (const t of this._gridSegments)
                            t.withSkirts.destroy(),
                            t.withoutSkirts.destroy();
                        if (this._wireframeIndexBuffer) {
                            this._wireframeIndexBuffer.destroy();
                            for (const t of this._wireframeSegments)
                                t.destroy()
                        }
                    }
                    _fillGridMeshWithLods(t, e) {
                        const i = new Vo
                          , n = new rs
                          , r = []
                          , o = t + 1 + 2
                          , s = e[0] + 1
                          , a = e[0] + 1 + (1 + e.length)
                          , l = (t, e, i) => {
                            let n = t === o - 1 ? t - 2 : 0 === t ? t : t - 1;
                            return n += i ? 24575 : 0,
                            [n, e]
                        }
                        ;
                        for (let t = 0; t < o; ++t)
                            i.emplaceBack(...l(t, 0, !0));
                        for (let t = 0; t < s; ++t)
                            for (let e = 0; e < o; ++e)
                                i.emplaceBack(...l(e, t, (0 === e || e === o - 1) && !0));
                        for (let t = 0; t < e.length; ++t) {
                            const n = e[t];
                            for (let t = 0; t < o; ++t)
                                i.emplaceBack(...l(t, n, !0))
                        }
                        for (let t = 0; t < e.length; ++t) {
                            const s = n.length
                              , l = e[t] + 1 + 2
                              , c = new rs;
                            for (let i = 0; i < l - 1; i++) {
                                const r = i === l - 2
                                  , s = r ? o * (a - e.length + t - i) : o;
                                for (let t = 0; t < o - 1; t++) {
                                    const e = i * o + t;
                                    0 === i || r || 0 === t || t === o - 2 ? (c.emplaceBack(e + 1, e, e + s),
                                    c.emplaceBack(e + s, e + s + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + s),
                                    n.emplaceBack(e + s, e + s + 1, e + 1))
                                }
                            }
                            const h = aa.simpleSegment(0, s, i.length, n.length - s);
                            for (let t = 0; t < c.uint16.length; t += 3)
                                n.emplaceBack(c.uint16[t], c.uint16[t + 1], c.uint16[t + 2]);
                            const u = aa.simpleSegment(0, s, i.length, n.length - s);
                            r.push({
                                withoutSkirts: h,
                                withSkirts: u
                            })
                        }
                        return {
                            vertices: i,
                            indices: n,
                            segments: r
                        }
                    }
                    _createGrid(t) {
                        const e = this._fillGridMeshWithLods(hl, ul);
                        this._gridSegments = e.segments,
                        this._gridBuffer = t.createVertexBuffer(e.vertices, el.members),
                        this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0)
                    }
                    _createPoles(t) {
                        const e = new rs;
                        for (let t = 0; t <= hl; t++)
                            e.emplaceBack(0, t + 1, t + 2);
                        this._poleIndexBuffer = t.createIndexBuffer(e, !0);
                        const i = new ls
                          , n = new ls;
                        this._poleSegments = [];
                        for (let t = 0, e = 0; t < sl; t++) {
                            const r = 360 / (1 << t);
                            i.emplaceBack(0, -ll, 0, .5, 0),
                            n.emplaceBack(0, -ll, 0, .5, 1);
                            for (let t = 0; t <= hl; t++) {
                                const e = t / hl
                                  , o = Oi(0, r, e)
                                  , [s,a,l] = Cl(Fl, Nl, o, ll);
                                i.emplaceBack(s, a, l, e, 0),
                                n.emplaceBack(s, a, l, e, 1)
                            }
                            this._poleSegments.push(aa.simpleSegment(e, 0, 66, 64)),
                            e += 66
                        }
                        this._poleNorthVertexBuffer = t.createVertexBuffer(i, Qa, !1),
                        this._poleSouthVertexBuffer = t.createVertexBuffer(n, Qa, !1)
                    }
                    getGridBuffers(t, e) {
                        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts]
                    }
                    getPoleBuffers(t) {
                        return [this._poleNorthVertexBuffer, this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]]
                    }
                    getWirefameBuffers(t, e) {
                        if (!this._wireframeSegments) {
                            const e = new hs
                              , i = hl
                              , n = i + 1 + 2
                              , r = 1;
                            this._wireframeSegments = [];
                            for (let t = 0, o = 0; t < ul.length; t++) {
                                const s = ul[t];
                                for (let t = r; t < s + r; t++)
                                    for (let o = r; o < i + r; o++) {
                                        const i = t * n + o;
                                        e.emplaceBack(i, i + 1),
                                        e.emplaceBack(i, i + n),
                                        e.emplaceBack(i, i + n + 1)
                                    }
                                const a = s * i * 3;
                                this._wireframeSegments.push(aa.simpleSegment(0, o, (s + 1) * n, a)),
                                o += a
                            }
                            this._wireframeIndexBuffer = t.createIndexBuffer(e)
                        }
                        return [this._gridBuffer, this._wireframeIndexBuffer, this._wireframeSegments[e]]
                    }
                }
                ,
                t.GlyphManager = rf,
                t.ImagePosition = Sd,
                t.KDBush = ym,
                t.LivePerformanceUtils = Ut,
                t.LngLat = Gl,
                t.LngLatBounds = ca,
                t.LocalGlyphMode = nf,
                t.MAX_MERCATOR_LATITUDE = Kl,
                t.MercatorCoordinate = Ql,
                t.ONE_EM = Nu,
                t.OverscaledTileID = mu,
                t.PerformanceMarkers = jt,
                t.Point = v,
                t.Properties = Lo,
                t.RGBAImage = jc,
                t.Ray = il,
                t.RequestManager = class {
                    constructor(t, e, i) {
                        this._transformRequestFn = t,
                        this._customAccessToken = e,
                        this._silenceAuthErrors = !!i,
                        this._createSkuToken()
                    }
                    _createSkuToken() {
                        const t = function() {
                            let t = "";
                            for (let e = 0; e < 10; e++)
                                t += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                            return {
                                token: ["1", d, t].join(""),
                                tokenExpiresAt: Date.now() + 432e5
                            }
                        }();
                        this._skuToken = t.token,
                        this._skuTokenExpiresAt = t.tokenExpiresAt
                    }
                    _isSkuTokenExpired() {
                        return Date.now() > this._skuTokenExpiresAt
                    }
                    transformRequest(t, e) {
                        return this._transformRequestFn && this._transformRequestFn(t, e) || {
                            url: t
                        }
                    }
                    normalizeStyleURL(t, e) {
                        if (!xt(t))
                            return t;
                        const i = Ct(t);
                        return i.path = `/styles/v1${i.path}`,
                        this._makeAPIURL(i, this._customAccessToken || e)
                    }
                    normalizeGlyphsURL(t, e) {
                        if (!xt(t))
                            return t;
                        const i = Ct(t);
                        return i.path = `/fonts/v1${i.path}`,
                        this._makeAPIURL(i, this._customAccessToken || e)
                    }
                    normalizeSourceURL(t, e, i, n) {
                        if (!xt(t))
                            return t;
                        const r = Ct(t);
                        return r.path = `/v4/${r.authority}.json`,
                        r.params.push("secure"),
                        i && r.params.push(`language=${i}`),
                        n && r.params.push(`worldview=${n}`),
                        this._makeAPIURL(r, this._customAccessToken || e)
                    }
                    normalizeSpriteURL(t, e, i, n) {
                        const r = Ct(t);
                        return xt(t) ? (r.path = `/styles/v1${r.path}/sprite${e}${i}`,
                        this._makeAPIURL(r, this._customAccessToken || n)) : (r.path += `${e}${i}`,
                        At(r))
                    }
                    normalizeTileURL(t, e, i) {
                        if (this._isSkuTokenExpired() && this._createSkuToken(),
                        t && !xt(t))
                            return t;
                        const n = Ct(t);
                        n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${e || i && "raster" !== n.authority && 512 === i ? "@2x" : ""}${s.supported ? ".webp" : "$1"}`),
                        "raster" === n.authority ? n.path = `/${o.RASTER_URL_PREFIX}${n.path}` : (n.path = n.path.replace(/^.+\/v4\//, "/"),
                        n.path = `/${o.TILE_URL_VERSION}${n.path}`);
                        const r = this._customAccessToken || function(t) {
                            for (const e of t) {
                                const t = e.match(/^access_token=(.*)$/);
                                if (t)
                                    return t[1]
                            }
                            return null
                        }(n.params) || o.ACCESS_TOKEN;
                        return o.REQUIRE_ACCESS_TOKEN && r && this._skuToken && n.params.push(`sku=${this._skuToken}`),
                        this._makeAPIURL(n, r)
                    }
                    canonicalizeTileURL(t, e) {
                        const i = Ct(t);
                        if (!i.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !i.path.match(/\.[\w]+$/))
                            return t;
                        let n = "mapbox://";
                        i.path.match(/^\/raster\/v1\//) ? n += `raster/${i.path.replace(`/${o.RASTER_URL_PREFIX}/`, "")}` : n += `tiles/${i.path.replace(`/${o.TILE_URL_VERSION}/`, "")}`;
                        let r = i.params;
                        return e && (r = r.filter((t => !t.match(/^access_token=/)))),
                        r.length && (n += `?${r.join("&")}`),
                        n
                    }
                    canonicalizeTileset(t, e) {
                        const i = !!e && xt(e)
                          , n = [];
                        for (const e of t.tiles || [])
                            bt(e) ? n.push(this.canonicalizeTileURL(e, i)) : n.push(e);
                        return n
                    }
                    _makeAPIURL(t, e) {
                        const i = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"
                          , n = Ct(o.API_URL);
                        if (t.protocol = n.protocol,
                        t.authority = n.authority,
                        "http" === t.protocol) {
                            const e = t.params.indexOf("secure");
                            e >= 0 && t.params.splice(e, 1)
                        }
                        if ("/" !== n.path && (t.path = `${n.path}${t.path}`),
                        !o.REQUIRE_ACCESS_TOKEN)
                            return At(t);
                        if (e = e || o.ACCESS_TOKEN,
                        !this._silenceAuthErrors) {
                            if (!e)
                                throw new Error(`An API access token is required to use Mapbox GL. ${i}`);
                            if ("s" === e[0])
                                throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${i}`)
                        }
                        return t.params = t.params.filter((t => -1 === t.indexOf("access_token"))),
                        t.params.push(`access_token=${e || ""}`),
                        At(t)
                    }
                }
                ,
                t.ResourceType = ct,
                t.SegmentVector = aa,
                t.SourceCache = im,
                t.StencilMode = Kp,
                t.StructArrayLayout1ui2 = us,
                t.StructArrayLayout2f1f2i16 = es,
                t.StructArrayLayout2i4 = Vo,
                t.StructArrayLayout2ui4 = hs,
                t.StructArrayLayout3f12 = ns,
                t.StructArrayLayout3ui6 = rs,
                t.StructArrayLayout4i8 = Zo,
                t.StructArrayLayout5f20 = ls,
                t.Texture = vp,
                t.Tile = Dp,
                t.Transitionable = Co,
                t.Uniform1f = Fs,
                t.Uniform1i = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = 0
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && this.current !== i && (this.current = i,
                        this.gl.uniform1i(this.location, i))
                    }
                }
                ,
                t.Uniform2f = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = [0, 0]
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] || (this.current = i,
                        this.gl.uniform2f(this.location, i[0], i[1])))
                    }
                }
                ,
                t.Uniform3f = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = [0, 0, 0]
                    }
                    set(t, e, i) {
                        this.fetchUniformLocation(t, e) && (i[0] === this.current[0] && i[1] === this.current[1] && i[2] === this.current[2] || (this.current = i,
                        this.gl.uniform3f(this.location, i[0], i[1], i[2])))
                    }
                }
                ,
                t.Uniform4f = Ns,
                t.UniformColor = js,
                t.UniformMatrix2f = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = Gs
                    }
                    set(t, e, i) {
                        if (this.fetchUniformLocation(t, e))
                            for (let t = 0; t < 4; t++)
                                if (i[t] !== this.current[t]) {
                                    this.current = i,
                                    this.gl.uniformMatrix2fv(this.location, !1, i);
                                    break
                                }
                    }
                }
                ,
                t.UniformMatrix3f = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = Vs
                    }
                    set(t, e, i) {
                        if (this.fetchUniformLocation(t, e))
                            for (let t = 0; t < 9; t++)
                                if (i[t] !== this.current[t]) {
                                    this.current = i,
                                    this.gl.uniformMatrix3fv(this.location, !1, i);
                                    break
                                }
                    }
                }
                ,
                t.UniformMatrix4f = class extends zs {
                    constructor(t) {
                        super(t),
                        this.current = Us
                    }
                    set(t, e, i) {
                        if (this.fetchUniformLocation(t, e)) {
                            if (i[12] !== this.current[12] || i[0] !== this.current[0])
                                return this.current = i,
                                void this.gl.uniformMatrix4fv(this.location, !1, i);
                            for (let t = 1; t < 16; t++)
                                if (i[t] !== this.current[t]) {
                                    this.current = i,
                                    this.gl.uniformMatrix4fv(this.location, !1, i);
                                    break
                                }
                        }
                    }
                }
                ,
                t.UnwrappedTileID = pu,
                t.ValidationError = nr,
                t.VectorTileFeature = $h,
                t.VectorTileWorkerSource = class extends te {
                    constructor(t, e, i, n, r) {
                        super(),
                        this.actor = t,
                        this.layerIndex = e,
                        this.availableImages = i,
                        this.loadVectorData = r || gm,
                        this.loading = {},
                        this.loaded = {},
                        this.deduped = new mm(t.scheduler),
                        this.isSpriteLoaded = n,
                        this.scheduler = t.scheduler
                    }
                    loadTile(t, e) {
                        const i = t.uid
                          , n = t && t.request
                          , r = n && n.collectResourceTiming
                          , o = this.loading[i] = new fm(t);
                        o.abort = this.loadVectorData(t, ( (s, a) => {
                            const l = !this.loading[i];
                            if (delete this.loading[i],
                            l || s || !a)
                                return o.status = "done",
                                l || (this.loaded[i] = o),
                                e(s);
                            const c = a.rawData
                              , h = {};
                            a.expires && (h.expires = a.expires),
                            a.cacheControl && (h.cacheControl = a.cacheControl),
                            o.vectorTile = a.vectorTile || new Hh(new _d(c));
                            const u = () => {
                                o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, ( (t, i) => {
                                    if (t || !i)
                                        return e(t);
                                    const o = {};
                                    if (r) {
                                        const t = Zt(n);
                                        t.length > 0 && (o.resourceTiming = JSON.parse(JSON.stringify(t)))
                                    }
                                    e(null, R({
                                        rawTileData: c.slice(0)
                                    }, i, h, o))
                                }
                                ))
                            }
                            ;
                            this.isSpriteLoaded ? u() : this.once("isSpriteLoaded", ( () => {
                                this.scheduler ? this.scheduler.add(u, {
                                    type: "parseTile",
                                    isSymbolTile: t.isSymbolTile,
                                    zoom: t.tileZoom
                                }) : u()
                            }
                            )),
                            this.loaded = this.loaded || {},
                            this.loaded[i] = o
                        }
                        ))
                    }
                    reloadTile(t, e) {
                        const i = this.loaded
                          , n = t.uid
                          , r = this;
                        if (i && i[n]) {
                            const o = i[n];
                            o.showCollisionBoxes = t.showCollisionBoxes,
                            o.enableTerrain = !!t.enableTerrain,
                            o.projection = t.projection,
                            o.tileTransform = Of(t.tileID.canonical, t.projection);
                            const s = (t, i) => {
                                const n = o.reloadCallback;
                                n && (delete o.reloadCallback,
                                o.parse(o.vectorTile, r.layerIndex, this.availableImages, r.actor, n)),
                                e(t, i)
                            }
                            ;
                            "parsing" === o.status ? o.reloadCallback = s : "done" === o.status && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s())
                        }
                    }
                    abortTile(t, e) {
                        const i = t.uid
                          , n = this.loading[i];
                        n && (n.abort && n.abort(),
                        delete this.loading[i]),
                        e()
                    }
                    removeTile(t, e) {
                        const i = this.loaded
                          , n = t.uid;
                        i && i[n] && delete i[n],
                        e()
                    }
                }
                ,
                t.WritingMode = Ad,
                t.ZoomDependentExpression = Qn,
                t.add = Ia,
                t.addDynamicAttributes = rp,
                t.adjoint = function(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = e[3]
                      , s = e[4]
                      , a = e[5]
                      , l = e[6]
                      , c = e[7]
                      , h = e[8];
                    return t[0] = s * h - a * c,
                    t[1] = r * c - n * h,
                    t[2] = n * a - r * s,
                    t[3] = a * l - o * h,
                    t[4] = i * h - r * l,
                    t[5] = r * o - i * a,
                    t[6] = o * c - s * l,
                    t[7] = n * l - i * c,
                    t[8] = i * s - n * o,
                    t
                }
                ,
                t.asyncAll = k,
                t.bezier = C,
                t.bindAll = N,
                t.boundsAttributes = Op,
                t.bufferConvexPolygon = function(t, e) {
                    const i = [];
                    for (let n = 0; n < t.length; n++) {
                        const r = P(n - 1, -1, t.length - 1)
                          , o = P(n + 1, -1, t.length - 1)
                          , s = t[n]
                          , a = t[o]
                          , l = t[r].sub(s).unit()
                          , c = a.sub(s).unit()
                          , h = c.angleWithSep(l.x, l.y)
                          , u = l.add(c).unit().mult(-1 * e / Math.sin(h / 2));
                        i.push(s.add(u))
                    }
                    return i
                }
                ,
                t.cacheEntryPossiblyAdded = function(t) {
                    lt++,
                    lt > rt && (t.getActor().send("enforceCacheSizeLimit", nt),
                    lt = 0)
                }
                ,
                t.calculateGlobeLabelMatrix = function(t, e) {
                    const {x: i, y: n} = t.point
                      , r = Rl(i, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);
                    return ga(r, r, Ol(vl(e)))
                }
                ,
                t.calculateGlobeMatrix = function(t) {
                    const {x: e, y: i} = t.point
                      , {lng: n, lat: r} = t._center;
                    return Rl(e, i, t.worldSize, n, r)
                }
                ,
                t.calculateGlobeMercatorMatrix = function(t) {
                    const e = t.pixelsPerMeter
                      , i = e / Hl(1, t.center.lat)
                      , n = pa(new Float64Array(16));
                    return _a(n, n, [t.point.x, t.point.y, 0]),
                    ya(n, n, [i, i, e]),
                    Float32Array.from(n)
                }
                ,
                t.circumferenceAtLatitude = Zl,
                t.clamp = I,
                t.clearTileCache = function(t) {
                    if (!ot())
                        return;
                    const i = e.caches.delete(tt);
                    t && i.catch(t).then(( () => t()))
                }
                ,
                t.clipLine = Kd,
                t.clone = function(t) {
                    var e = new ua(16);
                    return e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2],
                    e[3] = t[3],
                    e[4] = t[4],
                    e[5] = t[5],
                    e[6] = t[6],
                    e[7] = t[7],
                    e[8] = t[8],
                    e[9] = t[9],
                    e[10] = t[10],
                    e[11] = t[11],
                    e[12] = t[12],
                    e[13] = t[13],
                    e[14] = t[14],
                    e[15] = t[15],
                    e
                }
                ,
                t.clone$1 = G,
                t.collisionCircleLayout = Fu,
                t.config = o,
                t.conjugate = function(t, e) {
                    return t[0] = -e[0],
                    t[1] = -e[1],
                    t[2] = -e[2],
                    t[3] = e[3],
                    t
                }
                ,
                t.create = function() {
                    var t = new ua(16);
                    return ua != Float32Array && (t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0),
                    t[0] = 1,
                    t[5] = 1,
                    t[10] = 1,
                    t[15] = 1,
                    t
                }
                ,
                t.create$1 = da,
                t.createExpression = Kn,
                t.createLayout = jo,
                t.createStyleLayer = function(t) {
                    return "custom" === t.type ? new mp(t) : new yp[t.type](t)
                }
                ,
                t.cross = za,
                t.degToRad = w,
                t.distance = function(t, e) {
                    return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2])
                }
                ,
                t.div = function(t, e, i) {
                    return t[0] = e[0] / i[0],
                    t[1] = e[1] / i[1],
                    t[2] = e[2] / i[2],
                    t
                }
                ,
                t.dot = Ba,
                t.earthRadius = jl,
                t.ease = A,
                t.easeCubicInOut = S,
                t.ecefToLatLng = function([t,e,i]) {
                    const n = Math.hypot(t, e, i)
                      , r = Math.atan2(t, i)
                      , o = .5 * Math.PI - Math.acos(-e / n);
                    return new Gl(E(r),E(o))
                }
                ,
                t.emitValidationErrors = Zr,
                t.endsWith = j,
                t.enforceCacheSizeLimit = function(t) {
                    st(),
                    et && et.then((e => {
                        e.keys().then((i => {
                            for (let n = 0; n < i.length - t; n++)
                                e.delete(i[n])
                        }
                        ))
                    }
                    ))
                }
                ,
                t.evaluateSizeForFeature = Vu,
                t.evaluateSizeForZoom = Gu,
                t.evaluateVariableOffset = xf,
                t.evented = vo,
                t.exactEquals = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3]
                }
                ,
                t.exactEquals$1 = function(t, e) {
                    return t[0] === e[0] && t[1] === e[1] && t[2] === e[2]
                }
                ,
                t.exported = Xt,
                t.exported$1 = s,
                t.extend = R,
                t.extend$1 = ie,
                t.fillExtrusionHeightLift = lu,
                t.filterObject = V,
                t.fromMat4 = function(t, e) {
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t[3] = e[4],
                    t[4] = e[5],
                    t[5] = e[6],
                    t[6] = e[8],
                    t[7] = e[9],
                    t[8] = e[10],
                    t
                }
                ,
                t.fromQuat = function(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = e[3]
                      , s = i + i
                      , a = n + n
                      , l = r + r
                      , c = i * s
                      , h = n * s
                      , u = n * a
                      , d = r * s
                      , f = r * a
                      , p = r * l
                      , m = o * s
                      , g = o * a
                      , _ = o * l;
                    return t[0] = 1 - u - p,
                    t[1] = h + _,
                    t[2] = d - g,
                    t[3] = 0,
                    t[4] = h - _,
                    t[5] = 1 - c - p,
                    t[6] = f + m,
                    t[7] = 0,
                    t[8] = d + g,
                    t[9] = f - m,
                    t[10] = 1 - c - u,
                    t[11] = 0,
                    t[12] = 0,
                    t[13] = 0,
                    t[14] = 0,
                    t[15] = 1,
                    t
                }
                ,
                t.fromRotation = function(t, e) {
                    var i = Math.sin(e)
                      , n = Math.cos(e);
                    return t[0] = n,
                    t[1] = i,
                    t[2] = 0,
                    t[3] = -i,
                    t[4] = n,
                    t[5] = 0,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 1,
                    t
                }
                ,
                t.fromScaling = ba,
                t.furthestTileCorner = function(t) {
                    const e = Math.round((t + 45 + 360) % 360 / 90) % 4;
                    return T[e]
                }
                ,
                t.getAABBPointSquareDist = function(t, e, i) {
                    let n = 0;
                    for (let r = 0; r < 2; ++r) {
                        const o = i ? i[r] : 0;
                        t[r] > o && (n += (t[r] - o) * (t[r] - o)),
                        e[r] < o && (n += (o - e[r]) * (o - e[r]))
                    }
                    return n
                }
                ,
                t.getAnchorAlignment = Nd,
                t.getAnchorJustification = wf,
                t.getBounds = function(t) {
                    let e = 1 / 0
                      , i = 1 / 0
                      , n = -1 / 0
                      , r = -1 / 0;
                    for (const o of t)
                        e = Math.min(e, o.x),
                        i = Math.min(i, o.y),
                        n = Math.max(n, o.x),
                        r = Math.max(r, o.y);
                    return {
                        min: new v(e,i),
                        max: new v(n,r)
                    }
                }
                ,
                t.getColumn = Q,
                t.getDefaultExportFromCjs = f,
                t.getGridMatrix = function(t, e, i, n) {
                    const r = e.getNorth()
                      , o = e.getSouth()
                      , s = e.getWest()
                      , a = e.getEast()
                      , l = 1 << t.z
                      , c = a - s
                      , h = r - o
                      , u = c / hl
                      , d = -h / ul[i]
                      , f = [0, u, 0, d, 0, 0, r, s, 0];
                    if (t.z > 0) {
                        const t = 180 / n;
                        fa(f, f, [t / c + 1, 0, 0, 0, t / h + 1, 0, -.5 * t / u, .5 * t / d, 1])
                    }
                    return f[2] = l,
                    f[5] = t.x,
                    f[8] = t.y,
                    f
                }
                ,
                t.getImage = yt,
                t.getJSON = function(t, e) {
                    return dt(R(t, {
                        type: "json"
                    }), e)
                }
                ,
                t.getLatitudinalLod = function(t) {
                    const e = Kl - 5;
                    t = I(t, -e, e) / e * 90;
                    const i = Math.pow(Math.abs(Math.sin(w(t))), 3);
                    return Math.round(i * (ul.length - 1))
                }
                ,
                t.getMapSessionAPI = Ft,
                t.getPerformanceMeasurement = Zt,
                t.getProjection = Qf,
                t.getRTLTextPluginStatus = xo,
                t.getReferrer = ut,
                t.getTilePoint = function(t, {x: e, y: i}, n=0) {
                    return new v(((e - n) * t.scale - t.x) * la,(i * t.scale - t.y) * la)
                }
                ,
                t.getTileVec3 = function(t, e, i=0) {
                    return Aa(((e.x - i) * t.scale - t.x) * la, (e.y * t.scale - t.y) * la, Yl(e.z, e.y))
                }
                ,
                t.getVideo = function(t, i) {
                    const n = e.document.createElement("video");
                    n.muted = !0,
                    n.onloadstart = function() {
                        i(null, n)
                    }
                    ;
                    for (let i = 0; i < t.length; i++) {
                        const r = e.document.createElement("source");
                        pt(t[i]) || (n.crossOrigin = "Anonymous"),
                        r.src = t[i],
                        n.appendChild(r)
                    }
                    return {
                        cancel: () => {}
                    }
                }
                ,
                t.globeCenterToScreenPoint = function(t) {
                    const e = [0, 0, 0]
                      , i = pa(new Float64Array(16));
                    return ga(i, t.pixelMatrix, t.globeMatrix),
                    Fa(e, e, i),
                    new v(e[0],e[1])
                }
                ,
                t.globeDenormalizeECEF = Ol,
                t.globeECEFOrigin = function(t, e) {
                    const i = [0, 0, 0];
                    return Fa(i, i, kl(vl(e.canonical))),
                    Fa(i, i, t),
                    i
                }
                ,
                t.globeMetersToEcef = ml,
                t.globeNormalizeECEF = kl,
                t.globePixelsToTileUnits = function(t, e) {
                    return la / (512 * Math.pow(2, t)) * Ml(vl(e))
                }
                ,
                t.globePoleMatrixForTile = function(t, e, i) {
                    const n = pa(new Float64Array(16))
                      , r = (e / (1 << t) - .5) * Math.PI * 2;
                    return xa(n, i.globeMatrix, r),
                    Float32Array.from(n)
                }
                ,
                t.globeTileBounds = vl,
                t.globeTiltAtLngLat = Ll,
                t.globeToMercatorTransition = Dl,
                t.globeUseCustomAntiAliasing = function(t, e, i) {
                    const n = Dl(i.zoom)
                      , r = t.style.map._antialias
                      , o = !!e.extStandardDerivatives
                      , s = e.extStandardDerivativesForceOff || t.terrain && t.terrain.exaggeration() > 0;
                    return 0 === n && !r && !s && o
                }
                ,
                t.identity = pa,
                t.identity$1 = $a,
                t.invert = ma,
                t.isFullscreen = function() {
                    return !!e.document.fullscreenElement || !!e.document.webkitFullscreenElement
                }
                ,
                t.isLngLatBehindGlobe = Bl,
                t.isMapAuthenticated = function(t) {
                    return Nt.has(t)
                }
                ,
                t.isMapboxURL = xt,
                t.isSafariWithAntialiasingBug = function(t) {
                    const e = t.navigator ? t.navigator.userAgent : null;
                    return !!K(t) && e && (e.match("Version/15.4") || e.match("Version/15.5") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
                }
                ,
                t.latFromMercatorY = Xl,
                t.latLngToECEF = Al,
                t.len = Ga,
                t.length = Ca,
                t.length$1 = function(t) {
                    return Math.hypot(t[0], t[1], t[2], t[3])
                }
                ,
                t.lngFromMercatorX = $l,
                t.loadVectorTile = gm,
                t.makeRequest = dt,
                t.mapValue = function(t, e, i, n, r) {
                    return I((t - e) / (i - e) * (r - n) + n, n, r)
                }
                ,
                t.mercatorScale = Jl,
                t.mercatorXfromLng = ql,
                t.mercatorYfromLat = Wl,
                t.mercatorZfromAltitude = Hl,
                t.mul = Ea,
                t.mul$1 = Va,
                t.multiply = ga,
                t.multiply$1 = fa,
                t.multiply$2 = Pa,
                t.nextPowerOfTwo = z,
                t.normalize = La,
                t.normalize$1 = Ka,
                t.normalize$2 = qa,
                t.number = Oi,
                t.ortho = function(t, e, i, n, r, o, s) {
                    var a = 1 / (e - i)
                      , l = 1 / (n - r)
                      , c = 1 / (o - s);
                    return t[0] = -2 * a,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = -2 * l,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[10] = 2 * c,
                    t[11] = 0,
                    t[12] = (e + i) * a,
                    t[13] = (r + n) * l,
                    t[14] = (s + o) * c,
                    t[15] = 1,
                    t
                }
                ,
                t.pbf = Xu,
                t.perspective = function(t, e, i, n, r) {
                    var o, s = 1 / Math.tan(e / 2);
                    return t[0] = s / i,
                    t[1] = 0,
                    t[2] = 0,
                    t[3] = 0,
                    t[4] = 0,
                    t[5] = s,
                    t[6] = 0,
                    t[7] = 0,
                    t[8] = 0,
                    t[9] = 0,
                    t[11] = -1,
                    t[12] = 0,
                    t[13] = 0,
                    t[15] = 0,
                    null != r && r !== 1 / 0 ? (t[10] = (r + n) * (o = 1 / (n - r)),
                    t[14] = 2 * r * n * o) : (t[10] = -1,
                    t[14] = -2 * n),
                    t
                }
                ,
                t.pick = function(t, e) {
                    const i = {};
                    for (let n = 0; n < e.length; n++) {
                        const r = e[n];
                        r in t && (i[r] = t[r])
                    }
                    return i
                }
                ,
                t.plugin = wo,
                t.pointGeometry = _,
                t.polesInViewport = function(t) {
                    const e = pa(new Float64Array(16));
                    ga(e, t.pixelMatrix, t.globeMatrix);
                    const i = [0, dl, 0]
                      , n = [0, fl, 0];
                    return Fa(i, i, e),
                    Fa(n, n, e),
                    [i[0] > 0 && i[0] <= t.width && i[1] > 0 && i[1] <= t.height && !Bl(t, new Gl(t.center.lat,90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Bl(t, new Gl(t.center.lat,-90))]
                }
                ,
                t.polygonContainsPoint = bc,
                t.polygonIntersectsBox = wc,
                t.polygonIntersectsPolygon = dc,
                t.polygonizeBounds = function(t, e, i=0, n=!0) {
                    const r = new v(i,i)
                      , o = t.sub(r)
                      , s = e.add(r)
                      , a = [o, new v(s.x,o.y), s, new v(o.x,s.y)];
                    return n && a.push(o.clone()),
                    a
                }
                ,
                t.posAttributes = el,
                t.postMapLoadEvent = Dt,
                t.postPerformanceEvent = Bt,
                t.postTurnstileEvent = Ot,
                t.potpack = Ed,
                t.prevPowerOfTwo = function(t) {
                    return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                }
                ,
                t.radToDeg = E,
                t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"],
                t.registerForPluginStateChange = function(t) {
                    return t({
                        pluginStatus: mo,
                        pluginURL: go
                    }),
                    vo.on("pluginStateChange", t),
                    t
                }
                ,
                t.removeAuthState = function(t) {
                    Nt.delete(t)
                }
                ,
                t.renderColorRamp = Vc,
                t.resample = ec,
                t.rotateX = va,
                t.rotateX$1 = Xa,
                t.rotateY = xa,
                t.rotateY$1 = Ya,
                t.rotateZ = function(t, e, i) {
                    var n = Math.sin(i)
                      , r = Math.cos(i)
                      , o = e[0]
                      , s = e[1]
                      , a = e[2]
                      , l = e[3]
                      , c = e[4]
                      , h = e[5]
                      , u = e[6]
                      , d = e[7];
                    return e !== t && (t[8] = e[8],
                    t[9] = e[9],
                    t[10] = e[10],
                    t[11] = e[11],
                    t[12] = e[12],
                    t[13] = e[13],
                    t[14] = e[14],
                    t[15] = e[15]),
                    t[0] = o * r + c * n,
                    t[1] = s * r + h * n,
                    t[2] = a * r + u * n,
                    t[3] = l * r + d * n,
                    t[4] = c * r - o * n,
                    t[5] = h * r - s * n,
                    t[6] = u * r - a * n,
                    t[7] = d * r - l * n,
                    t
                }
                ,
                t.rotateZ$1 = function(t, e, i) {
                    i *= .5;
                    var n = e[0]
                      , r = e[1]
                      , o = e[2]
                      , s = e[3]
                      , a = Math.sin(i)
                      , l = Math.cos(i);
                    return t[0] = n * l + r * a,
                    t[1] = r * l - n * a,
                    t[2] = o * l + s * a,
                    t[3] = s * l - o * a,
                    t
                }
                ,
                t.scale = ya,
                t.scale$1 = Za,
                t.scale$2 = Ra,
                t.scaleAndAdd = Da,
                t.set = function(t, e, i, n) {
                    return t[0] = e,
                    t[1] = i,
                    t[2] = n,
                    t
                }
                ,
                t.setCacheLimits = function(t, e) {
                    nt = t,
                    rt = e
                }
                ,
                t.setColumn = function(t, e, i) {
                    t[4 * e + 0] = i[0],
                    t[4 * e + 1] = i[1],
                    t[4 * e + 2] = i[2],
                    t[4 * e + 3] = i[3]
                }
                ,
                t.setRTLTextPlugin = function(t, e, i=!1) {
                    if (mo === ho || mo === uo || mo === fo)
                        throw new Error("setRTLTextPlugin cannot be called multiple times.");
                    go = Xt.resolveURL(t),
                    mo = ho,
                    po = e,
                    yo(),
                    i || bo()
                }
                ,
                t.smoothstep = M,
                t.spec = ee,
                t.squaredLength = function(t) {
                    var e = t[0]
                      , i = t[1]
                      , n = t[2];
                    return e * e + i * i + n * n
                }
                ,
                t.storeAuthState = function(t, e) {
                    e ? Nt.add(t) : Nt.delete(t)
                }
                ,
                t.sub = Ua,
                t.subtract = Ma,
                t.symbolSize = Zu,
                t.tileAABB = function(t, e, i, n, r, o, s, a, l) {
                    if ("globe" === l.name)
                        return El(t, e, new fu(i,n,r));
                    const c = Of({
                        z: i,
                        x: n,
                        y: r
                    }, l);
                    return new ol([(o + c.x / c.scale) * e, e * (c.y / c.scale), s],[(o + c.x2 / c.scale) * e, e * (c.y2 / c.scale), a])
                }
                ,
                t.tileCornersToBounds = Tl,
                t.tileTransform = Of,
                t.transformMat3 = function(t, e, i) {
                    var n = e[0]
                      , r = e[1]
                      , o = e[2];
                    return t[0] = n * i[0] + r * i[3] + o * i[6],
                    t[1] = n * i[1] + r * i[4] + o * i[7],
                    t[2] = n * i[2] + r * i[5] + o * i[8],
                    t
                }
                ,
                t.transformMat4 = Fa,
                t.transformMat4$1 = Wa,
                t.transformQuat = Na,
                t.transitionTileAABBinECEF = bl,
                t.translate = _a,
                t.transpose = function(t, e) {
                    if (t === e) {
                        var i = e[1]
                          , n = e[2]
                          , r = e[5];
                        t[1] = e[3],
                        t[2] = e[6],
                        t[3] = i,
                        t[5] = e[7],
                        t[6] = n,
                        t[7] = r
                    } else
                        t[0] = e[0],
                        t[1] = e[3],
                        t[2] = e[6],
                        t[3] = e[1],
                        t[4] = e[4],
                        t[5] = e[7],
                        t[6] = e[2],
                        t[7] = e[5],
                        t[8] = e[8];
                    return t
                }
                ,
                t.triggerPluginCompletionEvent = _o,
                t.uniqueId = L,
                t.updateGlobeVertexNormal = function(t, e, i, n, r) {
                    const o = 5 * e + 2;
                    t.float32[o + 0] = i,
                    t.float32[o + 1] = n,
                    t.float32[o + 2] = r
                }
                ,
                t.validateCustomStyleLayer = function(t) {
                    const e = []
                      , i = t.id;
                    return void 0 === i && e.push({
                        message: `layers.${i}: missing required property "id"`
                    }),
                    void 0 === t.render && e.push({
                        message: `layers.${i}: missing required method "render"`
                    }),
                    t.renderingMode && "2d" !== t.renderingMode && "3d" !== t.renderingMode && e.push({
                        message: `layers.${i}: property "renderingMode" must be either "2d" or "3d"`
                    }),
                    e
                }
                ,
                t.validateFilter = t => Gr(Tr(t)),
                t.validateFog = t => Gr(Br(t)),
                t.validateLayer = t => Gr(Mr(t)),
                t.validateLight = t => Gr(Dr(t)),
                t.validateSource = t => Gr(Or(t)),
                t.validateStyle = jr,
                t.validateTerrain = t => Gr(Lr(t)),
                t.values = O,
                t.vectorTile = Lh,
                t.version = i,
                t.warnOnce = q,
                t.window = e,
                t.wrap = P
            }
            )),
            r(["./shared"], (function(t) {
                function e(t) {
                    if ("number" == typeof t || "boolean" == typeof t || "string" == typeof t || null == t)
                        return JSON.stringify(t);
                    if (Array.isArray(t)) {
                        let i = "[";
                        for (const n of t)
                            i += `${e(n)},`;
                        return `${i}]`
                    }
                    let i = "{";
                    for (const n of Object.keys(t).sort())
                        i += `${n}:${e(t[n])},`;
                    return `${i}}`
                }
                function i(i) {
                    let n = "";
                    for (const r of t.refProperties)
                        n += `/${e(i[r])}`;
                    return n
                }
                class r {
                    constructor(t) {
                        this.keyCache = {},
                        t && this.replace(t)
                    }
                    replace(t) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(t, [])
                    }
                    update(e, n) {
                        for (const i of e)
                            this._layerConfigs[i.id] = i,
                            (this._layers[i.id] = t.createStyleLayer(i)).compileFilter(),
                            this.keyCache[i.id] && delete this.keyCache[i.id];
                        for (const t of n)
                            delete this.keyCache[t],
                            delete this._layerConfigs[t],
                            delete this._layers[t];
                        this.familiesBySource = {};
                        const r = function(t, e) {
                            const n = {};
                            for (let r = 0; r < t.length; r++) {
                                const o = e && e[t[r].id] || i(t[r]);
                                e && (e[t[r].id] = o);
                                let s = n[o];
                                s || (s = n[o] = []),
                                s.push(t[r])
                            }
                            const r = [];
                            for (const t in n)
                                r.push(n[t]);
                            return r
                        }(t.values(this._layerConfigs), this.keyCache);
                        for (const t of r) {
                            const e = t.map((t => this._layers[t.id]))
                              , i = e[0];
                            if ("none" === i.visibility)
                                continue;
                            const n = i.source || "";
                            let r = this.familiesBySource[n];
                            r || (r = this.familiesBySource[n] = {});
                            const o = i.sourceLayer || "_geojsonTileLayer";
                            let s = r[o];
                            s || (s = r[o] = []),
                            s.push(e)
                        }
                    }
                }
                class o {
                    loadTile(e, i) {
                        const {uid: n, encoding: r, rawImageData: o, padding: s, buildQuadTree: a} = e
                          , l = t.window.ImageBitmap && o instanceof t.window.ImageBitmap ? this.getImageData(o, s) : o;
                        i(null, new t.DEMData(n,l,r,s < 1,a))
                    }
                    getImageData(t, e) {
                        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t.width,t.height),
                        this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", {
                            willReadFrequently: !0
                        })),
                        this.offscreenCanvas.width = t.width,
                        this.offscreenCanvas.height = t.height,
                        this.offscreenCanvasContext.drawImage(t, 0, 0, t.width, t.height);
                        const i = this.offscreenCanvasContext.getImageData(-e, -e, t.width + 2 * e, t.height + 2 * e);
                        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height),
                        i
                    }
                }
                function s(t, e) {
                    if (0 !== t.length) {
                        a(t[0], e);
                        for (var i = 1; i < t.length; i++)
                            a(t[i], !e)
                    }
                }
                function a(t, e) {
                    for (var i = 0, n = 0, r = 0, o = t.length, s = o - 1; r < o; s = r++) {
                        var a = (t[r][0] - t[s][0]) * (t[s][1] + t[r][1])
                          , l = i + a;
                        n += Math.abs(i) >= Math.abs(a) ? i - l + a : a - l + i,
                        i = l
                    }
                    i + n >= 0 != !!e && t.reverse()
                }
                var l = t.getDefaultExportFromCjs((function t(e, i) {
                    var n, r = e && e.type;
                    if ("FeatureCollection" === r)
                        for (n = 0; n < e.features.length; n++)
                            t(e.features[n], i);
                    else if ("GeometryCollection" === r)
                        for (n = 0; n < e.geometries.length; n++)
                            t(e.geometries[n], i);
                    else if ("Feature" === r)
                        t(e.geometry, i);
                    else if ("Polygon" === r)
                        s(e.coordinates, i);
                    else if ("MultiPolygon" === r)
                        for (n = 0; n < e.coordinates.length; n++)
                            s(e.coordinates[n], i);
                    return e
                }
                ));
                const c = t.VectorTileFeature.prototype.toGeoJSON;
                var h = {
                    exports: {}
                }
                  , u = t.pointGeometry
                  , d = t.vectorTile.VectorTileFeature
                  , f = p;
                function p(t, e) {
                    this.options = e || {},
                    this.features = t,
                    this.length = t.length
                }
                function m(t, e) {
                    this.id = "number" == typeof t.id ? t.id : void 0,
                    this.type = t.type,
                    this.rawGeometry = 1 === t.type ? [t.geometry] : t.geometry,
                    this.properties = t.tags,
                    this.extent = e || 4096
                }
                p.prototype.feature = function(t) {
                    return new m(this.features[t],this.options.extent)
                }
                ,
                m.prototype.loadGeometry = function() {
                    var t = this.rawGeometry;
                    this.geometry = [];
                    for (var e = 0; e < t.length; e++) {
                        for (var i = t[e], n = [], r = 0; r < i.length; r++)
                            n.push(new u(i[r][0],i[r][1]));
                        this.geometry.push(n)
                    }
                    return this.geometry
                }
                ,
                m.prototype.bbox = function() {
                    this.geometry || this.loadGeometry();
                    for (var t = this.geometry, e = 1 / 0, i = -1 / 0, n = 1 / 0, r = -1 / 0, o = 0; o < t.length; o++)
                        for (var s = t[o], a = 0; a < s.length; a++) {
                            var l = s[a];
                            e = Math.min(e, l.x),
                            i = Math.max(i, l.x),
                            n = Math.min(n, l.y),
                            r = Math.max(r, l.y)
                        }
                    return [e, n, i, r]
                }
                ,
                m.prototype.toGeoJSON = d.prototype.toGeoJSON;
                var g = t.pbf
                  , _ = f;
                function y(t) {
                    var e = new g;
                    return function(t, e) {
                        for (var i in t.layers)
                            e.writeMessage(3, v, t.layers[i])
                    }(t, e),
                    e.finish()
                }
                function v(t, e) {
                    var i;
                    e.writeVarintField(15, t.version || 1),
                    e.writeStringField(1, t.name || ""),
                    e.writeVarintField(5, t.extent || 4096);
                    var n = {
                        keys: [],
                        values: [],
                        keycache: {},
                        valuecache: {}
                    };
                    for (i = 0; i < t.length; i++)
                        n.feature = t.feature(i),
                        e.writeMessage(2, x, n);
                    var r = n.keys;
                    for (i = 0; i < r.length; i++)
                        e.writeStringField(3, r[i]);
                    var o = n.values;
                    for (i = 0; i < o.length; i++)
                        e.writeMessage(4, S, o[i])
                }
                function x(t, e) {
                    var i = t.feature;
                    void 0 !== i.id && e.writeVarintField(1, i.id),
                    e.writeMessage(2, b, t),
                    e.writeVarintField(3, i.type),
                    e.writeMessage(4, T, i)
                }
                function b(t, e) {
                    var i = t.feature
                      , n = t.keys
                      , r = t.values
                      , o = t.keycache
                      , s = t.valuecache;
                    for (var a in i.properties) {
                        var l = i.properties[a]
                          , c = o[a];
                        if (null !== l) {
                            void 0 === c && (n.push(a),
                            o[a] = c = n.length - 1),
                            e.writeVarint(c);
                            var h = typeof l;
                            "string" !== h && "boolean" !== h && "number" !== h && (l = JSON.stringify(l));
                            var u = h + ":" + l
                              , d = s[u];
                            void 0 === d && (r.push(l),
                            s[u] = d = r.length - 1),
                            e.writeVarint(d)
                        }
                    }
                }
                function w(t, e) {
                    return (e << 3) + (7 & t)
                }
                function E(t) {
                    return t << 1 ^ t >> 31
                }
                function T(t, e) {
                    for (var i = t.loadGeometry(), n = t.type, r = 0, o = 0, s = i.length, a = 0; a < s; a++) {
                        var l = i[a]
                          , c = 1;
                        1 === n && (c = l.length),
                        e.writeVarint(w(1, c));
                        for (var h = 3 === n ? l.length - 1 : l.length, u = 0; u < h; u++) {
                            1 === u && 1 !== n && e.writeVarint(w(2, h - 1));
                            var d = l[u].x - r
                              , f = l[u].y - o;
                            e.writeVarint(E(d)),
                            e.writeVarint(E(f)),
                            r += d,
                            o += f
                        }
                        3 === n && e.writeVarint(w(7, 1))
                    }
                }
                function S(t, e) {
                    var i = typeof t;
                    "string" === i ? e.writeStringField(1, t) : "boolean" === i ? e.writeBooleanField(7, t) : "number" === i && (t % 1 != 0 ? e.writeDoubleField(3, t) : t < 0 ? e.writeSVarintField(6, t) : e.writeVarintField(5, t))
                }
                h.exports = y,
                h.exports.fromVectorTileJs = y,
                h.exports.fromGeojsonVt = function(t, e) {
                    e = e || {};
                    var i = {};
                    for (var n in t)
                        i[n] = new _(t[n].features,e),
                        i[n].name = n,
                        i[n].version = e.version,
                        i[n].extent = e.extent;
                    return y({
                        layers: i
                    })
                }
                ,
                h.exports.GeoJSONWrapper = _;
                var C = t.getDefaultExportFromCjs(h.exports);
                const A = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: t => t
                }
                  , I = Math.fround || (M = new Float32Array(1),
                t => (M[0] = +t,
                M[0]));
                var M;
                const P = 3
                  , k = 5
                  , O = 6;
                class R {
                    constructor(t) {
                        this.options = Object.assign(Object.create(A), t),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(t) {
                        const {log: e, minZoom: i, maxZoom: r} = this.options;
                        e && n.time("total time");
                        const o = `prepare ${t.length} points`;
                        e && n.time(o),
                        this.points = t;
                        const s = [];
                        for (let e = 0; e < t.length; e++) {
                            const i = t[e];
                            if (!i.geometry)
                                continue;
                            const [n,r] = i.geometry.coordinates
                              , o = I(B(n))
                              , a = I(z(r));
                            s.push(o, a, 1 / 0, e, -1, 1),
                            this.options.reduce && s.push(0)
                        }
                        let a = this.trees[r + 1] = this._createTree(s);
                        e && n.timeEnd(o);
                        for (let t = r; t >= i; t--)
                            Date.now(),
                            a = this.trees[t] = this._createTree(this._cluster(a, t)),
                            e && (a.numItems,
                            Date.now());
                        return e && n.timeEnd("total time"),
                        this
                    }
                    getClusters(t, e) {
                        let i = ((t[0] + 180) % 360 + 360) % 360 - 180;
                        const n = Math.max(-90, Math.min(90, t[1]));
                        let r = 180 === t[2] ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
                        const o = Math.max(-90, Math.min(90, t[3]));
                        if (t[2] - t[0] >= 360)
                            i = -180,
                            r = 180;
                        else if (i > r) {
                            const t = this.getClusters([i, n, 180, o], e)
                              , s = this.getClusters([-180, n, r, o], e);
                            return t.concat(s)
                        }
                        const s = this.trees[this._limitZoom(e)]
                          , a = s.range(B(i), z(o), B(r), z(n))
                          , l = s.data
                          , c = [];
                        for (const t of a) {
                            const e = this.stride * t;
                            c.push(l[e + k] > 1 ? D(l, e, this.clusterProps) : this.points[l[e + P]])
                        }
                        return c
                    }
                    getChildren(t) {
                        const e = this._getOriginId(t)
                          , i = this._getOriginZoom(t)
                          , n = "No cluster with the specified id."
                          , r = this.trees[i];
                        if (!r)
                            throw new Error(n);
                        const o = r.data;
                        if (e * this.stride >= o.length)
                            throw new Error(n);
                        const s = this.options.radius / (this.options.extent * Math.pow(2, i - 1))
                          , a = r.within(o[e * this.stride], o[e * this.stride + 1], s)
                          , l = [];
                        for (const e of a) {
                            const i = e * this.stride;
                            o[i + 4] === t && l.push(o[i + k] > 1 ? D(o, i, this.clusterProps) : this.points[o[i + P]])
                        }
                        if (0 === l.length)
                            throw new Error(n);
                        return l
                    }
                    getLeaves(t, e, i) {
                        const n = [];
                        return this._appendLeaves(n, t, e = e || 10, i = i || 0, 0),
                        n
                    }
                    getTile(t, e, i) {
                        const n = this.trees[this._limitZoom(t)]
                          , r = Math.pow(2, t)
                          , {extent: o, radius: s} = this.options
                          , a = s / o
                          , l = (i - a) / r
                          , c = (i + 1 + a) / r
                          , h = {
                            features: []
                        };
                        return this._addTileFeatures(n.range((e - a) / r, l, (e + 1 + a) / r, c), n.data, e, i, r, h),
                        0 === e && this._addTileFeatures(n.range(1 - a / r, l, 1, c), n.data, r, i, r, h),
                        e === r - 1 && this._addTileFeatures(n.range(0, l, a / r, c), n.data, -1, i, r, h),
                        h.features.length ? h : null
                    }
                    getClusterExpansionZoom(t) {
                        let e = this._getOriginZoom(t) - 1;
                        for (; e <= this.options.maxZoom; ) {
                            const i = this.getChildren(t);
                            if (e++,
                            1 !== i.length)
                                break;
                            t = i[0].properties.cluster_id
                        }
                        return e
                    }
                    _appendLeaves(t, e, i, n, r) {
                        const o = this.getChildren(e);
                        for (const e of o) {
                            const o = e.properties;
                            if (o && o.cluster ? r + o.point_count <= n ? r += o.point_count : r = this._appendLeaves(t, o.cluster_id, i, n, r) : r < n ? r++ : t.push(e),
                            t.length === i)
                                break
                        }
                        return r
                    }
                    _createTree(e) {
                        const i = new t.KDBush(e.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let t = 0; t < e.length; t += this.stride)
                            i.add(e[t], e[t + 1]);
                        return i.finish(),
                        i.data = e,
                        i
                    }
                    _addTileFeatures(t, e, i, n, r, o) {
                        for (const s of t) {
                            const t = s * this.stride
                              , a = e[t + k] > 1;
                            let l, c, h;
                            if (a)
                                l = L(e, t, this.clusterProps),
                                c = e[t],
                                h = e[t + 1];
                            else {
                                const i = this.points[e[t + P]];
                                l = i.properties;
                                const [n,r] = i.geometry.coordinates;
                                c = B(n),
                                h = z(r)
                            }
                            const u = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (c * r - i)), Math.round(this.options.extent * (h * r - n))]],
                                tags: l
                            };
                            let d;
                            d = a || this.options.generateId ? e[t + P] : this.points[e[t + P]].id,
                            void 0 !== d && (u.id = d),
                            o.features.push(u)
                        }
                    }
                    _limitZoom(t) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1))
                    }
                    _cluster(t, e) {
                        const {radius: i, extent: n, reduce: r, minPoints: o} = this.options
                          , s = i / (n * Math.pow(2, e))
                          , a = t.data
                          , l = []
                          , c = this.stride;
                        for (let i = 0; i < a.length; i += c) {
                            if (a[i + 2] <= e)
                                continue;
                            a[i + 2] = e;
                            const n = a[i]
                              , h = a[i + 1]
                              , u = t.within(a[i], a[i + 1], s)
                              , d = a[i + k];
                            let f = d;
                            for (const t of u) {
                                const i = t * c;
                                a[i + 2] > e && (f += a[i + k])
                            }
                            if (f > d && f >= o) {
                                let t, o = n * d, s = h * d, p = -1;
                                const m = ((i / c | 0) << 5) + (e + 1) + this.points.length;
                                for (const n of u) {
                                    const l = n * c;
                                    if (a[l + 2] <= e)
                                        continue;
                                    a[l + 2] = e;
                                    const h = a[l + k];
                                    o += a[l] * h,
                                    s += a[l + 1] * h,
                                    a[l + 4] = m,
                                    r && (t || (t = this._map(a, i, !0),
                                    p = this.clusterProps.length,
                                    this.clusterProps.push(t)),
                                    r(t, this._map(a, l)))
                                }
                                a[i + 4] = m,
                                l.push(o / f, s / f, 1 / 0, m, -1, f),
                                r && l.push(p)
                            } else {
                                for (let t = 0; t < c; t++)
                                    l.push(a[i + t]);
                                if (f > 1)
                                    for (const t of u) {
                                        const i = t * c;
                                        if (!(a[i + 2] <= e)) {
                                            a[i + 2] = e;
                                            for (let t = 0; t < c; t++)
                                                l.push(a[i + t])
                                        }
                                    }
                            }
                        }
                        return l
                    }
                    _getOriginId(t) {
                        return t - this.points.length >> 5
                    }
                    _getOriginZoom(t) {
                        return (t - this.points.length) % 32
                    }
                    _map(t, e, i) {
                        if (t[e + k] > 1) {
                            const n = this.clusterProps[t[e + O]];
                            return i ? Object.assign({}, n) : n
                        }
                        const n = this.points[t[e + P]].properties
                          , r = this.options.map(n);
                        return i && r === n ? Object.assign({}, r) : r
                    }
                }
                function D(t, e, i) {
                    return {
                        type: "Feature",
                        id: t[e + P],
                        properties: L(t, e, i),
                        geometry: {
                            type: "Point",
                            coordinates: [(n = t[e],
                            360 * (n - .5)), F(t[e + 1])]
                        }
                    };
                    var n
                }
                function L(t, e, i) {
                    const n = t[e + k]
                      , r = n >= 1e4 ? `${Math.round(n / 1e3)}k` : n >= 1e3 ? Math.round(n / 100) / 10 + "k" : n
                      , o = t[e + O]
                      , s = -1 === o ? {} : Object.assign({}, i[o]);
                    return Object.assign(s, {
                        cluster: !0,
                        cluster_id: t[e + P],
                        point_count: n,
                        point_count_abbreviated: r
                    })
                }
                function B(t) {
                    return t / 360 + .5
                }
                function z(t) {
                    const e = Math.sin(t * Math.PI / 180)
                      , i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
                    return i < 0 ? 0 : i > 1 ? 1 : i
                }
                function F(t) {
                    const e = (180 - 360 * t) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(e)) / Math.PI - 90
                }
                function N(t, e, i, n) {
                    for (var r, o = n, s = i - e >> 1, a = i - e, l = t[e], c = t[e + 1], h = t[i], u = t[i + 1], d = e + 3; d < i; d += 3) {
                        var f = j(t[d], t[d + 1], l, c, h, u);
                        if (f > o)
                            r = d,
                            o = f;
                        else if (f === o) {
                            var p = Math.abs(d - s);
                            p < a && (r = d,
                            a = p)
                        }
                    }
                    o > n && (r - e > 3 && N(t, e, r, n),
                    t[r + 2] = o,
                    i - r > 3 && N(t, r, i, n))
                }
                function j(t, e, i, n, r, o) {
                    var s = r - i
                      , a = o - n;
                    if (0 !== s || 0 !== a) {
                        var l = ((t - i) * s + (e - n) * a) / (s * s + a * a);
                        l > 1 ? (i = r,
                        n = o) : l > 0 && (i += s * l,
                        n += a * l)
                    }
                    return (s = t - i) * s + (a = e - n) * a
                }
                function U(t, e, i, n) {
                    var r = {
                        id: void 0 === t ? null : t,
                        type: e,
                        geometry: i,
                        tags: n,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    return function(t) {
                        var e = t.geometry
                          , i = t.type;
                        if ("Point" === i || "MultiPoint" === i || "LineString" === i)
                            V(t, e);
                        else if ("Polygon" === i || "MultiLineString" === i)
                            for (var n = 0; n < e.length; n++)
                                V(t, e[n]);
                        else if ("MultiPolygon" === i)
                            for (n = 0; n < e.length; n++)
                                for (var r = 0; r < e[n].length; r++)
                                    V(t, e[n][r])
                    }(r),
                    r
                }
                function V(t, e) {
                    for (var i = 0; i < e.length; i += 3)
                        t.minX = Math.min(t.minX, e[i]),
                        t.minY = Math.min(t.minY, e[i + 1]),
                        t.maxX = Math.max(t.maxX, e[i]),
                        t.maxY = Math.max(t.maxY, e[i + 1])
                }
                function G(t, e, i, n) {
                    if (e.geometry) {
                        var r = e.geometry.coordinates
                          , o = e.geometry.type
                          , s = Math.pow(i.tolerance / ((1 << i.maxZoom) * i.extent), 2)
                          , a = []
                          , l = e.id;
                        if (i.promoteId ? l = e.properties[i.promoteId] : i.generateId && (l = n || 0),
                        "Point" === o)
                            Z(r, a);
                        else if ("MultiPoint" === o)
                            for (var c = 0; c < r.length; c++)
                                Z(r[c], a);
                        else if ("LineString" === o)
                            q(r, a, s, !1);
                        else if ("MultiLineString" === o) {
                            if (i.lineMetrics) {
                                for (c = 0; c < r.length; c++)
                                    q(r[c], a = [], s, !1),
                                    t.push(U(l, "LineString", a, e.properties));
                                return
                            }
                            W(r, a, s, !1)
                        } else if ("Polygon" === o)
                            W(r, a, s, !0);
                        else {
                            if ("MultiPolygon" !== o) {
                                if ("GeometryCollection" === o) {
                                    for (c = 0; c < e.geometry.geometries.length; c++)
                                        G(t, {
                                            id: l,
                                            geometry: e.geometry.geometries[c],
                                            properties: e.properties
                                        }, i, n);
                                    return
                                }
                                throw new Error("Input data is not a valid GeoJSON object.")
                            }
                            for (c = 0; c < r.length; c++) {
                                var h = [];
                                W(r[c], h, s, !0),
                                a.push(h)
                            }
                        }
                        t.push(U(l, o, a, e.properties))
                    }
                }
                function Z(t, e) {
                    e.push(H(t[0])),
                    e.push($(t[1])),
                    e.push(0)
                }
                function q(t, e, i, n) {
                    for (var r, o, s = 0, a = 0; a < t.length; a++) {
                        var l = H(t[a][0])
                          , c = $(t[a][1]);
                        e.push(l),
                        e.push(c),
                        e.push(0),
                        a > 0 && (s += n ? (r * c - l * o) / 2 : Math.sqrt(Math.pow(l - r, 2) + Math.pow(c - o, 2))),
                        r = l,
                        o = c
                    }
                    var h = e.length - 3;
                    e[2] = 1,
                    N(e, 0, h, i),
                    e[h + 2] = 1,
                    e.size = Math.abs(s),
                    e.start = 0,
                    e.end = e.size
                }
                function W(t, e, i, n) {
                    for (var r = 0; r < t.length; r++) {
                        var o = [];
                        q(t[r], o, i, n),
                        e.push(o)
                    }
                }
                function H(t) {
                    return t / 360 + .5
                }
                function $(t) {
                    var e = Math.sin(t * Math.PI / 180)
                      , i = .5 - .25 * Math.log((1 + e) / (1 - e)) / Math.PI;
                    return i < 0 ? 0 : i > 1 ? 1 : i
                }
                function X(t, e, i, n, r, o, s, a) {
                    if (n /= e,
                    o >= (i /= e) && s < n)
                        return t;
                    if (s < i || o >= n)
                        return null;
                    for (var l = [], c = 0; c < t.length; c++) {
                        var h = t[c]
                          , u = h.geometry
                          , d = h.type
                          , f = 0 === r ? h.minX : h.minY
                          , p = 0 === r ? h.maxX : h.maxY;
                        if (f >= i && p < n)
                            l.push(h);
                        else if (!(p < i || f >= n)) {
                            var m = [];
                            if ("Point" === d || "MultiPoint" === d)
                                Y(u, m, i, n, r);
                            else if ("LineString" === d)
                                K(u, m, i, n, r, !1, a.lineMetrics);
                            else if ("MultiLineString" === d)
                                Q(u, m, i, n, r, !1);
                            else if ("Polygon" === d)
                                Q(u, m, i, n, r, !0);
                            else if ("MultiPolygon" === d)
                                for (var g = 0; g < u.length; g++) {
                                    var _ = [];
                                    Q(u[g], _, i, n, r, !0),
                                    _.length && m.push(_)
                                }
                            if (m.length) {
                                if (a.lineMetrics && "LineString" === d) {
                                    for (g = 0; g < m.length; g++)
                                        l.push(U(h.id, d, m[g], h.tags));
                                    continue
                                }
                                "LineString" !== d && "MultiLineString" !== d || (1 === m.length ? (d = "LineString",
                                m = m[0]) : d = "MultiLineString"),
                                "Point" !== d && "MultiPoint" !== d || (d = 3 === m.length ? "Point" : "MultiPoint"),
                                l.push(U(h.id, d, m, h.tags))
                            }
                        }
                    }
                    return l.length ? l : null
                }
                function Y(t, e, i, n, r) {
                    for (var o = 0; o < t.length; o += 3) {
                        var s = t[o + r];
                        s >= i && s <= n && (e.push(t[o]),
                        e.push(t[o + 1]),
                        e.push(t[o + 2]))
                    }
                }
                function K(t, e, i, n, r, o, s) {
                    for (var a, l, c = J(t), h = 0 === r ? et : it, u = t.start, d = 0; d < t.length - 3; d += 3) {
                        var f = t[d]
                          , p = t[d + 1]
                          , m = t[d + 2]
                          , g = t[d + 3]
                          , _ = t[d + 4]
                          , y = 0 === r ? f : p
                          , v = 0 === r ? g : _
                          , x = !1;
                        s && (a = Math.sqrt(Math.pow(f - g, 2) + Math.pow(p - _, 2))),
                        y < i ? v > i && (l = h(c, f, p, g, _, i),
                        s && (c.start = u + a * l)) : y > n ? v < n && (l = h(c, f, p, g, _, n),
                        s && (c.start = u + a * l)) : tt(c, f, p, m),
                        v < i && y >= i && (l = h(c, f, p, g, _, i),
                        x = !0),
                        v > n && y <= n && (l = h(c, f, p, g, _, n),
                        x = !0),
                        !o && x && (s && (c.end = u + a * l),
                        e.push(c),
                        c = J(t)),
                        s && (u += a)
                    }
                    var b = t.length - 3;
                    f = t[b],
                    p = t[b + 1],
                    m = t[b + 2],
                    (y = 0 === r ? f : p) >= i && y <= n && tt(c, f, p, m),
                    b = c.length - 3,
                    o && b >= 3 && (c[b] !== c[0] || c[b + 1] !== c[1]) && tt(c, c[0], c[1], c[2]),
                    c.length && e.push(c)
                }
                function J(t) {
                    var e = [];
                    return e.size = t.size,
                    e.start = t.start,
                    e.end = t.end,
                    e
                }
                function Q(t, e, i, n, r, o) {
                    for (var s = 0; s < t.length; s++)
                        K(t[s], e, i, n, r, o, !1)
                }
                function tt(t, e, i, n) {
                    t.push(e),
                    t.push(i),
                    t.push(n)
                }
                function et(t, e, i, n, r, o) {
                    var s = (o - e) / (n - e);
                    return t.push(o),
                    t.push(i + (r - i) * s),
                    t.push(1),
                    s
                }
                function it(t, e, i, n, r, o) {
                    var s = (o - i) / (r - i);
                    return t.push(e + (n - e) * s),
                    t.push(o),
                    t.push(1),
                    s
                }
                function nt(t, e) {
                    for (var i = [], n = 0; n < t.length; n++) {
                        var r, o = t[n], s = o.type;
                        if ("Point" === s || "MultiPoint" === s || "LineString" === s)
                            r = rt(o.geometry, e);
                        else if ("MultiLineString" === s || "Polygon" === s) {
                            r = [];
                            for (var a = 0; a < o.geometry.length; a++)
                                r.push(rt(o.geometry[a], e))
                        } else if ("MultiPolygon" === s)
                            for (r = [],
                            a = 0; a < o.geometry.length; a++) {
                                for (var l = [], c = 0; c < o.geometry[a].length; c++)
                                    l.push(rt(o.geometry[a][c], e));
                                r.push(l)
                            }
                        i.push(U(o.id, s, r, o.tags))
                    }
                    return i
                }
                function rt(t, e) {
                    var i = [];
                    i.size = t.size,
                    void 0 !== t.start && (i.start = t.start,
                    i.end = t.end);
                    for (var n = 0; n < t.length; n += 3)
                        i.push(t[n] + e, t[n + 1], t[n + 2]);
                    return i
                }
                function ot(t, e) {
                    if (t.transformed)
                        return t;
                    var i, n, r, o = 1 << t.z, s = t.x, a = t.y;
                    for (i = 0; i < t.features.length; i++) {
                        var l = t.features[i]
                          , c = l.geometry
                          , h = l.type;
                        if (l.geometry = [],
                        1 === h)
                            for (n = 0; n < c.length; n += 2)
                                l.geometry.push(st(c[n], c[n + 1], e, o, s, a));
                        else
                            for (n = 0; n < c.length; n++) {
                                var u = [];
                                for (r = 0; r < c[n].length; r += 2)
                                    u.push(st(c[n][r], c[n][r + 1], e, o, s, a));
                                l.geometry.push(u)
                            }
                    }
                    return t.transformed = !0,
                    t
                }
                function st(t, e, i, n, r, o) {
                    return [Math.round(i * (t * n - r)), Math.round(i * (e * n - o))]
                }
                function at(t, e, i, n, r) {
                    for (var o = e === r.maxZoom ? 0 : r.tolerance / ((1 << e) * r.extent), s = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: 0,
                        source: null,
                        x: i,
                        y: n,
                        z: e,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    }, a = 0; a < t.length; a++) {
                        s.numFeatures++,
                        lt(s, t[a], o, r);
                        var l = t[a].minX
                          , c = t[a].minY
                          , h = t[a].maxX
                          , u = t[a].maxY;
                        l < s.minX && (s.minX = l),
                        c < s.minY && (s.minY = c),
                        h > s.maxX && (s.maxX = h),
                        u > s.maxY && (s.maxY = u)
                    }
                    return s
                }
                function lt(t, e, i, n) {
                    var r = e.geometry
                      , o = e.type
                      , s = [];
                    if ("Point" === o || "MultiPoint" === o)
                        for (var a = 0; a < r.length; a += 3)
                            s.push(r[a]),
                            s.push(r[a + 1]),
                            t.numPoints++,
                            t.numSimplified++;
                    else if ("LineString" === o)
                        ct(s, r, t, i, !1, !1);
                    else if ("MultiLineString" === o || "Polygon" === o)
                        for (a = 0; a < r.length; a++)
                            ct(s, r[a], t, i, "Polygon" === o, 0 === a);
                    else if ("MultiPolygon" === o)
                        for (var l = 0; l < r.length; l++) {
                            var c = r[l];
                            for (a = 0; a < c.length; a++)
                                ct(s, c[a], t, i, !0, 0 === a)
                        }
                    if (s.length) {
                        var h = e.tags || null;
                        if ("LineString" === o && n.lineMetrics) {
                            for (var u in h = {},
                            e.tags)
                                h[u] = e.tags[u];
                            h.mapbox_clip_start = r.start / r.size,
                            h.mapbox_clip_end = r.end / r.size
                        }
                        var d = {
                            geometry: s,
                            type: "Polygon" === o || "MultiPolygon" === o ? 3 : "LineString" === o || "MultiLineString" === o ? 2 : 1,
                            tags: h
                        };
                        null !== e.id && (d.id = e.id),
                        t.features.push(d)
                    }
                }
                function ct(t, e, i, n, r, o) {
                    var s = n * n;
                    if (n > 0 && e.size < (r ? s : n))
                        i.numPoints += e.length / 3;
                    else {
                        for (var a = [], l = 0; l < e.length; l += 3)
                            (0 === n || e[l + 2] > s) && (i.numSimplified++,
                            a.push(e[l]),
                            a.push(e[l + 1])),
                            i.numPoints++;
                        r && function(t, e) {
                            for (var i = 0, n = 0, r = t.length, o = r - 2; n < r; o = n,
                            n += 2)
                                i += (t[n] - t[o]) * (t[n + 1] + t[o + 1]);
                            if (i > 0 === e)
                                for (n = 0,
                                r = t.length; n < r / 2; n += 2) {
                                    var s = t[n]
                                      , a = t[n + 1];
                                    t[n] = t[r - 2 - n],
                                    t[n + 1] = t[r - 1 - n],
                                    t[r - 2 - n] = s,
                                    t[r - 1 - n] = a
                                }
                        }(a, o),
                        t.push(a)
                    }
                }
                function ht(t, e) {
                    var i = (e = this.options = function(t, e) {
                        for (var i in e)
                            t[i] = e[i];
                        return t
                    }(Object.create(this.options), e)).debug;
                    if (i && n.time("preprocess data"),
                    e.maxZoom < 0 || e.maxZoom > 24)
                        throw new Error("maxZoom should be in the 0-24 range");
                    if (e.promoteId && e.generateId)
                        throw new Error("promoteId and generateId cannot be used together.");
                    var r = function(t, e) {
                        var i = [];
                        if ("FeatureCollection" === t.type)
                            for (var n = 0; n < t.features.length; n++)
                                G(i, t.features[n], e, n);
                        else
                            G(i, "Feature" === t.type ? t : {
                                geometry: t
                            }, e);
                        return i
                    }(t, e);
                    this.tiles = {},
                    this.tileCoords = [],
                    i && (n.timeEnd("preprocess data"),
                    e.indexMaxZoom,
                    e.indexMaxPoints,
                    n.time("generate tiles"),
                    this.stats = {},
                    this.total = 0),
                    r = function(t, e) {
                        var i = e.buffer / e.extent
                          , n = t
                          , r = X(t, 1, -1 - i, i, 0, -1, 2, e)
                          , o = X(t, 1, 1 - i, 2 + i, 0, -1, 2, e);
                        return (r || o) && (n = X(t, 1, -i, 1 + i, 0, -1, 2, e) || [],
                        r && (n = nt(r, 1).concat(n)),
                        o && (n = n.concat(nt(o, -1)))),
                        n
                    }(r, e),
                    r.length && this.splitTile(r, 0, 0, 0),
                    i && (r.length && (this.tiles[0].numFeatures,
                    this.tiles[0].numPoints),
                    n.timeEnd("generate tiles"),
                    this.total,
                    JSON.stringify(this.stats))
                }
                function ut(t, e, i) {
                    return 32 * ((1 << t) * i + e) + t
                }
                function dt(e, i) {
                    const n = e.tileID.canonical;
                    if (!this._geoJSONIndex)
                        return i(null, null);
                    const r = this._geoJSONIndex.getTile(n.z, n.x, n.y);
                    if (!r)
                        return i(null, null);
                    const o = new class {
                        constructor(e) {
                            this.layers = {
                                _geojsonTileLayer: this
                            },
                            this.name = "_geojsonTileLayer",
                            this.extent = t.EXTENT,
                            this.length = e.length,
                            this._features = e
                        }
                        feature(e) {
                            return new class {
                                constructor(e) {
                                    this._feature = e,
                                    this.extent = t.EXTENT,
                                    this.type = e.type,
                                    this.properties = e.tags,
                                    "id"in e && !isNaN(e.id) && (this.id = parseInt(e.id, 10))
                                }
                                loadGeometry() {
                                    if (1 === this._feature.type) {
                                        const e = [];
                                        for (const i of this._feature.geometry)
                                            e.push([new t.Point(i[0],i[1])]);
                                        return e
                                    }
                                    {
                                        const e = [];
                                        for (const i of this._feature.geometry) {
                                            const n = [];
                                            for (const e of i)
                                                n.push(new t.Point(e[0],e[1]));
                                            e.push(n)
                                        }
                                        return e
                                    }
                                }
                                toGeoJSON(t, e, i) {
                                    return c.call(this, t, e, i)
                                }
                            }
                            (this._features[e])
                        }
                    }
                    (r.features);
                    let s = C(o);
                    0 === s.byteOffset && s.byteLength === s.buffer.byteLength || (s = new Uint8Array(s)),
                    i(null, {
                        vectorTile: o,
                        rawData: s.buffer
                    })
                }
                ht.prototype.options = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                },
                ht.prototype.splitTile = function(t, e, i, r, o, s, a) {
                    for (var l = [t, e, i, r], c = this.options, h = c.debug; l.length; ) {
                        r = l.pop(),
                        i = l.pop(),
                        e = l.pop(),
                        t = l.pop();
                        var u = 1 << e
                          , d = ut(e, i, r)
                          , f = this.tiles[d];
                        if (!f && (h > 1 && n.time("creation"),
                        f = this.tiles[d] = at(t, e, i, r, c),
                        this.tileCoords.push({
                            z: e,
                            x: i,
                            y: r
                        }),
                        h)) {
                            h > 1 && (f.numFeatures,
                            f.numPoints,
                            f.numSimplified,
                            n.timeEnd("creation"));
                            var p = "z" + e;
                            this.stats[p] = (this.stats[p] || 0) + 1,
                            this.total++
                        }
                        if (f.source = t,
                        o) {
                            if (e === c.maxZoom || e === o)
                                continue;
                            var m = 1 << o - e;
                            if (i !== Math.floor(s / m) || r !== Math.floor(a / m))
                                continue
                        } else if (e === c.indexMaxZoom || f.numPoints <= c.indexMaxPoints)
                            continue;
                        if (f.source = null,
                        0 !== t.length) {
                            h > 1 && n.time("clipping");
                            var g, _, y, v, x, b, w = .5 * c.buffer / c.extent, E = .5 - w, T = .5 + w, S = 1 + w;
                            g = _ = y = v = null,
                            x = X(t, u, i - w, i + T, 0, f.minX, f.maxX, c),
                            b = X(t, u, i + E, i + S, 0, f.minX, f.maxX, c),
                            t = null,
                            x && (g = X(x, u, r - w, r + T, 1, f.minY, f.maxY, c),
                            _ = X(x, u, r + E, r + S, 1, f.minY, f.maxY, c),
                            x = null),
                            b && (y = X(b, u, r - w, r + T, 1, f.minY, f.maxY, c),
                            v = X(b, u, r + E, r + S, 1, f.minY, f.maxY, c),
                            b = null),
                            h > 1 && n.timeEnd("clipping"),
                            l.push(g || [], e + 1, 2 * i, 2 * r),
                            l.push(_ || [], e + 1, 2 * i, 2 * r + 1),
                            l.push(y || [], e + 1, 2 * i + 1, 2 * r),
                            l.push(v || [], e + 1, 2 * i + 1, 2 * r + 1)
                        }
                    }
                }
                ,
                ht.prototype.getTile = function(t, e, i) {
                    var r = this.options
                      , o = r.extent
                      , s = r.debug;
                    if (t < 0 || t > 24)
                        return null;
                    var a = 1 << t
                      , l = ut(t, e = (e % a + a) % a, i);
                    if (this.tiles[l])
                        return ot(this.tiles[l], o);
                    for (var c, h = t, u = e, d = i; !c && h > 0; )
                        h--,
                        u = Math.floor(u / 2),
                        d = Math.floor(d / 2),
                        c = this.tiles[ut(h, u, d)];
                    return c && c.source ? (s > 1 && n.time("drilling down"),
                    this.splitTile(c.source, h, u, d, t, e, i),
                    s > 1 && n.timeEnd("drilling down"),
                    this.tiles[l] ? ot(this.tiles[l], o) : null) : null
                }
                ;
                class ft extends t.VectorTileWorkerSource {
                    constructor(t, e, i, n, r) {
                        super(t, e, i, n, dt),
                        r && (this.loadGeoJSON = r)
                    }
                    loadData(e, i) {
                        const n = e && e.request
                          , r = n && n.collectResourceTiming;
                        this.loadGeoJSON(e, ( (o, s) => {
                            if (o || !s)
                                return i(o);
                            if ("object" != typeof s)
                                return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));
                            {
                                l(s, !0);
                                try {
                                    if (e.filter) {
                                        const i = t.createExpression(e.filter, {
                                            type: "boolean",
                                            "property-type": "data-driven",
                                            overridable: !1,
                                            transition: !1
                                        });
                                        if ("error" === i.result)
                                            throw new Error(i.value.map((t => `${t.key}: ${t.message}`)).join(", "));
                                        const n = s.features.filter((t => i.value.evaluate({
                                            zoom: 0
                                        }, t)));
                                        s = {
                                            type: "FeatureCollection",
                                            features: n
                                        }
                                    }
                                    this._geoJSONIndex = e.cluster ? new R(function({superclusterOptions: e, clusterProperties: i}) {
                                        if (!i || !e)
                                            return e;
                                        const n = {}
                                          , r = {}
                                          , o = {
                                            accumulated: null,
                                            zoom: 0
                                        }
                                          , s = {
                                            properties: null
                                        }
                                          , a = Object.keys(i);
                                        for (const e of a) {
                                            const [o,s] = i[e]
                                              , a = t.createExpression(s)
                                              , l = t.createExpression("string" == typeof o ? [o, ["accumulated"], ["get", e]] : o);
                                            n[e] = a.value,
                                            r[e] = l.value
                                        }
                                        return e.map = t => {
                                            s.properties = t;
                                            const e = {};
                                            for (const t of a)
                                                e[t] = n[t].evaluate(o, s);
                                            return e
                                        }
                                        ,
                                        e.reduce = (t, e) => {
                                            s.properties = e;
                                            for (const e of a)
                                                o.accumulated = t[e],
                                                t[e] = r[e].evaluate(o, s)
                                        }
                                        ,
                                        e
                                    }(e)).load(s.features) : function(t, e) {
                                        return new ht(t,e)
                                    }(s, e.geojsonVtOptions)
                                } catch (o) {
                                    return i(o)
                                }
                                this.loaded = {};
                                const a = {};
                                if (r) {
                                    const i = t.getPerformanceMeasurement(n);
                                    i && (a.resourceTiming = {},
                                    a.resourceTiming[e.source] = JSON.parse(JSON.stringify(i)))
                                }
                                i(null, a)
                            }
                        }
                        ))
                    }
                    reloadTile(t, e) {
                        const i = this.loaded;
                        return i && i[t.uid] ? super.reloadTile(t, e) : this.loadTile(t, e)
                    }
                    loadGeoJSON(e, i) {
                        if (e.request)
                            t.getJSON(e.request, i);
                        else {
                            if ("string" != typeof e.data)
                                return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`));
                            try {
                                return i(null, JSON.parse(e.data))
                            } catch (t) {
                                return i(new Error(`Input data given to '${e.source}' is not a valid GeoJSON object.`))
                            }
                        }
                    }
                    getClusterExpansionZoom(t, e) {
                        try {
                            e(null, this._geoJSONIndex.getClusterExpansionZoom(t.clusterId))
                        } catch (t) {
                            e(t)
                        }
                    }
                    getClusterChildren(t, e) {
                        try {
                            e(null, this._geoJSONIndex.getChildren(t.clusterId))
                        } catch (t) {
                            e(t)
                        }
                    }
                    getClusterLeaves(t, e) {
                        try {
                            e(null, this._geoJSONIndex.getLeaves(t.clusterId, t.limit, t.offset))
                        } catch (t) {
                            e(t)
                        }
                    }
                }
                class pt {
                    constructor(e) {
                        this.self = e,
                        this.actor = new t.Actor(e,this),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.isSpriteLoaded = {},
                        this.projections = {},
                        this.defaultProjection = t.getProjection({
                            name: "mercator"
                        }),
                        this.workerSourceTypes = {
                            vector: t.VectorTileWorkerSource,
                            geojson: ft
                        },
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.self.registerWorkerSource = (t, e) => {
                            if (this.workerSourceTypes[t])
                                throw new Error(`Worker source with name "${t}" already registered.`);
                            this.workerSourceTypes[t] = e
                        }
                        ,
                        this.self.registerRTLTextPlugin = e => {
                            if (t.plugin.isParsed())
                                throw new Error("RTL text plugin already registered.");
                            t.plugin.applyArabicShaping = e.applyArabicShaping,
                            t.plugin.processBidirectionalText = e.processBidirectionalText,
                            t.plugin.processStyledBidirectionalText = e.processStyledBidirectionalText
                        }
                    }
                    clearCaches(t, e, i) {
                        delete this.layerIndexes[t],
                        delete this.availableImages[t],
                        delete this.workerSources[t],
                        delete this.demWorkerSources[t],
                        i()
                    }
                    checkIfReady(t, e, i) {
                        i()
                    }
                    setReferrer(t, e) {
                        this.referrer = e
                    }
                    spriteLoaded(e, i) {
                        this.isSpriteLoaded[e] = i;
                        for (const n in this.workerSources[e]) {
                            const r = this.workerSources[e][n];
                            for (const e in r)
                                r[e]instanceof t.VectorTileWorkerSource && (r[e].isSpriteLoaded = i,
                                r[e].fire(new t.Event("isSpriteLoaded")))
                        }
                    }
                    setImages(t, e, i) {
                        this.availableImages[t] = e;
                        for (const i in this.workerSources[t]) {
                            const n = this.workerSources[t][i];
                            for (const t in n)
                                n[t].availableImages = e
                        }
                        i()
                    }
                    enableTerrain(t, e, i) {
                        this.terrain = e,
                        i()
                    }
                    setProjection(e, i) {
                        this.projections[e] = t.getProjection(i)
                    }
                    setLayers(t, e, i) {
                        this.getLayerIndex(t).replace(e),
                        i()
                    }
                    updateLayers(t, e, i) {
                        this.getLayerIndex(t).update(e.layers, e.removedIds),
                        i()
                    }
                    loadTile(e, i, n) {
                        const r = this.enableTerrain ? t.extend({
                            enableTerrain: this.terrain
                        }, i) : i;
                        r.projection = this.projections[e] || this.defaultProjection,
                        this.getWorkerSource(e, i.type, i.source).loadTile(r, n)
                    }
                    loadDEMTile(e, i, n) {
                        const r = this.enableTerrain ? t.extend({
                            buildQuadTree: this.terrain
                        }, i) : i;
                        this.getDEMWorkerSource(e, i.source).loadTile(r, n)
                    }
                    reloadTile(e, i, n) {
                        const r = this.enableTerrain ? t.extend({
                            enableTerrain: this.terrain
                        }, i) : i;
                        r.projection = this.projections[e] || this.defaultProjection,
                        this.getWorkerSource(e, i.type, i.source).reloadTile(r, n)
                    }
                    abortTile(t, e, i) {
                        this.getWorkerSource(t, e.type, e.source).abortTile(e, i)
                    }
                    removeTile(t, e, i) {
                        this.getWorkerSource(t, e.type, e.source).removeTile(e, i)
                    }
                    removeSource(t, e, i) {
                        if (!this.workerSources[t] || !this.workerSources[t][e.type] || !this.workerSources[t][e.type][e.source])
                            return;
                        const n = this.workerSources[t][e.type][e.source];
                        delete this.workerSources[t][e.type][e.source],
                        void 0 !== n.removeSource ? n.removeSource(e, i) : i()
                    }
                    loadWorkerSource(t, e, i) {
                        try {
                            this.self.importScripts(e.url),
                            i()
                        } catch (t) {
                            i(t.toString())
                        }
                    }
                    syncRTLPluginState(e, i, n) {
                        try {
                            t.plugin.setState(i);
                            const e = t.plugin.getPluginURL();
                            if (t.plugin.isLoaded() && !t.plugin.isParsed() && null != e) {
                                this.self.importScripts(e);
                                const i = t.plugin.isParsed();
                                n(i ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${e}`), i)
                            }
                        } catch (t) {
                            n(t.toString())
                        }
                    }
                    getAvailableImages(t) {
                        let e = this.availableImages[t];
                        return e || (e = []),
                        e
                    }
                    getLayerIndex(t) {
                        let e = this.layerIndexes[t];
                        return e || (e = this.layerIndexes[t] = new r),
                        e
                    }
                    getWorkerSource(t, e, i) {
                        if (this.workerSources[t] || (this.workerSources[t] = {}),
                        this.workerSources[t][e] || (this.workerSources[t][e] = {}),
                        !this.workerSources[t][e][i]) {
                            const n = {
                                send: (e, i, n, r, o, s) => {
                                    this.actor.send(e, i, n, t, o, s)
                                }
                                ,
                                scheduler: this.actor.scheduler
                            };
                            this.workerSources[t][e][i] = new this.workerSourceTypes[e](n,this.getLayerIndex(t),this.getAvailableImages(t),this.isSpriteLoaded[t])
                        }
                        return this.workerSources[t][e][i]
                    }
                    getDEMWorkerSource(t, e) {
                        return this.demWorkerSources[t] || (this.demWorkerSources[t] = {}),
                        this.demWorkerSources[t][e] || (this.demWorkerSources[t][e] = new o),
                        this.demWorkerSources[t][e]
                    }
                    enforceCacheSizeLimit(e, i) {
                        t.enforceCacheSizeLimit(i)
                    }
                    getWorkerPerformanceMetrics(t, e, i) {
                        i(void 0, void 0)
                    }
                }
                return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new pt(self)),
                pt
            }
            )),
            r(["./shared"], (function(t) {
                function e(t, i) {
                    if (Array.isArray(t)) {
                        if (!Array.isArray(i) || t.length !== i.length)
                            return !1;
                        for (let n = 0; n < t.length; n++)
                            if (!e(t[n], i[n]))
                                return !1;
                        return !0
                    }
                    if ("object" == typeof t && null !== t && null !== i) {
                        if ("object" != typeof i)
                            return !1;
                        if (Object.keys(t).length !== Object.keys(i).length)
                            return !1;
                        for (const n in t)
                            if (!e(t[n], i[n]))
                                return !1;
                        return !0
                    }
                    return t === i
                }
                var i = r;
                function r(t) {
                    return !function(t) {
                        return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON"in window && "parse"in JSON && "stringify"in JSON ? function() {
                            if (!("Worker"in window && "Blob"in window && "URL"in window))
                                return !1;
                            var t, e, i = new Blob([""],{
                                type: "text/javascript"
                            }), n = URL.createObjectURL(i);
                            try {
                                e = new Worker(n),
                                t = !0
                            } catch (e) {
                                t = !1
                            }
                            return e && e.terminate(),
                            URL.revokeObjectURL(n),
                            t
                        }() ? "Uint8ClampedArray"in window ? ArrayBuffer.isView ? function() {
                            var t = document.createElement("canvas");
                            t.width = t.height = 1;
                            var e = t.getContext("2d");
                            if (!e)
                                return !1;
                            var i = e.getImageData(0, 0, 1, 1);
                            return i && i.width === t.width
                        }() ? (void 0 === o[e = t && t.failIfMajorPerformanceCaveat] && (o[e] = function(t) {
                            var e, i = function(t) {
                                var e = document.createElement("canvas")
                                  , i = Object.create(r.webGLContextAttributes);
                                return i.failIfMajorPerformanceCaveat = t,
                                e.getContext("webgl", i) || e.getContext("experimental-webgl", i)
                            }(t);
                            if (!i)
                                return !1;
                            try {
                                e = i.createShader(i.VERTEX_SHADER)
                            } catch (t) {
                                return !1
                            }
                            return !(!e || i.isContextLost()) && (i.shaderSource(e, "void main() {}"),
                            i.compileShader(e),
                            !0 === i.getShaderParameter(e, i.COMPILE_STATUS))
                        }(e)),
                        o[e] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
                        var e
                    }(t)
                }
                var o = {};
                function s(e, i, n) {
                    const r = t.window.document.createElement(e);
                    return void 0 !== i && (r.className = i),
                    n && n.appendChild(r),
                    r
                }
                function a(e, i, n) {
                    const r = t.window.document.createElementNS("http://www.w3.org/2000/svg", e);
                    for (const t of Object.keys(i))
                        r.setAttributeNS(null, t, i[t]);
                    return n && n.appendChild(r),
                    r
                }
                r.webGLContextAttributes = {
                    antialias: !1,
                    alpha: !0,
                    stencil: !0,
                    depth: !0
                };
                const l = t.window.document && t.window.document.documentElement.style
                  , c = l && void 0 !== l.userSelect ? "userSelect" : "WebkitUserSelect";
                let h;
                function u() {
                    l && c && (h = l[c],
                    l[c] = "none")
                }
                function d() {
                    l && c && (l[c] = h)
                }
                function f(e) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    t.window.removeEventListener("click", f, !0)
                }
                function p() {
                    t.window.addEventListener("click", f, !0),
                    t.window.setTimeout(( () => {
                        t.window.removeEventListener("click", f, !0)
                    }
                    ), 0)
                }
                function m(t, e) {
                    const i = t.getBoundingClientRect();
                    return y(t, i, e)
                }
                function g(t, e) {
                    const i = t.getBoundingClientRect()
                      , n = [];
                    for (let r = 0; r < e.length; r++)
                        n.push(y(t, i, e[r]));
                    return n
                }
                function _(e) {
                    return void 0 !== t.window.InstallTrigger && 2 === e.button && e.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e.button
                }
                function y(e, i, n) {
                    const r = e.offsetWidth === i.width ? 1 : e.offsetWidth / i.width;
                    return new t.Point((n.clientX - i.left) * r,(n.clientY - i.top) * r)
                }
                function v(t, e) {
                    var i = e[0]
                      , n = e[1]
                      , r = e[2]
                      , o = e[3]
                      , s = i * o - r * n;
                    return s ? (t[0] = o * (s = 1 / s),
                    t[1] = -n * s,
                    t[2] = -r * s,
                    t[3] = i * s,
                    t) : null
                }
                function x(t) {
                    const {userImage: e} = t;
                    return !!(e && e.render && e.render()) && (t.data.replace(new Uint8Array(e.data.buffer)),
                    !0)
                }
                class b extends t.Evented {
                    constructor() {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = !1,
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = new t.RGBAImage({
                            width: 1,
                            height: 1
                        }),
                        this.dirty = !0
                    }
                    isLoaded() {
                        return this.loaded
                    }
                    setLoaded(t) {
                        if (this.loaded !== t && (this.loaded = t,
                        t)) {
                            for (const {ids: t, callback: e} of this.requestors)
                                this._notify(t, e);
                            this.requestors = []
                        }
                    }
                    hasImage(t) {
                        return !!this.getImage(t)
                    }
                    getImage(t) {
                        return this.images[t]
                    }
                    addImage(t, e) {
                        this._validate(t, e) && (this.images[t] = e)
                    }
                    _validate(e, i) {
                        let n = !0;
                        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchX" value`))),
                        n = !1),
                        this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "stretchY" value`))),
                        n = !1),
                        this._validateContent(i.content, i) || (this.fire(new t.ErrorEvent(new Error(`Image "${e}" has invalid "content" value`))),
                        n = !1),
                        n
                    }
                    _validateStretch(t, e) {
                        if (!t)
                            return !0;
                        let i = 0;
                        for (const n of t) {
                            if (n[0] < i || n[1] < n[0] || e < n[1])
                                return !1;
                            i = n[1]
                        }
                        return !0
                    }
                    _validateContent(t, e) {
                        return !(t && (4 !== t.length || t[0] < 0 || e.data.width < t[0] || t[1] < 0 || e.data.height < t[1] || t[2] < 0 || e.data.width < t[2] || t[3] < 0 || e.data.height < t[3] || t[2] < t[0] || t[3] < t[1]))
                    }
                    updateImage(t, e) {
                        e.version = this.images[t].version + 1,
                        this.images[t] = e,
                        this.updatedImages[t] = !0
                    }
                    removeImage(t) {
                        const e = this.images[t];
                        delete this.images[t],
                        delete this.patterns[t],
                        e.userImage && e.userImage.onRemove && e.userImage.onRemove()
                    }
                    listImages() {
                        return Object.keys(this.images)
                    }
                    getImages(t, e) {
                        let i = !0;
                        if (!this.isLoaded())
                            for (const e of t)
                                this.images[e] || (i = !1);
                        this.isLoaded() || i ? this._notify(t, e) : this.requestors.push({
                            ids: t,
                            callback: e
                        })
                    }
                    _notify(e, i) {
                        const n = {};
                        for (const i of e) {
                            this.images[i] || this.fire(new t.Event("styleimagemissing",{
                                id: i
                            }));
                            const e = this.images[i];
                            e ? n[i] = {
                                data: e.data.clone(),
                                pixelRatio: e.pixelRatio,
                                sdf: e.sdf,
                                version: e.version,
                                stretchX: e.stretchX,
                                stretchY: e.stretchY,
                                content: e.content,
                                hasRenderCallback: Boolean(e.userImage && e.userImage.render)
                            } : t.warnOnce(`Image "${i}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                        }
                        i(null, n)
                    }
                    getPixelSize() {
                        const {width: t, height: e} = this.atlasImage;
                        return {
                            width: t,
                            height: e
                        }
                    }
                    getPattern(e) {
                        const i = this.patterns[e]
                          , n = this.getImage(e);
                        if (!n)
                            return null;
                        if (i && i.position.version === n.version)
                            return i.position;
                        if (i)
                            i.position.version = n.version;
                        else {
                            const i = {
                                w: n.data.width + 2,
                                h: n.data.height + 2,
                                x: 0,
                                y: 0
                            }
                              , r = new t.ImagePosition(i,n);
                            this.patterns[e] = {
                                bin: i,
                                position: r
                            }
                        }
                        return this._updatePatternAtlas(),
                        this.patterns[e].position
                    }
                    bind(e) {
                        const i = e.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                        this.dirty = !1) : this.atlasTexture = new t.Texture(e,this.atlasImage,i.RGBA),
                        this.atlasTexture && this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas() {
                        const e = [];
                        for (const t in this.patterns)
                            e.push(this.patterns[t].bin);
                        const {w: i, h: n} = t.potpack(e)
                          , r = this.atlasImage;
                        r.resize({
                            width: i || 1,
                            height: n || 1
                        });
                        for (const e in this.patterns) {
                            const {bin: i} = this.patterns[e]
                              , n = i.x + 1
                              , o = i.y + 1
                              , s = this.images[e].data
                              , a = s.width
                              , l = s.height;
                            t.RGBAImage.copy(s, r, {
                                x: 0,
                                y: 0
                            }, {
                                x: n,
                                y: o
                            }, {
                                width: a,
                                height: l
                            }),
                            t.RGBAImage.copy(s, r, {
                                x: 0,
                                y: l - 1
                            }, {
                                x: n,
                                y: o - 1
                            }, {
                                width: a,
                                height: 1
                            }),
                            t.RGBAImage.copy(s, r, {
                                x: 0,
                                y: 0
                            }, {
                                x: n,
                                y: o + l
                            }, {
                                width: a,
                                height: 1
                            }),
                            t.RGBAImage.copy(s, r, {
                                x: a - 1,
                                y: 0
                            }, {
                                x: n - 1,
                                y: o
                            }, {
                                width: 1,
                                height: l
                            }),
                            t.RGBAImage.copy(s, r, {
                                x: 0,
                                y: 0
                            }, {
                                x: n + a,
                                y: o
                            }, {
                                width: 1,
                                height: l
                            })
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {}
                    }
                    dispatchRenderCallbacks(t) {
                        for (const e of t) {
                            if (this.callbackDispatchedThisFrame[e])
                                continue;
                            this.callbackDispatchedThisFrame[e] = !0;
                            const t = this.images[e];
                            x(t) && this.updateImage(e, t)
                        }
                    }
                }
                const w = new t.Properties({
                    anchor: new t.DataConstantProperty(t.spec.light.anchor),
                    position: new class {
                        constructor() {
                            this.specification = t.spec.light.position
                        }
                        possiblyEvaluate(e, i) {
                            return function([e,i,n]) {
                                const r = t.degToRad(i + 90)
                                  , o = t.degToRad(n);
                                return {
                                    x: e * Math.cos(r) * Math.sin(o),
                                    y: e * Math.sin(r) * Math.sin(o),
                                    z: e * Math.cos(o),
                                    azimuthal: i,
                                    polar: n
                                }
                            }(e.expression.evaluate(i))
                        }
                        interpolate(e, i, n) {
                            return {
                                x: t.number(e.x, i.x, n),
                                y: t.number(e.y, i.y, n),
                                z: t.number(e.z, i.z, n),
                                azimuthal: t.number(e.azimuthal, i.azimuthal, n),
                                polar: t.number(e.polar, i.polar, n)
                            }
                        }
                    }
                    ,
                    color: new t.DataConstantProperty(t.spec.light.color),
                    intensity: new t.DataConstantProperty(t.spec.light.intensity)
                });
                class E extends t.Evented {
                    constructor(e) {
                        super(),
                        this._transitionable = new t.Transitionable(w),
                        this.setLight(e),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(e, i={}) {
                        if (!this._validate(t.validateLight, e, i))
                            for (const i in e) {
                                const n = e[i];
                                t.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), n) : this._transitionable.setValue(i, n)
                            }
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                    _validate(e, i, n) {
                        return (!n || !1 !== n.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: t.spec
                        })))
                    }
                }
                const T = new t.Properties({
                    source: new t.DataConstantProperty(t.spec.terrain.source),
                    exaggeration: new t.DataConstantProperty(t.spec.terrain.exaggeration)
                });
                let S = class extends t.Evented {
                    constructor(e, i) {
                        super(),
                        this._transitionable = new t.Transitionable(T),
                        this.set(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.drapeRenderMode = i
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(e) {
                        for (const i in e) {
                            const n = e[i];
                            t.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), n) : this._transitionable.setValue(i, n)
                        }
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                }
                ;
                function C(e, i, n, r) {
                    const o = t.smoothstep(45, 65, n)
                      , [s,a] = A(e, r)
                      , l = t.length(i);
                    let c = 1 - Math.min(1, Math.exp((l - s) / (a - s) * -6));
                    return c *= c * c,
                    c = Math.min(1, 1.00747 * c),
                    c * o * e.alpha
                }
                function A(t, e) {
                    const i = .5 / Math.tan(.5 * e);
                    return [t.range[0] + i, t.range[1] + i]
                }
                const I = new t.Properties({
                    range: new t.DataConstantProperty(t.spec.fog.range),
                    color: new t.DataConstantProperty(t.spec.fog.color),
                    "high-color": new t.DataConstantProperty(t.spec.fog["high-color"]),
                    "space-color": new t.DataConstantProperty(t.spec.fog["space-color"]),
                    "horizon-blend": new t.DataConstantProperty(t.spec.fog["horizon-blend"]),
                    "star-intensity": new t.DataConstantProperty(t.spec.fog["star-intensity"])
                });
                class M extends t.Evented {
                    constructor(e, i) {
                        super(),
                        this._transitionable = new t.Transitionable(I),
                        this.set(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this._transform = i
                    }
                    get state() {
                        const e = this._transform
                          , i = "globe" === e.projection.name
                          , n = t.globeToMercatorTransition(e.zoom)
                          , r = this.properties.get("range")
                          , o = [.5, 3];
                        return {
                            range: i ? [t.number(o[0], r[0], n), t.number(o[1], r[1], n)] : r,
                            horizonBlend: this.properties.get("horizon-blend"),
                            alpha: this.properties.get("color").a
                        }
                    }
                    get() {
                        return this._transitionable.serialize()
                    }
                    set(e, i={}) {
                        if (!this._validate(t.validateFog, e, i)) {
                            for (const i of Object.keys(t.spec.fog))
                                e && void 0 === e[i] && (e[i] = t.spec.fog[i].default);
                            for (const i in e) {
                                const n = e[i];
                                t.endsWith(i, "-transition") ? this._transitionable.setTransition(i.slice(0, -11), n) : this._transitionable.setValue(i, n)
                            }
                        }
                    }
                    getOpacity(e) {
                        if (!this._transform.projection.supportsFog)
                            return 0;
                        const i = this.properties && this.properties.get("color") || 1;
                        return ("globe" === this._transform.projection.name ? 1 : t.smoothstep(45, 65, e)) * i.a
                    }
                    getOpacityAtLatLng(e, i) {
                        return this._transform.projection.supportsFog ? function(e, i, n) {
                            const r = t.MercatorCoordinate.fromLngLat(i)
                              , o = n.elevation ? n.elevation.getAtPointOrZero(r) : 0
                              , s = [r.x, r.y, o];
                            return t.transformMat4(s, s, n.mercatorFogMatrix),
                            C(e, s, n.pitch, n._fov)
                        }(this.state, e, i) : 0
                    }
                    getFovAdjustedRange(t) {
                        return this._transform.projection.supportsFog ? A(this.state, t) : [0, 1]
                    }
                    updateTransitions(t) {
                        this._transitioning = this._transitionable.transitioned(t, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(t) {
                        this.properties = this._transitioning.possiblyEvaluate(t)
                    }
                    _validate(e, i, n) {
                        return (!n || !1 !== n.validate) && t.emitValidationErrors(this, e.call(t.validateStyle, t.extend({
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: t.spec
                        })))
                    }
                }
                class P {
                    constructor(e, i) {
                        this.workerPool = e,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = t.uniqueId();
                        const n = this.workerPool.acquire(this.id);
                        for (let t = 0; t < n.length; t++) {
                            const e = new P.Actor(n[t],i,this.id);
                            e.name = `Worker ${t}`,
                            this.actors.push(e)
                        }
                        this.ready = !1,
                        this.broadcast("checkIfReady", null, ( () => {
                            this.ready = !0
                        }
                        ))
                    }
                    broadcast(e, i, n) {
                        t.asyncAll(this.actors, ( (t, n) => {
                            t.send(e, i, n)
                        }
                        ), n = n || function() {}
                        )
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove() {
                        this.actors.forEach((t => {
                            t.remove()
                        }
                        )),
                        this.actors = [],
                        this.workerPool.release(this.id)
                    }
                }
                function k(e, i, n) {
                    return i * (t.EXTENT / (e.tileSize * Math.pow(2, n - e.tileID.overscaledZ)))
                }
                P.Actor = t.Actor;
                class O {
                    constructor(t, e, i, n) {
                        this.screenBounds = t,
                        this.cameraPoint = e,
                        this._screenRaycastCache = {},
                        this._cameraRaycastCache = {},
                        this.isAboveHorizon = i,
                        this.screenGeometry = this.bufferedScreenGeometry(0),
                        this.screenGeometryMercator = this._bufferedScreenMercator(0, n)
                    }
                    static createFromScreenPoints(e, i) {
                        let n, r;
                        if (e instanceof t.Point || "number" == typeof e[0]) {
                            const o = t.Point.convert(e);
                            n = [o],
                            r = i.isPointAboveHorizon(o)
                        } else {
                            const o = t.Point.convert(e[0])
                              , s = t.Point.convert(e[1]);
                            n = [o, s],
                            r = t.polygonizeBounds(o, s).every((t => i.isPointAboveHorizon(t)))
                        }
                        return new O(n,i.getCameraPoint(),r,i)
                    }
                    isPointQuery() {
                        return 1 === this.screenBounds.length
                    }
                    bufferedScreenGeometry(e) {
                        return t.polygonizeBounds(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], e)
                    }
                    bufferedCameraGeometry(e) {
                        const i = this.screenBounds[0]
                          , n = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.Point(1,1)) : this.screenBounds[1]
                          , r = t.polygonizeBounds(i, n, 0, !1);
                        return this.cameraPoint.y > n.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < n.x ? r.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= n.x ? r[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (r[3] = this.cameraPoint)),
                        t.bufferConvexPolygon(r, e)
                    }
                    bufferedCameraGeometryGlobe(e) {
                        const i = this.screenBounds[0]
                          , n = 1 === this.screenBounds.length ? this.screenBounds[0].add(new t.Point(1,1)) : this.screenBounds[1]
                          , r = t.polygonizeBounds(i, n, e)
                          , o = this.cameraPoint.clone();
                        switch (3 * ((o.y > i.y) + (o.y > n.y)) + ((o.x > i.x) + (o.x > n.x))) {
                        case 0:
                            r[0] = o,
                            r[4] = o.clone();
                            break;
                        case 1:
                            r.splice(1, 0, o);
                            break;
                        case 2:
                            r[1] = o;
                            break;
                        case 3:
                            r.splice(4, 0, o);
                            break;
                        case 5:
                            r.splice(2, 0, o);
                            break;
                        case 6:
                            r[3] = o;
                            break;
                        case 7:
                            r.splice(3, 0, o);
                            break;
                        case 8:
                            r[2] = o
                        }
                        return r
                    }
                    containsTile(e, i, n, r=0) {
                        const o = e.queryPadding / i._pixelsPerMercatorPixel + 1
                          , s = n ? this._bufferedCameraMercator(o, i) : this._bufferedScreenMercator(o, i);
                        let a = e.tileID.wrap + (s.unwrapped ? r : 0);
                        const l = s.polygon.map((i => t.getTilePoint(e.tileTransform, i, a)));
                        if (!t.polygonIntersectsBox(l, 0, 0, t.EXTENT, t.EXTENT))
                            return;
                        a = e.tileID.wrap + (this.screenGeometryMercator.unwrapped ? r : 0);
                        const c = this.screenGeometryMercator.polygon.map((i => t.getTileVec3(e.tileTransform, i, a)))
                          , h = c.map((e => new t.Point(e[0],e[1])))
                          , u = i.getFreeCameraOptions().position || new t.MercatorCoordinate(0,0,0)
                          , d = t.getTileVec3(e.tileTransform, u, a)
                          , f = c.map((e => {
                            const i = t.sub(e, e, d);
                            return t.normalize(i, i),
                            new t.Ray(d,i)
                        }
                        ))
                          , p = k(e, 1, i.zoom) * i._pixelsPerMercatorPixel;
                        return {
                            queryGeometry: this,
                            tilespaceGeometry: h,
                            tilespaceRays: f,
                            bufferedTilespaceGeometry: l,
                            bufferedTilespaceBounds: (m = t.getBounds(l),
                            m.min.x = t.clamp(m.min.x, 0, t.EXTENT),
                            m.min.y = t.clamp(m.min.y, 0, t.EXTENT),
                            m.max.x = t.clamp(m.max.x, 0, t.EXTENT),
                            m.max.y = t.clamp(m.max.y, 0, t.EXTENT),
                            m),
                            tile: e,
                            tileID: e.tileID,
                            pixelToTileUnitsFactor: p
                        };
                        var m
                    }
                    _bufferedScreenMercator(t, e) {
                        const i = L(t);
                        if (this._screenRaycastCache[i])
                            return this._screenRaycastCache[i];
                        {
                            let n;
                            return n = "globe" === e.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(t), e) : {
                                polygon: this.bufferedScreenGeometry(t).map((t => e.pointCoordinate3D(t))),
                                unwrapped: !0
                            },
                            this._screenRaycastCache[i] = n,
                            n
                        }
                    }
                    _bufferedCameraMercator(t, e) {
                        const i = L(t);
                        if (this._cameraRaycastCache[i])
                            return this._cameraRaycastCache[i];
                        {
                            let n;
                            return n = "globe" === e.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), e) : {
                                polygon: this.bufferedCameraGeometry(t).map((t => e.pointCoordinate3D(t))),
                                unwrapped: !0
                            },
                            this._cameraRaycastCache[i] = n,
                            n
                        }
                    }
                    _projectAndResample(e, i) {
                        const n = function(e, i) {
                            const n = t.multiply([], i.pixelMatrix, i.globeMatrix)
                              , r = [0, -t.GLOBE_RADIUS, 0, 1]
                              , o = [0, t.GLOBE_RADIUS, 0, 1]
                              , s = [0, 0, 0, 1];
                            t.transformMat4$1(r, r, n),
                            t.transformMat4$1(o, o, n),
                            t.transformMat4$1(s, s, n);
                            const a = new t.Point(r[0] / r[3],r[1] / r[3])
                              , l = new t.Point(o[0] / o[3],o[1] / o[3])
                              , c = t.polygonContainsPoint(e, a) && r[3] < s[3]
                              , h = t.polygonContainsPoint(e, l) && o[3] < s[3];
                            if (!c && !h)
                                return null;
                            const u = function(t, e, i) {
                                for (let n = 1; n < t.length; n++) {
                                    const r = D(e.pointCoordinate3D(t[n - 1]).x)
                                      , o = D(e.pointCoordinate3D(t[n]).x);
                                    if (i < 0) {
                                        if (r < o)
                                            return {
                                                idx: n,
                                                t: -r / (o - 1 - r)
                                            }
                                    } else if (o < r)
                                        return {
                                            idx: n,
                                            t: (1 - r) / (o + 1 - r)
                                        }
                                }
                                return null
                            }(e, i, c ? -1 : 1);
                            if (!u)
                                return null;
                            const {idx: d, t: f} = u;
                            let p = d > 1 ? R(e.slice(0, d), i) : []
                              , m = d < e.length ? R(e.slice(d), i) : [];
                            p = p.map((e => new t.Point(D(e.x),e.y))),
                            m = m.map((e => new t.Point(D(e.x),e.y)));
                            const g = [...p];
                            0 === g.length && g.push(m[m.length - 1]);
                            const _ = t.number(g[g.length - 1].y, (0 === m.length ? p[0] : m[0]).y, f);
                            let y;
                            return y = c ? [new t.Point(0,_), new t.Point(0,0), new t.Point(1,0), new t.Point(1,_)] : [new t.Point(1,_), new t.Point(1,1), new t.Point(0,1), new t.Point(0,_)],
                            g.push(...y),
                            0 === m.length ? g.push(p[0]) : g.push(...m),
                            {
                                polygon: g.map((e => new t.MercatorCoordinate(e.x,e.y))),
                                unwrapped: !1
                            }
                        }(e, i);
                        if (n)
                            return n;
                        const r = function(e, i) {
                            let n = !1
                              , r = -1 / 0
                              , o = 0;
                            for (let t = 0; t < e.length - 1; t++)
                                e[t].x > r && (r = e[t].x,
                                o = t);
                            for (let t = 0; t < e.length - 1; t++) {
                                const i = (o + t) % (e.length - 1)
                                  , r = e[i]
                                  , s = e[i + 1];
                                Math.abs(r.x - s.x) > .5 && (r.x < s.x ? (r.x += 1,
                                0 === i && (e[e.length - 1].x += 1)) : (s.x += 1,
                                i + 1 === e.length - 1 && (e[0].x += 1)),
                                n = !0)
                            }
                            const s = t.mercatorXfromLng(i.center.lng);
                            return n && s < Math.abs(s - 1) && e.forEach((t => {
                                t.x -= 1
                            }
                            )),
                            {
                                polygon: e,
                                unwrapped: n
                            }
                        }(R(e, i).map((e => new t.Point(D(e.x),e.y))), i);
                        return {
                            polygon: r.polygon.map((e => new t.MercatorCoordinate(e.x,e.y))),
                            unwrapped: r.unwrapped
                        }
                    }
                }
                function R(e, i) {
                    return t.resample(e, (t => {
                        const e = i.pointCoordinate3D(t);
                        t.x = e.x,
                        t.y = e.y
                    }
                    ), 1 / 256)
                }
                function D(t) {
                    return t < 0 ? 1 + t % 1 : t % 1
                }
                function L(t) {
                    return 100 * t | 0
                }
                function B(e, i, n, r, o) {
                    const s = function(n, r) {
                        if (n)
                            return o(n);
                        if (r) {
                            e.url && r.tiles && e.tiles && delete e.tiles;
                            const n = t.pick(t.extend(r, e), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                            r.vector_layers && (n.vectorLayers = r.vector_layers,
                            n.vectorLayerIds = n.vectorLayers.map((t => t.id))),
                            n.tiles = i.canonicalizeTileset(n, e.url),
                            o(null, n)
                        }
                    };
                    return e.url ? t.getJSON(i.transformRequest(i.normalizeSourceURL(e.url, null, n, r), t.ResourceType.Source), s) : t.exported.frame(( () => s(null, e)))
                }
                class z {
                    constructor(e, i, n) {
                        this.bounds = t.LngLatBounds.convert(this.validateBounds(e)),
                        this.minzoom = i || 0,
                        this.maxzoom = n || 24
                    }
                    validateBounds(t) {
                        return Array.isArray(t) && 4 === t.length ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90]
                    }
                    contains(e) {
                        const i = Math.pow(2, e.z)
                          , n = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i)
                          , r = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i)
                          , o = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i)
                          , s = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i);
                        return e.x >= n && e.x < o && e.y >= r && e.y < s
                    }
                }
                class F {
                    constructor(t, e, i) {
                        this.context = t;
                        const n = t.gl;
                        this.buffer = n.createBuffer(),
                        this.dynamicDraw = Boolean(i),
                        this.context.unbindVAO(),
                        t.bindElementBuffer.set(this.buffer),
                        n.bufferData(n.ELEMENT_ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW),
                        this.dynamicDraw || e.destroy()
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer)
                    }
                    updateData(t) {
                        const e = this.context.gl;
                        this.context.unbindVAO(),
                        this.bind(),
                        e.bufferSubData(e.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer)
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                const N = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class j {
                    constructor(t, e, i, n) {
                        this.length = e.length,
                        this.attributes = i,
                        this.itemSize = e.bytesPerElement,
                        this.dynamicDraw = n,
                        this.context = t;
                        const r = t.gl;
                        this.buffer = r.createBuffer(),
                        t.bindVertexBuffer.set(this.buffer),
                        r.bufferData(r.ARRAY_BUFFER, e.arrayBuffer, this.dynamicDraw ? r.DYNAMIC_DRAW : r.STATIC_DRAW),
                        this.dynamicDraw || e.destroy()
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(t) {
                        const e = this.context.gl;
                        this.bind(),
                        e.bufferSubData(e.ARRAY_BUFFER, 0, t.arrayBuffer)
                    }
                    enableAttributes(t, e) {
                        for (let i = 0; i < this.attributes.length; i++) {
                            const n = e.attributes[this.attributes[i].name];
                            void 0 !== n && t.enableVertexAttribArray(n)
                        }
                    }
                    setVertexAttribPointers(t, e, i) {
                        for (let n = 0; n < this.attributes.length; n++) {
                            const r = this.attributes[n]
                              , o = e.attributes[r.name];
                            void 0 !== o && t.vertexAttribPointer(o, r.components, t[N[r.type]], !1, this.itemSize, r.offset + this.itemSize * (i || 0))
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class U {
                    constructor(t) {
                        this.gl = t.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(t) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class V extends U {
                    getDefault() {
                        return t.Color.transparent
                    }
                    set(t) {
                        const e = this.current;
                        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class G extends U {
                    getDefault() {
                        return 1
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.clearDepth(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class Z extends U {
                    getDefault() {
                        return 0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.clearStencil(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class q extends U {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(t) {
                        const e = this.current;
                        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class W extends U {
                    getDefault() {
                        return !0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.depthMask(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class H extends U {
                    getDefault() {
                        return 255
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.stencilMask(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class $ extends U {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(t) {
                        const e = this.current;
                        (t.func !== e.func || t.ref !== e.ref || t.mask !== e.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class X extends U {
                    getDefault() {
                        const t = this.gl;
                        return [t.KEEP, t.KEEP, t.KEEP]
                    }
                    set(t) {
                        const e = this.current;
                        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class Y extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        t ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class K extends U {
                    getDefault() {
                        return [0, 1]
                    }
                    set(t) {
                        const e = this.current;
                        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class J extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        t ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class Q extends U {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.depthFunc(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class tt extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        t ? e.enable(e.BLEND) : e.disable(e.BLEND),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class et extends U {
                    getDefault() {
                        const t = this.gl;
                        return [t.ONE, t.ZERO]
                    }
                    set(t) {
                        const e = this.current;
                        (t[0] !== e[0] || t[1] !== e[1] || this.dirty) && (this.gl.blendFunc(t[0], t[1]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class it extends U {
                    getDefault() {
                        return t.Color.transparent
                    }
                    set(t) {
                        const e = this.current;
                        (t.r !== e.r || t.g !== e.g || t.b !== e.b || t.a !== e.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class nt extends U {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.blendEquation(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class rt extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        t ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class ot extends U {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.cullFace(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class st extends U {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.frontFace(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                let at, lt = class extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.useProgram(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                ;
                class ct extends U {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(t) {
                        (t !== this.current || this.dirty) && (this.gl.activeTexture(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class ht extends U {
                    getDefault() {
                        const t = this.gl;
                        return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight]
                    }
                    set(t) {
                        const e = this.current;
                        (t[0] !== e[0] || t[1] !== e[1] || t[2] !== e[2] || t[3] !== e[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class ut extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.bindFramebuffer(e.FRAMEBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class dt extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.bindRenderbuffer(e.RENDERBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class ft extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.bindTexture(e.TEXTURE_2D, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class pt extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.bindBuffer(e.ARRAY_BUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class mt extends U {
                    getDefault() {
                        return null
                    }
                    set(t) {
                        const e = this.gl;
                        e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class gt extends U {
                    constructor(t) {
                        super(t),
                        this.vao = t.extVertexArrayObject
                    }
                    getDefault() {
                        return null
                    }
                    set(t) {
                        this.vao && (t !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t),
                        this.current = t,
                        this.dirty = !1)
                    }
                }
                class _t extends U {
                    getDefault() {
                        return 4
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.pixelStorei(e.UNPACK_ALIGNMENT, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class yt extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class vt extends U {
                    getDefault() {
                        return !1
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        const e = this.gl;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class xt extends U {
                    constructor(t, e) {
                        super(t),
                        this.context = t,
                        this.parent = e
                    }
                    getDefault() {
                        return null
                    }
                }
                class bt extends xt {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const e = this.gl;
                        e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class wt extends xt {
                    attachment() {
                        return this.gl.DEPTH_ATTACHMENT
                    }
                    set(t) {
                        if (t === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const e = this.gl;
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, this.attachment(), e.RENDERBUFFER, t),
                        this.current = t,
                        this.dirty = !1
                    }
                }
                class Et extends wt {
                    attachment() {
                        return this.gl.DEPTH_STENCIL_ATTACHMENT
                    }
                }
                class Tt {
                    constructor(t, e, i, n) {
                        this.context = t,
                        this.width = e,
                        this.height = i;
                        const r = this.framebuffer = t.gl.createFramebuffer();
                        this.colorAttachment = new bt(t,r),
                        n && (this.depthAttachment = new wt(t,r))
                    }
                    destroy() {
                        const t = this.context.gl
                          , e = this.colorAttachment.get();
                        if (e && t.deleteTexture(e),
                        this.depthAttachment) {
                            const e = this.depthAttachment.get();
                            e && t.deleteRenderbuffer(e)
                        }
                        t.deleteFramebuffer(this.framebuffer)
                    }
                }
                class St {
                    constructor(t, e=!1) {
                        if (this.gl = t,
                        this.isWebGL2 = e,
                        this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"),
                        e) {
                            const e = t;
                            this.extVertexArrayObject = {
                                createVertexArrayOES: e.createVertexArray.bind(t),
                                deleteVertexArrayOES: e.deleteVertexArray.bind(t),
                                bindVertexArrayOES: e.bindVertexArray.bind(t)
                            }
                        }
                        this.clearColor = new V(this),
                        this.clearDepth = new G(this),
                        this.clearStencil = new Z(this),
                        this.colorMask = new q(this),
                        this.depthMask = new W(this),
                        this.stencilMask = new H(this),
                        this.stencilFunc = new $(this),
                        this.stencilOp = new X(this),
                        this.stencilTest = new Y(this),
                        this.depthRange = new K(this),
                        this.depthTest = new J(this),
                        this.depthFunc = new Q(this),
                        this.blend = new tt(this),
                        this.blendFunc = new et(this),
                        this.blendColor = new it(this),
                        this.blendEquation = new nt(this),
                        this.cullFace = new rt(this),
                        this.cullFaceSide = new ot(this),
                        this.frontFace = new st(this),
                        this.program = new lt(this),
                        this.activeTexture = new ct(this),
                        this.viewport = new ht(this),
                        this.bindFramebuffer = new ut(this),
                        this.bindRenderbuffer = new dt(this),
                        this.bindTexture = new ft(this),
                        this.bindVertexBuffer = new pt(this),
                        this.bindElementBuffer = new mt(this),
                        this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this),
                        this.pixelStoreUnpack = new _t(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new yt(this),
                        this.pixelStoreUnpackFlipY = new vt(this),
                        this.extTextureFilterAnisotropic = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                        this.extTextureFilterAnisotropicForceOff = !1,
                        this.extStandardDerivativesForceOff = !1,
                        this.extDebugRendererInfo = t.getExtension("WEBGL_debug_renderer_info"),
                        this.extDebugRendererInfo && (this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL),
                        this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)),
                        e || (this.extTextureHalfFloat = t.getExtension("OES_texture_half_float")),
                        (e || this.extTextureHalfFloat && t.getExtension("OES_texture_half_float_linear")) && (this.extRenderToTextureHalfFloat = t.getExtension("EXT_color_buffer_half_float")),
                        this.extStandardDerivatives = e || t.getExtension("OES_standard_derivatives"),
                        this.extTimerQuery = t.getExtension("EXT_disjoint_timer_query"),
                        this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE)
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = !0),
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(t, e) {
                        return new F(this,t,e)
                    }
                    createVertexBuffer(t, e, i) {
                        return new j(this,t,e,i)
                    }
                    createRenderbuffer(t, e, i) {
                        const n = this.gl
                          , r = n.createRenderbuffer();
                        return this.bindRenderbuffer.set(r),
                        n.renderbufferStorage(n.RENDERBUFFER, t, e, i),
                        this.bindRenderbuffer.set(null),
                        r
                    }
                    createFramebuffer(t, e, i) {
                        return new Tt(this,t,e,i)
                    }
                    clear({color: t, depth: e, stencil: i}) {
                        const n = this.gl;
                        let r = 0;
                        t && (r |= n.COLOR_BUFFER_BIT,
                        this.clearColor.set(t),
                        this.colorMask.set([!0, !0, !0, !0])),
                        void 0 !== e && (r |= n.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(e),
                        this.depthMask.set(!0)),
                        void 0 !== i && (r |= n.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(i),
                        this.stencilMask.set(255)),
                        n.clear(r)
                    }
                    setCullFace(t) {
                        !1 === t.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(t.mode),
                        this.frontFace.set(t.frontFace))
                    }
                    setDepthMode(t) {
                        t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(t.func),
                        this.depthMask.set(t.mask),
                        this.depthRange.set(t.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(t) {
                        t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(t.mask),
                        this.stencilOp.set([t.fail, t.depthFail, t.pass]),
                        this.stencilFunc.set({
                            func: t.test.func,
                            ref: t.ref,
                            mask: t.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(i) {
                        e(i.blendFunction, t.ColorMode.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(i.blendFunction),
                        this.blendColor.set(i.blendColor)),
                        this.colorMask.set(i.mask)
                    }
                    unbindVAO() {
                        this.extVertexArrayObject && this.bindVertexArrayOES.set(null)
                    }
                }
                class Ct extends t.Evented {
                    constructor(e, i, n, r) {
                        if (super(),
                        this.id = e,
                        this.dispatcher = n,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        t.extend(this, t.pick(i, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = t.extend({
                            type: "vector"
                        }, i),
                        this._collectResourceTiming = i.collectResourceTiming,
                        512 !== this.tileSize)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(r),
                        this._tileWorkers = {},
                        this._deduped = new t.DedupedRequest
                    }
                    load(e) {
                        this._loaded = !1,
                        this.fire(new t.Event("dataloading",{
                            dataType: "source"
                        }));
                        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language
                          , r = this.map._worldview;
                        this._tileJSONRequest = B(this._options, this.map._requestManager, i, r, ( (o, s) => {
                            this._tileJSONRequest = null,
                            this._loaded = !0,
                            o ? (i && n.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`),
                            r && 2 !== r.length && n.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${r}`),
                            this.fire(new t.ErrorEvent(o))) : s && (t.extend(this, s),
                            s.bounds && (this.tileBounds = new z(s.bounds,this.minzoom,this.maxzoom)),
                            t.postTurnstileEvent(s.tiles, this.map._requestManager._customAccessToken),
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "metadata"
                            })),
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))),
                            e && e(o)
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(t) {
                        return !this.tileBounds || this.tileBounds.contains(t.canonical)
                    }
                    onAdd(t) {
                        this.map = t,
                        this.load()
                    }
                    reload() {
                        this.cancelTileJSONRequest(),
                        this.load(( () => this.map.style._clearSource(this.id)))
                    }
                    setTiles(t) {
                        return this._options.tiles = t,
                        this.reload(),
                        this
                    }
                    setUrl(t) {
                        return this.url = t,
                        this._options.url = t,
                        this.reload(),
                        this
                    }
                    onRemove() {
                        this.cancelTileJSONRequest()
                    }
                    serialize() {
                        return t.extend({}, this._options)
                    }
                    loadTile(e, i) {
                        const n = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme))
                          , r = {
                            request: this.map._requestManager.transformRequest(n, t.ResourceType.Tile),
                            data: void 0,
                            uid: e.uid,
                            tileID: e.tileID,
                            tileZoom: e.tileZoom,
                            zoom: e.tileID.overscaledZ,
                            tileSize: this.tileSize * e.tileID.overscaleFactor(),
                            type: this.type,
                            source: this.id,
                            pixelRatio: t.exported.devicePixelRatio,
                            showCollisionBoxes: this.map.showCollisionBoxes,
                            promoteId: this.promoteId,
                            isSymbolTile: e.isSymbolTile
                        };
                        if (r.request.collectResourceTiming = this._collectResourceTiming,
                        e.actor && "expired" !== e.state)
                            "loading" === e.state ? e.reloadCallback = i : e.request = e.actor.send("reloadTile", r, o.bind(this));
                        else if (e.actor = this._tileWorkers[n] = this._tileWorkers[n] || this.dispatcher.getActor(),
                        this.dispatcher.ready)
                            e.request = e.actor.send("loadTile", r, o.bind(this), void 0, !0);
                        else {
                            const i = t.loadVectorTile.call({
                                deduped: this._deduped
                            }, r, ( (t, i) => {
                                t || !i ? o.call(this, t) : (r.data = {
                                    cacheControl: i.cacheControl,
                                    expires: i.expires,
                                    rawData: i.rawData.slice(0)
                                },
                                e.actor && e.actor.send("loadTile", r, o.bind(this), void 0, !0))
                            }
                            ), !0);
                            e.request = {
                                cancel: i
                            }
                        }
                        function o(n, r) {
                            return delete e.request,
                            e.aborted ? i(null) : n && 404 !== n.status ? i(n) : (r && r.resourceTiming && (e.resourceTiming = r.resourceTiming),
                            this.map._refreshExpiredTiles && r && e.setExpiryData(r),
                            e.loadVectorData(r, this.map.painter),
                            t.cacheEntryPossiblyAdded(this.dispatcher),
                            i(null),
                            void (e.reloadCallback && (this.loadTile(e, e.reloadCallback),
                            e.reloadCallback = null)))
                        }
                    }
                    abortTile(t) {
                        t.request && (t.request.cancel(),
                        delete t.request),
                        t.actor && t.actor.send("abortTile", {
                            uid: t.uid,
                            type: this.type,
                            source: this.id
                        })
                    }
                    unloadTile(t) {
                        t.unloadVectorData(),
                        t.actor && t.actor.send("removeTile", {
                            uid: t.uid,
                            type: this.type,
                            source: this.id
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                    afterUpdate() {
                        this._tileWorkers = {}
                    }
                    cancelTileJSONRequest() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                        this._tileJSONRequest = null)
                    }
                }
                class At extends t.Evented {
                    constructor(e, i, n, r) {
                        super(),
                        this.id = e,
                        this.dispatcher = n,
                        this.setEventedParent(r),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = t.extend({
                            type: "raster"
                        }, i),
                        t.extend(this, t.pick(i, ["url", "scheme", "tileSize"]))
                    }
                    load(e) {
                        this._loaded = !1,
                        this.fire(new t.Event("dataloading",{
                            dataType: "source"
                        })),
                        this._tileJSONRequest = B(this._options, this.map._requestManager, null, null, ( (i, n) => {
                            this._tileJSONRequest = null,
                            this._loaded = !0,
                            i ? this.fire(new t.ErrorEvent(i)) : n && (t.extend(this, n),
                            n.bounds && (this.tileBounds = new z(n.bounds,this.minzoom,this.maxzoom)),
                            t.postTurnstileEvent(n.tiles),
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "metadata"
                            })),
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))),
                            e && e(i)
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(t) {
                        this.map = t,
                        this.load()
                    }
                    reload() {
                        this.cancelTileJSONRequest(),
                        this.load(( () => this.map.style._clearSource(this.id)))
                    }
                    setTiles(t) {
                        return this._options.tiles = t,
                        this.reload(),
                        this
                    }
                    setUrl(t) {
                        return this.url = t,
                        this._options.url = t,
                        this.reload(),
                        this
                    }
                    onRemove() {
                        this.cancelTileJSONRequest()
                    }
                    serialize() {
                        return t.extend({}, this._options)
                    }
                    hasTile(t) {
                        return !this.tileBounds || this.tileBounds.contains(t.canonical)
                    }
                    loadTile(e, i) {
                        const n = t.exported.devicePixelRatio >= 2
                          , r = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), n, this.tileSize);
                        e.request = t.getImage(this.map._requestManager.transformRequest(r, t.ResourceType.Tile), ( (n, r, o, s) => (delete e.request,
                        e.aborted ? (e.state = "unloaded",
                        i(null)) : n ? (e.state = "errored",
                        i(n)) : r ? (this.map._refreshExpiredTiles && e.setExpiryData({
                            cacheControl: o,
                            expires: s
                        }),
                        e.setTexture(r, this.map.painter),
                        e.state = "loaded",
                        t.cacheEntryPossiblyAdded(this.dispatcher),
                        void i(null)) : i(null))))
                    }
                    static loadTileData(t, e, i) {
                        t.setTexture(e, i)
                    }
                    static unloadTileData(t, e) {
                        t.texture && e.saveTileTexture(t.texture)
                    }
                    abortTile(t, e) {
                        t.request && (t.request.cancel(),
                        delete t.request),
                        e()
                    }
                    unloadTile(t, e) {
                        t.texture && this.map.painter.saveTileTexture(t.texture),
                        e()
                    }
                    hasTransition() {
                        return !1
                    }
                    cancelTileJSONRequest() {
                        this._tileJSONRequest && (this._tileJSONRequest.cancel(),
                        this._tileJSONRequest = null)
                    }
                }
                function It(e, i, n, r, o, s, a, l) {
                    const c = [e, n, o, i, r, s, 1, 1, 1]
                      , h = [a, l, 1]
                      , u = t.adjoint([], c)
                      , [d,f,p] = t.transformMat3(h, h, t.transpose(u, u));
                    return t.multiply$1(c, [d, 0, 0, 0, f, 0, 0, 0, p], c)
                }
                class Mt extends t.Evented {
                    constructor(t, e, i, n) {
                        super(),
                        this.id = t,
                        this.dispatcher = i,
                        this.coordinates = e.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.setEventedParent(n),
                        this.options = e,
                        this._dirty = !1
                    }
                    load(e, i) {
                        this._loaded = i || !1,
                        this.fire(new t.Event("dataloading",{
                            dataType: "source"
                        })),
                        this.url = this.options.url,
                        this._imageRequest = t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), ( (i, n) => {
                            if (this._imageRequest = null,
                            this._loaded = !0,
                            i)
                                this.fire(new t.ErrorEvent(i));
                            else if (n) {
                                const {HTMLImageElement: i} = t.window;
                                this.image = n instanceof i ? t.exported.getImageData(n) : n,
                                this._dirty = !0,
                                this.width = this.image.width,
                                this.height = this.image.height,
                                e && (this.coordinates = e),
                                this._finishLoading()
                            }
                        }
                        ))
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(t) {
                        return this.image && t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(),
                        this._imageRequest = null),
                        this.options.url = t.url,
                        this.load(t.coordinates, this._loaded),
                        this) : this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(t) {
                        this.map = t,
                        this.load()
                    }
                    onRemove() {
                        this._imageRequest && (this._imageRequest.cancel(),
                        this._imageRequest = null),
                        this.texture && this.texture.destroy()
                    }
                    setCoordinates(e) {
                        this.coordinates = e,
                        this._boundsArray = void 0;
                        const i = e.map(t.MercatorCoordinate.fromLngLat);
                        return this.tileID = function(e) {
                            let i = 1 / 0
                              , n = 1 / 0
                              , r = -1 / 0
                              , o = -1 / 0;
                            for (const t of e)
                                i = Math.min(i, t.x),
                                n = Math.min(n, t.y),
                                r = Math.max(r, t.x),
                                o = Math.max(o, t.y);
                            const s = Math.max(r - i, o - n)
                              , a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2))
                              , l = Math.pow(2, a);
                            return new t.CanonicalTileID(a,Math.floor((i + r) / 2 * l),Math.floor((n + o) / 2 * l))
                        }(i),
                        this.minzoom = this.maxzoom = this.tileID.z,
                        this.fire(new t.Event("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    _clear() {
                        this._boundsArray = void 0
                    }
                    _prepareData(e) {
                        for (const t in this.tiles) {
                            const e = this.tiles[t];
                            "loaded" !== e.state && (e.state = "loaded",
                            e.texture = this.texture)
                        }
                        if (this._boundsArray)
                            return;
                        const i = t.tileTransform(this.tileID, this.map.transform.projection)
                          , [n,r,o,s] = this.coordinates.map((e => {
                            const n = i.projection.project(e[0], e[1]);
                            return t.getTilePoint(i, n)._round()
                        }
                        ));
                        this.perspectiveTransform = function(e, i, n, r, o, s, a, l, c, h) {
                            const u = It(0, 0, e, 0, 0, i, e, i)
                              , d = It(n, r, o, s, a, l, c, h);
                            return t.multiply$1(d, t.adjoint(u, u), d),
                            [d[6] / d[8] * e / t.EXTENT, d[7] / d[8] * i / t.EXTENT]
                        }(this.width, this.height, n.x, n.y, r.x, r.y, s.x, s.y, o.x, o.y);
                        const a = this._boundsArray = new t.StructArrayLayout4i8;
                        a.emplaceBack(n.x, n.y, 0, 0),
                        a.emplaceBack(r.x, r.y, t.EXTENT, 0),
                        a.emplaceBack(s.x, s.y, 0, t.EXTENT),
                        a.emplaceBack(o.x, o.y, t.EXTENT, t.EXTENT),
                        this.boundsBuffer && this.boundsBuffer.destroy(),
                        this.boundsBuffer = e.createVertexBuffer(a, t.boundsAttributes.members),
                        this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)
                    }
                    prepare() {
                        if (0 === Object.keys(this.tiles).length || !this.image)
                            return;
                        const e = this.map.painter.context
                          , i = e.gl;
                        this._dirty && (this.texture ? this.texture.update(this.image) : (this.texture = new t.Texture(e,this.image,i.RGBA),
                        this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE)),
                        this._dirty = !1),
                        this._prepareData(e)
                    }
                    loadTile(t, e) {
                        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t,
                        t.buckets = {},
                        e(null)) : (t.state = "errored",
                        e(null))
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                }
                const Pt = {
                    vector: Ct,
                    raster: At,
                    "raster-dem": class extends At {
                        constructor(e, i, n, r) {
                            super(e, i, n, r),
                            this.type = "raster-dem",
                            this.maxzoom = 22,
                            this._options = t.extend({
                                type: "raster-dem"
                            }, i),
                            this.encoding = i.encoding || "mapbox"
                        }
                        loadTile(e, i) {
                            const n = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
                            function r(t, n) {
                                t && (e.state = "errored",
                                i(t)),
                                n && (e.dem = n,
                                e.dem.onDeserialize(),
                                e.needsHillshadePrepare = !0,
                                e.needsDEMTextureUpload = !0,
                                e.state = "loaded",
                                i(null))
                            }
                            e.request = t.getImage(this.map._requestManager.transformRequest(n, t.ResourceType.Tile), function(n, o, s, a) {
                                if (delete e.request,
                                e.aborted)
                                    e.state = "unloaded",
                                    i(null);
                                else if (n)
                                    e.state = "errored",
                                    i(n);
                                else if (o) {
                                    this.map._refreshExpiredTiles && e.setExpiryData({
                                        cacheControl: s,
                                        expires: a
                                    });
                                    const i = t.window.ImageBitmap && o instanceof t.window.ImageBitmap && (null == at && (at = t.window.OffscreenCanvas && new t.window.OffscreenCanvas(1,1).getContext("2d") && "function" == typeof t.window.createImageBitmap),
                                    at)
                                      , n = 1 - (o.width - t.prevPowerOfTwo(o.width)) / 2;
                                    n < 1 || e.neighboringTiles || (e.neighboringTiles = this._getNeighboringTiles(e.tileID));
                                    const l = i ? o : t.exported.getImageData(o, n)
                                      , c = {
                                        uid: e.uid,
                                        coord: e.tileID,
                                        source: this.id,
                                        rawImageData: l,
                                        encoding: this.encoding,
                                        padding: n
                                    };
                                    e.actor && "expired" !== e.state || (e.actor = this.dispatcher.getActor(),
                                    e.actor.send("loadDEMTile", c, r.bind(this), void 0, !0))
                                }
                            }
                            .bind(this))
                        }
                        _getNeighboringTiles(e) {
                            const i = e.canonical
                              , n = Math.pow(2, i.z)
                              , r = (i.x - 1 + n) % n
                              , o = 0 === i.x ? e.wrap - 1 : e.wrap
                              , s = (i.x + 1 + n) % n
                              , a = i.x + 1 === n ? e.wrap + 1 : e.wrap
                              , l = {};
                            return l[new t.OverscaledTileID(e.overscaledZ,o,i.z,r,i.y).key] = {
                                backfilled: !1
                            },
                            l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y).key] = {
                                backfilled: !1
                            },
                            i.y > 0 && (l[new t.OverscaledTileID(e.overscaledZ,o,i.z,r,i.y - 1).key] = {
                                backfilled: !1
                            },
                            l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y - 1).key] = {
                                backfilled: !1
                            },
                            l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y - 1).key] = {
                                backfilled: !1
                            }),
                            i.y + 1 < n && (l[new t.OverscaledTileID(e.overscaledZ,o,i.z,r,i.y + 1).key] = {
                                backfilled: !1
                            },
                            l[new t.OverscaledTileID(e.overscaledZ,e.wrap,i.z,i.x,i.y + 1).key] = {
                                backfilled: !1
                            },
                            l[new t.OverscaledTileID(e.overscaledZ,a,i.z,s,i.y + 1).key] = {
                                backfilled: !1
                            }),
                            l
                        }
                        unloadTile(t) {
                            t.demTexture && this.map.painter.saveTileTexture(t.demTexture),
                            t.fbo && (t.fbo.destroy(),
                            delete t.fbo),
                            t.dem && delete t.dem,
                            delete t.neighboringTiles,
                            t.state = "unloaded"
                        }
                    }
                    ,
                    geojson: class extends t.Evented {
                        constructor(e, i, n, r) {
                            super(),
                            this.id = e,
                            this.type = "geojson",
                            this.minzoom = 0,
                            this.maxzoom = 18,
                            this.tileSize = 512,
                            this.isTileClipped = !0,
                            this.reparseOverscaled = !0,
                            this._loaded = !1,
                            this.actor = n.getActor(),
                            this.setEventedParent(r),
                            this._data = i.data,
                            this._options = t.extend({}, i),
                            this._collectResourceTiming = i.collectResourceTiming,
                            void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom),
                            i.type && (this.type = i.type),
                            i.attribution && (this.attribution = i.attribution),
                            this.promoteId = i.promoteId;
                            const o = t.EXTENT / this.tileSize;
                            this.workerOptions = t.extend({
                                source: this.id,
                                cluster: i.cluster || !1,
                                geojsonVtOptions: {
                                    buffer: (void 0 !== i.buffer ? i.buffer : 128) * o,
                                    tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * o,
                                    extent: t.EXTENT,
                                    maxZoom: this.maxzoom,
                                    lineMetrics: i.lineMetrics || !1,
                                    generateId: i.generateId || !1
                                },
                                superclusterOptions: {
                                    maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,
                                    minPoints: Math.max(2, i.clusterMinPoints || 2),
                                    extent: t.EXTENT,
                                    radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * o,
                                    log: !1,
                                    generateId: i.generateId || !1
                                },
                                clusterProperties: i.clusterProperties,
                                filter: i.filter
                            }, i.workerOptions)
                        }
                        onAdd(t) {
                            this.map = t,
                            this.setData(this._data)
                        }
                        setData(t) {
                            return this._data = t,
                            this._updateWorkerData(),
                            this
                        }
                        getClusterExpansionZoom(t, e) {
                            return this.actor.send("geojson.getClusterExpansionZoom", {
                                clusterId: t,
                                source: this.id
                            }, e),
                            this
                        }
                        getClusterChildren(t, e) {
                            return this.actor.send("geojson.getClusterChildren", {
                                clusterId: t,
                                source: this.id
                            }, e),
                            this
                        }
                        getClusterLeaves(t, e, i, n) {
                            return this.actor.send("geojson.getClusterLeaves", {
                                source: this.id,
                                clusterId: t,
                                limit: e,
                                offset: i
                            }, n),
                            this
                        }
                        _updateWorkerData() {
                            if (this._pendingLoad)
                                return void (this._coalesce = !0);
                            this.fire(new t.Event("dataloading",{
                                dataType: "source"
                            })),
                            this._loaded = !1;
                            const e = t.extend({}, this.workerOptions)
                              , i = this._data;
                            "string" == typeof i ? (e.request = this.map._requestManager.transformRequest(t.exported.resolveURL(i), t.ResourceType.Source),
                            e.request.collectResourceTiming = this._collectResourceTiming) : e.data = JSON.stringify(i),
                            this._pendingLoad = this.actor.send(`${this.type}.loadData`, e, ( (e, i) => {
                                if (this._loaded = !0,
                                this._pendingLoad = null,
                                e)
                                    this.fire(new t.ErrorEvent(e));
                                else {
                                    const e = {
                                        dataType: "source",
                                        sourceDataType: this._metadataFired ? "content" : "metadata"
                                    };
                                    this._collectResourceTiming && i && i.resourceTiming && i.resourceTiming[this.id] && (e.resourceTiming = i.resourceTiming[this.id]),
                                    this.fire(new t.Event("data",e)),
                                    this._metadataFired = !0
                                }
                                this._coalesce && (this._updateWorkerData(),
                                this._coalesce = !1)
                            }
                            ))
                        }
                        loaded() {
                            return this._loaded
                        }
                        loadTile(e, i) {
                            const n = e.actor ? "reloadTile" : "loadTile";
                            e.actor = this.actor,
                            e.request = this.actor.send(n, {
                                type: this.type,
                                uid: e.uid,
                                tileID: e.tileID,
                                tileZoom: e.tileZoom,
                                zoom: e.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                pixelRatio: t.exported.devicePixelRatio,
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId
                            }, ( (t, r) => (delete e.request,
                            e.unloadVectorData(),
                            e.aborted ? i(null) : t ? i(t) : (e.loadVectorData(r, this.map.painter, "reloadTile" === n),
                            i(null)))), void 0, "loadTile" === n)
                        }
                        abortTile(t) {
                            t.request && (t.request.cancel(),
                            delete t.request),
                            t.aborted = !0
                        }
                        unloadTile(t) {
                            t.unloadVectorData(),
                            this.actor.send("removeTile", {
                                uid: t.uid,
                                type: this.type,
                                source: this.id
                            })
                        }
                        onRemove() {
                            this._pendingLoad && this._pendingLoad.cancel()
                        }
                        serialize() {
                            return t.extend({}, this._options, {
                                type: this.type,
                                data: this._data
                            })
                        }
                        hasTransition() {
                            return !1
                        }
                    }
                    ,
                    video: class extends Mt {
                        constructor(t, e, i, n) {
                            super(t, e, i, n),
                            this.roundZoom = !0,
                            this.type = "video",
                            this.options = e
                        }
                        load() {
                            this._loaded = !1;
                            const e = this.options;
                            this.urls = [];
                            for (const i of e.urls)
                                this.urls.push(this.map._requestManager.transformRequest(i, t.ResourceType.Source).url);
                            t.getVideo(this.urls, ( (e, i) => {
                                this._loaded = !0,
                                e ? this.fire(new t.ErrorEvent(e)) : i && (this.video = i,
                                this.video.loop = !0,
                                this.video.setAttribute("playsinline", ""),
                                this.video.addEventListener("playing", ( () => {
                                    this.map.triggerRepaint()
                                }
                                )),
                                this.map && this.video.play(),
                                this._finishLoading())
                            }
                            ))
                        }
                        pause() {
                            this.video && this.video.pause()
                        }
                        play() {
                            this.video && this.video.play()
                        }
                        seek(e) {
                            if (this.video) {
                                const i = this.video.seekable;
                                e < i.start(0) || e > i.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
                            }
                        }
                        getVideo() {
                            return this.video
                        }
                        onAdd(t) {
                            this.map || (this.map = t,
                            this.load(),
                            this.video && (this.video.play(),
                            this.setCoordinates(this.coordinates)))
                        }
                        prepare() {
                            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                                return;
                            const e = this.map.painter.context
                              , i = e.gl;
                            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                            i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e,this.video,i.RGBA),
                            this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                            this.width = this.video.videoWidth,
                            this.height = this.video.videoHeight),
                            this._prepareData(e)
                        }
                        serialize() {
                            return {
                                type: "video",
                                urls: this.urls,
                                coordinates: this.coordinates
                            }
                        }
                        hasTransition() {
                            return this.video && !this.video.paused
                        }
                    }
                    ,
                    image: Mt,
                    canvas: class extends Mt {
                        constructor(e, i, n, r) {
                            super(e, i, n, r),
                            i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some((t => !Array.isArray(t) || 2 !== t.length || t.some((t => "number" != typeof t)))) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "coordinates"'))),
                            i.animate && "boolean" != typeof i.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                            i.canvas ? "string" == typeof i.canvas || i.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e}`,null,'missing required property "canvas"'))),
                            this.options = i,
                            this.animate = void 0 === i.animate || i.animate
                        }
                        load() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        }
                        getCanvas() {
                            return this.canvas
                        }
                        onAdd(t) {
                            this.map = t,
                            this.load(),
                            this.canvas && this.animate && this.play()
                        }
                        onRemove() {
                            this.pause()
                        }
                        prepare() {
                            let e = !1;
                            if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                            e = !0),
                            this.canvas.height !== this.height && (this.height = this.canvas.height,
                            e = !0),
                            this._hasInvalidDimensions())
                                return;
                            if (0 === Object.keys(this.tiles).length)
                                return;
                            const i = this.map.painter.context;
                            this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                                premultiply: !0
                            }) : this.texture = new t.Texture(i,this.canvas,i.gl.RGBA,{
                                premultiply: !0
                            }),
                            this._prepareData(i)
                        }
                        serialize() {
                            return {
                                type: "canvas",
                                coordinates: this.coordinates
                            }
                        }
                        hasTransition() {
                            return this._playing
                        }
                        _hasInvalidDimensions() {
                            for (const t of [this.canvas.width, this.canvas.height])
                                if (isNaN(t) || t <= 0)
                                    return !0;
                            return !1
                        }
                    }
                    ,
                    custom: class extends t.Evented {
                        constructor(e, i, n, r) {
                            super(),
                            this.id = e,
                            this.type = "custom",
                            this._dataType = "raster",
                            this._dispatcher = n,
                            this._implementation = i,
                            this.setEventedParent(r),
                            this.scheme = "xyz",
                            this.minzoom = 0,
                            this.maxzoom = 22,
                            this.tileSize = 512,
                            this._loaded = !1,
                            this.roundZoom = !0,
                            this._implementation || this.fire(new t.ErrorEvent(new Error(`Missing implementation for ${this.id} custom source`))),
                            this._implementation.loadTile || this.fire(new t.ErrorEvent(new Error(`Missing loadTile implementation for ${this.id} custom source`))),
                            this._implementation.bounds && (this.tileBounds = new z(this._implementation.bounds,this.minzoom,this.maxzoom)),
                            i.update = this._update.bind(this),
                            i.clearTiles = this._clearTiles.bind(this),
                            i.coveringTiles = this._coveringTiles.bind(this),
                            t.extend(this, t.pick(i, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]))
                        }
                        serialize() {
                            return t.pick(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"])
                        }
                        load() {
                            this._loaded = !0,
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "metadata"
                            })),
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))
                        }
                        loaded() {
                            return this._loaded
                        }
                        onAdd(e) {
                            this._map = e,
                            this._loaded = !1,
                            this.fire(new t.Event("dataloading",{
                                dataType: "source"
                            })),
                            this._implementation.onAdd && this._implementation.onAdd(e),
                            this.load()
                        }
                        onRemove(t) {
                            this._implementation.onRemove && this._implementation.onRemove(t)
                        }
                        hasTile(t) {
                            if (this._implementation.hasTile) {
                                const {x: e, y: i, z: n} = t.canonical;
                                return this._implementation.hasTile({
                                    x: e,
                                    y: i,
                                    z: n
                                })
                            }
                            return !this.tileBounds || this.tileBounds.contains(t.canonical)
                        }
                        loadTile(e, i) {
                            const {x: n, y: r, z: o} = e.tileID.canonical
                              , s = new t.window.AbortController;
                            e.request = Promise.resolve(this._implementation.loadTile({
                                x: n,
                                y: r,
                                z: o
                            }, {
                                signal: s.signal
                            })).then(function(n) {
                                return delete e.request,
                                e.aborted ? (e.state = "unloaded",
                                i(null)) : void 0 === n ? (e.state = "errored",
                                i(null)) : null === n ? (this.loadTileData(e, {
                                    width: this.tileSize,
                                    height: this.tileSize,
                                    data: null
                                }),
                                e.state = "loaded",
                                i(null)) : function(e) {
                                    return e instanceof t.window.ImageData || e instanceof t.window.HTMLCanvasElement || e instanceof t.window.ImageBitmap || e instanceof t.window.HTMLImageElement
                                }(n) ? (this.loadTileData(e, n),
                                e.state = "loaded",
                                void i(null)) : (e.state = "errored",
                                i(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))
                            }
                            .bind(this)).catch((t => {
                                20 !== t.code && (e.state = "errored",
                                i(t))
                            }
                            )),
                            e.request.cancel = () => s.abort()
                        }
                        loadTileData(t, e) {
                            At.loadTileData(t, e, this._map.painter)
                        }
                        unloadTileData(t) {
                            At.unloadTileData(t, this._map.painter)
                        }
                        unloadTile(t, e) {
                            if (this.unloadTileData(t),
                            this._implementation.unloadTile) {
                                const {x: e, y: i, z: n} = t.tileID.canonical;
                                this._implementation.unloadTile({
                                    x: e,
                                    y: i,
                                    z: n
                                })
                            }
                            e()
                        }
                        abortTile(t, e) {
                            t.request && t.request.cancel && (t.request.cancel(),
                            delete t.request),
                            e()
                        }
                        hasTransition() {
                            return !1
                        }
                        _coveringTiles() {
                            return this._map.transform.coveringTiles({
                                tileSize: this.tileSize,
                                minzoom: this.minzoom,
                                maxzoom: this.maxzoom,
                                roundZoom: this.roundZoom
                            }).map((t => ({
                                x: t.canonical.x,
                                y: t.canonical.y,
                                z: t.canonical.z
                            })))
                        }
                        _clearTiles() {
                            this._map.style._clearSource(this.id)
                        }
                        _update() {
                            this.fire(new t.Event("data",{
                                dataType: "source",
                                sourceDataType: "content"
                            }))
                        }
                    }
                }
                  , kt = function(e, i, n, r) {
                    const o = new Pt[i.type](e,i,n,r);
                    if (o.id !== e)
                        throw new Error(`Expected Source id to be ${e} instead of ${o.id}`);
                    return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], o),
                    o
                };
                function Ot(e, i) {
                    const n = t.identity([]);
                    return t.scale(n, n, [.5 * e.width, .5 * -e.height, 1]),
                    t.translate(n, n, [1, -1, 0]),
                    t.multiply(n, n, e.calculateProjMatrix(i.toUnwrapped())),
                    Float32Array.from(n)
                }
                function Rt(t, e, i, n, r, o, s, a=!1) {
                    const l = t.tilesIn(n, s, a);
                    l.sort(Lt);
                    const c = [];
                    for (const n of l)
                        c.push({
                            wrappedTileID: n.tile.tileID.wrapped().key,
                            queryResults: n.tile.queryRenderedFeatures(e, i, t._state, n, r, o, Ot(t.transform, n.tile.tileID), a)
                        });
                    const h = function(t) {
                        const e = {}
                          , i = {};
                        for (const n of t) {
                            const t = n.queryResults
                              , r = n.wrappedTileID
                              , o = i[r] = i[r] || {};
                            for (const i in t) {
                                const n = t[i]
                                  , r = o[i] = o[i] || {}
                                  , s = e[i] = e[i] || [];
                                for (const t of n)
                                    r[t.featureIndex] || (r[t.featureIndex] = !0,
                                    s.push(t))
                            }
                        }
                        return e
                    }(c);
                    for (const e in h)
                        h[e].forEach((e => {
                            const i = e.feature
                              , n = i.layer;
                            n && "background" !== n.type && "sky" !== n.type && (i.source = n.source,
                            n["source-layer"] && (i.sourceLayer = n["source-layer"]),
                            i.state = void 0 !== i.id ? t.getFeatureState(n["source-layer"], i.id) : {})
                        }
                        ));
                    return h
                }
                function Dt(t, e) {
                    const i = t.getRenderableIds().map((e => t.getTileByID(e)))
                      , n = []
                      , r = {};
                    for (let t = 0; t < i.length; t++) {
                        const o = i[t]
                          , s = o.tileID.canonical.key;
                        r[s] || (r[s] = !0,
                        o.querySourceFeatures(n, e))
                    }
                    return n
                }
                function Lt(t, e) {
                    const i = t.tileID
                      , n = e.tileID;
                    return i.overscaledZ - n.overscaledZ || i.canonical.y - n.canonical.y || i.wrap - n.wrap || i.canonical.x - n.canonical.x
                }
                function Bt() {
                    return null != po.workerClass ? new po.workerClass : new t.window.Worker(po.workerUrl)
                }
                const zt = "mapboxgl_preloaded_worker_pool";
                class Ft {
                    constructor() {
                        this.active = {}
                    }
                    acquire(t) {
                        if (!this.workers)
                            for (this.workers = []; this.workers.length < Ft.workerCount; )
                                this.workers.push(new Bt);
                        return this.active[t] = !0,
                        this.workers.slice()
                    }
                    release(t) {
                        delete this.active[t],
                        0 === this.numActive() && (this.workers.forEach((t => {
                            t.terminate()
                        }
                        )),
                        this.workers = null)
                    }
                    isPreloaded() {
                        return !!this.active[zt]
                    }
                    numActive() {
                        return Object.keys(this.active).length
                    }
                }
                let Nt;
                function jt() {
                    return Nt || (Nt = new Ft),
                    Nt
                }
                function Ut(e, i) {
                    const n = {};
                    for (const t in e)
                        "ref" !== t && (n[t] = e[t]);
                    return t.refProperties.forEach((t => {
                        t in i && (n[t] = i[t])
                    }
                    )),
                    n
                }
                function Vt(t) {
                    t = t.slice();
                    const e = Object.create(null);
                    for (let i = 0; i < t.length; i++)
                        e[t[i].id] = t[i];
                    for (let i = 0; i < t.length; i++)
                        "ref"in t[i] && (t[i] = Ut(t[i], e[t[i].ref]));
                    return t
                }
                Ft.workerCount = 2;
                const Gt = {
                    setStyle: "setStyle",
                    addLayer: "addLayer",
                    removeLayer: "removeLayer",
                    setPaintProperty: "setPaintProperty",
                    setLayoutProperty: "setLayoutProperty",
                    setFilter: "setFilter",
                    addSource: "addSource",
                    removeSource: "removeSource",
                    setGeoJSONSourceData: "setGeoJSONSourceData",
                    setLayerZoomRange: "setLayerZoomRange",
                    setLayerProperty: "setLayerProperty",
                    setCenter: "setCenter",
                    setZoom: "setZoom",
                    setBearing: "setBearing",
                    setPitch: "setPitch",
                    setSprite: "setSprite",
                    setGlyphs: "setGlyphs",
                    setTransition: "setTransition",
                    setLight: "setLight",
                    setTerrain: "setTerrain",
                    setFog: "setFog",
                    setProjection: "setProjection"
                };
                function Zt(t, e, i) {
                    i.push({
                        command: Gt.addSource,
                        args: [t, e[t]]
                    })
                }
                function qt(t, e, i) {
                    e.push({
                        command: Gt.removeSource,
                        args: [t]
                    }),
                    i[t] = !0
                }
                function Wt(t, e, i, n) {
                    qt(t, i, n),
                    Zt(t, e, i)
                }
                function Ht(t, i, n) {
                    let r;
                    for (r in t[n])
                        if (t[n].hasOwnProperty(r) && "data" !== r && !e(t[n][r], i[n][r]))
                            return !1;
                    for (r in i[n])
                        if (i[n].hasOwnProperty(r) && "data" !== r && !e(t[n][r], i[n][r]))
                            return !1;
                    return !0
                }
                function $t(t, i, n, r, o, s) {
                    let a;
                    for (a in i = i || {},
                    t = t || {})
                        t.hasOwnProperty(a) && (e(t[a], i[a]) || n.push({
                            command: s,
                            args: [r, a, i[a], o]
                        }));
                    for (a in i)
                        i.hasOwnProperty(a) && !t.hasOwnProperty(a) && (e(t[a], i[a]) || n.push({
                            command: s,
                            args: [r, a, i[a], o]
                        }))
                }
                function Xt(t) {
                    return t.id
                }
                function Yt(t, e) {
                    return t[e.id] = e,
                    t
                }
                class Kt {
                    constructor(t, e) {
                        this.reset(t, e)
                    }
                    reset(t, e) {
                        this.points = t || [],
                        this._distances = [0];
                        for (let t = 1; t < this.points.length; t++)
                            this._distances[t] = this._distances[t - 1] + this.points[t].dist(this.points[t - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(e || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(e) {
                        if (1 === this.points.length)
                            return this.points[0];
                        e = t.clamp(e, 0, 1);
                        let i = 1
                          , n = this._distances[i];
                        const r = e * this.paddedLength + this.padding;
                        for (; n < r && i < this._distances.length; )
                            n = this._distances[++i];
                        const o = i - 1
                          , s = this._distances[o]
                          , a = n - s
                          , l = a > 0 ? (r - s) / a : 0;
                        return this.points[o].mult(1 - l).add(this.points[i].mult(l))
                    }
                }
                class Jt {
                    constructor(t, e, i) {
                        const n = this.boxCells = []
                          , r = this.circleCells = [];
                        this.xCellCount = Math.ceil(t / i),
                        this.yCellCount = Math.ceil(e / i);
                        for (let t = 0; t < this.xCellCount * this.yCellCount; t++)
                            n.push([]),
                            r.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = t,
                        this.height = e,
                        this.xScale = this.xCellCount / t,
                        this.yScale = this.yCellCount / e,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(t, e, i, n, r) {
                        this._forEachCell(e, i, n, r, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(t),
                        this.bboxes.push(e),
                        this.bboxes.push(i),
                        this.bboxes.push(n),
                        this.bboxes.push(r)
                    }
                    insertCircle(t, e, i, n) {
                        this._forEachCell(e - n, i - n, e + n, i + n, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(t),
                        this.circles.push(e),
                        this.circles.push(i),
                        this.circles.push(n)
                    }
                    _insertBoxCell(t, e, i, n, r, o) {
                        this.boxCells[r].push(o)
                    }
                    _insertCircleCell(t, e, i, n, r, o) {
                        this.circleCells[r].push(o)
                    }
                    _query(t, e, i, n, r, o) {
                        if (i < 0 || t > this.width || n < 0 || e > this.height)
                            return !r && [];
                        const s = [];
                        if (t <= 0 && e <= 0 && this.width <= i && this.height <= n) {
                            if (r)
                                return !0;
                            for (let t = 0; t < this.boxKeys.length; t++)
                                s.push({
                                    key: this.boxKeys[t],
                                    x1: this.bboxes[4 * t],
                                    y1: this.bboxes[4 * t + 1],
                                    x2: this.bboxes[4 * t + 2],
                                    y2: this.bboxes[4 * t + 3]
                                });
                            for (let t = 0; t < this.circleKeys.length; t++) {
                                const e = this.circles[3 * t]
                                  , i = this.circles[3 * t + 1]
                                  , n = this.circles[3 * t + 2];
                                s.push({
                                    key: this.circleKeys[t],
                                    x1: e - n,
                                    y1: i - n,
                                    x2: e + n,
                                    y2: i + n
                                })
                            }
                            return o ? s.filter(o) : s
                        }
                        return this._forEachCell(t, e, i, n, this._queryCell, s, {
                            hitTest: r,
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, o),
                        r ? s.length > 0 : s
                    }
                    _queryCircle(t, e, i, n, r) {
                        const o = t - i
                          , s = t + i
                          , a = e - i
                          , l = e + i;
                        if (s < 0 || o > this.width || l < 0 || a > this.height)
                            return !n && [];
                        const c = [];
                        return this._forEachCell(o, a, s, l, this._queryCellCircle, c, {
                            hitTest: n,
                            circle: {
                                x: t,
                                y: e,
                                radius: i
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, r),
                        n ? c.length > 0 : c
                    }
                    query(t, e, i, n, r) {
                        return this._query(t, e, i, n, !1, r)
                    }
                    hitTest(t, e, i, n, r) {
                        return this._query(t, e, i, n, !0, r)
                    }
                    hitTestCircle(t, e, i, n) {
                        return this._queryCircle(t, e, i, !0, n)
                    }
                    _queryCell(t, e, i, n, r, o, s, a) {
                        const l = s.seenUids
                          , c = this.boxCells[r];
                        if (null !== c) {
                            const r = this.bboxes;
                            for (const h of c)
                                if (!l.box[h]) {
                                    l.box[h] = !0;
                                    const c = 4 * h;
                                    if (t <= r[c + 2] && e <= r[c + 3] && i >= r[c + 0] && n >= r[c + 1] && (!a || a(this.boxKeys[h]))) {
                                        if (s.hitTest)
                                            return o.push(!0),
                                            !0;
                                        o.push({
                                            key: this.boxKeys[h],
                                            x1: r[c],
                                            y1: r[c + 1],
                                            x2: r[c + 2],
                                            y2: r[c + 3]
                                        })
                                    }
                                }
                        }
                        const h = this.circleCells[r];
                        if (null !== h) {
                            const r = this.circles;
                            for (const c of h)
                                if (!l.circle[c]) {
                                    l.circle[c] = !0;
                                    const h = 3 * c;
                                    if (this._circleAndRectCollide(r[h], r[h + 1], r[h + 2], t, e, i, n) && (!a || a(this.circleKeys[c]))) {
                                        if (s.hitTest)
                                            return o.push(!0),
                                            !0;
                                        {
                                            const t = r[h]
                                              , e = r[h + 1]
                                              , i = r[h + 2];
                                            o.push({
                                                key: this.circleKeys[c],
                                                x1: t - i,
                                                y1: e - i,
                                                x2: t + i,
                                                y2: e + i
                                            })
                                        }
                                    }
                                }
                        }
                    }
                    _queryCellCircle(t, e, i, n, r, o, s, a) {
                        const l = s.circle
                          , c = s.seenUids
                          , h = this.boxCells[r];
                        if (null !== h) {
                            const t = this.bboxes;
                            for (const e of h)
                                if (!c.box[e]) {
                                    c.box[e] = !0;
                                    const i = 4 * e;
                                    if (this._circleAndRectCollide(l.x, l.y, l.radius, t[i + 0], t[i + 1], t[i + 2], t[i + 3]) && (!a || a(this.boxKeys[e])))
                                        return o.push(!0),
                                        !0
                                }
                        }
                        const u = this.circleCells[r];
                        if (null !== u) {
                            const t = this.circles;
                            for (const e of u)
                                if (!c.circle[e]) {
                                    c.circle[e] = !0;
                                    const i = 3 * e;
                                    if (this._circlesCollide(t[i], t[i + 1], t[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[e])))
                                        return o.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(t, e, i, n, r, o, s, a) {
                        const l = this._convertToXCellCoord(t)
                          , c = this._convertToYCellCoord(e)
                          , h = this._convertToXCellCoord(i)
                          , u = this._convertToYCellCoord(n);
                        for (let d = l; d <= h; d++)
                            for (let l = c; l <= u; l++)
                                if (r.call(this, t, e, i, n, this.xCellCount * l + d, o, s, a))
                                    return
                    }
                    _convertToXCellCoord(t) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)))
                    }
                    _convertToYCellCoord(t) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)))
                    }
                    _circlesCollide(t, e, i, n, r, o) {
                        const s = n - t
                          , a = r - e
                          , l = i + o;
                        return l * l > s * s + a * a
                    }
                    _circleAndRectCollide(t, e, i, n, r, o, s) {
                        const a = (o - n) / 2
                          , l = Math.abs(t - (n + a));
                        if (l > a + i)
                            return !1;
                        const c = (s - r) / 2
                          , h = Math.abs(e - (r + c));
                        if (h > c + i)
                            return !1;
                        if (l <= a || h <= c)
                            return !0;
                        const u = l - a
                          , d = h - c;
                        return u * u + d * d <= i * i
                    }
                }
                const Qt = {
                    unknown: 0,
                    flipRequired: 1,
                    flipNotRequired: 2
                }
                  , te = Math.tan(85 * Math.PI / 180);
                function ee(e, i, n, r, o, s, a) {
                    const l = t.create();
                    if (n)
                        if ("globe" === s.name) {
                            const e = t.calculateGlobeLabelMatrix(o, i);
                            t.multiply(l, l, e)
                        } else {
                            const e = v([], a);
                            l[0] = e[0],
                            l[1] = e[1],
                            l[4] = e[2],
                            l[5] = e[3],
                            r || t.rotateZ(l, l, o.angle)
                        }
                    else
                        t.multiply(l, o.labelPlaneMatrix, e);
                    return l
                }
                function ie(t, e, i, n, r, o, s) {
                    const a = ee(t, e, i, n, r, o, s);
                    return "globe" === o.name && i || (a[2] = a[6] = a[10] = a[14] = 0),
                    a
                }
                function ne(e, i, n, r, o, s, a) {
                    if (n) {
                        if ("globe" === s.name) {
                            const l = ee(e, i, n, r, o, s, a);
                            return t.invert(l, l),
                            t.multiply(l, e, l),
                            l
                        }
                        {
                            const i = t.clone(e)
                              , n = t.identity([]);
                            return n[0] = a[0],
                            n[1] = a[1],
                            n[4] = a[2],
                            n[5] = a[3],
                            t.multiply(i, i, n),
                            r || t.rotateZ(i, i, -o.angle),
                            i
                        }
                    }
                    return o.glCoordMatrix
                }
                function re(e, i, n, r) {
                    const o = [e, i, n, 1];
                    n ? t.transformMat4$1(o, o, r) : me(o, o, r);
                    const s = o[3];
                    return o[0] /= s,
                    o[1] /= s,
                    o[2] /= s,
                    o
                }
                function oe(t, e) {
                    return Math.min(.5 + t / e * .5, 1.5)
                }
                function se(t, e) {
                    const i = t[0] / t[3]
                      , n = t[1] / t[3];
                    return i >= -e[0] && i <= e[0] && n >= -e[1] && n <= e[1]
                }
                function ae(e, i, n, r, o, s, a, l, c, h) {
                    const u = n.transform
                      , d = r ? e.textSizeData : e.iconSizeData
                      , f = t.evaluateSizeForZoom(d, n.transform.zoom)
                      , p = "globe" === u.projection.name
                      , m = [256 / n.width * 2 + 1, 256 / n.height * 2 + 1]
                      , g = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
                    g.clear();
                    let _ = null;
                    p && (_ = r ? e.text.globeExtVertexArray : e.icon.globeExtVertexArray);
                    const y = e.lineVertexArray
                      , v = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray
                      , x = n.transform.width / n.transform.height;
                    let b, w = !1;
                    for (let r = 0; r < v.length; r++) {
                        const p = v.get(r)
                          , {numGlyphs: E, writingMode: T} = p;
                        if (T !== t.WritingMode.vertical || w || b === t.WritingMode.horizontal || (w = !0),
                        b = T,
                        (p.hidden || T === t.WritingMode.vertical) && !w) {
                            pe(E, g);
                            continue
                        }
                        w = !1;
                        const S = new t.Point(p.tileAnchorX,p.tileAnchorY);
                        let {x: C, y: A, z: I} = u.projection.projectTilePoint(S.x, S.y, h.canonical);
                        if (c) {
                            const [t,e,i] = c(S);
                            C += t,
                            A += e,
                            I += i
                        }
                        const M = [C, A, I, 1];
                        if (t.transformMat4$1(M, M, i),
                        !se(M, m)) {
                            pe(E, g);
                            continue
                        }
                        const P = oe(n.transform.cameraToCenterDistance, M[3])
                          , k = t.evaluateSizeForFeature(d, f, p)
                          , O = a ? k / P : k * P
                          , R = re(C, A, I, o);
                        if (R[3] <= 0) {
                            pe(E, g);
                            continue
                        }
                        let D = {};
                        const L = a ? null : c
                          , B = he(p, O, !1, l, i, o, s, e.glyphOffsetArray, y, g, _, R, S, D, x, L, u.projection, h, a);
                        w = B.useVertical,
                        L && B.needsFlipping && (D = {}),
                        (B.notEnoughRoom || w || B.needsFlipping && he(p, O, !0, l, i, o, s, e.glyphOffsetArray, y, g, _, R, S, D, x, L, u.projection, h, a).notEnoughRoom) && pe(E, g)
                    }
                    r ? (e.text.dynamicLayoutVertexBuffer.updateData(g),
                    _ && e.text.globeExtVertexBuffer.updateData(_)) : (e.icon.dynamicLayoutVertexBuffer.updateData(g),
                    _ && e.icon.globeExtVertexBuffer.updateData(_))
                }
                function le(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m) {
                    const {lineStartIndex: g, glyphStartIndex: _, segment: y} = a
                      , v = _ + a.numGlyphs
                      , x = g + a.lineLength
                      , b = e.getoffsetX(_)
                      , w = e.getoffsetX(v - 1)
                      , E = fe(t * b, i, n, r, o, s, y, g, x, l, c, h, u, d, !0, f, p, m);
                    if (!E)
                        return null;
                    const T = fe(t * w, i, n, r, o, s, y, g, x, l, c, h, u, d, !0, f, p, m);
                    return T ? {
                        first: E,
                        last: T
                    } : null
                }
                function ce(e, i, n, r) {
                    return e === t.WritingMode.horizontal && Math.abs(r) > Math.abs(n) ? {
                        useVertical: !0
                    } : e === t.WritingMode.vertical ? r > 0 ? {
                        needsFlipping: !0
                    } : null : i !== Qt.unknown && function(t, e) {
                        return 0 === t || Math.abs(e / t) > te
                    }(n, r) ? i === Qt.flipRequired ? {
                        needsFlipping: !0
                    } : null : n < 0 ? {
                        needsFlipping: !0
                    } : null
                }
                function he(e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y, v) {
                    const x = i / 24
                      , b = e.lineOffsetX * x
                      , w = e.lineOffsetY * x
                      , {lineStartIndex: E, glyphStartIndex: T, numGlyphs: S, segment: C, writingMode: A, flipState: I} = e
                      , M = E + e.lineLength
                      , P = e => {
                        if (u) {
                            const [i,n,r] = e.up
                              , o = h.length;
                            t.updateGlobeVertexNormal(u, o + 0, i, n, r),
                            t.updateGlobeVertexNormal(u, o + 1, i, n, r),
                            t.updateGlobeVertexNormal(u, o + 2, i, n, r),
                            t.updateGlobeVertexNormal(u, o + 3, i, n, r)
                        }
                        const [i,n,r] = e.point;
                        t.addDynamicAttributes(h, i, n, r, e.angle)
                    }
                    ;
                    if (S > 1) {
                        const t = le(x, l, b, w, n, d, f, e, c, s, p, g, !1, _, y, v);
                        if (!t)
                            return {
                                notEnoughRoom: !0
                            };
                        if (r && !n) {
                            let[i,n,r] = t.first.point
                              , [o,s,l] = t.last.point;
                            [i,n] = re(i, n, r, a),
                            [o,s] = re(o, s, l, a);
                            const c = ce(A, I, (o - i) * m, s - n);
                            if (e.flipState = c && c.needsFlipping ? Qt.flipRequired : Qt.flipNotRequired,
                            c)
                                return c
                        }
                        P(t.first);
                        for (let t = T + 1; t < T + S - 1; t++) {
                            const e = fe(x * l.getoffsetX(t), b, w, n, d, f, C, E, M, c, s, p, g, !1, !1, _, y, v);
                            if (!e)
                                return h.length -= 4 * (t - T),
                                {
                                    notEnoughRoom: !0
                                };
                            P(e)
                        }
                        P(t.last)
                    } else {
                        if (r && !n) {
                            const i = re(f.x, f.y, 0, o)
                              , n = E + C + 1
                              , r = new t.Point(c.getx(n),c.gety(n))
                              , s = re(r.x, r.y, 0, o)
                              , a = s[3] > 0 ? s : de(f, r, i, 1, o, void 0, _, y.canonical)
                              , l = ce(A, I, (a[0] - i[0]) * m, a[1] - i[1]);
                            if (e.flipState = l && l.needsFlipping ? Qt.flipRequired : Qt.flipNotRequired,
                            l)
                                return l
                        }
                        const i = fe(x * l.getoffsetX(T), b, w, n, d, f, C, E, M, c, s, p, g, !1, !1, _, y, v);
                        if (!i)
                            return {
                                notEnoughRoom: !0
                            };
                        P(i)
                    }
                    return {}
                }
                function ue(t, e, i, n, r) {
                    const {x: o, y: s, z: a} = n.projectTilePoint(t.x, t.y, e);
                    if (!r)
                        return re(o, s, a, i);
                    const [l,c,h] = r(t);
                    return re(o + l, s + c, a + h, i)
                }
                function de(e, i, n, r, o, s, a, l) {
                    const c = ue(e.sub(i)._unit()._add(e), l, o, a, s);
                    return t.sub(c, n, c),
                    t.normalize(c, c),
                    t.scaleAndAdd(c, n, c, r)
                }
                function fe(e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _, y) {
                    const v = r ? e - i : e + i;
                    let x = v > 0 ? 1 : -1
                      , b = 0;
                    r && (x *= -1,
                    b = Math.PI),
                    x < 0 && (b += Math.PI);
                    let w = l + a + (x > 0 ? 0 : 1) | 0
                      , E = o
                      , T = o
                      , S = 0
                      , C = 0;
                    const A = Math.abs(v)
                      , I = []
                      , M = [];
                    let P = s
                      , k = P;
                    const O = () => de(k, P, T, A - S + 1, u, f, g, _.canonical);
                    for (; S + C <= A; ) {
                        if (w += x,
                        w < l || w >= c)
                            return null;
                        if (T = E,
                        k = P,
                        I.push(T),
                        p && M.push(k),
                        P = new t.Point(h.getx(w),h.gety(w)),
                        E = d[w],
                        !E) {
                            const t = ue(P, _.canonical, u, g, f);
                            E = t[3] > 0 ? d[w] = t : O()
                        }
                        S += C,
                        C = t.distance(T, E)
                    }
                    m && f && (d[w] && (E = O(),
                    C = t.distance(T, E)),
                    d[w] = E);
                    const R = (A - S) / C
                      , D = P.sub(k)._mult(R)._add(k)
                      , L = t.sub([], E, T)
                      , B = t.scaleAndAdd([], T, L, R);
                    let z = [0, 0, 1]
                      , F = L[0]
                      , N = L[1];
                    if (y && (z = g.upVector(_.canonical, D.x, D.y),
                    0 !== z[0] || 0 !== z[1] || 1 !== z[2])) {
                        const e = [z[2], 0, -z[0]]
                          , i = t.cross([], z, e);
                        t.normalize(e, e),
                        t.normalize(i, i),
                        F = t.dot(L, e),
                        N = t.dot(L, i)
                    }
                    if (n) {
                        const e = t.cross([], z, L);
                        t.normalize(e, e),
                        t.scaleAndAdd(B, B, e, n * x)
                    }
                    const j = b + Math.atan2(N, F);
                    return I.push(B),
                    p && M.push(D),
                    {
                        point: B,
                        angle: j,
                        path: I,
                        tilePath: M,
                        up: z
                    }
                }
                function pe(t, e) {
                    const i = e.length
                      , n = i + 4 * t;
                    e.resize(n),
                    e.float32.fill(-1 / 0, 4 * i, 4 * n)
                }
                function me(t, e, i) {
                    const n = e[0]
                      , r = e[1];
                    return t[0] = i[0] * n + i[4] * r + i[12],
                    t[1] = i[1] * n + i[5] * r + i[13],
                    t[3] = i[3] * n + i[7] * r + i[15],
                    t
                }
                const ge = 100;
                class _e {
                    constructor(t, e, i=new Jt(t.width + 200,t.height + 200,25), n=new Jt(t.width + 200,t.height + 200,25)) {
                        this.transform = t,
                        this.grid = i,
                        this.ignoredGrid = n,
                        this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance,
                        this.screenRightBoundary = t.width + ge,
                        this.screenBottomBoundary = t.height + ge,
                        this.gridRightBoundary = t.width + 200,
                        this.gridBottomBoundary = t.height + 200,
                        this.fogState = e
                    }
                    placeCollisionBox(t, e, i, n, r, o, s, a) {
                        let l = i.projectedAnchorX
                          , c = i.projectedAnchorY
                          , h = i.projectedAnchorZ;
                        const u = i.elevation
                          , d = i.tileID
                          , f = t.getProjection();
                        if (u && d) {
                            const [t,e,n] = f.upVector(d.canonical, i.tileAnchorX, i.tileAnchorY)
                              , r = f.upVectorScale(d.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                            l += t * u * r,
                            c += e * u * r,
                            h += n * u * r
                        }
                        const p = this.projectAndGetPerspectiveRatio(s, l, c, h, i.tileID, "globe" === f.name || !!u || this.transform.pitch > 0, f)
                          , m = o * p.perspectiveRatio
                          , g = (i.x1 * e + n.x - i.padding) * m + p.point.x
                          , _ = (i.y1 * e + n.y - i.padding) * m + p.point.y
                          , y = (i.x2 * e + n.x + i.padding) * m + p.point.x
                          , v = (i.y2 * e + n.y + i.padding) * m + p.point.y
                          , x = p.perspectiveRatio <= .55 || p.occluded;
                        return !this.isInsideGrid(g, _, y, v) || !r && this.grid.hitTest(g, _, y, v, a) || x ? {
                            box: [],
                            offscreen: !1,
                            occluded: p.occluded
                        } : {
                            box: [g, _, y, v],
                            offscreen: this.isOffscreen(g, _, y, v),
                            occluded: !1
                        }
                    }
                    placeCollisionCircles(e, i, n, r, o, s, a, l, c, h, u, d, f, p, m) {
                        const g = []
                          , _ = this.transform.elevation
                          , y = e.getProjection()
                          , v = _ ? _.getAtTileOffsetFunc(m, this.transform.center.lat, this.transform.worldSize, y) : null
                          , x = new t.Point(n.tileAnchorX,n.tileAnchorY);
                        let {x: b, y: w, z: E} = y.projectTilePoint(x.x, x.y, m.canonical);
                        if (v) {
                            const [t,e,i] = v(x);
                            b += t,
                            w += e,
                            E += i
                        }
                        const T = "globe" === y.name
                          , S = this.projectAndGetPerspectiveRatio(a, b, w, E, m, T || !!_ || this.transform.pitch > 0, y)
                          , {perspectiveRatio: C} = S
                          , A = (u ? s / C : s * C) / t.ONE_EM
                          , I = re(b, w, E, l)
                          , M = S.signedDistanceFromCamera > 0 ? le(A, o, n.lineOffsetX * A, n.lineOffsetY * A, !1, I, x, n, r, l, {}, _ && !u ? v : null, u && !!_, y, m, u) : null;
                        let P = !1
                          , k = !1
                          , O = !0;
                        if (M && !S.occluded) {
                            const e = .5 * f * C + p
                              , n = new t.Point(-100,-100)
                              , r = new t.Point(this.screenRightBoundary,this.screenBottomBoundary)
                              , o = new Kt
                              , {first: s, last: a} = M
                              , l = s.path.length;
                            let u = [];
                            for (let t = l - 1; t >= 1; t--)
                                u.push(s.path[t]);
                            for (let t = 1; t < a.path.length; t++)
                                u.push(a.path[t]);
                            const m = 2.5 * e;
                            c && (u = u.map(( ([t,e,i], n) => (v && !T && (i = v(n < l - 1 ? s.tilePath[l - 1 - n] : a.tilePath[n - l + 2])[2]),
                            re(t, e, i, c)))),
                            u.some((t => t[3] <= 0)) && (u = []));
                            let _ = [];
                            if (u.length > 0) {
                                let e = 1 / 0
                                  , i = -1 / 0
                                  , o = 1 / 0
                                  , s = -1 / 0;
                                for (const t of u)
                                    e = Math.min(e, t[0]),
                                    o = Math.min(o, t[1]),
                                    i = Math.max(i, t[0]),
                                    s = Math.max(s, t[1]);
                                i >= n.x && e <= r.x && s >= n.y && o <= r.y && (_ = [u.map((e => new t.Point(e[0],e[1])))],
                                (e < n.x || i > r.x || o < n.y || s > r.y) && (_ = t.clipLine(_, n.x, n.y, r.x, r.y)))
                            }
                            for (const t of _) {
                                o.reset(t, .25 * e);
                                let n = 0;
                                n = o.length <= .5 * e ? 1 : Math.ceil(o.paddedLength / m) + 1;
                                for (let t = 0; t < n; t++) {
                                    const r = t / Math.max(n - 1, 1)
                                      , s = o.lerp(r)
                                      , a = s.x + ge
                                      , l = s.y + ge;
                                    g.push(a, l, e, 0);
                                    const c = a - e
                                      , u = l - e
                                      , f = a + e
                                      , p = l + e;
                                    if (O = O && this.isOffscreen(c, u, f, p),
                                    k = k || this.isInsideGrid(c, u, f, p),
                                    !i && this.grid.hitTestCircle(a, l, e, d) && (P = !0,
                                    !h))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: P,
                                            occluded: !1
                                        }
                                }
                            }
                        }
                        return {
                            circles: !h && P || !k ? [] : g,
                            offscreen: O,
                            collisionDetected: P,
                            occluded: S.occluded
                        }
                    }
                    queryRenderedSymbols(e) {
                        if (0 === e.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                            return {};
                        const i = [];
                        let n = 1 / 0
                          , r = 1 / 0
                          , o = -1 / 0
                          , s = -1 / 0;
                        for (const a of e) {
                            const e = new t.Point(a.x + ge,a.y + ge);
                            n = Math.min(n, e.x),
                            r = Math.min(r, e.y),
                            o = Math.max(o, e.x),
                            s = Math.max(s, e.y),
                            i.push(e)
                        }
                        const a = this.grid.query(n, r, o, s).concat(this.ignoredGrid.query(n, r, o, s))
                          , l = {}
                          , c = {};
                        for (const e of a) {
                            const n = e.key;
                            if (void 0 === l[n.bucketInstanceId] && (l[n.bucketInstanceId] = {}),
                            l[n.bucketInstanceId][n.featureIndex])
                                continue;
                            const r = [new t.Point(e.x1,e.y1), new t.Point(e.x2,e.y1), new t.Point(e.x2,e.y2), new t.Point(e.x1,e.y2)];
                            t.polygonIntersectsPolygon(i, r) && (l[n.bucketInstanceId][n.featureIndex] = !0,
                            void 0 === c[n.bucketInstanceId] && (c[n.bucketInstanceId] = []),
                            c[n.bucketInstanceId].push(n.featureIndex))
                        }
                        return c
                    }
                    insertCollisionBox(t, e, i, n, r) {
                        (e ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: i,
                            featureIndex: n,
                            collisionGroupID: r
                        }, t[0], t[1], t[2], t[3])
                    }
                    insertCollisionCircles(t, e, i, n, r) {
                        const o = e ? this.ignoredGrid : this.grid
                          , s = {
                            bucketInstanceId: i,
                            featureIndex: n,
                            collisionGroupID: r
                        };
                        for (let e = 0; e < t.length; e += 4)
                            o.insertCircle(s, t[e], t[e + 1], t[e + 2])
                    }
                    projectAndGetPerspectiveRatio(e, i, n, r, o, s, a) {
                        const l = [i, n, r, 1];
                        let c = !1;
                        if (r || this.transform.pitch > 0) {
                            if (t.transformMat4$1(l, l, e),
                            this.fogState && o && "globe" !== a.name) {
                                const e = function(e, i, n, r, o, s) {
                                    const a = s.calculateFogTileMatrix(o)
                                      , l = [i, n, r];
                                    return t.transformMat4(l, l, a),
                                    C(e, l, s.pitch, s._fov)
                                }(this.fogState, i, n, r, o.toUnwrapped(), this.transform);
                                c = e > .9
                            }
                        } else
                            me(l, l, e);
                        const h = l[3];
                        return {
                            point: new t.Point((l[0] / h + 1) / 2 * this.transform.width + ge,(-l[1] / h + 1) / 2 * this.transform.height + ge),
                            perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),
                            signedDistanceFromCamera: h,
                            occluded: s && l[2] > h || c
                        }
                    }
                    isOffscreen(t, e, i, n) {
                        return i < ge || t >= this.screenRightBoundary || n < ge || e > this.screenBottomBoundary
                    }
                    isInsideGrid(t, e, i, n) {
                        return i >= 0 && t < this.gridRightBoundary && n >= 0 && e < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const e = t.identity([]);
                        return t.translate(e, e, [-100, -100, 0]),
                        e
                    }
                }
                function ye(e, i, n) {
                    const r = i.createTileMatrix(e, e.worldSize, n.toUnwrapped());
                    return t.multiply(new Float32Array(16), e.projMatrix, r)
                }
                function ve(t, e, i) {
                    if (e.projection.name === i.projection.name)
                        return t.projMatrix;
                    const n = i.clone();
                    return n.setProjection(e.projection),
                    ye(n, e.getProjection(), t)
                }
                function xe(t, e, i) {
                    return e.name === i.projection.name ? t.projMatrix : ye(i, e, t)
                }
                class be {
                    constructor(t, e, i, n) {
                        this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? e : -e))) : n && i ? 1 : 0,
                        this.placed = i
                    }
                    isHidden() {
                        return 0 === this.opacity && !this.placed
                    }
                }
                class we {
                    constructor(t, e, i, n, r, o=!1) {
                        this.text = new be(t ? t.text : null,e,i,r),
                        this.icon = new be(t ? t.icon : null,e,n,r),
                        this.clipped = o
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class Ee {
                    constructor(t, e, i, n=!1) {
                        this.text = t,
                        this.icon = e,
                        this.skipFade = i,
                        this.clipped = n
                    }
                }
                class Te {
                    constructor() {
                        this.invProjMatrix = t.create(),
                        this.viewportMatrix = t.create(),
                        this.circles = []
                    }
                }
                class Se {
                    constructor(t, e, i, n, r) {
                        this.bucketInstanceId = t,
                        this.featureIndex = e,
                        this.sourceLayerIndex = i,
                        this.bucketIndex = n,
                        this.tileID = r
                    }
                }
                class Ce {
                    constructor(t) {
                        this.crossSourceCollisions = t,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(t) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[t]) {
                            const e = ++this.maxGroupID;
                            this.collisionGroups[t] = {
                                ID: e,
                                predicate: t => t.collisionGroupID === e
                            }
                        }
                        return this.collisionGroups[t]
                    }
                }
                function Ae(e, i, n, r, o) {
                    const {horizontalAlign: s, verticalAlign: a} = t.getAnchorAlignment(e)
                      , l = -(s - .5) * i
                      , c = -(a - .5) * n
                      , h = t.evaluateVariableOffset(e, r);
                    return new t.Point(l + h[0] * o,c + h[1] * o)
                }
                function Ie(e, i, n, r, o) {
                    const s = new t.Point(e,i);
                    return n && s._rotate(r ? o : -o),
                    s
                }
                class Me {
                    constructor(t, e, i, n, r) {
                        this.transform = t.clone(),
                        this.projection = t.projection.name,
                        this.collisionIndex = new _e(this.transform,r),
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = e,
                        this.retainedQueryData = {},
                        this.collisionGroups = new Ce(i),
                        this.collisionCircleArrays = {},
                        this.prevPlacement = n,
                        n && (n.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    getBucketParts(e, i, n, r) {
                        const o = n.getBucket(i)
                          , s = n.latestFeatureIndex;
                        if (!o || !s || i.id !== o.layerIds[0])
                            return;
                        const a = o.layers[0].layout
                          , l = n.collisionBoxArray
                          , c = Math.pow(2, this.transform.zoom - n.tileID.overscaledZ)
                          , h = n.tileSize / t.EXTENT
                          , u = n.tileID.toUnwrapped();
                        this.transform.setProjection(o.projection);
                        const d = (f = n.tileID,
                        p = o.getProjection(),
                        m = this.transform,
                        p.name === this.projection ? m.calculateProjMatrix(f.toUnwrapped()) : ye(m, p, f));
                        var f, p, m;
                        const g = "map" === a.get("text-pitch-alignment")
                          , _ = "map" === a.get("text-rotation-alignment");
                        i.compileFilter();
                        const y = i.dynamicFilter()
                          , v = i.dynamicFilterNeedsFeature()
                          , x = this.transform.calculatePixelsToTileUnitsMatrix(n)
                          , b = ie(d, n.tileID.canonical, g, _, this.transform, o.getProjection(), x);
                        let w = null;
                        if (g) {
                            const e = ne(d, n.tileID.canonical, g, _, this.transform, o.getProjection(), x);
                            w = t.multiply([], this.transform.labelPlaneMatrix, e)
                        }
                        let E = null;
                        y && n.latestFeatureIndex && (E = {
                            unwrappedTileID: u,
                            dynamicFilter: y,
                            dynamicFilterNeedsFeature: v,
                            featureIndex: n.latestFeatureIndex
                        }),
                        this.retainedQueryData[o.bucketInstanceId] = new Se(o.bucketInstanceId,s,o.sourceLayerIndex,o.index,n.tileID);
                        const T = {
                            bucket: o,
                            layout: a,
                            posMatrix: d,
                            textLabelPlaneMatrix: b,
                            labelToScreenMatrix: w,
                            clippingData: E,
                            scale: c,
                            textPixelRatio: h,
                            holdingForFade: n.holdingForFade(),
                            collisionBoxArray: l,
                            partiallyEvaluatedTextSize: t.evaluateSizeForZoom(o.textSizeData, this.transform.zoom),
                            partiallyEvaluatedIconSize: t.evaluateSizeForZoom(o.iconSizeData, this.transform.zoom),
                            collisionGroup: this.collisionGroups.get(o.sourceID)
                        };
                        if (r)
                            for (const t of o.sortKeyRanges) {
                                const {sortKey: i, symbolInstanceStart: n, symbolInstanceEnd: r} = t;
                                e.push({
                                    sortKey: i,
                                    symbolInstanceStart: n,
                                    symbolInstanceEnd: r,
                                    parameters: T
                                })
                            }
                        else
                            e.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: o.symbolInstances.length,
                                parameters: T
                            })
                    }
                    attemptAnchorPlacement(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _) {
                        const {textOffset0: y, textOffset1: v, crossTileID: x} = u
                          , b = [y, v]
                          , w = Ae(t, i, n, b, r)
                          , E = this.collisionIndex.placeCollisionBox(f, r, e, Ie(w.x, w.y, o, s, this.transform.angle), h, a, l, c.predicate);
                        if (m) {
                            const t = f.getSymbolInstanceIconSize(_, this.transform.zoom, u.placedIconSymbolIndex);
                            if (0 === this.collisionIndex.placeCollisionBox(f, t, m, Ie(w.x, w.y, o, s, this.transform.angle), h, a, l, c.predicate).box.length)
                                return
                        }
                        if (E.box.length > 0) {
                            let e;
                            return this.prevPlacement && this.prevPlacement.variableOffsets[x] && this.prevPlacement.placements[x] && this.prevPlacement.placements[x].text && (e = this.prevPlacement.variableOffsets[x].anchor),
                            this.variableOffsets[x] = {
                                textOffset: b,
                                width: i,
                                height: n,
                                anchor: t,
                                textScale: r,
                                prevAnchor: e
                            },
                            this.markUsedJustification(f, t, u, p),
                            f.allowVerticalPlacement && (this.markUsedOrientation(f, p, u),
                            this.placedOrientations[x] = p),
                            {
                                shift: w,
                                placedGlyphBoxes: E
                            }
                        }
                    }
                    placeLayerBucketPart(e, i, n, r) {
                        const {bucket: o, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: h, textPixelRatio: u, holdingForFade: d, collisionBoxArray: f, partiallyEvaluatedTextSize: p, partiallyEvaluatedIconSize: m, collisionGroup: g} = e.parameters
                          , _ = s.get("text-optional")
                          , y = s.get("icon-optional")
                          , v = s.get("text-allow-overlap")
                          , x = s.get("icon-allow-overlap")
                          , b = "map" === s.get("text-rotation-alignment")
                          , w = "map" === s.get("text-pitch-alignment")
                          , E = "none" !== s.get("icon-text-fit")
                          , T = "viewport-y" === s.get("symbol-z-order");
                        this.transform.setProjection(o.projection);
                        let S = v && (x || !o.hasIconData() || y)
                          , C = x && (v || !o.hasTextData() || _);
                        !o.collisionArrays && f && o.deserializeCollisionBoxes(f),
                        n && r && o.updateCollisionDebugBuffers(this.transform.zoom, f);
                        const A = (e, r, f) => {
                            const {crossTileID: T, numVerticalGlyphVertices: A} = e;
                            if (h) {
                                const n = {
                                    zoom: this.transform.zoom,
                                    pitch: this.transform.pitch
                                };
                                let r = null;
                                if (h.dynamicFilterNeedsFeature) {
                                    const t = this.retainedQueryData[o.bucketInstanceId];
                                    r = h.featureIndex.loadFeature({
                                        featureIndex: e.featureIndex,
                                        bucketIndex: t.bucketIndex,
                                        sourceLayerIndex: t.sourceLayerIndex,
                                        layoutVertexArrayOffset: 0
                                    })
                                }
                                if (!(0,
                                h.dynamicFilter)(n, r, this.retainedQueryData[o.bucketInstanceId].tileID.canonical, new t.Point(e.tileAnchorX,e.tileAnchorY), this.transform.calculateDistanceTileData(h.unwrappedTileID)))
                                    return this.placements[T] = new Ee(!1,!1,!1,!0),
                                    void i.add(T)
                            }
                            if (i.has(T))
                                return;
                            if (d)
                                return void (this.placements[T] = new Ee(!1,!1,!1));
                            let I = !1
                              , M = !1
                              , P = !0
                              , k = !1
                              , O = !1
                              , R = null
                              , D = {
                                box: null,
                                offscreen: null,
                                occluded: null
                            }
                              , L = {
                                box: null,
                                offscreen: null,
                                occluded: null
                            }
                              , B = null
                              , z = null
                              , F = null
                              , N = 0
                              , j = 0
                              , U = 0;
                            f.textFeatureIndex ? N = f.textFeatureIndex : e.useRuntimeCollisionCircles && (N = e.featureIndex),
                            f.verticalTextFeatureIndex && (j = f.verticalTextFeatureIndex);
                            const V = t => {
                                t.tileID = this.retainedQueryData[o.bucketInstanceId].tileID;
                                const e = this.transform.elevation;
                                (e || t.elevation) && (t.elevation = e ? e.getAtTileOffset(t.tileID, t.tileAnchorX, t.tileAnchorY) : 0)
                            }
                              , G = f.textBox;
                            if (G) {
                                V(G);
                                const i = i => {
                                    let n = t.WritingMode.horizontal;
                                    if (o.allowVerticalPlacement && !i && this.prevPlacement) {
                                        const t = this.prevPlacement.placedOrientations[T];
                                        t && (this.placedOrientations[T] = t,
                                        n = t,
                                        this.markUsedOrientation(o, n, e))
                                    }
                                    return n
                                }
                                  , n = (e, i) => {
                                    if (o.allowVerticalPlacement && A > 0 && f.verticalTextBox) {
                                        for (const n of o.writingModes)
                                            if (n === t.WritingMode.vertical ? (D = i(),
                                            L = D) : D = e(),
                                            D && D.box && D.box.length)
                                                break
                                    } else
                                        D = e()
                                }
                                ;
                                if (s.get("text-variable-anchor")) {
                                    let l = s.get("text-variable-anchor");
                                    if (this.prevPlacement && this.prevPlacement.variableOffsets[T]) {
                                        const t = this.prevPlacement.variableOffsets[T];
                                        l.indexOf(t.anchor) > 0 && (l = l.filter((e => e !== t.anchor)),
                                        l.unshift(t.anchor))
                                    }
                                    const c = (t, i, n) => {
                                        const s = o.getSymbolInstanceTextSize(p, e, this.transform.zoom, r)
                                          , c = (t.x2 - t.x1) * s + 2 * t.padding
                                          , h = (t.y2 - t.y1) * s + 2 * t.padding
                                          , d = E && !x ? i : null;
                                        d && V(d);
                                        let f = {
                                            box: [],
                                            offscreen: !1,
                                            occluded: !1
                                        };
                                        const _ = v ? 2 * l.length : l.length;
                                        for (let i = 0; i < _; ++i) {
                                            const _ = this.attemptAnchorPlacement(l[i % l.length], t, c, h, s, b, w, u, a, g, i >= l.length, e, r, o, n, d, p, m);
                                            if (_ && (f = _.placedGlyphBoxes,
                                            f && f.box && f.box.length)) {
                                                I = !0,
                                                R = _.shift;
                                                break
                                            }
                                        }
                                        return f
                                    }
                                    ;
                                    n(( () => c(G, f.iconBox, t.WritingMode.horizontal)), ( () => {
                                        const e = f.verticalTextBox;
                                        return e && V(e),
                                        o.allowVerticalPlacement && !(D && D.box && D.box.length) && A > 0 && e ? c(e, f.verticalIconBox, t.WritingMode.vertical) : {
                                            box: null,
                                            offscreen: null,
                                            occluded: null
                                        }
                                    }
                                    )),
                                    D && (I = D.box,
                                    P = D.offscreen,
                                    k = D.occluded);
                                    const h = i(!(!D || !D.box));
                                    if (!I && this.prevPlacement) {
                                        const t = this.prevPlacement.variableOffsets[T];
                                        t && (this.variableOffsets[T] = t,
                                        this.markUsedJustification(o, t.anchor, e, h))
                                    }
                                } else {
                                    const s = (i, n) => {
                                        const s = o.getSymbolInstanceTextSize(p, e, this.transform.zoom, r)
                                          , l = this.collisionIndex.placeCollisionBox(o, s, i, new t.Point(0,0), v, u, a, g.predicate);
                                        return l && l.box && l.box.length && (this.markUsedOrientation(o, n, e),
                                        this.placedOrientations[T] = n),
                                        l
                                    }
                                    ;
                                    n(( () => s(G, t.WritingMode.horizontal)), ( () => {
                                        const e = f.verticalTextBox;
                                        return o.allowVerticalPlacement && A > 0 && e ? (V(e),
                                        s(e, t.WritingMode.vertical)) : {
                                            box: null,
                                            offscreen: null,
                                            occluded: null
                                        }
                                    }
                                    )),
                                    i(!!(D && D.box && D.box.length))
                                }
                            }
                            if (B = D,
                            I = B && B.box && B.box.length > 0,
                            P = B && B.offscreen,
                            k = B && B.occluded,
                            e.useRuntimeCollisionCircles) {
                                const i = o.text.placedSymbolArray.get(e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex)
                                  , r = t.evaluateSizeForFeature(o.textSizeData, p, i)
                                  , h = s.get("text-padding");
                                z = this.collisionIndex.placeCollisionCircles(o, v, i, o.lineVertexArray, o.glyphOffsetArray, r, a, l, c, n, w, g.predicate, e.collisionCircleDiameter * r / t.ONE_EM, h, this.retainedQueryData[o.bucketInstanceId].tileID),
                                I = v || z.circles.length > 0 && !z.collisionDetected,
                                P = P && z.offscreen,
                                k = z.occluded
                            }
                            if (f.iconFeatureIndex && (U = f.iconFeatureIndex),
                            f.iconBox) {
                                const i = i => {
                                    V(i);
                                    const n = E && R ? Ie(R.x, R.y, b, w, this.transform.angle) : new t.Point(0,0)
                                      , r = o.getSymbolInstanceIconSize(m, this.transform.zoom, e.placedIconSymbolIndex);
                                    return this.collisionIndex.placeCollisionBox(o, r, i, n, x, u, a, g.predicate)
                                }
                                ;
                                L && L.box && L.box.length && f.verticalIconBox ? (F = i(f.verticalIconBox),
                                M = F.box.length > 0) : (F = i(f.iconBox),
                                M = F.box.length > 0),
                                P = P && F.offscreen,
                                O = F.occluded
                            }
                            const Z = _ || 0 === e.numHorizontalGlyphVertices && 0 === A
                              , q = y || 0 === e.numIconVertices;
                            if (Z || q ? q ? Z || (M = M && I) : I = M && I : M = I = M && I,
                            I && B && B.box && this.collisionIndex.insertCollisionBox(B.box, s.get("text-ignore-placement"), o.bucketInstanceId, L && L.box && j ? j : N, g.ID),
                            M && F && this.collisionIndex.insertCollisionBox(F.box, s.get("icon-ignore-placement"), o.bucketInstanceId, U, g.ID),
                            z && (I && this.collisionIndex.insertCollisionCircles(z.circles, s.get("text-ignore-placement"), o.bucketInstanceId, N, g.ID),
                            n)) {
                                const t = o.bucketInstanceId;
                                let e = this.collisionCircleArrays[t];
                                void 0 === e && (e = this.collisionCircleArrays[t] = new Te);
                                for (let t = 0; t < z.circles.length; t += 4)
                                    e.circles.push(z.circles[t + 0]),
                                    e.circles.push(z.circles[t + 1]),
                                    e.circles.push(z.circles[t + 2]),
                                    e.circles.push(z.collisionDetected ? 1 : 0)
                            }
                            const W = "globe" !== o.projection.name;
                            S = S && (W || !k),
                            C = C && (W || !O),
                            this.placements[T] = new Ee(I || S,M || C,P || o.justReloaded),
                            i.add(T)
                        }
                        ;
                        if (T) {
                            const t = o.getSortedSymbolIndexes(this.transform.angle);
                            for (let e = t.length - 1; e >= 0; --e) {
                                const i = t[e];
                                A(o.symbolInstances.get(i), i, o.collisionArrays[i])
                            }
                        } else
                            for (let t = e.symbolInstanceStart; t < e.symbolInstanceEnd; t++)
                                A(o.symbolInstances.get(t), t, o.collisionArrays[t]);
                        if (n && o.bucketInstanceId in this.collisionCircleArrays) {
                            const e = this.collisionCircleArrays[o.bucketInstanceId];
                            t.invert(e.invProjMatrix, a),
                            e.viewportMatrix = this.collisionIndex.getViewportMatrix()
                        }
                        o.justReloaded = !1
                    }
                    markUsedJustification(e, i, n, r) {
                        const {leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c} = n
                          , h = t.getAnchorJustification(i)
                          , u = r === t.WritingMode.vertical ? l : "left" === h ? o : "center" === h ? s : "right" === h ? a : -1;
                        o >= 0 && (e.text.placedSymbolArray.get(o).crossTileID = u >= 0 && o !== u ? 0 : c),
                        s >= 0 && (e.text.placedSymbolArray.get(s).crossTileID = u >= 0 && s !== u ? 0 : c),
                        a >= 0 && (e.text.placedSymbolArray.get(a).crossTileID = u >= 0 && a !== u ? 0 : c),
                        l >= 0 && (e.text.placedSymbolArray.get(l).crossTileID = u >= 0 && l !== u ? 0 : c)
                    }
                    markUsedOrientation(e, i, n) {
                        const r = i === t.WritingMode.horizontal || i === t.WritingMode.horizontalOnly ? i : 0
                          , o = i === t.WritingMode.vertical ? i : 0
                          , {leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c} = n
                          , h = e.text.placedSymbolArray;
                        s >= 0 && (h.get(s).placedOrientation = r),
                        a >= 0 && (h.get(a).placedOrientation = r),
                        l >= 0 && (h.get(l).placedOrientation = r),
                        c >= 0 && (h.get(c).placedOrientation = o)
                    }
                    commit(t) {
                        this.commitTime = t,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const e = this.prevPlacement;
                        let i = !1;
                        this.prevZoomAdjustment = e ? e.zoomAdjustment(this.transform.zoom) : 0;
                        const n = e ? e.symbolFadeChange(t) : 1
                          , r = e ? e.opacities : {}
                          , o = e ? e.variableOffsets : {}
                          , s = e ? e.placedOrientations : {};
                        for (const t in this.placements) {
                            const e = this.placements[t]
                              , o = r[t];
                            o ? (this.opacities[t] = new we(o,n,e.text,e.icon,null,e.clipped),
                            i = i || e.text !== o.text.placed || e.icon !== o.icon.placed) : (this.opacities[t] = new we(null,n,e.text,e.icon,e.skipFade,e.clipped),
                            i = i || e.text || e.icon)
                        }
                        for (const t in r) {
                            const e = r[t];
                            if (!this.opacities[t]) {
                                const r = new we(e,n,!1,!1);
                                r.isHidden() || (this.opacities[t] = r,
                                i = i || e.text.placed || e.icon.placed)
                            }
                        }
                        for (const t in o)
                            this.variableOffsets[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.variableOffsets[t] = o[t]);
                        for (const t in s)
                            this.placedOrientations[t] || !this.opacities[t] || this.opacities[t].isHidden() || (this.placedOrientations[t] = s[t]);
                        i ? this.lastPlacementChangeTime = t : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e ? e.lastPlacementChangeTime : t)
                    }
                    updateLayerOpacities(t, e) {
                        const i = new Set;
                        for (const n of e) {
                            const e = n.getBucket(t);
                            e && n.latestFeatureIndex && t.id === e.layerIds[0] && this.updateBucketOpacities(e, i, n.collisionBoxArray)
                        }
                    }
                    updateBucketOpacities(e, i, n) {
                        e.hasTextData() && e.text.opacityVertexArray.clear(),
                        e.hasIconData() && e.icon.opacityVertexArray.clear(),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                        const r = e.layers[0].layout
                          , o = !!e.layers[0].dynamicFilter()
                          , s = new we(null,0,!1,!1,!0)
                          , a = r.get("text-allow-overlap")
                          , l = r.get("icon-allow-overlap")
                          , c = r.get("text-variable-anchor")
                          , h = "map" === r.get("text-rotation-alignment")
                          , u = "map" === r.get("text-pitch-alignment")
                          , d = "none" !== r.get("icon-text-fit")
                          , f = new we(null,0,a && (l || !e.hasIconData() || r.get("icon-optional")),l && (a || !e.hasTextData() || r.get("text-optional")),!0);
                        !e.collisionArrays && n && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(n);
                        const p = (t, e, i) => {
                            for (let n = 0; n < e / 4; n++)
                                t.opacityVertexArray.emplaceBack(i)
                        }
                        ;
                        let m = 0;
                        for (let n = 0; n < e.symbolInstances.length; n++) {
                            const r = e.symbolInstances.get(n)
                              , {numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, crossTileID: g, numIconVertices: _} = r
                              , y = i.has(g);
                            let v = this.opacities[g];
                            y ? v = s : v || (v = f,
                            this.opacities[g] = v),
                            i.add(g);
                            const x = a > 0 || l > 0
                              , b = _ > 0
                              , w = this.placedOrientations[g]
                              , E = w === t.WritingMode.vertical
                              , T = w === t.WritingMode.horizontal || w === t.WritingMode.horizontalOnly;
                            if (!x && !b || v.isHidden() || m++,
                            x) {
                                const t = Fe(v.text);
                                p(e.text, a, E ? Ne : t),
                                p(e.text, l, T ? Ne : t);
                                const i = v.text.isHidden()
                                  , {leftJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: o, rightJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: c} = r
                                  , h = e.text.placedSymbolArray
                                  , u = i || E ? 1 : 0;
                                n >= 0 && (h.get(n).hidden = u),
                                o >= 0 && (h.get(o).hidden = u),
                                s >= 0 && (h.get(s).hidden = u),
                                c >= 0 && (h.get(c).hidden = i || T ? 1 : 0);
                                const d = this.variableOffsets[g];
                                d && this.markUsedJustification(e, d.anchor, r, w);
                                const f = this.placedOrientations[g];
                                f && (this.markUsedJustification(e, "left", r, f),
                                this.markUsedOrientation(e, f, r))
                            }
                            if (b) {
                                const t = Fe(v.icon)
                                  , {placedIconSymbolIndex: i, verticalPlacedIconSymbolIndex: n} = r
                                  , o = e.icon.placedSymbolArray
                                  , s = v.icon.isHidden() ? 1 : 0;
                                i >= 0 && (p(e.icon, _, E ? Ne : t),
                                o.get(i).hidden = s),
                                n >= 0 && (p(e.icon, r.numVerticalIconVertices, T ? Ne : t),
                                o.get(n).hidden = s)
                            }
                            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                                const i = e.collisionArrays[n];
                                if (i) {
                                    let n = new t.Point(0,0)
                                      , r = !0;
                                    if (i.textBox || i.verticalTextBox) {
                                        if (c) {
                                            const t = this.variableOffsets[g];
                                            t ? (n = Ae(t.anchor, t.width, t.height, t.textOffset, t.textScale),
                                            h && n._rotate(u ? this.transform.angle : -this.transform.angle)) : r = !1
                                        }
                                        o && (r = !v.clipped),
                                        i.textBox && Pe(e.textCollisionBox.collisionVertexArray, v.text.placed, !r || E, n.x, n.y),
                                        i.verticalTextBox && Pe(e.textCollisionBox.collisionVertexArray, v.text.placed, !r || T, n.x, n.y)
                                    }
                                    const s = r && Boolean(!T && i.verticalIconBox);
                                    i.iconBox && Pe(e.iconCollisionBox.collisionVertexArray, v.icon.placed, s, d ? n.x : 0, d ? n.y : 0),
                                    i.verticalIconBox && Pe(e.iconCollisionBox.collisionVertexArray, v.icon.placed, !s, d ? n.x : 0, d ? n.y : 0)
                                }
                            }
                        }
                        if (e.fullyClipped = 0 === m,
                        e.sortFeatures(this.transform.angle),
                        this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                        e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                        e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                        e.bucketInstanceId in this.collisionCircleArrays) {
                            const t = this.collisionCircleArrays[e.bucketInstanceId];
                            e.placementInvProjMatrix = t.invProjMatrix,
                            e.placementViewportMatrix = t.viewportMatrix,
                            e.collisionCircleArray = t.circles,
                            delete this.collisionCircleArrays[e.bucketInstanceId]
                        }
                    }
                    symbolFadeChange(t) {
                        return 0 === this.fadeDuration ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(t) {
                        return Math.max(0, (this.transform.zoom - t) / 1.5)
                    }
                    hasTransitions(t) {
                        return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(t, e) {
                        const i = this.zoomAtLastRecencyCheck === e ? 1 - this.zoomAdjustment(e) : 1;
                        return this.zoomAtLastRecencyCheck = e,
                        this.commitTime + this.fadeDuration * i > t
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function Pe(t, e, i, n, r) {
                    t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, r || 0),
                    t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, r || 0),
                    t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, r || 0),
                    t.emplaceBack(e ? 1 : 0, i ? 1 : 0, n || 0, r || 0)
                }
                const ke = Math.pow(2, 25)
                  , Oe = Math.pow(2, 24)
                  , Re = Math.pow(2, 17)
                  , De = Math.pow(2, 16)
                  , Le = Math.pow(2, 9)
                  , Be = Math.pow(2, 8)
                  , ze = Math.pow(2, 1);
                function Fe(t) {
                    if (0 === t.opacity && !t.placed)
                        return 0;
                    if (1 === t.opacity && t.placed)
                        return 4294967295;
                    const e = t.placed ? 1 : 0
                      , i = Math.floor(127 * t.opacity);
                    return i * ke + e * Oe + i * Re + e * De + i * Le + e * Be + i * ze + e
                }
                const Ne = 0;
                class je {
                    constructor(t) {
                        this._sortAcrossTiles = "viewport-y" !== t.layout.get("symbol-z-order") && void 0 !== t.layout.get("symbol-sort-key").constantOr(1),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = new Set,
                        this._bucketParts = []
                    }
                    continuePlacement(t, e, i, n, r) {
                        const o = this._bucketParts;
                        for (; this._currentTileIndex < t.length; )
                            if (e.getBucketParts(o, n, t[this._currentTileIndex], this._sortAcrossTiles),
                            this._currentTileIndex++,
                            r())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        o.sort(( (t, e) => t.sortKey - e.sortKey))); this._currentPartIndex < o.length; ) {
                            const t = o[this._currentPartIndex];
                            if (e.placeLayerBucketPart(t, this._seenCrossTileIDs, i, 0 === t.symbolInstanceStart),
                            this._currentPartIndex++,
                            r())
                                return !0
                        }
                        return !1
                    }
                }
                class Ue {
                    constructor(t, e, i, n, r, o, s, a) {
                        this.placement = new Me(t,r,o,s,a),
                        this._currentPlacementIndex = e.length - 1,
                        this._forceFullPlacement = i,
                        this._showCollisionBoxes = n,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(e, i, n) {
                        const r = t.exported.now()
                          , o = () => {
                            const e = t.exported.now() - r;
                            return !this._forceFullPlacement && e > 2
                        }
                        ;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const t = i[e[this._currentPlacementIndex]]
                              , r = this.placement.collisionIndex.transform.zoom;
                            if ("symbol" === t.type && (!t.minzoom || t.minzoom <= r) && (!t.maxzoom || t.maxzoom > r)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new je(t)),
                                this._inProgressLayer.continuePlacement(n[t.source], this.placement, this._showCollisionBoxes, t, o))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(t) {
                        return this.placement.commit(t),
                        this.placement
                    }
                }
                const Ve = 512 / t.EXTENT / 2;
                class Ge {
                    constructor(e, i, n) {
                        this.tileID = e,
                        this.bucketInstanceId = n,
                        this.index = new t.KDBush(i.length,16,Int32Array),
                        this.keys = [],
                        this.crossTileIDs = [];
                        const r = e.canonical.x * t.EXTENT
                          , o = e.canonical.y * t.EXTENT;
                        for (let t = 0; t < i.length; t++) {
                            const {key: e, crossTileID: n, tileAnchorX: s, tileAnchorY: a} = i.get(t)
                              , l = Math.floor((r + s) * Ve)
                              , c = Math.floor((o + a) * Ve);
                            this.index.add(l, c),
                            this.keys.push(e),
                            this.crossTileIDs.push(n)
                        }
                        this.index.finish()
                    }
                    findMatches(e, i, n) {
                        const r = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z)
                          , o = Ve / Math.pow(2, i.canonical.z - this.tileID.canonical.z)
                          , s = i.canonical.x * t.EXTENT
                          , a = i.canonical.y * t.EXTENT;
                        for (let t = 0; t < e.length; t++) {
                            const i = e.get(t);
                            if (i.crossTileID)
                                continue;
                            const {key: l, tileAnchorX: c, tileAnchorY: h} = i
                              , u = Math.floor((s + c) * o)
                              , d = Math.floor((a + h) * o)
                              , f = this.index.range(u - r, d - r, u + r, d + r);
                            for (const t of f) {
                                const e = this.crossTileIDs[t];
                                if (this.keys[t] === l && !n.has(e)) {
                                    n.add(e),
                                    i.crossTileID = e;
                                    break
                                }
                            }
                        }
                    }
                }
                class Ze {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class qe {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(t) {
                        const e = Math.round((t - this.lng) / 360);
                        if (0 !== e)
                            for (const t in this.indexes) {
                                const i = this.indexes[t]
                                  , n = {};
                                for (const t in i) {
                                    const r = i[t];
                                    r.tileID = r.tileID.unwrapTo(r.tileID.wrap + e),
                                    n[r.tileID.key] = r
                                }
                                this.indexes[t] = n
                            }
                        this.lng = t
                    }
                    addBucket(t, e, i) {
                        if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
                            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === e.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key])
                        }
                        for (let t = 0; t < e.symbolInstances.length; t++)
                            e.symbolInstances.get(t).crossTileID = 0;
                        this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = new Set);
                        const n = this.usedCrossTileIDs[t.overscaledZ];
                        for (const i in this.indexes) {
                            const r = this.indexes[i];
                            if (Number(i) > t.overscaledZ)
                                for (const i in r) {
                                    const o = r[i];
                                    o.tileID.isChildOf(t) && o.findMatches(e.symbolInstances, t, n)
                                }
                            else {
                                const o = r[t.scaledTo(Number(i)).key];
                                o && o.findMatches(e.symbolInstances, t, n)
                            }
                        }
                        for (let t = 0; t < e.symbolInstances.length; t++) {
                            const r = e.symbolInstances.get(t);
                            r.crossTileID || (r.crossTileID = i.generate(),
                            n.add(r.crossTileID))
                        }
                        return void 0 === this.indexes[t.overscaledZ] && (this.indexes[t.overscaledZ] = {}),
                        this.indexes[t.overscaledZ][t.key] = new Ge(t,e.symbolInstances,e.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(t, e) {
                        for (const i of e.crossTileIDs)
                            this.usedCrossTileIDs[t].delete(i)
                    }
                    removeStaleBuckets(t) {
                        let e = !1;
                        for (const i in this.indexes) {
                            const n = this.indexes[i];
                            for (const r in n)
                                t[n[r].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, n[r]),
                                delete n[r],
                                e = !0)
                        }
                        return e
                    }
                }
                class We {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new Ze,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(t, e, i, n) {
                        let r = this.layerIndexes[t.id];
                        void 0 === r && (r = this.layerIndexes[t.id] = new qe);
                        let o = !1;
                        const s = {};
                        "globe" !== n.name && r.handleWrapJump(i);
                        for (const i of e) {
                            const e = i.getBucket(t);
                            e && t.id === e.layerIds[0] && (e.bucketInstanceId || (e.bucketInstanceId = ++this.maxBucketInstanceId),
                            r.addBucket(i.tileID, e, this.crossTileIDs) && (o = !0),
                            s[e.bucketInstanceId] = !0)
                        }
                        return r.removeStaleBuckets(s) && (o = !0),
                        o
                    }
                    pruneUnusedLayers(t) {
                        const e = {};
                        t.forEach((t => {
                            e[t] = !0
                        }
                        ));
                        for (const t in this.layerIndexes)
                            e[t] || delete this.layerIndexes[t]
                    }
                }
                const He = (e, i) => t.emitValidationErrors(e, i && i.filter((t => "source.canvas" !== t.identifier)))
                  , $e = t.pick(Gt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setProjection"])
                  , Xe = t.pick(Gt, ["setCenter", "setZoom", "setBearing", "setPitch"])
                  , Ye = {
                    version: 8,
                    layers: [],
                    sources: {}
                }
                  , Ke = {
                    fill: !0,
                    line: !0,
                    background: !0,
                    hillshade: !0,
                    raster: !0
                };
                class Je extends t.Evented {
                    constructor(e, i={}) {
                        super(),
                        this.map = e,
                        this.dispatcher = new P(jt(),this),
                        this.imageManager = new b,
                        this.imageManager.setEventedParent(this),
                        this.glyphManager = new t.GlyphManager(e._requestManager,i.localFontFamily ? t.LocalGlyphMode.all : i.localIdeographFontFamily ? t.LocalGlyphMode.ideographs : t.LocalGlyphMode.none,i.localFontFamily || i.localIdeographFontFamily),
                        this.crossTileSymbolIndex = new We,
                        this._layers = {},
                        this._num3DLayers = 0,
                        this._numSymbolLayers = 0,
                        this._numCircleLayers = 0,
                        this._serializedLayers = {},
                        this._sourceCaches = {},
                        this._otherSourceCaches = {},
                        this._symbolSourceCaches = {},
                        this._loaded = !1,
                        this._availableImages = [],
                        this._order = [],
                        this._drapedFirstOrder = [],
                        this._markersNeedUpdate = !1,
                        this._resetUpdates(),
                        this.dispatcher.broadcast("setReferrer", t.getReferrer());
                        const n = this;
                        this._rtlTextPluginCallback = Je.registerForPluginStateChange((e => {
                            n.dispatcher.broadcast("syncRTLPluginState", {
                                pluginStatus: e.pluginStatus,
                                pluginURL: e.pluginURL
                            }, ( (e, i) => {
                                if (t.triggerPluginCompletionEvent(e),
                                i && i.every((t => t)))
                                    for (const t in n._sourceCaches) {
                                        const e = n._sourceCaches[t]
                                          , i = e.getSource().type;
                                        "vector" !== i && "geojson" !== i || e.reload()
                                    }
                            }
                            ))
                        }
                        )),
                        this.on("data", (t => {
                            if ("source" !== t.dataType || "metadata" !== t.sourceDataType)
                                return;
                            const e = this.getSource(t.sourceId);
                            if (e && e.vectorLayerIds)
                                for (const t in this._layers) {
                                    const i = this._layers[t];
                                    i.source === e.id && this._validateLayer(i)
                                }
                        }
                        ))
                    }
                    loadURL(e, i={}) {
                        this.fire(new t.Event("dataloading",{
                            dataType: "style"
                        }));
                        const n = "boolean" == typeof i.validate ? i.validate : !t.isMapboxURL(e);
                        e = this.map._requestManager.normalizeStyleURL(e, i.accessToken);
                        const r = this.map._requestManager.transformRequest(e, t.ResourceType.Style);
                        this._request = t.getJSON(r, ( (e, i) => {
                            this._request = null,
                            e ? this.fire(new t.ErrorEvent(e)) : i && this._load(i, n)
                        }
                        ))
                    }
                    loadJSON(e, i={}) {
                        this.fire(new t.Event("dataloading",{
                            dataType: "style"
                        })),
                        this._request = t.exported.frame(( () => {
                            this._request = null,
                            this._load(e, !1 !== i.validate)
                        }
                        ))
                    }
                    loadEmpty() {
                        this.fire(new t.Event("dataloading",{
                            dataType: "style"
                        })),
                        this._load(Ye, !1)
                    }
                    _updateLayerCount(t, e) {
                        const i = e ? 1 : -1;
                        t.is3D() && (this._num3DLayers += i),
                        "circle" === t.type && (this._numCircleLayers += i),
                        "symbol" === t.type && (this._numSymbolLayers += i)
                    }
                    _load(e, i) {
                        if (i && He(this, t.validateStyle(e)))
                            return;
                        this._loaded = !0,
                        this.stylesheet = t.clone$1(e),
                        this._updateMapProjection();
                        for (const t in e.sources)
                            this.addSource(t, e.sources[t], {
                                validate: !1
                            });
                        this._changed = !1,
                        e.sprite ? this._loadSprite(e.sprite) : (this.imageManager.setLoaded(!0),
                        this.dispatcher.broadcast("spriteLoaded", !0)),
                        this.glyphManager.setURL(e.glyphs);
                        const n = Vt(this.stylesheet.layers);
                        this._order = n.map((t => t.id)),
                        this._layers = {},
                        this._serializedLayers = {};
                        for (const e of n) {
                            const i = t.createStyleLayer(e);
                            i.setEventedParent(this, {
                                layer: {
                                    id: i.id
                                }
                            }),
                            this._layers[i.id] = i,
                            this._serializedLayers[i.id] = i.serialize(),
                            this._updateLayerCount(i, !0)
                        }
                        this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)),
                        this.light = new E(this.stylesheet.light),
                        this.stylesheet.terrain && !this.terrainSetForDrapingOnly() && this._createTerrain(this.stylesheet.terrain, 1),
                        this.stylesheet.fog && this._createFog(this.stylesheet.fog),
                        this._updateDrapeFirstLayers(),
                        this.fire(new t.Event("data",{
                            dataType: "style"
                        })),
                        this.fire(new t.Event("style.load"))
                    }
                    terrainSetForDrapingOnly() {
                        return !!this.terrain && 0 === this.terrain.drapeRenderMode
                    }
                    setProjection(t) {
                        t ? this.stylesheet.projection = t : delete this.stylesheet.projection,
                        this._updateMapProjection()
                    }
                    applyProjectionUpdate() {
                        this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions),
                        this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null))
                    }
                    _updateMapProjection() {
                        this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.stylesheet.projection)
                    }
                    _loadSprite(e) {
                        this._spriteRequest = function(e, i, n) {
                            let r, o, s;
                            const a = t.exported.devicePixelRatio > 1 ? "@2x" : "";
                            let l = t.getJSON(i.transformRequest(i.normalizeSpriteURL(e, a, ".json"), t.ResourceType.SpriteJSON), ( (t, e) => {
                                l = null,
                                s || (s = t,
                                r = e,
                                h())
                            }
                            ))
                              , c = t.getImage(i.transformRequest(i.normalizeSpriteURL(e, a, ".png"), t.ResourceType.SpriteImage), ( (t, e) => {
                                c = null,
                                s || (s = t,
                                o = e,
                                h())
                            }
                            ));
                            function h() {
                                if (s)
                                    n(s);
                                else if (r && o) {
                                    const e = t.exported.getImageData(o)
                                      , i = {};
                                    for (const n in r) {
                                        const {width: o, height: s, x: a, y: l, sdf: c, pixelRatio: h, stretchX: u, stretchY: d, content: f} = r[n]
                                          , p = new t.RGBAImage({
                                            width: o,
                                            height: s
                                        });
                                        t.RGBAImage.copy(e, p, {
                                            x: a,
                                            y: l
                                        }, {
                                            x: 0,
                                            y: 0
                                        }, {
                                            width: o,
                                            height: s
                                        }),
                                        i[n] = {
                                            data: p,
                                            pixelRatio: h,
                                            sdf: c,
                                            stretchX: u,
                                            stretchY: d,
                                            content: f
                                        }
                                    }
                                    n(null, i)
                                }
                            }
                            return {
                                cancel() {
                                    l && (l.cancel(),
                                    l = null),
                                    c && (c.cancel(),
                                    c = null)
                                }
                            }
                        }(e, this.map._requestManager, ( (e, i) => {
                            if (this._spriteRequest = null,
                            e)
                                this.fire(new t.ErrorEvent(e));
                            else if (i)
                                for (const t in i)
                                    this.imageManager.addImage(t, i[t]);
                            this.imageManager.setLoaded(!0),
                            this._availableImages = this.imageManager.listImages(),
                            this.dispatcher.broadcast("setImages", this._availableImages),
                            this.dispatcher.broadcast("spriteLoaded", !0),
                            this.fire(new t.Event("data",{
                                dataType: "style"
                            }))
                        }
                        ))
                    }
                    _validateLayer(e) {
                        const i = this.getSource(e.source);
                        if (!i)
                            return;
                        const n = e.sourceLayer;
                        n && ("geojson" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(n)) && this.fire(new t.ErrorEvent(new Error(`Source layer "${n}" does not exist on source "${i.id}" as specified by style layer "${e.id}"`)))
                    }
                    loaded() {
                        if (!this._loaded)
                            return !1;
                        if (Object.keys(this._updatedSources).length)
                            return !1;
                        for (const t in this._sourceCaches)
                            if (!this._sourceCaches[t].loaded())
                                return !1;
                        return !!this.imageManager.isLoaded()
                    }
                    _serializeLayers(t) {
                        const e = [];
                        for (const i of t) {
                            const t = this._layers[i];
                            "custom" !== t.type && e.push(t.serialize())
                        }
                        return e
                    }
                    hasTransitions() {
                        if (this.light && this.light.hasTransition())
                            return !0;
                        if (this.fog && this.fog.hasTransition())
                            return !0;
                        for (const t in this._sourceCaches)
                            if (this._sourceCaches[t].hasTransition())
                                return !0;
                        for (const t in this._layers)
                            if (this._layers[t].hasTransition())
                                return !0;
                        return !1
                    }
                    get order() {
                        return this.map._optimizeForTerrain && this.terrain ? this._drapedFirstOrder : this._order
                    }
                    isLayerDraped(t) {
                        return !!this.terrain && ("function" == typeof t.isLayerDraped ? t.isLayerDraped() : Ke[t.type])
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading")
                    }
                    update(e) {
                        if (!this._loaded)
                            return;
                        const i = this._changed;
                        if (this._changed) {
                            const t = Object.keys(this._updatedLayers)
                              , i = Object.keys(this._removedLayers);
                            (t.length || i.length) && this._updateWorkerLayers(t, i);
                            for (const t in this._updatedSources) {
                                const e = this._updatedSources[t];
                                "reload" === e ? this._reloadSource(t) : "clear" === e && this._clearSource(t)
                            }
                            this._updateTilesForChangedImages();
                            for (const t in this._updatedPaintProps)
                                this._layers[t].updateTransitions(e);
                            this.light.updateTransitions(e),
                            this.fog && this.fog.updateTransitions(e),
                            this._resetUpdates()
                        }
                        const n = {};
                        for (const t in this._sourceCaches) {
                            const e = this._sourceCaches[t];
                            n[t] = e.used,
                            e.used = !1
                        }
                        for (const t of this._order) {
                            const i = this._layers[t];
                            if (i.recalculate(e, this._availableImages),
                            !i.isHidden(e.zoom)) {
                                const t = this._getLayerSourceCache(i);
                                t && (t.used = !0)
                            }
                            const n = this.map.painter;
                            if (n) {
                                const t = i.getProgramIds();
                                if (!t)
                                    continue;
                                const r = i.getProgramConfiguration(e.zoom);
                                for (const e of t)
                                    n.useProgram(e, r)
                            }
                        }
                        for (const e in n) {
                            const i = this._sourceCaches[e];
                            n[e] !== i.used && i.getSource().fire(new t.Event("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: i.getSource().id
                            }))
                        }
                        this.light.recalculate(e),
                        this.terrain && this.terrain.recalculate(e),
                        this.fog && this.fog.recalculate(e),
                        this.z = e.zoom,
                        this._markersNeedUpdate && (this._updateMarkersOpacity(),
                        this._markersNeedUpdate = !1),
                        i && this.fire(new t.Event("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const t = Object.keys(this._changedImages);
                        if (t.length) {
                            for (const e in this._sourceCaches)
                                this._sourceCaches[e].reloadTilesForDependencies(["icons", "patterns"], t);
                            this._changedImages = {}
                        }
                    }
                    _updateWorkerLayers(t, e) {
                        this.dispatcher.broadcast("updateLayers", {
                            layers: this._serializeLayers(t),
                            removedIds: e
                        })
                    }
                    _resetUpdates() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSources = {},
                        this._updatedPaintProps = {},
                        this._changedImages = {}
                    }
                    setState(i) {
                        if (this._checkLoaded(),
                        He(this, t.validateStyle(i)))
                            return !1;
                        (i = t.clone$1(i)).layers = Vt(i.layers);
                        const r = function(t, i) {
                            if (!t)
                                return [{
                                    command: Gt.setStyle,
                                    args: [i]
                                }];
                            let r = [];
                            try {
                                if (!e(t.version, i.version))
                                    return [{
                                        command: Gt.setStyle,
                                        args: [i]
                                    }];
                                e(t.center, i.center) || r.push({
                                    command: Gt.setCenter,
                                    args: [i.center]
                                }),
                                e(t.zoom, i.zoom) || r.push({
                                    command: Gt.setZoom,
                                    args: [i.zoom]
                                }),
                                e(t.bearing, i.bearing) || r.push({
                                    command: Gt.setBearing,
                                    args: [i.bearing]
                                }),
                                e(t.pitch, i.pitch) || r.push({
                                    command: Gt.setPitch,
                                    args: [i.pitch]
                                }),
                                e(t.sprite, i.sprite) || r.push({
                                    command: Gt.setSprite,
                                    args: [i.sprite]
                                }),
                                e(t.glyphs, i.glyphs) || r.push({
                                    command: Gt.setGlyphs,
                                    args: [i.glyphs]
                                }),
                                e(t.transition, i.transition) || r.push({
                                    command: Gt.setTransition,
                                    args: [i.transition]
                                }),
                                e(t.light, i.light) || r.push({
                                    command: Gt.setLight,
                                    args: [i.light]
                                }),
                                e(t.fog, i.fog) || r.push({
                                    command: Gt.setFog,
                                    args: [i.fog]
                                }),
                                e(t.projection, i.projection) || r.push({
                                    command: Gt.setProjection,
                                    args: [i.projection]
                                });
                                const n = {}
                                  , o = [];
                                !function(t, i, n, r) {
                                    let o;
                                    for (o in i = i || {},
                                    t = t || {})
                                        t.hasOwnProperty(o) && (i.hasOwnProperty(o) || qt(o, n, r));
                                    for (o in i) {
                                        if (!i.hasOwnProperty(o))
                                            continue;
                                        const s = i[o];
                                        t.hasOwnProperty(o) ? e(t[o], s) || ("geojson" === t[o].type && "geojson" === s.type && Ht(t, i, o) ? n.push({
                                            command: Gt.setGeoJSONSourceData,
                                            args: [o, s.data]
                                        }) : Wt(o, i, n, r)) : Zt(o, i, n)
                                    }
                                }(t.sources, i.sources, o, n);
                                const s = [];
                                t.layers && t.layers.forEach((t => {
                                    t.source && n[t.source] ? r.push({
                                        command: Gt.removeLayer,
                                        args: [t.id]
                                    }) : s.push(t)
                                }
                                ));
                                let a = t.terrain;
                                a && n[a.source] && (r.push({
                                    command: Gt.setTerrain,
                                    args: [void 0]
                                }),
                                a = void 0),
                                r = r.concat(o),
                                e(a, i.terrain) || r.push({
                                    command: Gt.setTerrain,
                                    args: [i.terrain]
                                }),
                                function(t, i, n) {
                                    i = i || [];
                                    const r = (t = t || []).map(Xt)
                                      , o = i.map(Xt)
                                      , s = t.reduce(Yt, {})
                                      , a = i.reduce(Yt, {})
                                      , l = r.slice()
                                      , c = Object.create(null);
                                    let h, u, d, f, p, m, g;
                                    for (h = 0,
                                    u = 0; h < r.length; h++)
                                        d = r[h],
                                        a.hasOwnProperty(d) ? u++ : (n.push({
                                            command: Gt.removeLayer,
                                            args: [d]
                                        }),
                                        l.splice(l.indexOf(d, u), 1));
                                    for (h = 0,
                                    u = 0; h < o.length; h++)
                                        d = o[o.length - 1 - h],
                                        l[l.length - 1 - h] !== d && (s.hasOwnProperty(d) ? (n.push({
                                            command: Gt.removeLayer,
                                            args: [d]
                                        }),
                                        l.splice(l.lastIndexOf(d, l.length - u), 1)) : u++,
                                        m = l[l.length - h],
                                        n.push({
                                            command: Gt.addLayer,
                                            args: [a[d], m]
                                        }),
                                        l.splice(l.length - h, 0, d),
                                        c[d] = !0);
                                    for (h = 0; h < o.length; h++)
                                        if (d = o[h],
                                        f = s[d],
                                        p = a[d],
                                        !c[d] && !e(f, p))
                                            if (e(f.source, p.source) && e(f["source-layer"], p["source-layer"]) && e(f.type, p.type)) {
                                                for (g in $t(f.layout, p.layout, n, d, null, Gt.setLayoutProperty),
                                                $t(f.paint, p.paint, n, d, null, Gt.setPaintProperty),
                                                e(f.filter, p.filter) || n.push({
                                                    command: Gt.setFilter,
                                                    args: [d, p.filter]
                                                }),
                                                e(f.minzoom, p.minzoom) && e(f.maxzoom, p.maxzoom) || n.push({
                                                    command: Gt.setLayerZoomRange,
                                                    args: [d, p.minzoom, p.maxzoom]
                                                }),
                                                f)
                                                    f.hasOwnProperty(g) && "layout" !== g && "paint" !== g && "filter" !== g && "metadata" !== g && "minzoom" !== g && "maxzoom" !== g && (0 === g.indexOf("paint.") ? $t(f[g], p[g], n, d, g.slice(6), Gt.setPaintProperty) : e(f[g], p[g]) || n.push({
                                                        command: Gt.setLayerProperty,
                                                        args: [d, g, p[g]]
                                                    }));
                                                for (g in p)
                                                    p.hasOwnProperty(g) && !f.hasOwnProperty(g) && "layout" !== g && "paint" !== g && "filter" !== g && "metadata" !== g && "minzoom" !== g && "maxzoom" !== g && (0 === g.indexOf("paint.") ? $t(f[g], p[g], n, d, g.slice(6), Gt.setPaintProperty) : e(f[g], p[g]) || n.push({
                                                        command: Gt.setLayerProperty,
                                                        args: [d, g, p[g]]
                                                    }))
                                            } else
                                                n.push({
                                                    command: Gt.removeLayer,
                                                    args: [d]
                                                }),
                                                m = l[l.lastIndexOf(d) + 1],
                                                n.push({
                                                    command: Gt.addLayer,
                                                    args: [p, m]
                                                })
                                }(s, i.layers, r)
                            } catch (t) {
                                n.warn("Unable to compute style diff:", t),
                                r = [{
                                    command: Gt.setStyle,
                                    args: [i]
                                }]
                            }
                            return r
                        }(this.serialize(), i).filter((t => !(t.command in Xe)));
                        if (0 === r.length)
                            return !1;
                        const o = r.filter((t => !(t.command in $e)));
                        if (o.length > 0)
                            throw new Error(`Unimplemented: ${o.map((t => t.command)).join(", ")}.`);
                        return r.forEach((t => {
                            "setTransition" !== t.command && "setProjection" !== t.command && this[t.command].apply(this, t.args)
                        }
                        )),
                        this.stylesheet = i,
                        this._updateMapProjection(),
                        !0
                    }
                    addImage(e, i) {
                        return this.getImage(e) ? this.fire(new t.ErrorEvent(new Error("An image with this name already exists."))) : (this.imageManager.addImage(e, i),
                        this._afterImageUpdated(e),
                        this)
                    }
                    updateImage(t, e) {
                        this.imageManager.updateImage(t, e)
                    }
                    getImage(t) {
                        return this.imageManager.getImage(t)
                    }
                    removeImage(e) {
                        return this.getImage(e) ? (this.imageManager.removeImage(e),
                        this._afterImageUpdated(e),
                        this) : this.fire(new t.ErrorEvent(new Error("No image with this name exists.")))
                    }
                    _afterImageUpdated(e) {
                        this._availableImages = this.imageManager.listImages(),
                        this._changedImages[e] = !0,
                        this._changed = !0,
                        this.dispatcher.broadcast("setImages", this._availableImages),
                        this.fire(new t.Event("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this._availableImages.slice()
                    }
                    addSource(e, i, n={}) {
                        if (this._checkLoaded(),
                        void 0 !== this.getSource(e))
                            throw new Error("There is already a source with this ID");
                        if (!i.type)
                            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(t.validateSource, `sources.${e}`, i, null, n))
                            return;
                        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                        const r = kt(e, i, this.dispatcher, this);
                        r.setEventedParent(this, ( () => ({
                            isSourceLoaded: this._isSourceCacheLoaded(e),
                            source: r.serialize(),
                            sourceId: e
                        })));
                        const o = i => {
                            const n = (i ? "symbol:" : "other:") + e
                              , o = this._sourceCaches[n] = new t.SourceCache(n,r,i);
                            (i ? this._symbolSourceCaches : this._otherSourceCaches)[e] = o,
                            o.style = this,
                            o.onAdd(this.map)
                        }
                        ;
                        o(!1),
                        "vector" !== i.type && "geojson" !== i.type || o(!0),
                        r.onAdd && r.onAdd(this.map),
                        this._changed = !0
                    }
                    removeSource(e) {
                        this._checkLoaded();
                        const i = this.getSource(e);
                        if (!i)
                            throw new Error("There is no source with this ID");
                        for (const i in this._layers)
                            if (this._layers[i].source === e)
                                return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while layer "${i}" is using it.`)));
                        if (this.terrain && this.terrain.get().source === e)
                            return this.fire(new t.ErrorEvent(new Error(`Source "${e}" cannot be removed while terrain is using it.`)));
                        const n = this._getSourceCaches(e);
                        for (const e of n)
                            delete this._sourceCaches[e.id],
                            delete this._updatedSources[e.id],
                            e.fire(new t.Event("data",{
                                sourceDataType: "metadata",
                                dataType: "source",
                                sourceId: e.getSource().id
                            })),
                            e.setEventedParent(null),
                            e.clearTiles();
                        return delete this._otherSourceCaches[e],
                        delete this._symbolSourceCaches[e],
                        i.setEventedParent(null),
                        i.onRemove && i.onRemove(this.map),
                        this._changed = !0,
                        this
                    }
                    setGeoJSONSourceData(t, e) {
                        this._checkLoaded(),
                        this.getSource(t).setData(e),
                        this._changed = !0
                    }
                    getSource(t) {
                        const e = this._getSourceCache(t);
                        return e && e.getSource()
                    }
                    _getSources() {
                        const t = [];
                        for (const e in this._otherSourceCaches) {
                            const i = this._getSourceCache(e);
                            i && t.push(i.getSource())
                        }
                        return t
                    }
                    addLayer(e, i, n={}) {
                        this._checkLoaded();
                        const r = e.id;
                        if (this.getLayer(r))
                            return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${r}" already exists on this map`)));
                        let o;
                        if ("custom" === e.type) {
                            if (He(this, t.validateCustomStyleLayer(e)))
                                return;
                            o = t.createStyleLayer(e)
                        } else {
                            if ("object" == typeof e.source && (this.addSource(r, e.source),
                            e = t.clone$1(e),
                            e = t.extend(e, {
                                source: r
                            })),
                            this._validate(t.validateLayer, `layers.${r}`, e, {
                                arrayIndex: -1
                            }, n))
                                return;
                            o = t.createStyleLayer(e),
                            this._validateLayer(o),
                            o.setEventedParent(this, {
                                layer: {
                                    id: r
                                }
                            }),
                            this._serializedLayers[o.id] = o.serialize(),
                            this._updateLayerCount(o, !0)
                        }
                        const s = i ? this._order.indexOf(i) : this._order.length;
                        if (i && -1 === s)
                            return void this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`)));
                        this._order.splice(s, 0, r),
                        this._layerOrderChanged = !0,
                        this._layers[r] = o;
                        const a = this._getLayerSourceCache(o);
                        if (this._removedLayers[r] && o.source && a && "custom" !== o.type) {
                            const t = this._removedLayers[r];
                            delete this._removedLayers[r],
                            t.type !== o.type ? this._updatedSources[o.source] = "clear" : (this._updatedSources[o.source] = "reload",
                            a.pause())
                        }
                        this._updateLayer(o),
                        o.onAdd && o.onAdd(this.map),
                        this._updateDrapeFirstLayers()
                    }
                    moveLayer(e, i) {
                        if (this._checkLoaded(),
                        this._changed = !0,
                        !this._layers[e])
                            return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                        if (e === i)
                            return;
                        const n = this._order.indexOf(e);
                        this._order.splice(n, 1);
                        const r = i ? this._order.indexOf(i) : this._order.length;
                        i && -1 === r ? this.fire(new t.ErrorEvent(new Error(`Layer with id "${i}" does not exist on this map.`))) : (this._order.splice(r, 0, e),
                        this._layerOrderChanged = !0,
                        this._updateDrapeFirstLayers())
                    }
                    removeLayer(e) {
                        this._checkLoaded();
                        const i = this._layers[e];
                        if (!i)
                            return void this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be removed.`)));
                        i.setEventedParent(null),
                        this._updateLayerCount(i, !1);
                        const n = this._order.indexOf(e);
                        this._order.splice(n, 1),
                        this._layerOrderChanged = !0,
                        this._changed = !0,
                        this._removedLayers[e] = i,
                        delete this._layers[e],
                        delete this._serializedLayers[e],
                        delete this._updatedLayers[e],
                        delete this._updatedPaintProps[e],
                        i.onRemove && i.onRemove(this.map),
                        this._updateDrapeFirstLayers()
                    }
                    getLayer(t) {
                        return this._layers[t]
                    }
                    hasLayer(t) {
                        return t in this._layers
                    }
                    hasLayerType(t) {
                        for (const e in this._layers)
                            if (this._layers[e].type === t)
                                return !0;
                        return !1
                    }
                    setLayerZoomRange(e, i, n) {
                        this._checkLoaded();
                        const r = this.getLayer(e);
                        r ? r.minzoom === i && r.maxzoom === n || (null != i && (r.minzoom = i),
                        null != n && (r.maxzoom = n),
                        this._updateLayer(r)) : this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot have zoom extent.`)))
                    }
                    setFilter(i, n, r={}) {
                        this._checkLoaded();
                        const o = this.getLayer(i);
                        if (o) {
                            if (!e(o.filter, n))
                                return null == n ? (o.filter = void 0,
                                void this._updateLayer(o)) : void (this._validate(t.validateFilter, `layers.${o.id}.filter`, n, {
                                    layerType: o.type
                                }, r) || (o.filter = t.clone$1(n),
                                this._updateLayer(o)))
                        } else
                            this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be filtered.`)))
                    }
                    getFilter(e) {
                        const i = this.getLayer(e);
                        return i && t.clone$1(i.filter)
                    }
                    setLayoutProperty(i, n, r, o={}) {
                        this._checkLoaded();
                        const s = this.getLayer(i);
                        s ? e(s.getLayoutProperty(n), r) || (s.setLayoutProperty(n, r, o),
                        this._updateLayer(s)) : this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)))
                    }
                    getLayoutProperty(e, i) {
                        const n = this.getLayer(e);
                        if (n)
                            return n.getLayoutProperty(i);
                        this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style.`)))
                    }
                    setPaintProperty(i, n, r, o={}) {
                        this._checkLoaded();
                        const s = this.getLayer(i);
                        s ? e(s.getPaintProperty(n), r) || (s.setPaintProperty(n, r, o) && this._updateLayer(s),
                        this._changed = !0,
                        this._updatedPaintProps[i] = !0) : this.fire(new t.ErrorEvent(new Error(`The layer '${i}' does not exist in the map's style and cannot be styled.`)))
                    }
                    getPaintProperty(t, e) {
                        const i = this.getLayer(t);
                        return i && i.getPaintProperty(e)
                    }
                    setFeatureState(e, i) {
                        this._checkLoaded();
                        const n = e.source
                          , r = e.sourceLayer
                          , o = this.getSource(n);
                        if (!o)
                            return void this.fire(new t.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`)));
                        const s = o.type;
                        if ("geojson" === s && r)
                            return void this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
                        if ("vector" === s && !r)
                            return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided.")));
                        const a = this._getSourceCaches(n);
                        for (const t of a)
                            t.setFeatureState(r, e.id, i)
                    }
                    removeFeatureState(e, i) {
                        this._checkLoaded();
                        const n = e.source
                          , r = this.getSource(n);
                        if (!r)
                            return void this.fire(new t.ErrorEvent(new Error(`The source '${n}' does not exist in the map's style.`)));
                        const o = r.type
                          , s = "vector" === o ? e.sourceLayer : void 0;
                        if ("vector" === o && !s)
                            return void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        if (i && "string" != typeof e.id && "number" != typeof e.id)
                            return void this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property.")));
                        const a = this._getSourceCaches(n);
                        for (const t of a)
                            t.removeFeatureState(s, e.id, i)
                    }
                    getFeatureState(e) {
                        this._checkLoaded();
                        const i = e.source
                          , n = e.sourceLayer
                          , r = this.getSource(i);
                        if (r) {
                            if ("vector" !== r.type || n)
                                return void 0 === e.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))),
                                this._getSourceCaches(i)[0].getFeatureState(n, e.id);
                            this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")))
                        } else
                            this.fire(new t.ErrorEvent(new Error(`The source '${i}' does not exist in the map's style.`)))
                    }
                    getTransition() {
                        return t.extend({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet && this.stylesheet.transition)
                    }
                    serialize() {
                        const e = {};
                        for (const t in this._sourceCaches) {
                            const i = this._sourceCaches[t].getSource();
                            e[i.id] || (e[i.id] = i.serialize())
                        }
                        return t.filterObject({
                            version: this.stylesheet.version,
                            name: this.stylesheet.name,
                            metadata: this.stylesheet.metadata,
                            light: this.stylesheet.light,
                            terrain: this.getTerrain() || void 0,
                            fog: this.stylesheet.fog,
                            center: this.stylesheet.center,
                            zoom: this.stylesheet.zoom,
                            bearing: this.stylesheet.bearing,
                            pitch: this.stylesheet.pitch,
                            sprite: this.stylesheet.sprite,
                            glyphs: this.stylesheet.glyphs,
                            transition: this.stylesheet.transition,
                            projection: this.stylesheet.projection,
                            sources: e,
                            layers: this._serializeLayers(this._order)
                        }, (t => void 0 !== t))
                    }
                    _updateLayer(t) {
                        this._updatedLayers[t.id] = !0;
                        const e = this._getLayerSourceCache(t);
                        t.source && !this._updatedSources[t.source] && e && "raster" !== e.getSource().type && (this._updatedSources[t.source] = "reload",
                        e.pause()),
                        this._changed = !0,
                        t.invalidateCompiledFilter()
                    }
                    _flattenAndSortRenderedFeatures(t) {
                        const e = t => "fill-extrusion" === this._layers[t].type
                          , i = {}
                          , n = [];
                        for (let r = this._order.length - 1; r >= 0; r--) {
                            const o = this._order[r];
                            if (e(o)) {
                                i[o] = r;
                                for (const e of t) {
                                    const t = e[o];
                                    if (t)
                                        for (const e of t)
                                            n.push(e)
                                }
                            }
                        }
                        n.sort(( (t, e) => e.intersectionZ - t.intersectionZ));
                        const r = [];
                        for (let o = this._order.length - 1; o >= 0; o--) {
                            const s = this._order[o];
                            if (e(s))
                                for (let t = n.length - 1; t >= 0; t--) {
                                    const e = n[t].feature;
                                    if (i[e.layer.id] < o)
                                        break;
                                    r.push(e),
                                    n.pop()
                                }
                            else
                                for (const e of t) {
                                    const t = e[s];
                                    if (t)
                                        for (const e of t)
                                            r.push(e.feature)
                                }
                        }
                        return r
                    }
                    queryRenderedFeatures(e, i, n) {
                        i && i.filter && this._validate(t.validateFilter, "queryRenderedFeatures.filter", i.filter, null, i);
                        const r = {};
                        if (i && i.layers) {
                            if (!Array.isArray(i.layers))
                                return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))),
                                [];
                            for (const e of i.layers) {
                                const i = this._layers[e];
                                if (!i)
                                    return this.fire(new t.ErrorEvent(new Error(`The layer '${e}' does not exist in the map's style and cannot be queried for features.`))),
                                    [];
                                r[i.source] = !0
                            }
                        }
                        const o = [];
                        i.availableImages = this._availableImages;
                        const s = i && i.layers ? i.layers.some((t => {
                            const e = this.getLayer(t);
                            return e && e.is3D()
                        }
                        )) : this.has3DLayers()
                          , a = O.createFromScreenPoints(e, n);
                        for (const t in this._sourceCaches) {
                            const e = this._sourceCaches[t].getSource().id;
                            i.layers && !r[e] || o.push(Rt(this._sourceCaches[t], this._layers, this._serializedLayers, a, i, n, s, !!this.map._showQueryGeometry))
                        }
                        return this.placement && o.push(function(t, e, i, n, r, o, s) {
                            const a = {}
                              , l = o.queryRenderedSymbols(n)
                              , c = [];
                            for (const t of Object.keys(l).map(Number))
                                c.push(s[t]);
                            c.sort(Lt);
                            for (const i of c) {
                                const n = i.featureIndex.lookupSymbolFeatures(l[i.bucketInstanceId], e, i.bucketIndex, i.sourceLayerIndex, r.filter, r.layers, r.availableImages, t);
                                for (const t in n) {
                                    const e = a[t] = a[t] || []
                                      , r = n[t];
                                    r.sort(( (t, e) => {
                                        const n = i.featureSortOrder;
                                        if (n) {
                                            const i = n.indexOf(t.featureIndex);
                                            return n.indexOf(e.featureIndex) - i
                                        }
                                        return e.featureIndex - t.featureIndex
                                    }
                                    ));
                                    for (const t of r)
                                        e.push(t)
                                }
                            }
                            for (const e in a)
                                a[e].forEach((n => {
                                    const r = n.feature
                                      , o = i(t[e]);
                                    if (!o)
                                        return;
                                    const s = o.getFeatureState(r.layer["source-layer"], r.id);
                                    r.source = r.layer.source,
                                    r.layer["source-layer"] && (r.sourceLayer = r.layer["source-layer"]),
                                    r.state = s
                                }
                                ));
                            return a
                        }(this._layers, this._serializedLayers, this._getLayerSourceCache.bind(this), a.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)),
                        this._flattenAndSortRenderedFeatures(o)
                    }
                    querySourceFeatures(e, i) {
                        i && i.filter && this._validate(t.validateFilter, "querySourceFeatures.filter", i.filter, null, i);
                        const n = this._getSourceCaches(e);
                        let r = [];
                        for (const t of n)
                            r = r.concat(Dt(t, i));
                        return r
                    }
                    addSourceType(t, e, i) {
                        return Je.getSourceType(t) ? i(new Error(`A source type called "${t}" already exists.`)) : (Je.setSourceType(t, e),
                        e.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", {
                            name: t,
                            url: e.workerSourceURL
                        }, i) : i(null, null))
                    }
                    getLight() {
                        return this.light.getLight()
                    }
                    setLight(t, i={}) {
                        this._checkLoaded();
                        const n = this.light.getLight();
                        let r = !1;
                        for (const i in t)
                            if (!e(t[i], n[i])) {
                                r = !0;
                                break
                            }
                        if (!r)
                            return;
                        const o = this._setTransitionParameters({
                            duration: 300,
                            delay: 0
                        });
                        this.light.setLight(t, i),
                        this.light.updateTransitions(o)
                    }
                    getTerrain() {
                        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null
                    }
                    setTerrainForDraping() {
                        this.setTerrain({
                            source: "",
                            exaggeration: 0
                        }, 0)
                    }
                    setTerrain(i, n=1) {
                        if (this._checkLoaded(),
                        !i)
                            return delete this.terrain,
                            delete this.stylesheet.terrain,
                            this.dispatcher.broadcast("enableTerrain", !1),
                            this._force3DLayerUpdate(),
                            void (this._markersNeedUpdate = !0);
                        let r = i;
                        if (1 === n) {
                            if ("object" == typeof r.source) {
                                const e = "terrain-dem-src";
                                this.addSource(e, r.source),
                                r = t.clone$1(r),
                                r = t.extend(r, {
                                    source: e
                                })
                            }
                            if (this._validate(t.validateTerrain, "terrain", r))
                                return
                        }
                        if (!this.terrain || this.terrain && n !== this.terrain.drapeRenderMode) {
                            if (!r)
                                return;
                            this._createTerrain(r, n)
                        } else {
                            const i = this.terrain
                              , n = i.get();
                            for (const e of Object.keys(t.spec.terrain))
                                !r.hasOwnProperty(e) && t.spec.terrain[e].default && (r[e] = t.spec.terrain[e].default);
                            for (const t in r)
                                if (!e(r[t], n[t])) {
                                    i.set(r),
                                    this.stylesheet.terrain = r;
                                    const t = this._setTransitionParameters({
                                        duration: 0
                                    });
                                    i.updateTransitions(t);
                                    break
                                }
                        }
                        this._updateDrapeFirstLayers(),
                        this._markersNeedUpdate = !0
                    }
                    _createFog(t) {
                        const e = this.fog = new M(t,this.map.transform);
                        this.stylesheet.fog = t;
                        const i = this._setTransitionParameters({
                            duration: 0
                        });
                        e.updateTransitions(i)
                    }
                    _updateMarkersOpacity() {
                        0 !== this.map._markers.length && this.map._requestDomTask(( () => {
                            for (const t of this.map._markers)
                                t._evaluateOpacity()
                        }
                        ))
                    }
                    getFog() {
                        return this.fog ? this.fog.get() : null
                    }
                    setFog(t) {
                        if (this._checkLoaded(),
                        !t)
                            return delete this.fog,
                            delete this.stylesheet.fog,
                            void (this._markersNeedUpdate = !0);
                        if (this.fog) {
                            const i = this.fog
                              , n = i.get();
                            0 === Object.keys(t).length && i.set(t);
                            for (const r in t)
                                if (!e(t[r], n[r])) {
                                    i.set(t),
                                    this.stylesheet.fog = t;
                                    const e = this._setTransitionParameters({
                                        duration: 0
                                    });
                                    i.updateTransitions(e);
                                    break
                                }
                        } else
                            this._createFog(t);
                        this._markersNeedUpdate = !0
                    }
                    _setTransitionParameters(e) {
                        return {
                            now: t.exported.now(),
                            transition: t.extend(e, this.stylesheet.transition)
                        }
                    }
                    _updateDrapeFirstLayers() {
                        if (!this.map._optimizeForTerrain || !this.terrain)
                            return;
                        const t = this._order.filter((t => this.isLayerDraped(this._layers[t])))
                          , e = this._order.filter((t => !this.isLayerDraped(this._layers[t])));
                        this._drapedFirstOrder = [],
                        this._drapedFirstOrder.push(...t),
                        this._drapedFirstOrder.push(...e)
                    }
                    _createTerrain(t, e) {
                        const i = this.terrain = new S(t,e);
                        this.stylesheet.terrain = t,
                        this.dispatcher.broadcast("enableTerrain", !this.terrainSetForDrapingOnly()),
                        this._force3DLayerUpdate();
                        const n = this._setTransitionParameters({
                            duration: 0
                        });
                        i.updateTransitions(n)
                    }
                    _force3DLayerUpdate() {
                        for (const t in this._layers) {
                            const e = this._layers[t];
                            "fill-extrusion" === e.type && this._updateLayer(e)
                        }
                    }
                    _forceSymbolLayerUpdate() {
                        for (const t in this._layers) {
                            const e = this._layers[t];
                            "symbol" === e.type && this._updateLayer(e)
                        }
                    }
                    _validate(e, i, n, r, o={}) {
                        return (!o || !1 !== o.validate) && He(this, e.call(t.validateStyle, t.extend({
                            key: i,
                            style: this.serialize(),
                            value: n,
                            styleSpec: t.spec
                        }, r)))
                    }
                    _remove() {
                        this._request && (this._request.cancel(),
                        this._request = null),
                        this._spriteRequest && (this._spriteRequest.cancel(),
                        this._spriteRequest = null),
                        t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
                        for (const t in this._layers)
                            this._layers[t].setEventedParent(null);
                        for (const t in this._sourceCaches)
                            this._sourceCaches[t].clearTiles(),
                            this._sourceCaches[t].setEventedParent(null);
                        this.imageManager.setEventedParent(null),
                        this.setEventedParent(null),
                        this.dispatcher.remove()
                    }
                    _clearSource(t) {
                        const e = this._getSourceCaches(t);
                        for (const t of e)
                            t.clearTiles()
                    }
                    _reloadSource(t) {
                        const e = this._getSourceCaches(t);
                        for (const t of e)
                            t.resume(),
                            t.reload()
                    }
                    _reloadSources() {
                        for (const t of this._getSources())
                            t.reload && t.reload()
                    }
                    _updateSources(t) {
                        for (const e in this._sourceCaches)
                            this._sourceCaches[e].update(t)
                    }
                    _generateCollisionBoxes() {
                        for (const t in this._sourceCaches) {
                            const e = this._sourceCaches[t];
                            e.resume(),
                            e.reload()
                        }
                    }
                    _updatePlacement(e, i, n, r, o=!1) {
                        let s = !1
                          , a = !1;
                        const l = {};
                        for (const t of this._order) {
                            const i = this._layers[t];
                            if ("symbol" !== i.type)
                                continue;
                            if (!l[i.source]) {
                                const t = this._getLayerSourceCache(i);
                                if (!t)
                                    continue;
                                l[i.source] = t.getRenderableIds(!0).map((e => t.getTileByID(e))).sort(( (t, e) => e.tileID.overscaledZ - t.tileID.overscaledZ || (t.tileID.isLessThan(e.tileID) ? -1 : 1)))
                            }
                            const n = this.crossTileSymbolIndex.addLayer(i, l[i.source], e.center.lng, e.projection);
                            s = s || n
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                        o = o || this._layerOrderChanged || 0 === n,
                        this._layerOrderChanged && this.fire(new t.Event("neworder")),
                        (o || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e.zoom)) && (this.pauseablePlacement = new Ue(e,this._order,o,i,n,r,this.placement,this.fog && e.projection.supportsFog ? this.fog.state : null),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()),
                        a = !0),
                        s && this.pauseablePlacement.placement.setStale()),
                        a || s)
                            for (const t of this._order) {
                                const e = this._layers[t];
                                "symbol" === e.type && this.placement.updateLayerOpacities(e, l[e.source])
                            }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now())
                    }
                    _releaseSymbolFadeTiles() {
                        for (const t in this._sourceCaches)
                            this._sourceCaches[t].releaseSymbolFadeTiles()
                    }
                    getImages(t, e, i) {
                        this.imageManager.getImages(e.icons, i),
                        this._updateTilesForChangedImages();
                        const n = t => {
                            t && t.setDependencies(e.tileID.key, e.type, e.icons)
                        }
                        ;
                        n(this._otherSourceCaches[e.source]),
                        n(this._symbolSourceCaches[e.source])
                    }
                    getGlyphs(t, e, i) {
                        this.glyphManager.getGlyphs(e.stacks, i)
                    }
                    getResource(e, i, n) {
                        return t.makeRequest(i, n)
                    }
                    _getSourceCache(t) {
                        return this._otherSourceCaches[t]
                    }
                    _getLayerSourceCache(t) {
                        return "symbol" === t.type ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source]
                    }
                    _getSourceCaches(t) {
                        const e = [];
                        return this._otherSourceCaches[t] && e.push(this._otherSourceCaches[t]),
                        this._symbolSourceCaches[t] && e.push(this._symbolSourceCaches[t]),
                        e
                    }
                    _isSourceCacheLoaded(e) {
                        const i = this._getSourceCaches(e);
                        return 0 === i.length ? (this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e}'`))),
                        !1) : i.every((t => t.loaded()))
                    }
                    has3DLayers() {
                        return this._num3DLayers > 0
                    }
                    hasSymbolLayers() {
                        return this._numSymbolLayers > 0
                    }
                    hasCircleLayers() {
                        return this._numCircleLayers > 0
                    }
                    _clearWorkerCaches() {
                        this.dispatcher.broadcast("clearCaches")
                    }
                    destroy() {
                        this._clearWorkerCaches(),
                        this.terrainSetForDrapingOnly() && (delete this.terrain,
                        delete this.stylesheet.terrain)
                    }
                }
                Je.getSourceType = function(t) {
                    return Pt[t]
                }
                ,
                Je.setSourceType = function(t, e) {
                    Pt[t] = e
                }
                ,
                Je.registerForPluginStateChange = t.registerForPluginStateChange;
                var Qe = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#define EXTENT 8192.0\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0"
                  , ti = "attribute highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;varying highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}"
                  , ei = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\nconst float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\n#ifdef TERRAIN\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;\n#else\nuniform sampler2D u_dem;uniform sampler2D u_dem_prev;\n#endif\nuniform vec4 u_dem_unpack;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float decodeElevation(vec4 v) {return dot(vec4(v.xyz*255.0,-1.0),u_dem_unpack);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem,pos));\n#ifdef TERRAIN_DEM_NEAREST_FILTER\nreturn u_exaggeration*tl;\n#endif\nfloat tr=decodeElevation(texture2D(u_dem,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture2D(u_dem_prev,pos).a;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=decodeElevation(texture2D(u_dem_prev,pos));float tr=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,0.0)));float bl=decodeElevation(texture2D(u_dem_prev,pos+vec2(0.0,dd)));float br=decodeElevation(texture2D(u_dem_prev,pos+vec2(dd,dd)));return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nhighp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture2D(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(\nunpack_depth(texture2D(u_depth,uv-df.xz)),unpack_depth(texture2D(u_depth,uv+df.xz)),unpack_depth(texture2D(u_depth,uv-df.zy)),unpack_depth(texture2D(u_depth,uv+df.zy))\n);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nfloat tl=texture2D(u_dem,pos).a;float tr=texture2D(u_dem,pos+vec2(off.x,0.0)).a;float bl=texture2D(u_dem,pos+vec2(0.0,off.y)).a;float br=texture2D(u_dem,pos+off).a;\n#else\nvec4 demtl=vec4(texture2D(u_dem,pos).xyz*255.0,-1.0);float tl=dot(demtl,u_dem_unpack);vec4 demtr=vec4(texture2D(u_dem,pos+vec2(off.x,0.0)).xyz*255.0,-1.0);float tr=dot(demtr,u_dem_unpack);vec4 dembl=vec4(texture2D(u_dem,pos+vec2(0.0,off.y)).xyz*255.0,-1.0);float bl=dot(dembl,u_dem_unpack);vec4 dembr=vec4(texture2D(u_dem,pos+off).xyz*255.0,-1.0);float br=dot(dembr,u_dem_unpack);\n#endif\nreturn vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }\n#endif"
                  , ii = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;varying vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif"
                  , ni = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump float u_fog_temporal_offset;varying vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,opacity);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec3 fog_dither(vec3 color) {vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif";
                let ri = {}
                  , oi = {};
                const si = [];
                ui(Qe, si),
                ui(ei, si),
                ui(ii, si),
                ui(ni, si),
                ri = di("", ei),
                oi = di(ni, ii);
                const ai = di("\n#if __VERSION__ >=300\n#define varying in\n#define gl_FragColor glFragColor\n#define texture2D texture\n#define textureCube texture\nout vec4 glFragColor;\n#endif\nhighp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}", "\n#if __VERSION__ >=300\n#define attribute in\n#define varying out\n#define texture2D texture\n#endif\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);//Normalized device coordinate that is not rendered.")
                  , li = Qe
                  , ci = "\n#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif";
                var hi = {
                    background: di("uniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nvarying vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform vec4 u_color;varying vec4 v_color;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(u_color);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    backgroundPattern: di("uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    circle: di("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\ngl_FragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}"),
                    clippingMask: di("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
                    heatmap: di("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {gl_FragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nvarying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                    heatmapTexture: di("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"),
                    collisionBox: di("varying float v_placed;varying float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);gl_FragColor =mix(red,blue,step(0.5,v_placed))*0.5;gl_FragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", "attribute vec3 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;attribute float a_size_scale;attribute vec2 a_padding;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*elevation(a_anchor_pos),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                    collisionCircle: di("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos_2f;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    debug: di("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;\n#endif\nvarying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}"),
                    fill: di("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    fillOutline: di("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    fillOutlinePattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;varying vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    fillPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    fillExtrusion: di("varying vec4 v_color;\n#ifdef RENDER_SHADOWS\nvarying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\nvoid main() {\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvec3 normal=v_normal;\n#endif\nfloat z;vec4 color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);color=mix(v_color,v_roof_color,z);\n#else\ncolor=v_color;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);color.rgb=color.rgb*shade;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef ZERO_ROOF_RADIUS\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#endif\ncolor.xyz=shadowed_color_normal(color.xyz,normalize(normal),v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec4 v_color;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying highp vec4 v_pos_light_view_0;varying highp vec4 v_pos_light_view_1;varying float v_depth;\n#endif\n#ifdef ZERO_ROOF_RADIUS\nvarying vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nvarying highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS)\nv_normal=normal;\n#endif\nbase=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele;vec3 pos;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nv_pos_light_view_0=u_light_matrix_0*vec4(pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1);v_depth=gl_Position.w;\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}v_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting(color,NdotL);\n#else\nv_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_color*=u_opacity;\n#ifdef ZERO_ROOF_RADIUS\nv_roof_color=vec4(0.0,0.0,0.0,1.0);\n#ifdef LIGHTING_3D_MODE\nv_roof_color=apply_lighting(color,calculate_NdotL(vec3(0.0,0.0,1.0)));\n#else\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));\n#endif\nv_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                    fillExtrusionPattern: di("uniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,v_NdotL)*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\ngl_FragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec4 a_pos_normal_ed;attribute vec2 a_centroid_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_pos_3;attribute vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\nvarying vec2 v_pos;varying vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;varying vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nvarying float v_NdotL;\n#endif\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_NdotL=NdotL;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif \n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}"),
                    hillshadePrepare: di("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nreturn texture2D(u_image,coord).a/4.0;\n#else\nvec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;\n#endif\n}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: di("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\ngl_FragColor=apply_lighting(gl_FragColor);\n#endif\n#ifdef FOG\ngl_FragColor=fog_dither(fog_apply_premultiplied(gl_FragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    line: di("uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\nuniform float u_border_width;uniform vec4 u_border_color;float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture2D(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture2D(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trimmed=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef RENDER_LINE_ALPHA_DISCARD\nif (alpha < u_alpha_discard_threshold) {discard;}\n#endif\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=(u_border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);\n#ifdef RENDER_LINE_BORDER_AUTO\nfloat Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}\n#else\nout_color.rgb=mix(u_border_color.rgb*u_border_color.a*trimmed,out_color.rgb,smoothAlpha);\n#endif\n}\n#endif\ngl_FragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define EXTRUDE_SCALE 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nattribute highp vec4 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nattribute float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec4 v_uv;\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;varying vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nfloat a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);\n#else\nv_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                    linePattern: di("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture2D(u_image,pos);\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting(color);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern\n#pragma mapbox: define lowp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#else\nv_gamma_scale=1.0;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}"),
                    raster: di("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply(out_color,v_fog_pos));\n#endif\ngl_FragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,0,w);v_pos0=a_texture_pos/8192.0;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}"),
                    symbolIcon: di("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;}"),
                    symbolSDF: di("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_pixeloffset;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);\n#endif\nvec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nvec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade);}"),
                    symbolTextAndIcon: di("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec4 a_pos_offset;attribute vec4 a_tex_size;attribute vec4 a_projected_pos;attribute float a_fade_opacity;\n#ifdef PROJECTION_GLOBE_VIEW\nattribute vec3 a_globe_anchor;attribute vec3 a_globe_normal;\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nvarying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;vec3 h=elevationVector(tile_anchor)*elevation(tile_anchor);float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\nfloat occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#else\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,float(projected_point.w <=0.0 || occlusion_fade==0.0));\n#endif\nfloat gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;\n#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)\nprojection_transition_fade=1.0-step(EPSILON,u_zoom_transition);\n#endif\nv_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity*projection_transition_fade,is_sdf);}"),
                    terrainRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nvarying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nvoid main() {vec4 color=texture2D(u_image0,v_pos0);\n#ifdef RENDER_SHADOWS\ncolor.xyz=shadowed_color(color.xyz,v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_skirt_height;attribute vec2 a_pos;varying vec2 v_pos0;\n#ifdef FOG\nvarying float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;varying vec4 v_pos_light_view_0;varying vec4 v_pos_light_view_1;varying float v_depth;\n#endif\nconst float wireframeOffset=0.00015;void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;\n#ifdef TERRAIN_WIREFRAME\nelevation+=wireframeOffset;\n#endif\nv_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;\n#endif\n}"),
                    terrainDepth: di("#ifdef GL_ES\nprecision highp float;\n#endif\nvarying float v_depth;void main() {gl_FragColor=pack_depth(v_depth);}", "uniform mat4 u_matrix;attribute vec2 a_pos;varying float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
                    skybox: di("\nvarying lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=textureCube(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);gl_FragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
                    skyboxGradient: di("varying highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture2D(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", ti),
                    skyboxCapture: di("\nvarying highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;\n#ifdef GL_ES\nprecision highp float;\n#endif\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;gl_FragColor=vec4(color,1.0);}", "attribute highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;varying highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"),
                    globeRaster: di("uniform sampler2D u_image0;varying vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nvec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture2D(u_image0,v_pos0);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#else\ncolor=texture2D(u_image0,v_pos0);\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ngl_FragColor=color;\n#ifdef TERRAIN_WIREFRAME\ngl_FragColor=vec4(1.0,0.0,0.0,0.8);\n#endif\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nattribute vec3 a_globe_pos;attribute vec2 a_uv;\n#else\nattribute vec2 a_pos;\n#endif\nvarying vec2 v_pos0;const float wireframeOffset=1e3;float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(QUARTER_PI+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);\n#ifdef TERRAIN_WIREFRAME\nheight+=wireframeOffset;\n#endif\nglobe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}"),
                    globeAtmosphere: di("uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec3 u_start_color;uniform vec4 u_color;uniform vec4 u_space_color;uniform vec4 u_high_color;uniform float u_star_intensity;uniform float u_star_size;uniform float u_star_density;uniform float u_horizon_angle;uniform mat4 u_rotation_matrix;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;highp float random(highp vec3 p) {p=fract(p*vec3(23.2342,97.1231,91.2342));p+=dot(p.zxy,p.yxz+123.1234);return fract(p.x*p.y);}float stars(vec3 p,float scale,vec2 offset) {vec2 uv_scale=(u_viewport/u_star_size)*scale;vec3 position=vec3(p.xy*uv_scale+offset*u_viewport,p.z);vec3 q=fract(position)-0.5;vec3 id=floor(position);float random_visibility=step(random(id),u_star_density);float circle=smoothstep(0.5+u_star_intensity,0.5,length(q));return circle*random_visibility;}void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {discard;return;}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(dot(dir,horizon_dir)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;float closest_point_to_center=length(closest_point-u_globe_pos);float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c =mix(color_stop_2,c2,t);float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);vec2 uv=gl_FragCoord.xy/u_viewport-0.5;float aspect_ratio=u_viewport.x/u_viewport.y;vec4 uv_dir=vec4(normalize(vec3(uv.x*aspect_ratio,uv.y,1.0)),1.0);uv_dir=u_rotation_matrix*uv_dir;vec3 n=abs(uv_dir.xyz);vec2 uv_remap=(n.x > n.y && n.x > n.z) ? uv_dir.yz/uv_dir.x:\n(n.y > n.x && n.y > n.z) ? uv_dir.zx/uv_dir.y:\nuv_dir.xy/uv_dir.z;uv_remap.x/=aspect_ratio;vec3 D=vec3(uv_remap,1.0);highp float star_field=0.0;if (u_star_intensity > 0.0) {star_field+=stars(D,1.2,vec2(0.0,0.0));star_field+=stars(D,1.0,vec2(1.0,0.0));star_field+=stars(D,0.8,vec2(0.0,1.0));star_field+=stars(D,0.6,vec2(1.0,1.0));star_field*=(1.0-pow(t,0.25+(1.0-u_high_color.a)*0.75));c+=star_field*alpha_2;}c=dither(c,gl_FragCoord.xy+u_temporal_offset);gl_FragColor=vec4(c,a);}", "attribute vec3 a_pos;attribute vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;varying highp vec3 v_ray_dir;varying highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}")
                };
                function ui(t, e) {
                    const i = t.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
                    for (let t of i)
                        if (t = t.trim(),
                        "#" === t[0] && t.includes("if") && !t.includes("endif")) {
                            t = t.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
                            const i = t.split(" ");
                            for (const t of i)
                                e.includes(t) || e.push(t)
                        }
                }
                function di(t, e) {
                    const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                      , n = e.match(/attribute (highp |mediump |lowp )?([\w]+) ([\w]+)/g)
                      , r = {}
                      , o = [...si];
                    return ui(t, o),
                    ui(e, o),
                    {
                        fragmentSource: t = t.replace(i, ( (t, e, i, n, o) => (r[o] = !0,
                        "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nvarying ${i} ${n} ${o};\n#else\nuniform ${i} ${n} u_${o};\n#endif\n` : `\n#ifdef HAS_UNIFORM_u_${o}\n    ${i} ${n} ${o} = u_${o};\n#endif\n`))),
                        vertexSource: e = e.replace(i, ( (t, e, i, n, o) => {
                            const s = "float" === n ? "vec2" : "vec4"
                              , a = o.match(/color/) ? "color" : s;
                            return r[o] ? "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${s} a_${o};\nvarying ${i} ${n} ${o};\n#else\nuniform ${i} ${n} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = a_${o};\n#else\n    ${i} ${n} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${n} ${o} = u_${o};\n#endif\n` : "define" === e ? `\n#ifndef HAS_UNIFORM_u_${o}\nuniform lowp float u_${o}_t;\nattribute ${i} ${s} a_${o};\n#else\nuniform ${i} ${n} u_${o};\n#endif\n` : "vec4" === a ? `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${n} ${o} = a_${o};\n#else\n    ${i} ${n} ${o} = u_${o};\n#endif\n` : `\n#ifndef HAS_UNIFORM_u_${o}\n    ${i} ${n} ${o} = unpack_mix_${a}(a_${o}, u_${o}_t);\n#else\n    ${i} ${n} ${o} = u_${o};\n#endif\n`
                        }
                        )),
                        staticAttributes: n,
                        usedDefines: o
                    }
                }
                class fi {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffers = [],
                        this.vao = null
                    }
                    bind(t, e, i, n, r, o, s) {
                        this.context = t;
                        let a = this.boundPaintVertexBuffers.length !== n.length;
                        for (let t = 0; !a && t < n.length; t++)
                            this.boundPaintVertexBuffers[t] !== n[t] && (a = !0);
                        let l = this.boundDynamicVertexBuffers.length !== s.length;
                        for (let t = 0; !l && t < s.length; t++)
                            this.boundDynamicVertexBuffers[t] !== s[t] && (l = !0);
                        if (!t.extVertexArrayObject || !this.vao || this.boundProgram !== e || this.boundLayoutVertexBuffer !== i || a || l || this.boundIndexBuffer !== r || this.boundVertexOffset !== o)
                            this.freshBind(e, i, n, r, o, s);
                        else {
                            t.bindVertexArrayOES.set(this.vao);
                            for (const t of s)
                                t && t.bind();
                            r && r.dynamicDraw && r.bind()
                        }
                    }
                    freshBind(t, e, i, n, r, o) {
                        let s;
                        const a = t.numAttributes
                          , l = this.context
                          , c = l.gl;
                        if (l.extVertexArrayObject)
                            this.vao && this.destroy(),
                            this.vao = l.extVertexArrayObject.createVertexArrayOES(),
                            l.bindVertexArrayOES.set(this.vao),
                            s = 0,
                            this.boundProgram = t,
                            this.boundLayoutVertexBuffer = e,
                            this.boundPaintVertexBuffers = i,
                            this.boundIndexBuffer = n,
                            this.boundVertexOffset = r,
                            this.boundDynamicVertexBuffers = o;
                        else {
                            s = l.currentNumAttributes || 0;
                            for (let t = a; t < s; t++)
                                c.disableVertexAttribArray(t)
                        }
                        e.enableAttributes(c, t),
                        e.bind(),
                        e.setVertexAttribPointers(c, t, r);
                        for (const e of i)
                            e.enableAttributes(c, t),
                            e.bind(),
                            e.setVertexAttribPointers(c, t, r);
                        for (const e of o)
                            e && (e.enableAttributes(c, t),
                            e.bind(),
                            e.setVertexAttribPointers(c, t, r));
                        n && n.bind(),
                        l.currentNumAttributes = a
                    }
                    destroy() {
                        this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao),
                        this.vao = null)
                    }
                }
                function pi(e, i) {
                    const n = Math.pow(2, i.canonical.z)
                      , r = i.canonical.y;
                    return [new t.MercatorCoordinate(0,r / n).toLngLat().lat, new t.MercatorCoordinate(0,(r + 1) / n).toLngLat().lat]
                }
                function mi(e, i, n, r, o, s, a) {
                    const l = e.context
                      , c = l.gl
                      , h = n.fbo;
                    if (!h)
                        return;
                    e.prepareDrawTile();
                    const u = e.useProgram("hillshade");
                    l.activeTexture.set(c.TEXTURE0),
                    c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());
                    const d = ( (t, e, i, n) => {
                        const r = i.paint.get("hillshade-shadow-color")
                          , o = i.paint.get("hillshade-highlight-color")
                          , s = i.paint.get("hillshade-accent-color");
                        let a = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                        "viewport" === i.paint.get("hillshade-illumination-anchor") && (a -= t.transform.angle);
                        const l = !t.options.moving;
                        return {
                            u_matrix: n || t.transform.calculateProjMatrix(e.tileID.toUnwrapped(), l),
                            u_image: 0,
                            u_latrange: pi(0, e.tileID),
                            u_light: [i.paint.get("hillshade-exaggeration"), a],
                            u_shadow: r,
                            u_highlight: o,
                            u_accent: s
                        }
                    }
                    )(e, n, r, e.terrain ? i.projMatrix : null);
                    e.prepareDrawProgram(l, u, i.toUnwrapped());
                    const {tileBoundsBuffer: f, tileBoundsIndexBuffer: p, tileBoundsSegments: m} = e.getTileBoundsBuffers(n);
                    u.draw(l, c.TRIANGLES, o, s, a, t.CullFaceMode.disabled, d, r.id, f, p, m)
                }
                function gi(e, i, n) {
                    if (!i.needsDEMTextureUpload)
                        return;
                    const r = e.context
                      , o = r.gl;
                    r.pixelStoreUnpackPremultiplyAlpha.set(!1),
                    i.demTexture = i.demTexture || e.getTileTexture(n.stride);
                    const s = n.getPixels();
                    i.demTexture ? i.demTexture.update(s, {
                        premultiply: !1
                    }) : i.demTexture = new t.Texture(r,s,o.RGBA,{
                        premultiply: !1
                    }),
                    i.needsDEMTextureUpload = !1
                }
                function _i(e, i, n, r, o, s) {
                    const a = e.context
                      , l = a.gl;
                    if (!i.dem)
                        return;
                    const c = i.dem;
                    if (a.activeTexture.set(l.TEXTURE1),
                    gi(e, i, c),
                    !i.demTexture)
                        return;
                    i.demTexture.bind(l.NEAREST, l.CLAMP_TO_EDGE);
                    const h = c.dim;
                    a.activeTexture.set(l.TEXTURE0);
                    let u = i.fbo;
                    if (!u) {
                        const e = new t.Texture(a,{
                            width: h,
                            height: h,
                            data: null
                        },l.RGBA);
                        e.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                        u = i.fbo = a.createFramebuffer(h, h, !0),
                        u.colorAttachment.set(e.texture)
                    }
                    a.bindFramebuffer.set(u.framebuffer),
                    a.viewport.set([0, 0, h, h]);
                    const {tileBoundsBuffer: d, tileBoundsIndexBuffer: f, tileBoundsSegments: p} = e.getMercatorTileBoundsBuffers();
                    e.useProgram("hillshadePrepare").draw(a, l.TRIANGLES, r, o, s, t.CullFaceMode.disabled, ( (e, i) => {
                        const n = i.stride
                          , r = t.create();
                        return t.ortho(r, 0, t.EXTENT, -t.EXTENT, 0, 0, 1),
                        t.translate(r, r, [0, -t.EXTENT, 0]),
                        {
                            u_matrix: r,
                            u_image: 1,
                            u_dimension: [n, n],
                            u_zoom: e.overscaledZ,
                            u_unpack: i.unpackVector
                        }
                    }
                    )(i.tileID, c), n.id, d, f, p),
                    i.needsHillshadePrepare = !1
                }
                const yi = e => ({
                    u_matrix: new t.UniformMatrix4f(e),
                    u_image0: new t.Uniform1i(e),
                    u_skirt_height: new t.Uniform1f(e)
                })
                  , vi = (t, e) => ({
                    u_matrix: t,
                    u_image0: 0,
                    u_skirt_height: e
                })
                  , xi = (t, e, i, n, r, o, s, a, l, c, h, u, d, f, p) => ({
                    u_proj_matrix: Float32Array.from(t),
                    u_globe_matrix: e,
                    u_normalize_matrix: Float32Array.from(n),
                    u_merc_matrix: i,
                    u_zoom_transition: r,
                    u_merc_center: o,
                    u_image0: 0,
                    u_frustum_tl: s,
                    u_frustum_tr: a,
                    u_frustum_br: l,
                    u_frustum_bl: c,
                    u_globe_pos: h,
                    u_globe_radius: u,
                    u_viewport: d,
                    u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9),
                    u_skirt_height: f
                });
                function bi(t, e) {
                    return null != t && null != e && !(!t.hasData() || !e.hasData()) && null != t.demTexture && null != e.demTexture && t.tileID.key !== e.tileID.key
                }
                const wi = new class {
                    constructor() {
                        this.operations = {}
                    }
                    newMorphing(t, e, i, n, r) {
                        if (t in this.operations) {
                            const e = this.operations[t];
                            e.to.tileID.key !== i.tileID.key && (e.queued = i)
                        } else
                            this.operations[t] = {
                                startTime: n,
                                phase: 0,
                                duration: r,
                                from: e,
                                to: i,
                                queued: null
                            }
                    }
                    getMorphValuesForProxy(t) {
                        if (!(t in this.operations))
                            return null;
                        const e = this.operations[t];
                        return {
                            from: e.from,
                            to: e.to,
                            phase: e.phase
                        }
                    }
                    update(t) {
                        for (const e in this.operations) {
                            const i = this.operations[e];
                            for (i.phase = (t - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i); )
                                if (!this._nextOp(i, t)) {
                                    delete this.operations[e];
                                    break
                                }
                        }
                    }
                    _nextOp(t, e) {
                        return !!t.queued && (t.from = t.to,
                        t.to = t.queued,
                        t.queued = null,
                        t.phase = 0,
                        t.startTime = e,
                        !0)
                    }
                    _validOp(t) {
                        return t.from.hasData() && t.to.hasData()
                    }
                }
                  , Ei = {
                    0: null,
                    1: "TERRAIN_VERTEX_MORPHING",
                    2: "TERRAIN_WIREFRAME"
                };
                function Ti(t) {
                    return 6 * Math.pow(1.5, 22 - t)
                }
                function Si(t, e) {
                    const i = 1 << t.z;
                    return !e && (0 === t.x || t.x === i - 1) || 0 === t.y || t.y === i - 1
                }
                const Ci = t => ({
                    u_matrix: t
                });
                function Ai(e, i, n, r, o) {
                    if (o > 0) {
                        const s = t.exported.now()
                          , a = (s - e.timeAdded) / o
                          , l = i ? (s - i.timeAdded) / o : -1
                          , c = n.getSource()
                          , h = r.coveringZoomLevel({
                            tileSize: c.tileSize,
                            roundZoom: c.roundZoom
                        })
                          , u = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(e.tileID.overscaledZ - h)
                          , d = u && e.refreshedUponExpiration ? 1 : t.clamp(u ? a : 1 - l, 0, 1);
                        return e.refreshedUponExpiration && a >= 1 && (e.refreshedUponExpiration = !1),
                        i ? {
                            opacity: 1,
                            mix: 1 - d
                        } : {
                            opacity: d,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                class Ii extends t.SourceCache {
                    constructor(t) {
                        const e = {
                            type: "raster-dem",
                            maxzoom: t.transform.maxZoom
                        }
                          , i = new P(jt(),null)
                          , n = kt("mock-dem", e, i, t.style);
                        super("mock-dem", n, !1),
                        n.setEventedParent(this),
                        this._sourceLoaded = !0
                    }
                    _loadTile(t, e) {
                        t.state = "loaded",
                        e(null)
                    }
                }
                class Mi extends t.SourceCache {
                    constructor(t) {
                        const e = kt("proxy", {
                            type: "geojson",
                            maxzoom: t.transform.maxZoom
                        }, new P(jt(),null), t.style);
                        super("proxy", e, !1),
                        e.setEventedParent(this),
                        this.map = this.getSource().map = t,
                        this.used = this._sourceLoaded = !0,
                        this.renderCache = [],
                        this.renderCachePool = [],
                        this.proxyCachedFBO = {}
                    }
                    update(e, i, n) {
                        if (e.freezeTileCoverage)
                            return;
                        this.transform = e;
                        const r = e.coveringTiles({
                            tileSize: this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled
                        }).reduce(( (i, n) => {
                            if (i[n.key] = "",
                            !this._tiles[n.key]) {
                                const i = new t.Tile(n,this._source.tileSize * n.overscaleFactor(),e.tileZoom);
                                i.state = "loaded",
                                this._tiles[n.key] = i
                            }
                            return i
                        }
                        ), {});
                        for (const t in this._tiles)
                            t in r || (this.freeFBO(t),
                            this._tiles[t].unloadVectorData(),
                            delete this._tiles[t])
                    }
                    freeFBO(t) {
                        const e = this.proxyCachedFBO[t];
                        if (void 0 !== e) {
                            const i = Object.values(e);
                            this.renderCachePool.push(...i),
                            delete this.proxyCachedFBO[t]
                        }
                    }
                    deallocRenderCache() {
                        this.renderCache.forEach((t => t.fb.destroy())),
                        this.renderCache = [],
                        this.renderCachePool = [],
                        this.proxyCachedFBO = {}
                    }
                }
                class Pi extends t.OverscaledTileID {
                    constructor(t, e, i) {
                        super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y),
                        this.proxyTileKey = e,
                        this.projMatrix = i
                    }
                }
                class ki extends t.Elevation {
                    constructor(e, i) {
                        super(),
                        this.painter = e,
                        this.terrainTileForTile = {},
                        this.prevTerrainTileForTile = {};
                        const [n,r,o] = function(e) {
                            const i = new t.StructArrayLayout2i4
                              , n = new t.StructArrayLayout3ui6
                              , r = 131;
                            i.reserve(17161),
                            n.reserve(33800);
                            const o = t.EXTENT / 128
                              , s = t.EXTENT + o / 2
                              , a = s + o;
                            for (let e = -o; e < a; e += o)
                                for (let n = -o; n < a; n += o) {
                                    const r = n < 0 || n > s || e < 0 || e > s ? 24575 : 0
                                      , o = t.clamp(Math.round(n), 0, t.EXTENT)
                                      , a = t.clamp(Math.round(e), 0, t.EXTENT);
                                    i.emplaceBack(o + r, a)
                                }
                            const l = (t, e) => {
                                const i = e * r + t;
                                n.emplaceBack(i + 1, i, i + r),
                                n.emplaceBack(i + r, i + r + 1, i + 1)
                            }
                            ;
                            for (let t = 1; t < 129; t++)
                                for (let e = 1; e < 129; e++)
                                    l(e, t);
                            return [0, 129].forEach((t => {
                                for (let e = 0; e < 130; e++)
                                    l(e, t),
                                    l(t, e)
                            }
                            )),
                            [i, n, 32768]
                        }()
                          , s = e.context;
                        this.gridBuffer = s.createVertexBuffer(n, t.posAttributes.members),
                        this.gridIndexBuffer = s.createIndexBuffer(r),
                        this.gridSegments = t.SegmentVector.simpleSegment(0, 0, n.length, r.length),
                        this.gridNoSkirtSegments = t.SegmentVector.simpleSegment(0, 0, n.length, o),
                        this.proxyCoords = [],
                        this.proxiedCoords = {},
                        this._visibleDemTiles = [],
                        this._drapedRenderBatches = [],
                        this._sourceTilesOverlap = {},
                        this.proxySourceCache = new Mi(i.map),
                        this.orthoMatrix = t.create(),
                        t.ortho(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? .015 : 0, t.EXTENT, 0, t.EXTENT, 0, 1);
                        const a = s.gl;
                        this._overlapStencilMode = new t.StencilMode({
                            func: a.GEQUAL,
                            mask: 255
                        },0,255,a.KEEP,a.KEEP,a.REPLACE),
                        this._previousZoom = e.transform.zoom,
                        this.pool = [],
                        this._findCoveringTileCache = {},
                        this._tilesDirty = {},
                        this.style = i,
                        this._useVertexMorphing = !0,
                        this._exaggeration = 1,
                        this._mockSourceCache = new Ii(i.map)
                    }
                    set style(t) {
                        t.on("data", this._onStyleDataEvent.bind(this)),
                        t.on("neworder", this._checkRenderCacheEfficiency.bind(this)),
                        this._style = t,
                        this._checkRenderCacheEfficiency(),
                        this._style.map.on("moveend", ( () => {
                            this._clearLineLayersFromRenderCache()
                        }
                        ))
                    }
                    update(e, i, n) {
                        if (e && e.terrain) {
                            this._style !== e && (this.style = e),
                            this.enabled = !0;
                            const r = e.terrain.properties;
                            this.sourceCache = 0 === e.terrain.drapeRenderMode ? this._mockSourceCache : e._getSourceCache(r.get("source")),
                            this._exaggeration = r.get("exaggeration");
                            const o = () => {
                                this.sourceCache.used && t.warnOnce(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                                const e = this.getScaledDemTileSize();
                                this.sourceCache.update(i, e, !0),
                                this.resetTileLookupCache(this.sourceCache.id)
                            }
                            ;
                            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id),
                            this.sourceCache.usedForTerrain = !0,
                            o(),
                            this._initializing = !0),
                            o(),
                            i.updateElevation(!0, n),
                            this.resetTileLookupCache(this.proxySourceCache.id),
                            this.proxySourceCache.update(i),
                            this._emptyDEMTextureDirty = !0
                        } else
                            this._disable()
                    }
                    resetTileLookupCache(t) {
                        this._findCoveringTileCache[t] = {}
                    }
                    getScaledDemTileSize() {
                        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize
                    }
                    _checkRenderCacheEfficiency() {
                        const e = this.renderCacheEfficiency(this._style);
                        this._style.map._optimizeForTerrain || 100 !== e.efficiency && t.warnOnce(`Terrain render cache efficiency is not optimal (${e.efficiency}%) and performance\n                may be affected negatively, consider placing all background, fill and line layers before layer\n                with id '${e.firstUndrapedLayer}' or create a map using optimizeForTerrain: true option.`)
                    }
                    _onStyleDataEvent(t) {
                        t.coord && "source" === t.dataType ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : "style" === t.dataType && (this._invalidateRenderCache = !0)
                    }
                    _disable() {
                        if (this.enabled && (this.enabled = !1,
                        this._sharedDepthStencil = void 0,
                        this.proxySourceCache.deallocRenderCache(),
                        this._style))
                            for (const t in this._style._sourceCaches)
                                this._style._sourceCaches[t].usedForTerrain = !1
                    }
                    destroy() {
                        this._disable(),
                        this._emptyDEMTexture && this._emptyDEMTexture.destroy(),
                        this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(),
                        this.pool.forEach((t => t.fb.destroy())),
                        this.pool = [],
                        this._depthFBO && (this._depthFBO.destroy(),
                        this._depthFBO = void 0,
                        this._depthTexture = void 0)
                    }
                    _source() {
                        return this.enabled ? this.sourceCache : null
                    }
                    isUsingMockSource() {
                        return this.sourceCache === this._mockSourceCache
                    }
                    exaggeration() {
                        return this._exaggeration
                    }
                    get visibleDemTiles() {
                        return this._visibleDemTiles
                    }
                    get drapeBufferSize() {
                        const t = 2 * this.proxySourceCache.getSource().tileSize;
                        return [t, t]
                    }
                    set useVertexMorphing(t) {
                        this._useVertexMorphing = t
                    }
                    updateTileBinding(e) {
                        if (!this.enabled)
                            return;
                        this.prevTerrainTileForTile = this.terrainTileForTile;
                        const i = this.proxySourceCache
                          , n = this.painter.transform;
                        this._initializing && (this._initializing = 0 === n._centerAltitude && -1 === this.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(n.center), -1),
                        this._emptyDEMTextureDirty = !this._initializing);
                        const r = this.proxyCoords = i.getIds().map((t => {
                            const e = i.getTileByID(t).tileID;
                            return e.projMatrix = n.calculateProjMatrix(e.toUnwrapped()),
                            e
                        }
                        ));
                        !function(e, i) {
                            const n = i.transform.pointCoordinate(i.transform.getCameraPoint())
                              , r = new t.Point(n.x,n.y);
                            e.sort(( (e, i) => {
                                if (i.overscaledZ - e.overscaledZ)
                                    return i.overscaledZ - e.overscaledZ;
                                const n = new t.Point(e.canonical.x + (1 << e.canonical.z) * e.wrap,e.canonical.y)
                                  , o = new t.Point(i.canonical.x + (1 << i.canonical.z) * i.wrap,i.canonical.y)
                                  , s = r.mult(1 << e.canonical.z);
                                return s.x -= .5,
                                s.y -= .5,
                                s.distSqr(n) - s.distSqr(o)
                            }
                            ))
                        }(r, this.painter),
                        this._previousZoom = n.zoom;
                        const o = this.proxyToSource || {};
                        this.proxyToSource = {},
                        r.forEach((t => {
                            this.proxyToSource[t.key] = {}
                        }
                        )),
                        this.terrainTileForTile = {};
                        const s = this._style._sourceCaches;
                        for (const t in s) {
                            const i = s[t];
                            if (!i.used)
                                continue;
                            if (i !== this.sourceCache && this.resetTileLookupCache(i.id),
                            this._setupProxiedCoordsForOrtho(i, e[t], o),
                            i.usedForTerrain)
                                continue;
                            const n = e[t];
                            i.getSource().reparseOverscaled && this._assignTerrainTiles(n)
                        }
                        this.proxiedCoords[i.id] = r.map((t => new Pi(t,t.key,this.orthoMatrix))),
                        this._assignTerrainTiles(r),
                        this._prepareDEMTextures(),
                        this._setupDrapedRenderBatches(),
                        this._initFBOPool(),
                        this._setupRenderCache(o),
                        this.renderingToTexture = !1,
                        this._updateTimestamp = t.exported.now();
                        const a = {};
                        this._visibleDemTiles = [];
                        for (const t of this.proxyCoords) {
                            const e = this.terrainTileForTile[t.key];
                            if (!e)
                                continue;
                            const i = e.tileID.key;
                            i in a || (this._visibleDemTiles.push(e),
                            a[i] = i)
                        }
                    }
                    _assignTerrainTiles(t) {
                        this._initializing || t.forEach((t => {
                            if (this.terrainTileForTile[t.key])
                                return;
                            const e = this._findTileCoveringTileID(t, this.sourceCache);
                            e && (this.terrainTileForTile[t.key] = e)
                        }
                        ))
                    }
                    _prepareDEMTextures() {
                        const t = this.painter.context
                          , e = t.gl;
                        for (const i in this.terrainTileForTile) {
                            const n = this.terrainTileForTile[i]
                              , r = n.dem;
                            !r || n.demTexture && !n.needsDEMTextureUpload || (t.activeTexture.set(e.TEXTURE1),
                            gi(this.painter, n, r))
                        }
                    }
                    _prepareDemTileUniforms(t, e, i, n) {
                        if (!e || null == e.demTexture)
                            return !1;
                        const r = t.tileID.canonical
                          , o = Math.pow(2, e.tileID.canonical.z - r.z)
                          , s = n || "";
                        return i[`u_dem_tl${s}`] = [r.x * o % 1, r.y * o % 1],
                        i[`u_dem_scale${s}`] = o,
                        !0
                    }
                    get emptyDEMTexture() {
                        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture()
                    }
                    get emptyDepthBufferTexture() {
                        const e = this.painter.context
                          , i = e.gl;
                        if (!this._emptyDepthBufferTexture) {
                            const n = new t.RGBAImage({
                                width: 1,
                                height: 1
                            },Uint8Array.of(255, 255, 255, 255));
                            this._emptyDepthBufferTexture = new t.Texture(e,n,i.RGBA,{
                                premultiply: !1
                            })
                        }
                        return this._emptyDepthBufferTexture
                    }
                    _getLoadedAreaMinimum() {
                        let t = 0;
                        const e = this._visibleDemTiles.reduce(( (e, i) => {
                            if (!i.dem)
                                return e;
                            const n = i.dem.tree.minimums[0];
                            return n > 0 && t++,
                            e + n
                        }
                        ), 0);
                        return t ? e / t : 0
                    }
                    _updateEmptyDEMTexture() {
                        const e = this.painter.context
                          , i = e.gl;
                        e.activeTexture.set(i.TEXTURE2);
                        const n = this._getLoadedAreaMinimum()
                          , r = new t.RGBAImage({
                            width: 1,
                            height: 1
                        },new Uint8Array(t.DEMData.pack(n, this.sourceCache.getSource().encoding)));
                        this._emptyDEMTextureDirty = !1;
                        let o = this._emptyDEMTexture;
                        return o ? o.update(r, {
                            premultiply: !1
                        }) : o = this._emptyDEMTexture = new t.Texture(e,r,i.RGBA,{
                            premultiply: !1
                        }),
                        o
                    }
                    setupElevationDraw(e, i, n) {
                        const r = this.painter.context
                          , o = r.gl
                          , s = (a = this.sourceCache.getSource().encoding,
                        {
                            u_dem: 2,
                            u_dem_prev: 4,
                            u_dem_unpack: t.DEMData.getUnpackVector(a),
                            u_dem_tl: [0, 0],
                            u_dem_tl_prev: [0, 0],
                            u_dem_scale: 0,
                            u_dem_scale_prev: 0,
                            u_dem_size: 0,
                            u_dem_lerp: 1,
                            u_depth: 3,
                            u_depth_size_inv: [0, 0],
                            u_exaggeration: 0
                        });
                        var a;
                        s.u_dem_size = this.sourceCache.getSource().tileSize,
                        s.u_exaggeration = this.exaggeration();
                        let l = null
                          , c = null
                          , h = 1;
                        if (n && n.morphing && this._useVertexMorphing) {
                            const t = n.morphing.srcDemTile
                              , i = n.morphing.dstDemTile;
                            h = n.morphing.phase,
                            t && i && (this._prepareDemTileUniforms(e, t, s, "_prev") && (c = t),
                            this._prepareDemTileUniforms(e, i, s) && (l = i))
                        }
                        if (c && l ? (r.activeTexture.set(o.TEXTURE2),
                        l.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                        r.activeTexture.set(o.TEXTURE4),
                        c.demTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE, o.NEAREST),
                        s.u_dem_lerp = h) : (l = this.terrainTileForTile[e.tileID.key],
                        r.activeTexture.set(o.TEXTURE2),
                        (this._prepareDemTileUniforms(e, l, s) ? l.demTexture : this.emptyDEMTexture).bind(o.NEAREST, o.CLAMP_TO_EDGE)),
                        r.activeTexture.set(o.TEXTURE3),
                        n && n.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE),
                        this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE),
                        s.u_depth_size_inv = [1, 1]),
                        n && n.useMeterToDem && l) {
                            const e = (1 << l.tileID.canonical.z) * t.mercatorZfromAltitude(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                            s.u_meter_to_dem = e
                        }
                        if (n && n.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = n.labelPlaneMatrixInv),
                        i.setTerrainUniformValues(r, s),
                        "globe" === this.painter.transform.projection.name) {
                            const t = this.globeUniformValues(this.painter.transform, e.tileID.canonical, n && n.useDenormalizedUpVectorScale);
                            i.setGlobeUniformValues(r, t)
                        }
                    }
                    globeUniformValues(e, i, n) {
                        const r = e.projection;
                        return {
                            u_tile_tl_up: r.upVector(i, 0, 0),
                            u_tile_tr_up: r.upVector(i, t.EXTENT, 0),
                            u_tile_br_up: r.upVector(i, t.EXTENT, t.EXTENT),
                            u_tile_bl_up: r.upVector(i, 0, t.EXTENT),
                            u_tile_up_scale: n ? t.globeMetersToEcef(1) : r.upVectorScale(i, e.center.lat, e.worldSize).metersToTile
                        }
                    }
                    renderToBackBuffer(e) {
                        const i = this.painter
                          , n = this.painter.context;
                        0 !== e.length && (n.bindFramebuffer.set(null),
                        n.viewport.set([0, 0, i.width, i.height]),
                        i.gpuTimingDeferredRenderStart(),
                        this.renderingToTexture = !1,
                        function(e, i, n, r, o) {
                            if ("globe" === e.transform.projection.name)
                                !function(e, i, n, r, o) {
                                    const s = e.context
                                      , a = s.gl;
                                    let l, c;
                                    const h = e.options.showTerrainWireframe ? 2 : 0
                                      , u = e.transform
                                      , d = t.globeUseCustomAntiAliasing(e, s, u)
                                      , f = (t, i) => {
                                        if (c === t)
                                            return;
                                        const n = [Ei[t], "PROJECTION_GLOBE_VIEW"];
                                        d && n.push("CUSTOM_ANTIALIASING"),
                                        i && n.push(Ei[h]),
                                        l = e.useProgram("globeRaster", null, n),
                                        c = t
                                    }
                                      , p = e.colorModeForRenderPass()
                                      , m = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                                    wi.update(o);
                                    const g = t.calculateGlobeMercatorMatrix(u)
                                      , _ = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
                                      , y = h ? [!1, !0] : [!1]
                                      , v = e.globeSharedBuffers
                                      , x = [u.width * t.exported.devicePixelRatio, u.height * t.exported.devicePixelRatio]
                                      , b = Float32Array.from(u.globeMatrix)
                                      , w = {
                                        useDenormalizedUpVectorScale: !0
                                    };
                                    if (y.forEach((h => {
                                        const u = e.transform
                                          , d = Ti(u.zoom) * i.exaggeration();
                                        c = -1;
                                        const y = h ? a.LINES : a.TRIANGLES;
                                        for (const c of r) {
                                            const r = n.getTile(c)
                                              , E = t.StencilMode.disabled
                                              , T = i.prevTerrainTileForTile[c.key]
                                              , S = i.terrainTileForTile[c.key];
                                            bi(T, S) && wi.newMorphing(c.key, T, S, o, 250),
                                            s.activeTexture.set(a.TEXTURE0),
                                            r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                            const C = wi.getMorphValuesForProxy(c.key)
                                              , A = C ? 1 : 0;
                                            C && t.extend$1(w, {
                                                morphing: {
                                                    srcDemTile: C.from,
                                                    dstDemTile: C.to,
                                                    phase: t.easeCubicInOut(C.phase)
                                                }
                                            });
                                            const I = t.tileCornersToBounds(c.canonical)
                                              , M = t.getLatitudinalLod(I.getCenter().lat)
                                              , P = t.getGridMatrix(c.canonical, I, M, u.worldSize / u._pixelsPerMercatorPixel)
                                              , k = t.globeNormalizeECEF(t.globeTileBounds(c.canonical))
                                              , O = xi(u.projMatrix, b, g, k, t.globeToMercatorTransition(u.zoom), _, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, x, d, P);
                                            if (f(A, h),
                                            i.setupElevationDraw(r, l, w),
                                            e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                            v) {
                                                const [i,n,r] = h ? v.getWirefameBuffers(e.context, M) : v.getGridBuffers(M, 0 !== d);
                                                l.draw(s, y, m, E, p, t.CullFaceMode.backCCW, O, "globe_raster", i, n, r)
                                            }
                                        }
                                    }
                                    )),
                                    v) {
                                        const o = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                                        d && o.push("CUSTOM_ANTIALIASING"),
                                        l = e.useProgram("globeRaster", null, o);
                                        for (const o of r) {
                                            const {x: r, y: c, z: h} = o.canonical
                                              , d = 0 === c
                                              , f = c === (1 << h) - 1
                                              , [g,y,b,E] = v.getPoleBuffers(h);
                                            if (E && (d || f)) {
                                                const c = n.getTile(o);
                                                s.activeTexture.set(a.TEXTURE0),
                                                c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                                                let v = t.globePoleMatrixForTile(h, r, u);
                                                const T = t.globeNormalizeECEF(t.globeTileBounds(o.canonical))
                                                  , S = (e, i) => e.draw(s, a.TRIANGLES, m, t.StencilMode.disabled, p, t.CullFaceMode.disabled, xi(u.projMatrix, v, v, T, 0, _, u.frustumCorners.TL, u.frustumCorners.TR, u.frustumCorners.BR, u.frustumCorners.BL, u.globeCenterInViewSpace, u.globeRadius, x, 0), "globe_pole_raster", i, b, E);
                                                i.setupElevationDraw(c, l, w),
                                                e.prepareDrawProgram(s, l, o.toUnwrapped()),
                                                d && S(l, g),
                                                f && (v = t.scale(t.create(), v, [1, -1, 1]),
                                                S(l, y))
                                            }
                                        }
                                    }
                                }(e, i, n, r, o);
                            else {
                                const s = e.context
                                  , a = s.gl;
                                let l, c;
                                const h = e.options.showTerrainWireframe ? 2 : 0
                                  , u = (t, i) => {
                                    if (c === t)
                                        return;
                                    const n = [Ei[t]];
                                    i && n.push(Ei[h]),
                                    l = e.useProgram("terrainRaster", null, n),
                                    c = t
                                }
                                  , d = e.colorModeForRenderPass()
                                  , f = new t.DepthMode(a.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                                wi.update(o);
                                const p = e.transform
                                  , m = Ti(p.zoom) * i.exaggeration();
                                (h ? [!1, !0] : [!1]).forEach((h => {
                                    c = -1;
                                    const g = h ? a.LINES : a.TRIANGLES
                                      , [_,y] = h ? i.getWirefameBuffer() : [i.gridIndexBuffer, i.gridSegments];
                                    for (const c of r) {
                                        const r = n.getTile(c)
                                          , v = t.StencilMode.disabled
                                          , x = i.prevTerrainTileForTile[c.key]
                                          , b = i.terrainTileForTile[c.key];
                                        bi(x, b) && wi.newMorphing(c.key, x, b, o, 250),
                                        s.activeTexture.set(a.TEXTURE0),
                                        r.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE, a.LINEAR_MIPMAP_NEAREST);
                                        const w = wi.getMorphValuesForProxy(c.key)
                                          , E = w ? 1 : 0;
                                        let T;
                                        w && (T = {
                                            morphing: {
                                                srcDemTile: w.from,
                                                dstDemTile: w.to,
                                                phase: t.easeCubicInOut(w.phase)
                                            }
                                        });
                                        const S = vi(c.projMatrix, Si(c.canonical, p.renderWorldCopies) ? m / 10 : m);
                                        u(E, h),
                                        i.setupElevationDraw(r, l, T),
                                        e.prepareDrawProgram(s, l, c.toUnwrapped()),
                                        l.draw(s, g, f, v, d, t.CullFaceMode.backCCW, S, "terrain_raster", i.gridBuffer, _, y)
                                    }
                                }
                                ))
                            }
                        }(i, this, this.proxySourceCache, e, this._updateTimestamp),
                        this.renderingToTexture = !0,
                        i.gpuTimingDeferredRenderEnd(),
                        e.splice(0, e.length))
                    }
                    renderBatch(e) {
                        if (0 === this._drapedRenderBatches.length)
                            return e + 1;
                        this.renderingToTexture = !0;
                        const i = this.painter
                          , n = this.painter.context
                          , r = this.proxySourceCache
                          , o = this.proxiedCoords[r.id]
                          , s = this._drapedRenderBatches.shift()
                          , a = []
                          , l = i.style.order;
                        let c = 0;
                        for (const h of o) {
                            const o = r.getTileByID(h.proxyTileKey)
                              , u = r.proxyCachedFBO[h.key] ? r.proxyCachedFBO[h.key][e] : void 0
                              , d = void 0 !== u ? r.renderCache[u] : this.pool[c++]
                              , f = void 0 !== u;
                            if (o.texture = d.tex,
                            f && !d.dirty) {
                                a.push(o.tileID);
                                continue
                            }
                            let p;
                            n.bindFramebuffer.set(d.fb.framebuffer),
                            this.renderedToTile = !1,
                            d.dirty && (n.clear({
                                color: t.Color.transparent,
                                stencil: 0
                            }),
                            d.dirty = !1);
                            for (let t = s.start; t <= s.end; ++t) {
                                const e = i.style._layers[l[t]];
                                if (e.isHidden(i.transform.zoom))
                                    continue;
                                const r = i.style._getLayerSourceCache(e)
                                  , o = r ? this.proxyToSource[h.key][r.id] : [h];
                                if (!o)
                                    continue;
                                const s = o;
                                n.viewport.set([0, 0, d.fb.width, d.fb.height]),
                                p !== (r ? r.id : null) && (this._setupStencil(d, o, e, r),
                                p = r ? r.id : null),
                                i.renderLayer(i, r, e, s)
                            }
                            this.renderedToTile ? (d.dirty = !0,
                            a.push(o.tileID)) : f || --c,
                            5 === c && (c = 0,
                            this.renderToBackBuffer(a))
                        }
                        return this.renderToBackBuffer(a),
                        this.renderingToTexture = !1,
                        n.bindFramebuffer.set(null),
                        n.viewport.set([0, 0, i.width, i.height]),
                        s.end + 1
                    }
                    postRender() {}
                    renderCacheEfficiency(t) {
                        const e = t.order.length;
                        if (0 === e)
                            return {
                                efficiency: 100
                            };
                        let i, n = 0, r = 0, o = !1;
                        for (let s = 0; s < e; ++s) {
                            const e = t._layers[t.order[s]];
                            this._style.isLayerDraped(e) ? (o && ++n,
                            ++r) : o || (o = !0,
                            i = e.id)
                        }
                        return 0 === r ? {
                            efficiency: 100
                        } : {
                            efficiency: 100 * (1 - n / r),
                            firstUndrapedLayer: i
                        }
                    }
                    getMinElevationBelowMSL() {
                        let t = 0;
                        return this._visibleDemTiles.filter((t => t.dem)).forEach((e => {
                            t = Math.min(t, e.dem.tree.minimums[0])
                        }
                        )),
                        0 === t ? t : (t - 30) * this._exaggeration
                    }
                    raycast(t, e, i) {
                        if (!this._visibleDemTiles)
                            return null;
                        const n = this._visibleDemTiles.filter((t => t.dem)).map((n => {
                            const r = n.tileID
                              , o = 1 << r.overscaledZ
                              , {x: s, y: a} = r.canonical
                              , l = s / o
                              , c = (s + 1) / o
                              , h = a / o
                              , u = (a + 1) / o;
                            return {
                                minx: l,
                                miny: h,
                                maxx: c,
                                maxy: u,
                                t: n.dem.tree.raycastRoot(l, h, c, u, t, e, i),
                                tile: n
                            }
                        }
                        ));
                        n.sort(( (t, e) => (null !== t.t ? t.t : Number.MAX_VALUE) - (null !== e.t ? e.t : Number.MAX_VALUE)));
                        for (const r of n) {
                            if (null == r.t)
                                return null;
                            const n = r.tile.dem.tree.raycast(r.minx, r.miny, r.maxx, r.maxy, t, e, i);
                            if (null != n)
                                return n
                        }
                        return null
                    }
                    _createFBO() {
                        const e = this.painter.context
                          , i = e.gl
                          , n = this.drapeBufferSize;
                        e.activeTexture.set(i.TEXTURE0);
                        const r = new t.Texture(e,{
                            width: n[0],
                            height: n[1],
                            data: null
                        },i.RGBA);
                        r.bind(i.LINEAR, i.CLAMP_TO_EDGE);
                        const o = e.createFramebuffer(n[0], n[1], !1);
                        return o.colorAttachment.set(r.texture),
                        o.depthAttachment = new Et(e,o.framebuffer),
                        void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = e.createRenderbuffer(e.gl.DEPTH_STENCIL, n[0], n[1]),
                        this._stencilRef = 0,
                        o.depthAttachment.set(this._sharedDepthStencil),
                        e.clear({
                            stencil: 0
                        })) : o.depthAttachment.set(this._sharedDepthStencil),
                        e.extTextureFilterAnisotropic && !e.extTextureFilterAnisotropicForceOff && i.texParameterf(i.TEXTURE_2D, e.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, e.extTextureFilterAnisotropicMax),
                        {
                            fb: o,
                            tex: r,
                            dirty: !1
                        }
                    }
                    _initFBOPool() {
                        for (; this.pool.length < Math.min(5, this.proxyCoords.length); )
                            this.pool.push(this._createFBO())
                    }
                    _shouldDisableRenderCache() {
                        if (this._style.light && this._style.light.hasTransition())
                            return !0;
                        for (const t in this._style._sourceCaches)
                            if (this._style._sourceCaches[t].hasTransition())
                                return !0;
                        return this._style.order.some((t => {
                            const e = this._style._layers[t]
                              , i = e.isHidden(this.painter.transform.zoom);
                            return "custom" === e.type ? !i && e.shouldRedrape() : !i && e.hasTransition()
                        }
                        ))
                    }
                    _clearLineLayersFromRenderCache() {
                        let e = !1;
                        for (const t of this._style._getSources())
                            if (t instanceof Ct) {
                                e = !0;
                                break
                            }
                        if (!e)
                            return;
                        const i = {};
                        for (let e = 0; e < this._style.order.length; ++e) {
                            const n = this._style._layers[this._style.order[e]]
                              , r = this._style._getLayerSourceCache(n);
                            if (r && !i[r.id] && !n.isHidden(this.painter.transform.zoom) && "line" === n.type && n.widthExpression()instanceof t.ZoomDependentExpression) {
                                i[r.id] = !0;
                                for (const t of this.proxyCoords) {
                                    const e = this.proxyToSource[t.key][r.id];
                                    if (e)
                                        for (const t of e)
                                            this._clearRenderCacheForTile(r.id, t)
                                }
                            }
                        }
                    }
                    _clearRasterLayersFromRenderCache() {
                        let t = !1;
                        for (const e in this._style._sourceCaches)
                            if (this._style._sourceCaches[e]._source instanceof At) {
                                t = !0;
                                break
                            }
                        if (!t)
                            return;
                        const e = {};
                        for (let t = 0; t < this._style.order.length; ++t) {
                            const i = this._style._layers[this._style.order[t]]
                              , n = this._style._getLayerSourceCache(i);
                            if (!n || e[n.id])
                                continue;
                            if (i.isHidden(this.painter.transform.zoom) || "raster" !== i.type)
                                continue;
                            const r = i.paint.get("raster-fade-duration");
                            for (const t of this.proxyCoords) {
                                const e = this.proxyToSource[t.key][n.id];
                                if (e)
                                    for (const t of e) {
                                        const e = Ai(n.getTile(t), n.findLoadedParent(t, 0), n, this.painter.transform, r);
                                        (1 !== e.opacity || 0 !== e.mix) && this._clearRenderCacheForTile(n.id, t)
                                    }
                            }
                        }
                    }
                    _setupDrapedRenderBatches() {
                        const t = this._style.order
                          , e = t.length;
                        if (0 === e)
                            return;
                        const i = [];
                        let n, r = 0, o = this._style._layers[t[r]];
                        for (; !this._style.isLayerDraped(o) && o.isHidden(this.painter.transform.zoom) && ++r < e; )
                            o = this._style._layers[t[r]];
                        for (; r < e; ++r) {
                            const e = this._style._layers[t[r]];
                            e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === n && (n = r) : void 0 !== n && (i.push({
                                start: n,
                                end: r - 1
                            }),
                            n = void 0))
                        }
                        void 0 !== n && i.push({
                            start: n,
                            end: r - 1
                        }),
                        this._drapedRenderBatches = i
                    }
                    _setupRenderCache(t) {
                        const e = this.proxySourceCache;
                        if (this._shouldDisableRenderCache() || this._invalidateRenderCache) {
                            if (this._invalidateRenderCache = !1,
                            e.renderCache.length > e.renderCachePool.length) {
                                const t = Object.values(e.proxyCachedFBO);
                                e.proxyCachedFBO = {};
                                for (let i = 0; i < t.length; ++i) {
                                    const n = Object.values(t[i]);
                                    e.renderCachePool.push(...n)
                                }
                            }
                            return
                        }
                        this._clearRasterLayersFromRenderCache();
                        const i = this.proxyCoords
                          , n = this._tilesDirty;
                        for (let r = i.length - 1; r >= 0; r--) {
                            const o = i[r];
                            if (e.getTileByID(o.key),
                            void 0 !== e.proxyCachedFBO[o.key]) {
                                const i = t[o.key]
                                  , r = this.proxyToSource[o.key];
                                let s = 0;
                                for (const t in r) {
                                    const e = r[t]
                                      , o = i[t];
                                    if (!o || o.length !== e.length || e.some(( (e, i) => e !== o[i] || n[t] && n[t].hasOwnProperty(e.key)))) {
                                        s = -1;
                                        break
                                    }
                                    ++s
                                }
                                for (const t in e.proxyCachedFBO[o.key])
                                    e.renderCache[e.proxyCachedFBO[o.key][t]].dirty = s < 0 || s !== Object.values(i).length
                            }
                        }
                        const r = [...this._drapedRenderBatches];
                        r.sort(( (t, e) => e.end - e.start - (t.end - t.start)));
                        for (const t of r)
                            for (const n of i) {
                                if (e.proxyCachedFBO[n.key])
                                    continue;
                                let i = e.renderCachePool.pop();
                                void 0 === i && e.renderCache.length < 50 && (i = e.renderCache.length,
                                e.renderCache.push(this._createFBO())),
                                void 0 !== i && (e.proxyCachedFBO[n.key] = {},
                                e.proxyCachedFBO[n.key][t.start] = i,
                                e.renderCache[i].dirty = !0)
                            }
                        this._tilesDirty = {}
                    }
                    _setupStencil(t, e, i, n) {
                        if (!n || !this._sourceTilesOverlap[n.id])
                            return void (this._overlapStencilType && (this._overlapStencilType = !1));
                        const r = this.painter.context
                          , o = r.gl;
                        if (e.length <= 1)
                            return void (this._overlapStencilType = !1);
                        let s;
                        if (i.isTileClipped())
                            s = e.length,
                            this._overlapStencilMode.test = {
                                func: o.EQUAL,
                                mask: 255
                            },
                            this._overlapStencilType = "Clip";
                        else {
                            if (!(e[0].overscaledZ > e[e.length - 1].overscaledZ))
                                return void (this._overlapStencilType = !1);
                            s = 1,
                            this._overlapStencilMode.test = {
                                func: o.GREATER,
                                mask: 255
                            },
                            this._overlapStencilType = "Mask"
                        }
                        this._stencilRef + s > 255 && (r.clear({
                            stencil: 0
                        }),
                        this._stencilRef = 0),
                        this._stencilRef += s,
                        this._overlapStencilMode.ref = this._stencilRef,
                        i.isTileClipped() && this._renderTileClippingMasks(e, this._overlapStencilMode.ref)
                    }
                    clipOrMaskOverlapStencilType() {
                        return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType
                    }
                    stencilModeForRTTOverlap(e) {
                        return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]),
                        this._overlapStencilMode) : t.StencilMode.disabled
                    }
                    _renderTileClippingMasks(e, i) {
                        const n = this.painter
                          , r = this.painter.context
                          , o = r.gl;
                        n._tileClippingMaskIDs = {},
                        r.setColorMode(t.ColorMode.disabled),
                        r.setDepthMode(t.DepthMode.disabled);
                        const s = n.useProgram("clippingMask");
                        for (const a of e) {
                            const e = n._tileClippingMaskIDs[a.key] = --i;
                            s.draw(r, o.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                                func: o.ALWAYS,
                                mask: 0
                            },e,255,o.KEEP,o.KEEP,o.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, Ci(a.projMatrix), "$clipping", n.tileExtentBuffer, n.quadTriangleIndexBuffer, n.tileExtentSegments)
                        }
                    }
                    pointCoordinate(e) {
                        const i = this.painter.transform;
                        if (e.x < 0 || e.x > i.width || e.y < 0 || e.y > i.height)
                            return null;
                        const n = [e.x, e.y, 1, 1];
                        t.transformMat4$1(n, n, i.pixelMatrixInverse),
                        t.scale$1(n, n, 1 / n[3]),
                        n[0] /= i.worldSize,
                        n[1] /= i.worldSize;
                        const r = i._camera.position
                          , o = t.mercatorZfromAltitude(1, i.center.lat)
                          , s = [r[0], r[1], r[2] / o, 0]
                          , a = t.subtract([], n.slice(0, 3), s);
                        t.normalize(a, a);
                        const l = this.raycast(s, a, this._exaggeration);
                        return null !== l && l ? (t.scaleAndAdd(s, s, a, l),
                        s[3] = s[2],
                        s[2] *= o,
                        s) : null
                    }
                    drawDepth() {
                        const e = this.painter
                          , i = e.context
                          , n = this.proxySourceCache
                          , r = Math.ceil(e.width)
                          , o = Math.ceil(e.height);
                        if (!this._depthFBO || this._depthFBO.width === r && this._depthFBO.height === o || (this._depthFBO.destroy(),
                        this._depthFBO = void 0,
                        this._depthTexture = void 0),
                        !this._depthFBO) {
                            const e = i.gl
                              , n = i.createFramebuffer(r, o, !0);
                            i.activeTexture.set(e.TEXTURE0);
                            const s = new t.Texture(i,{
                                width: r,
                                height: o,
                                data: null
                            },e.RGBA);
                            s.bind(e.NEAREST, e.CLAMP_TO_EDGE),
                            n.colorAttachment.set(s.texture);
                            const a = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, r, o);
                            n.depthAttachment.set(a),
                            this._depthFBO = n,
                            this._depthTexture = s
                        }
                        i.bindFramebuffer.set(this._depthFBO.framebuffer),
                        i.viewport.set([0, 0, r, o]),
                        function(e, i, n, r) {
                            if ("globe" === e.transform.projection.name)
                                return;
                            const o = e.context
                              , s = o.gl;
                            o.clear({
                                depth: 1
                            });
                            const a = e.useProgram("terrainDepth")
                              , l = new t.DepthMode(s.LESS,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                            for (const e of r) {
                                const r = n.getTile(e)
                                  , c = vi(e.projMatrix, 0);
                                i.setupElevationDraw(r, a),
                                a.draw(o, s.TRIANGLES, l, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.backCCW, c, "terrain_depth", i.gridBuffer, i.gridIndexBuffer, i.gridNoSkirtSegments)
                            }
                        }(e, this, n, this.proxyCoords)
                    }
                    _setupProxiedCoordsForOrtho(t, e, i) {
                        if (t.getSource()instanceof Mt)
                            return this._setupProxiedCoordsForImageSource(t, e, i);
                        this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
                        const n = this.proxiedCoords[t.id] = []
                          , r = this.proxyCoords;
                        for (let e = 0; e < r.length; e++) {
                            const o = r[e]
                              , s = this._findTileCoveringTileID(o, t);
                            if (s) {
                                const e = this._createProxiedId(o, s, i[o.key] && i[o.key][t.id]);
                                n.push(e),
                                this.proxyToSource[o.key][t.id] = [e]
                            }
                        }
                        let o = !1;
                        for (let r = 0; r < e.length; r++) {
                            const s = t.getTile(e[r]);
                            if (!s || !s.hasData())
                                continue;
                            const a = this._findTileCoveringTileID(s.tileID, this.proxySourceCache);
                            if (a && a.tileID.canonical.z !== s.tileID.canonical.z) {
                                const e = this.proxyToSource[a.tileID.key][t.id]
                                  , r = this._createProxiedId(a.tileID, s, i[a.tileID.key] && i[a.tileID.key][t.id]);
                                e ? e.splice(e.length - 1, 0, r) : this.proxyToSource[a.tileID.key][t.id] = [r],
                                n.push(r),
                                o = !0
                            }
                        }
                        this._sourceTilesOverlap[t.id] = o
                    }
                    _setupProxiedCoordsForImageSource(e, i, n) {
                        if (!e.getSource().loaded())
                            return;
                        const r = this.proxiedCoords[e.id] = []
                          , o = this.proxyCoords
                          , s = e.getSource()
                          , a = new t.Point(s.tileID.x,s.tileID.y)._div(1 << s.tileID.z)
                          , l = s.coordinates.map(t.MercatorCoordinate.fromLngLat).reduce(( (t, e) => (t.min.x = Math.min(t.min.x, e.x - a.x),
                        t.min.y = Math.min(t.min.y, e.y - a.y),
                        t.max.x = Math.max(t.max.x, e.x - a.x),
                        t.max.y = Math.max(t.max.y, e.y - a.y),
                        t)), {
                            min: new t.Point(Number.MAX_VALUE,Number.MAX_VALUE),
                            max: new t.Point(-Number.MAX_VALUE,-Number.MAX_VALUE)
                        })
                          , c = (e, i) => {
                            const n = e.wrap + e.canonical.x / (1 << e.canonical.z)
                              , r = e.canonical.y / (1 << e.canonical.z)
                              , o = t.EXTENT / (1 << e.canonical.z)
                              , s = i.wrap + i.canonical.x / (1 << i.canonical.z)
                              , a = i.canonical.y / (1 << i.canonical.z);
                            return n + o < s + l.min.x || n > s + l.max.x || r + o < a + l.min.y || r > a + l.max.y
                        }
                        ;
                        for (let t = 0; t < o.length; t++) {
                            const s = o[t];
                            for (let t = 0; t < i.length; t++) {
                                const o = e.getTile(i[t]);
                                if (!o || !o.hasData())
                                    continue;
                                if (c(s, o.tileID))
                                    continue;
                                const a = this._createProxiedId(s, o, n[s.key] && n[s.key][e.id])
                                  , l = this.proxyToSource[s.key][e.id];
                                l ? l.push(a) : this.proxyToSource[s.key][e.id] = [a],
                                r.push(a)
                            }
                        }
                    }
                    _createProxiedId(e, i, n) {
                        let r = this.orthoMatrix;
                        if (n) {
                            const t = n.find((t => t.key === i.tileID.key));
                            if (t)
                                return t
                        }
                        if (i.tileID.key !== e.key) {
                            const n = e.canonical.z - i.tileID.canonical.z;
                            let o, s, a;
                            r = t.create();
                            const l = i.tileID.wrap - e.wrap << e.overscaledZ;
                            n > 0 ? (o = t.EXTENT >> n,
                            s = o * ((i.tileID.canonical.x << n) - e.canonical.x + l),
                            a = o * ((i.tileID.canonical.y << n) - e.canonical.y)) : (o = t.EXTENT << -n,
                            s = t.EXTENT * (i.tileID.canonical.x - (e.canonical.x + l << -n)),
                            a = t.EXTENT * (i.tileID.canonical.y - (e.canonical.y << -n))),
                            t.ortho(r, 0, o, 0, o, 0, 1),
                            t.translate(r, r, [s, a, 0])
                        }
                        return new Pi(i.tileID,e.key,r)
                    }
                    _findTileCoveringTileID(e, i) {
                        let n = i.getTile(e);
                        if (n && n.hasData())
                            return n;
                        const r = this._findCoveringTileCache[i.id]
                          , o = r[e.key];
                        if (n = o ? i.getTileByID(o) : null,
                        n && n.hasData() || null === o)
                            return n;
                        let s = n ? n.tileID : e
                          , a = s.overscaledZ;
                        const l = i.getSource().minzoom
                          , c = [];
                        if (!o) {
                            const r = i.getSource().maxzoom;
                            if (e.canonical.z >= r) {
                                const n = e.canonical.z - r;
                                i.getSource().reparseOverscaled ? (a = Math.max(e.canonical.z + 2, i.transform.tileZoom),
                                s = new t.OverscaledTileID(a,e.wrap,r,e.canonical.x >> n,e.canonical.y >> n)) : 0 !== n && (a = r,
                                s = new t.OverscaledTileID(a,e.wrap,r,e.canonical.x >> n,e.canonical.y >> n))
                            }
                            s.key !== e.key && (c.push(s.key),
                            n = i.getTile(s))
                        }
                        const h = t => {
                            c.forEach((e => {
                                r[e] = t
                            }
                            )),
                            c.length = 0
                        }
                        ;
                        for (a -= 1; a >= l && (!n || !n.hasData()); a--) {
                            n && h(n.tileID.key);
                            const t = s.calculateScaledKey(a);
                            if (n = i.getTileByID(t),
                            n && n.hasData())
                                break;
                            const e = r[t];
                            if (null === e)
                                break;
                            void 0 === e ? c.push(t) : n = i.getTileByID(e)
                        }
                        return h(n ? n.tileID.key : null),
                        n && n.hasData() ? n : null
                    }
                    findDEMTileFor(t) {
                        return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null
                    }
                    prepareDrawTile() {
                        this.renderedToTile = !0
                    }
                    _clearRenderCacheForTile(t, e) {
                        let i = this._tilesDirty[t];
                        i || (i = this._tilesDirty[t] = {}),
                        i[e.key] = !0
                    }
                    getWirefameBuffer() {
                        if (!this.wireframeSegments) {
                            const e = function(e) {
                                let i = 0;
                                const n = new t.StructArrayLayout2ui4
                                  , r = 131;
                                for (let t = 1; t < 129; t++) {
                                    for (let e = 1; e < 129; e++)
                                        i = t * r + e,
                                        n.emplaceBack(i, i + 1),
                                        n.emplaceBack(i, i + r),
                                        n.emplaceBack(i + 1, i + r),
                                        128 === t && n.emplaceBack(i + r, i + r + 1);
                                    n.emplaceBack(i + 1, i + 1 + r)
                                }
                                return n
                            }();
                            this.wireframeIndexBuffer = this.painter.context.createIndexBuffer(e),
                            this.wireframeSegments = t.SegmentVector.simpleSegment(0, 0, this.gridBuffer.length, e.length)
                        }
                        return [this.wireframeIndexBuffer, this.wireframeSegments]
                    }
                }
                class Oi {
                    static cacheKey(t, e, i, n) {
                        let r = `${e}${n ? n.cacheKey : ""}`;
                        for (const e of i)
                            t.usedDefines.includes(e) && (r += `/${e}`);
                        return r
                    }
                    constructor(e, i, n, r, o, s) {
                        const a = e.gl;
                        this.program = a.createProgram();
                        const l = function(t) {
                            const e = [];
                            for (let i = 0; i < t.length; i++) {
                                if (null === t[i])
                                    continue;
                                const n = t[i].split(" ");
                                e.push(n.pop())
                            }
                            return e
                        }(n.staticAttributes)
                          , c = r ? r.getBinderAttributes() : []
                          , h = l.concat(c);
                        let u = r ? r.defines() : [];
                        u = u.concat(s.map((t => `#define ${t}`)));
                        const d = e.isWebGL2 ? "#version 300 es\n" : ""
                          , f = d + u.concat(e.extStandardDerivatives && 0 === d.length ? "#extension GL_OES_standard_derivatives : enable\n".concat(ci) : ci, ci, li, ai.fragmentSource, oi.fragmentSource, n.fragmentSource).join("\n")
                          , p = d + u.concat("\n#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif", li, ai.vertexSource, oi.vertexSource, ri.vertexSource, n.vertexSource).join("\n")
                          , m = a.createShader(a.FRAGMENT_SHADER);
                        if (a.isContextLost())
                            return void (this.failedToCreate = !0);
                        a.shaderSource(m, f),
                        a.compileShader(m),
                        a.attachShader(this.program, m);
                        const g = a.createShader(a.VERTEX_SHADER);
                        if (a.isContextLost())
                            this.failedToCreate = !0;
                        else {
                            a.shaderSource(g, p),
                            a.compileShader(g),
                            a.attachShader(this.program, g),
                            this.attributes = {},
                            this.numAttributes = h.length;
                            for (let t = 0; t < this.numAttributes; t++)
                                h[t] && (a.bindAttribLocation(this.program, t, h[t]),
                                this.attributes[h[t]] = t);
                            a.linkProgram(this.program),
                            a.deleteShader(g),
                            a.deleteShader(m),
                            this.fixedUniforms = o(e),
                            this.binderUniforms = r ? r.getUniforms(e) : [],
                            s.includes("TERRAIN") && (this.terrainUniforms = (e => ({
                                u_dem: new t.Uniform1i(e),
                                u_dem_prev: new t.Uniform1i(e),
                                u_dem_unpack: new t.Uniform4f(e),
                                u_dem_tl: new t.Uniform2f(e),
                                u_dem_scale: new t.Uniform1f(e),
                                u_dem_tl_prev: new t.Uniform2f(e),
                                u_dem_scale_prev: new t.Uniform1f(e),
                                u_dem_size: new t.Uniform1f(e),
                                u_dem_lerp: new t.Uniform1f(e),
                                u_exaggeration: new t.Uniform1f(e),
                                u_depth: new t.Uniform1i(e),
                                u_depth_size_inv: new t.Uniform2f(e),
                                u_meter_to_dem: new t.Uniform1f(e),
                                u_label_plane_matrix_inv: new t.UniformMatrix4f(e)
                            }))(e)),
                            s.includes("GLOBE") && (this.globeUniforms = (e => ({
                                u_tile_tl_up: new t.Uniform3f(e),
                                u_tile_tr_up: new t.Uniform3f(e),
                                u_tile_br_up: new t.Uniform3f(e),
                                u_tile_bl_up: new t.Uniform3f(e),
                                u_tile_up_scale: new t.Uniform1f(e)
                            }))(e)),
                            s.includes("FOG") && (this.fogUniforms = (e => ({
                                u_fog_matrix: new t.UniformMatrix4f(e),
                                u_fog_range: new t.Uniform2f(e),
                                u_fog_color: new t.Uniform4f(e),
                                u_fog_horizon_blend: new t.Uniform1f(e),
                                u_fog_temporal_offset: new t.Uniform1f(e),
                                u_frustum_tl: new t.Uniform3f(e),
                                u_frustum_tr: new t.Uniform3f(e),
                                u_frustum_br: new t.Uniform3f(e),
                                u_frustum_bl: new t.Uniform3f(e),
                                u_globe_pos: new t.Uniform3f(e),
                                u_globe_radius: new t.Uniform1f(e),
                                u_globe_transition: new t.Uniform1f(e),
                                u_is_globe: new t.Uniform1i(e),
                                u_viewport: new t.Uniform2f(e)
                            }))(e))
                        }
                    }
                    setTerrainUniformValues(t, e) {
                        if (!this.terrainUniforms)
                            return;
                        const i = this.terrainUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const t in e)
                                i[t] && i[t].set(this.program, t, e[t])
                        }
                    }
                    setGlobeUniformValues(t, e) {
                        if (!this.globeUniforms)
                            return;
                        const i = this.globeUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const t in e)
                                i[t] && i[t].set(this.program, t, e[t])
                        }
                    }
                    setFogUniformValues(t, e) {
                        if (!this.fogUniforms)
                            return;
                        const i = this.fogUniforms;
                        if (!this.failedToCreate) {
                            t.program.set(this.program);
                            for (const t in e)
                                i[t].set(this.program, t, e[t])
                        }
                    }
                    draw(t, e, i, n, r, o, s, a, l, c, h, u, d, f, p) {
                        const m = t.gl;
                        if (this.failedToCreate)
                            return;
                        t.program.set(this.program),
                        t.setDepthMode(i),
                        t.setStencilMode(n),
                        t.setColorMode(r),
                        t.setCullFace(o);
                        for (const t of Object.keys(this.fixedUniforms))
                            this.fixedUniforms[t].set(this.program, t, s[t]);
                        f && f.setUniforms(this.program, t, this.binderUniforms, u, {
                            zoom: d
                        });
                        const g = {
                            [m.LINES]: 2,
                            [m.TRIANGLES]: 3,
                            [m.LINE_STRIP]: 1
                        }[e];
                        for (const i of h.get()) {
                            const n = i.vaos || (i.vaos = {});
                            (n[a] || (n[a] = new fi)).bind(t, this, l, f ? f.getPaintVertexBuffers() : [], c, i.vertexOffset, p || []),
                            m.drawElements(e, i.primitiveLength * g, m.UNSIGNED_SHORT, i.primitiveOffset * g * 2)
                        }
                    }
                }
                function Ri(t, e) {
                    const i = Math.pow(2, e.tileID.overscaledZ)
                      , n = e.tileSize * Math.pow(2, t.transform.tileZoom) / i
                      , r = n * (e.tileID.canonical.x + e.tileID.wrap * i)
                      , o = n * e.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: e.imageAtlasTexture.size,
                        u_tile_units_to_pixels: 1 / k(e, 1, t.transform.tileZoom),
                        u_pixel_coord_upper: [r >> 16, o >> 16],
                        u_pixel_coord_lower: [65535 & r, 65535 & o]
                    }
                }
                const Di = t.create()
                  , Li = (e, i, n, r, o, s, a, l, c, h, u) => {
                    const d = i.style.light
                      , f = d.properties.get("position")
                      , p = [f.x, f.y, f.z]
                      , m = t.create$1();
                    "viewport" === d.properties.get("anchor") && (t.fromRotation(m, -i.transform.angle),
                    t.transformMat3(p, p, m));
                    const g = d.properties.get("color")
                      , _ = i.transform
                      , y = {
                        u_matrix: e,
                        u_lightpos: p,
                        u_lightintensity: d.properties.get("intensity"),
                        u_lightcolor: [g.r, g.g, g.b],
                        u_vertical_gradient: +n,
                        u_opacity: r,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: Di,
                        u_merc_center: [0, 0],
                        u_up_dir: [0, 0, 0],
                        u_height_lift: 0,
                        u_ao: o,
                        u_edge_radius: s
                    };
                    return "globe" === _.projection.name && (y.u_tile_id = [a.canonical.x, a.canonical.y, 1 << a.canonical.z],
                    y.u_zoom_transition = c,
                    y.u_inv_rot_matrix = u,
                    y.u_merc_center = h,
                    y.u_up_dir = _.projection.upVector(new t.CanonicalTileID(0,0,0), h[0] * t.EXTENT, h[1] * t.EXTENT),
                    y.u_height_lift = l),
                    y
                }
                  , Bi = (e, i, n, r, o, s, a, l, c, h, u, d) => {
                    const f = Li(e, i, n, r, o, s, a, c, h, u, d)
                      , p = {
                        u_height_factor: -Math.pow(2, a.overscaledZ) / l.tileSize / 8
                    };
                    return t.extend(f, Ri(i, l), p)
                }
                  , zi = t => ({
                    u_matrix: t
                })
                  , Fi = (e, i, n) => t.extend(zi(e), Ri(i, n))
                  , Ni = (t, e) => ({
                    u_matrix: t,
                    u_world: e
                })
                  , ji = (e, i, n, r) => t.extend(Fi(e, i, n), {
                    u_world: r
                })
                  , Ui = t.create()
                  , Vi = (e, i, n, r, o, s) => {
                    const a = e.transform
                      , l = "globe" === a.projection.name;
                    let c;
                    if ("map" === s.paint.get("circle-pitch-alignment"))
                        if (l) {
                            const e = t.globePixelsToTileUnits(a.zoom, i.canonical) * a._pixelsPerMercatorPixel;
                            c = Float32Array.from([e, 0, 0, e])
                        } else
                            c = a.calculatePixelsToTileUnitsMatrix(n);
                    else
                        c = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);
                    const h = {
                        u_camera_to_center_distance: a.cameraToCenterDistance,
                        u_matrix: e.translatePosMatrix(i.projMatrix, n, s.paint.get("circle-translate"), s.paint.get("circle-translate-anchor")),
                        u_device_pixel_ratio: t.exported.devicePixelRatio,
                        u_extrude_scale: c,
                        u_inv_rot_matrix: Ui,
                        u_merc_center: [0, 0],
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_up_dir: [0, 0, 0]
                    };
                    if (l) {
                        h.u_inv_rot_matrix = r,
                        h.u_merc_center = o,
                        h.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z],
                        h.u_zoom_transition = t.globeToMercatorTransition(a.zoom);
                        const e = o[0] * t.EXTENT
                          , n = o[1] * t.EXTENT;
                        h.u_up_dir = a.projection.upVector(new t.CanonicalTileID(0,0,0), e, n)
                    }
                    return h
                }
                  , Gi = t => {
                    const e = [];
                    return "map" === t.paint.get("circle-pitch-alignment") && e.push("PITCH_WITH_MAP"),
                    "map" === t.paint.get("circle-pitch-scale") && e.push("SCALE_WITH_MAP"),
                    e
                }
                  , Zi = (e, i, n, r) => {
                    const o = t.EXTENT / n.tileSize;
                    return {
                        u_matrix: e,
                        u_camera_to_center_distance: i.getCameraToCenterDistance(r),
                        u_extrude_scale: [i.pixelsToGLUnits[0] / o, i.pixelsToGLUnits[1] / o]
                    }
                }
                  , qi = (t, e, i=1) => ({
                    u_matrix: t,
                    u_color: e,
                    u_overlay: 0,
                    u_overlay_scale: i
                })
                  , Wi = t.create()
                  , Hi = (e, i, n, r, o, s, a) => {
                    const l = e.transform
                      , c = "globe" === l.projection.name
                      , h = c ? t.globePixelsToTileUnits(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : k(n, 1, s)
                      , u = {
                        u_matrix: i.projMatrix,
                        u_extrude_scale: h,
                        u_intensity: a,
                        u_inv_rot_matrix: Wi,
                        u_merc_center: [0, 0],
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_up_dir: [0, 0, 0]
                    };
                    if (c) {
                        u.u_inv_rot_matrix = r,
                        u.u_merc_center = o,
                        u.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z],
                        u.u_zoom_transition = t.globeToMercatorTransition(l.zoom);
                        const e = o[0] * t.EXTENT
                          , n = o[1] * t.EXTENT;
                        u.u_up_dir = l.projection.upVector(new t.CanonicalTileID(0,0,0), e, n)
                    }
                    return u
                }
                  , $i = (t, e, i, n, r, o, s) => {
                    const a = t.transform
                      , l = a.calculatePixelsToTileUnitsMatrix(e);
                    return {
                        u_matrix: Ki(t, e, i, n),
                        u_pixels_to_tile_units: l,
                        u_device_pixel_ratio: o,
                        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]],
                        u_dash_image: 0,
                        u_gradient_image: 1,
                        u_image_height: r,
                        u_texsize: Ji(i) ? e.lineAtlasTexture.size : [0, 0],
                        u_tile_units_to_pixels: Yi(e, t.transform),
                        u_alpha_discard_threshold: 0,
                        u_trim_offset: s
                    }
                }
                  , Xi = (t, e, i, n, r) => {
                    const o = t.transform;
                    return {
                        u_matrix: Ki(t, e, i, n),
                        u_texsize: e.imageAtlasTexture.size,
                        u_pixels_to_tile_units: o.calculatePixelsToTileUnitsMatrix(e),
                        u_device_pixel_ratio: r,
                        u_image: 0,
                        u_tile_units_to_pixels: Yi(e, o),
                        u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]],
                        u_alpha_discard_threshold: 0
                    }
                }
                ;
                function Yi(t, e) {
                    return 1 / k(t, 1, e.tileZoom)
                }
                function Ki(t, e, i, n) {
                    return t.translatePosMatrix(n || e.tileID.projMatrix, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
                }
                function Ji(t) {
                    const e = t.paint.get("line-dasharray").value;
                    return e.value || "constant" !== e.kind
                }
                const Qi = (t, e, i, n, r, o) => {
                    return {
                        u_matrix: t,
                        u_tl_parent: e,
                        u_scale_parent: i,
                        u_fade_t: n.mix,
                        u_opacity: n.opacity * r.paint.get("raster-opacity"),
                        u_image0: 0,
                        u_image1: 1,
                        u_brightness_low: r.paint.get("raster-brightness-min"),
                        u_brightness_high: r.paint.get("raster-brightness-max"),
                        u_saturation_factor: (a = r.paint.get("raster-saturation"),
                        a > 0 ? 1 - 1 / (1.001 - a) : -a),
                        u_contrast_factor: (s = r.paint.get("raster-contrast"),
                        s > 0 ? 1 / (1 - s) : 1 + s),
                        u_spin_weights: tn(r.paint.get("raster-hue-rotate")),
                        u_perspective_transform: o
                    };
                    var s, a
                }
                ;
                function tn(t) {
                    t *= Math.PI / 180;
                    const e = Math.sin(t)
                      , i = Math.cos(t);
                    return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
                }
                const en = t.create()
                  , nn = (e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g) => {
                    const _ = o.transform
                      , y = {
                        u_is_size_zoom_constant: +("constant" === e || "source" === e),
                        u_is_size_feature_constant: +("constant" === e || "camera" === e),
                        u_size_t: i ? i.uSizeT : 0,
                        u_size: i ? i.uSize : 0,
                        u_camera_to_center_distance: _.cameraToCenterDistance,
                        u_rotate_symbol: +n,
                        u_aspect_ratio: _.width / _.height,
                        u_fade_change: o.options.fadeDuration ? o.symbolFadeChange : 1,
                        u_matrix: s,
                        u_label_plane_matrix: a,
                        u_coord_matrix: l,
                        u_is_text: +c,
                        u_pitch_with_map: +r,
                        u_texsize: h,
                        u_texture: 0,
                        u_tile_id: [0, 0, 0],
                        u_zoom_transition: 0,
                        u_inv_rot_matrix: en,
                        u_merc_center: [0, 0],
                        u_camera_forward: [0, 0, 0],
                        u_ecef_origin: [0, 0, 0],
                        u_tile_matrix: en,
                        u_up_vector: [0, -1, 0]
                    };
                    return "globe" === g.name && (y.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z],
                    y.u_zoom_transition = d,
                    y.u_inv_rot_matrix = p,
                    y.u_merc_center = f,
                    y.u_camera_forward = _._camera.forward(),
                    y.u_ecef_origin = t.globeECEFOrigin(_.globeMatrix, u.toUnwrapped()),
                    y.u_tile_matrix = Float32Array.from(_.globeMatrix),
                    y.u_up_vector = m),
                    y
                }
                  , rn = (e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g, _) => t.extend(nn(e, i, n, r, o, s, a, l, c, h, d, f, p, m, g, _), {
                    u_gamma_scale: r ? o.transform.cameraToCenterDistance * Math.cos(o.terrain ? 0 : o.transform._pitch) : 1,
                    u_device_pixel_ratio: t.exported.devicePixelRatio,
                    u_is_halo: +u
                })
                  , on = (e, i, n, r, o, s, a, l, c, h, u, d, f, p, m, g) => t.extend(rn(e, i, n, r, o, s, a, l, !0, c, !0, u, d, f, p, m, g), {
                    u_texsize_icon: h,
                    u_texture_icon: 1
                })
                  , sn = (t, e, i) => ({
                    u_matrix: t,
                    u_opacity: e,
                    u_color: i
                })
                  , an = (e, i, n, r, o) => t.extend(function(t, e, i) {
                    const n = e.imageManager.getPattern(t.toString())
                      , {width: r, height: o} = e.imageManager.getPixelSize()
                      , s = Math.pow(2, i.tileID.overscaledZ)
                      , a = i.tileSize * Math.pow(2, e.transform.tileZoom) / s
                      , l = a * (i.tileID.canonical.x + i.tileID.wrap * s)
                      , c = a * i.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl: n.tl,
                        u_pattern_br: n.br,
                        u_texsize: [r, o],
                        u_pattern_size: n.displaySize,
                        u_tile_units_to_pixels: 1 / k(i, 1, e.transform.tileZoom),
                        u_pixel_coord_upper: [l >> 16, c >> 16],
                        u_pixel_coord_lower: [65535 & l, 65535 & c]
                    }
                }(r, n, o), {
                    u_matrix: e,
                    u_opacity: i
                })
                  , ln = {
                    fillExtrusion: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_lightpos: new t.Uniform3f(e),
                        u_lightintensity: new t.Uniform1f(e),
                        u_lightcolor: new t.Uniform3f(e),
                        u_vertical_gradient: new t.Uniform1f(e),
                        u_opacity: new t.Uniform1f(e),
                        u_edge_radius: new t.Uniform1f(e),
                        u_ao: new t.Uniform2f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_up_dir: new t.Uniform3f(e),
                        u_height_lift: new t.Uniform1f(e)
                    }),
                    fillExtrusionPattern: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_lightpos: new t.Uniform3f(e),
                        u_lightintensity: new t.Uniform1f(e),
                        u_lightcolor: new t.Uniform3f(e),
                        u_vertical_gradient: new t.Uniform1f(e),
                        u_height_factor: new t.Uniform1f(e),
                        u_edge_radius: new t.Uniform1f(e),
                        u_ao: new t.Uniform2f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_up_dir: new t.Uniform3f(e),
                        u_height_lift: new t.Uniform1f(e),
                        u_image: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_pixel_coord_upper: new t.Uniform2f(e),
                        u_pixel_coord_lower: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e),
                        u_opacity: new t.Uniform1f(e)
                    }),
                    fill: e => ({
                        u_matrix: new t.UniformMatrix4f(e)
                    }),
                    fillPattern: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_image: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_pixel_coord_upper: new t.Uniform2f(e),
                        u_pixel_coord_lower: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e)
                    }),
                    fillOutline: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_world: new t.Uniform2f(e)
                    }),
                    fillOutlinePattern: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_world: new t.Uniform2f(e),
                        u_image: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_pixel_coord_upper: new t.Uniform2f(e),
                        u_pixel_coord_lower: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e)
                    }),
                    circle: e => ({
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_extrude_scale: new t.UniformMatrix2f(e),
                        u_device_pixel_ratio: new t.Uniform1f(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_up_dir: new t.Uniform3f(e)
                    }),
                    collisionBox: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_extrude_scale: new t.Uniform2f(e)
                    }),
                    collisionCircle: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_inv_matrix: new t.UniformMatrix4f(e),
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_viewport_size: new t.Uniform2f(e)
                    }),
                    debug: e => ({
                        u_color: new t.UniformColor(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_overlay: new t.Uniform1i(e),
                        u_overlay_scale: new t.Uniform1f(e)
                    }),
                    clippingMask: e => ({
                        u_matrix: new t.UniformMatrix4f(e)
                    }),
                    heatmap: e => ({
                        u_extrude_scale: new t.Uniform1f(e),
                        u_intensity: new t.Uniform1f(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_up_dir: new t.Uniform3f(e)
                    }),
                    heatmapTexture: e => ({
                        u_image: new t.Uniform1i(e),
                        u_color_ramp: new t.Uniform1i(e),
                        u_opacity: new t.Uniform1f(e)
                    }),
                    hillshade: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_image: new t.Uniform1i(e),
                        u_latrange: new t.Uniform2f(e),
                        u_light: new t.Uniform2f(e),
                        u_shadow: new t.UniformColor(e),
                        u_highlight: new t.UniformColor(e),
                        u_accent: new t.UniformColor(e)
                    }),
                    hillshadePrepare: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_image: new t.Uniform1i(e),
                        u_dimension: new t.Uniform2f(e),
                        u_zoom: new t.Uniform1f(e),
                        u_unpack: new t.Uniform4f(e)
                    }),
                    line: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_pixels_to_tile_units: new t.UniformMatrix2f(e),
                        u_device_pixel_ratio: new t.Uniform1f(e),
                        u_units_to_pixels: new t.Uniform2f(e),
                        u_dash_image: new t.Uniform1i(e),
                        u_gradient_image: new t.Uniform1i(e),
                        u_image_height: new t.Uniform1f(e),
                        u_texsize: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e),
                        u_alpha_discard_threshold: new t.Uniform1f(e),
                        u_trim_offset: new t.Uniform2f(e)
                    }),
                    linePattern: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_texsize: new t.Uniform2f(e),
                        u_pixels_to_tile_units: new t.UniformMatrix2f(e),
                        u_device_pixel_ratio: new t.Uniform1f(e),
                        u_image: new t.Uniform1i(e),
                        u_units_to_pixels: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e),
                        u_alpha_discard_threshold: new t.Uniform1f(e)
                    }),
                    raster: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_tl_parent: new t.Uniform2f(e),
                        u_scale_parent: new t.Uniform1f(e),
                        u_fade_t: new t.Uniform1f(e),
                        u_opacity: new t.Uniform1f(e),
                        u_image0: new t.Uniform1i(e),
                        u_image1: new t.Uniform1i(e),
                        u_brightness_low: new t.Uniform1f(e),
                        u_brightness_high: new t.Uniform1f(e),
                        u_saturation_factor: new t.Uniform1f(e),
                        u_contrast_factor: new t.Uniform1f(e),
                        u_spin_weights: new t.Uniform3f(e),
                        u_perspective_transform: new t.Uniform2f(e)
                    }),
                    symbolIcon: e => ({
                        u_is_size_zoom_constant: new t.Uniform1i(e),
                        u_is_size_feature_constant: new t.Uniform1i(e),
                        u_size_t: new t.Uniform1f(e),
                        u_size: new t.Uniform1f(e),
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_rotate_symbol: new t.Uniform1i(e),
                        u_aspect_ratio: new t.Uniform1f(e),
                        u_fade_change: new t.Uniform1f(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_label_plane_matrix: new t.UniformMatrix4f(e),
                        u_coord_matrix: new t.UniformMatrix4f(e),
                        u_is_text: new t.Uniform1i(e),
                        u_pitch_with_map: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_camera_forward: new t.Uniform3f(e),
                        u_tile_matrix: new t.UniformMatrix4f(e),
                        u_up_vector: new t.Uniform3f(e),
                        u_ecef_origin: new t.Uniform3f(e),
                        u_texture: new t.Uniform1i(e)
                    }),
                    symbolSDF: e => ({
                        u_is_size_zoom_constant: new t.Uniform1i(e),
                        u_is_size_feature_constant: new t.Uniform1i(e),
                        u_size_t: new t.Uniform1f(e),
                        u_size: new t.Uniform1f(e),
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_rotate_symbol: new t.Uniform1i(e),
                        u_aspect_ratio: new t.Uniform1f(e),
                        u_fade_change: new t.Uniform1f(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_label_plane_matrix: new t.UniformMatrix4f(e),
                        u_coord_matrix: new t.UniformMatrix4f(e),
                        u_is_text: new t.Uniform1i(e),
                        u_pitch_with_map: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_texture: new t.Uniform1i(e),
                        u_gamma_scale: new t.Uniform1f(e),
                        u_device_pixel_ratio: new t.Uniform1f(e),
                        u_tile_id: new t.Uniform3f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_inv_rot_matrix: new t.UniformMatrix4f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_camera_forward: new t.Uniform3f(e),
                        u_tile_matrix: new t.UniformMatrix4f(e),
                        u_up_vector: new t.Uniform3f(e),
                        u_ecef_origin: new t.Uniform3f(e),
                        u_is_halo: new t.Uniform1i(e)
                    }),
                    symbolTextAndIcon: e => ({
                        u_is_size_zoom_constant: new t.Uniform1i(e),
                        u_is_size_feature_constant: new t.Uniform1i(e),
                        u_size_t: new t.Uniform1f(e),
                        u_size: new t.Uniform1f(e),
                        u_camera_to_center_distance: new t.Uniform1f(e),
                        u_rotate_symbol: new t.Uniform1i(e),
                        u_aspect_ratio: new t.Uniform1f(e),
                        u_fade_change: new t.Uniform1f(e),
                        u_matrix: new t.UniformMatrix4f(e),
                        u_label_plane_matrix: new t.UniformMatrix4f(e),
                        u_coord_matrix: new t.UniformMatrix4f(e),
                        u_is_text: new t.Uniform1i(e),
                        u_pitch_with_map: new t.Uniform1i(e),
                        u_texsize: new t.Uniform2f(e),
                        u_texsize_icon: new t.Uniform2f(e),
                        u_texture: new t.Uniform1i(e),
                        u_texture_icon: new t.Uniform1i(e),
                        u_gamma_scale: new t.Uniform1f(e),
                        u_device_pixel_ratio: new t.Uniform1f(e),
                        u_is_halo: new t.Uniform1i(e)
                    }),
                    background: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_opacity: new t.Uniform1f(e),
                        u_color: new t.UniformColor(e)
                    }),
                    backgroundPattern: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_opacity: new t.Uniform1f(e),
                        u_image: new t.Uniform1i(e),
                        u_pattern_tl: new t.Uniform2f(e),
                        u_pattern_br: new t.Uniform2f(e),
                        u_texsize: new t.Uniform2f(e),
                        u_pattern_size: new t.Uniform2f(e),
                        u_pixel_coord_upper: new t.Uniform2f(e),
                        u_pixel_coord_lower: new t.Uniform2f(e),
                        u_tile_units_to_pixels: new t.Uniform1f(e)
                    }),
                    terrainRaster: yi,
                    terrainDepth: yi,
                    skybox: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_sun_direction: new t.Uniform3f(e),
                        u_cubemap: new t.Uniform1i(e),
                        u_opacity: new t.Uniform1f(e),
                        u_temporal_offset: new t.Uniform1f(e)
                    }),
                    skyboxGradient: e => ({
                        u_matrix: new t.UniformMatrix4f(e),
                        u_color_ramp: new t.Uniform1i(e),
                        u_center_direction: new t.Uniform3f(e),
                        u_radius: new t.Uniform1f(e),
                        u_opacity: new t.Uniform1f(e),
                        u_temporal_offset: new t.Uniform1f(e)
                    }),
                    skyboxCapture: e => ({
                        u_matrix_3f: new t.UniformMatrix3f(e),
                        u_sun_direction: new t.Uniform3f(e),
                        u_sun_intensity: new t.Uniform1f(e),
                        u_color_tint_r: new t.Uniform4f(e),
                        u_color_tint_m: new t.Uniform4f(e),
                        u_luminance: new t.Uniform1f(e)
                    }),
                    globeRaster: e => ({
                        u_proj_matrix: new t.UniformMatrix4f(e),
                        u_globe_matrix: new t.UniformMatrix4f(e),
                        u_normalize_matrix: new t.UniformMatrix4f(e),
                        u_merc_matrix: new t.UniformMatrix4f(e),
                        u_zoom_transition: new t.Uniform1f(e),
                        u_merc_center: new t.Uniform2f(e),
                        u_image0: new t.Uniform1i(e),
                        u_grid_matrix: new t.UniformMatrix3f(e),
                        u_skirt_height: new t.Uniform1f(e),
                        u_frustum_tl: new t.Uniform3f(e),
                        u_frustum_tr: new t.Uniform3f(e),
                        u_frustum_br: new t.Uniform3f(e),
                        u_frustum_bl: new t.Uniform3f(e),
                        u_globe_pos: new t.Uniform3f(e),
                        u_globe_radius: new t.Uniform1f(e),
                        u_viewport: new t.Uniform2f(e)
                    }),
                    globeAtmosphere: e => ({
                        u_frustum_tl: new t.Uniform3f(e),
                        u_frustum_tr: new t.Uniform3f(e),
                        u_frustum_br: new t.Uniform3f(e),
                        u_frustum_bl: new t.Uniform3f(e),
                        u_horizon: new t.Uniform1f(e),
                        u_transition: new t.Uniform1f(e),
                        u_fadeout_range: new t.Uniform1f(e),
                        u_color: new t.Uniform4f(e),
                        u_high_color: new t.Uniform4f(e),
                        u_space_color: new t.Uniform4f(e),
                        u_star_intensity: new t.Uniform1f(e),
                        u_star_density: new t.Uniform1f(e),
                        u_star_size: new t.Uniform1f(e),
                        u_temporal_offset: new t.Uniform1f(e),
                        u_horizon_angle: new t.Uniform1f(e),
                        u_rotation_matrix: new t.UniformMatrix4f(e)
                    })
                };
                let cn;
                function hn(e, i, n, r, o, s, a) {
                    const l = e.context
                      , c = l.gl
                      , h = e.transform
                      , u = e.useProgram("collisionBox")
                      , d = [];
                    let f = 0
                      , p = 0;
                    for (let m = 0; m < r.length; m++) {
                        const g = r[m]
                          , _ = i.getTile(g)
                          , y = _.getBucket(n);
                        if (!y)
                            continue;
                        const v = ve(g, y, h);
                        let x = v;
                        0 === o[0] && 0 === o[1] || (x = e.translatePosMatrix(v, _, o, s));
                        const b = a ? y.textCollisionBox : y.iconCollisionBox
                          , w = y.collisionCircleArray;
                        if (w.length > 0) {
                            const e = t.create()
                              , i = x;
                            t.mul(e, y.placementInvProjMatrix, h.glCoordMatrix),
                            t.mul(e, e, y.placementViewportMatrix),
                            d.push({
                                circleArray: w,
                                circleOffset: p,
                                transform: i,
                                invTransform: e,
                                projection: y.getProjection()
                            }),
                            f += w.length / 4,
                            p = f
                        }
                        b && (e.terrain && e.terrain.setupElevationDraw(_, u),
                        u.draw(l, c.LINES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, Zi(x, h, _, y.getProjection()), n.id, b.layoutVertexBuffer, b.indexBuffer, b.segments, null, h.zoom, null, [b.collisionVertexBuffer, b.collisionVertexBufferExt]))
                    }
                    if (!a || !d.length)
                        return;
                    const m = e.useProgram("collisionCircle")
                      , g = new t.StructArrayLayout2f1f2i16;
                    g.resize(4 * f),
                    g._trim();
                    let _ = 0;
                    for (const t of d)
                        for (let e = 0; e < t.circleArray.length / 4; e++) {
                            const i = 4 * e
                              , n = t.circleArray[i + 0]
                              , r = t.circleArray[i + 1]
                              , o = t.circleArray[i + 2]
                              , s = t.circleArray[i + 3];
                            g.emplace(_++, n, r, o, s, 0),
                            g.emplace(_++, n, r, o, s, 1),
                            g.emplace(_++, n, r, o, s, 2),
                            g.emplace(_++, n, r, o, s, 3)
                        }
                    (!cn || cn.length < 2 * f) && (cn = function(e) {
                        const i = 2 * e
                          , n = new t.StructArrayLayout3ui6;
                        n.resize(i),
                        n._trim();
                        for (let t = 0; t < i; t++) {
                            const e = 6 * t;
                            n.uint16[e + 0] = 4 * t + 0,
                            n.uint16[e + 1] = 4 * t + 1,
                            n.uint16[e + 2] = 4 * t + 2,
                            n.uint16[e + 3] = 4 * t + 2,
                            n.uint16[e + 4] = 4 * t + 3,
                            n.uint16[e + 5] = 4 * t + 0
                        }
                        return n
                    }(f));
                    const y = l.createIndexBuffer(cn, !0)
                      , v = l.createVertexBuffer(g, t.collisionCircleLayout.members, !0);
                    for (const i of d) {
                        const r = {
                            u_matrix: i.transform,
                            u_inv_matrix: i.invTransform,
                            u_camera_to_center_distance: (x = h).getCameraToCenterDistance(i.projection),
                            u_viewport_size: [x.width, x.height]
                        };
                        m.draw(l, c.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, r, n.id, v, y, t.SegmentVector.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom)
                    }
                    var x;
                    v.destroy(),
                    y.destroy()
                }
                const un = t.create();
                function dn({width: e, height: i, anchor: n, textOffset: r, textScale: o}, s) {
                    const {horizontalAlign: a, verticalAlign: l} = t.getAnchorAlignment(n)
                      , c = -(a - .5) * e
                      , h = -(l - .5) * i
                      , u = t.evaluateVariableOffset(n, r);
                    return new t.Point((c / o + u[0]) * s,(h / o + u[1]) * s)
                }
                function fn(e, i, n, r, o, s, a, l, c, h, u) {
                    const d = e.text.placedSymbolArray
                      , f = e.text.dynamicLayoutVertexArray
                      , p = e.icon.dynamicLayoutVertexArray
                      , m = {}
                      , g = e.getProjection()
                      , _ = xe(l, g, s)
                      , y = s.elevation
                      , v = g.upVectorScale(l.canonical, s.center.lat, s.worldSize).metersToTile;
                    f.clear();
                    for (let p = 0; p < d.length; p++) {
                        const x = d.get(p)
                          , {tileAnchorX: b, tileAnchorY: w, numGlyphs: E} = x
                          , T = x.hidden || !x.crossTileID || e.allowVerticalPlacement && !x.placedOrientation ? null : r[x.crossTileID];
                        if (T) {
                            let r = 0
                              , d = 0
                              , p = 0;
                            if (y) {
                                const t = y ? y.getAtTileOffset(l, b, w) : 0
                                  , [e,i,n] = g.upVector(l.canonical, b, w);
                                r = t * e * v,
                                d = t * i * v,
                                p = t * n * v
                            }
                            let[S,C,A,I] = re(x.projectedAnchorX + r, x.projectedAnchorY + d, x.projectedAnchorZ + p, n ? _ : a);
                            const M = oe(s.getCameraToCenterDistance(g), I);
                            let P = o.evaluateSizeForFeature(e.textSizeData, h, x) * M / t.ONE_EM;
                            n && (P *= e.tilePixelRatio / c);
                            const k = dn(T, P);
                            n ? (({x: S, y: C, z: A} = g.projectTilePoint(b + k.x, w + k.y, l.canonical)),
                            [S,C,A] = re(S + r, C + d, A + p, a)) : (i && k._rotate(-s.angle),
                            S += k.x,
                            C += k.y,
                            A = 0);
                            const O = e.allowVerticalPlacement && x.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                            for (let e = 0; e < E; e++)
                                t.addDynamicAttributes(f, S, C, A, O);
                            u && x.associatedIconIndex >= 0 && (m[x.associatedIconIndex] = {
                                x: S,
                                y: C,
                                z: A,
                                angle: O
                            })
                        } else
                            pe(E, f)
                    }
                    if (u) {
                        p.clear();
                        const i = e.icon.placedSymbolArray;
                        for (let e = 0; e < i.length; e++) {
                            const n = i.get(e)
                              , {numGlyphs: r} = n
                              , o = m[e];
                            if (n.hidden || !o)
                                pe(r, p);
                            else {
                                const {x: e, y: i, z: n, angle: s} = o;
                                for (let o = 0; o < r; o++)
                                    t.addDynamicAttributes(p, e, i, n, s)
                            }
                        }
                        e.icon.dynamicLayoutVertexBuffer.updateData(p)
                    }
                    e.text.dynamicLayoutVertexBuffer.updateData(f)
                }
                function pn(t, e, i) {
                    return i.iconsInText && e ? "symbolTextAndIcon" : t ? "symbolSDF" : "symbolIcon"
                }
                function mn(e, i, n, r, o, s, a, l, c, h, u, d) {
                    const f = e.context
                      , p = f.gl
                      , m = e.transform
                      , g = "map" === l
                      , _ = "map" === c
                      , y = g && "point" !== n.layout.get("symbol-placement")
                      , v = g && !_ && !y
                      , x = void 0 !== n.layout.get("symbol-sort-key").constantOr(1);
                    let b = !1;
                    const w = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                      , E = [t.mercatorXfromLng(m.center.lng), t.mercatorYfromLat(m.center.lat)]
                      , T = n.layout.get("text-variable-anchor")
                      , S = "globe" === m.projection.name
                      , C = []
                      , A = [0, -1, 0];
                    let I = A;
                    !S && !m.mercatorFromTransition || g || (I = function(e) {
                        const i = e._camera.getWorldToCamera(e.worldSize, 1)
                          , n = t.multiply([], i, e.globeMatrix);
                        t.invert(n, n);
                        const r = [0, 0, 0]
                          , o = [0, 1, 0, 0];
                        return t.transformMat4$1(o, o, n),
                        r[0] = o[0],
                        r[1] = o[1],
                        r[2] = o[2],
                        t.normalize(r, r),
                        r
                    }(m));
                    for (const l of r) {
                        const r = i.getTile(l)
                          , c = r.getBucket(n);
                        if (!c)
                            continue;
                        if ("mercator" === c.projection.name && S)
                            continue;
                        const u = o ? c.text : c.icon;
                        if (!u || c.fullyClipped || !u.segments.get().length)
                            continue;
                        const d = u.programConfigurations.get(n.id)
                          , f = o || c.sdfIcons
                          , w = o ? c.textSizeData : c.iconSizeData
                          , M = _ || 0 !== m.pitch
                          , P = t.evaluateSizeForZoom(w, m.zoom);
                        let k, O, R, D, L = [0, 0], B = null;
                        if (o)
                            O = r.glyphAtlasTexture,
                            R = p.LINEAR,
                            k = r.glyphAtlasTexture.size,
                            c.iconsInText && (L = r.imageAtlasTexture.size,
                            B = r.imageAtlasTexture,
                            D = M || e.options.rotating || e.options.zooming || "composite" === w.kind || "camera" === w.kind ? p.LINEAR : p.NEAREST);
                        else {
                            const t = 1 !== n.layout.get("icon-size").constantOr(0) || c.iconsNeedLinear;
                            O = r.imageAtlasTexture,
                            R = f || e.options.rotating || e.options.zooming || t || M ? p.LINEAR : p.NEAREST,
                            k = r.imageAtlasTexture.size
                        }
                        const z = "globe" === c.projection.name
                          , F = z ? I : A
                          , N = z ? t.globeToMercatorTransition(m.zoom) : 0
                          , j = xe(l, c.getProjection(), m)
                          , U = m.calculatePixelsToTileUnitsMatrix(r)
                          , V = ee(j, r.tileID.canonical, _, g, m, c.getProjection(), U)
                          , G = e.terrain && _ && y ? t.invert(t.create(), V) : un
                          , Z = ne(j, r.tileID.canonical, _, g, m, c.getProjection(), U)
                          , q = T && c.hasTextData()
                          , W = "none" !== n.layout.get("icon-text-fit") && q && c.hasIconData();
                        if (y) {
                            const t = m.elevation
                              , i = t ? t.getAtTileOffsetFunc(l, m.center.lat, m.worldSize, c.getProjection()) : null
                              , n = ie(j, r.tileID.canonical, _, g, m, c.getProjection(), U);
                            ae(c, j, e, o, n, Z, _, h, i, l)
                        }
                        const H = y || o && T || W
                          , $ = e.translatePosMatrix(j, r, s, a)
                          , X = H ? un : V
                          , Y = e.translatePosMatrix(Z, r, s, a, !0)
                          , K = c.getProjection().createInversionMatrix(m, l.canonical)
                          , J = [];
                        e.terrainRenderModeElevated() && _ && J.push("PITCH_WITH_MAP_TERRAIN"),
                        z && J.push("PROJECTION_GLOBE_VIEW"),
                        H && J.push("PROJECTED_POS_ON_VIEWPORT");
                        const Q = f && 0 !== n.paint.get(o ? "text-halo-width" : "icon-halo-width").constantOr(1);
                        let tt;
                        tt = f ? c.iconsInText ? on(w.kind, P, v, _, e, $, X, Y, k, L, l, N, E, K, F, c.getProjection()) : rn(w.kind, P, v, _, e, $, X, Y, o, k, !0, l, N, E, K, F, c.getProjection()) : nn(w.kind, P, v, _, e, $, X, Y, o, k, l, N, E, K, F, c.getProjection());
                        const et = {
                            program: e.useProgram(pn(f, o, c), d, J),
                            buffers: u,
                            uniformValues: tt,
                            atlasTexture: O,
                            atlasTextureIcon: B,
                            atlasInterpolation: R,
                            atlasInterpolationIcon: D,
                            isSDF: f,
                            hasHalo: Q,
                            tile: r,
                            labelPlaneMatrixInv: G
                        };
                        if (x && c.canOverlap) {
                            b = !0;
                            const e = u.segments.get();
                            for (const i of e)
                                C.push({
                                    segments: new t.SegmentVector([i]),
                                    sortKey: i.sortKey,
                                    state: et
                                })
                        } else
                            C.push({
                                segments: u.segments,
                                sortKey: 0,
                                state: et
                            })
                    }
                    b && C.sort(( (t, e) => t.sortKey - e.sortKey));
                    for (const t of C) {
                        const i = t.state;
                        if (e.terrain && e.terrain.setupElevationDraw(i.tile, i.program, {
                            useDepthForOcclusion: !S,
                            labelPlaneMatrixInv: i.labelPlaneMatrixInv
                        }),
                        f.activeTexture.set(p.TEXTURE0),
                        i.atlasTexture.bind(i.atlasInterpolation, p.CLAMP_TO_EDGE),
                        i.atlasTextureIcon && (f.activeTexture.set(p.TEXTURE1),
                        i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, p.CLAMP_TO_EDGE)),
                        i.isSDF) {
                            const r = i.uniformValues;
                            i.hasHalo && (r.u_is_halo = 1,
                            gn(i.buffers, t.segments, n, e, i.program, w, u, d, r)),
                            r.u_is_halo = 0
                        }
                        gn(i.buffers, t.segments, n, e, i.program, w, u, d, i.uniformValues)
                    }
                }
                function gn(e, i, n, r, o, s, a, l, c) {
                    const h = r.context
                      , u = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.globeExtVertexBuffer];
                    o.draw(h, h.gl.TRIANGLES, s, a, l, t.CullFaceMode.disabled, c, n.id, e.layoutVertexBuffer, e.indexBuffer, i, n.paint, r.transform.zoom, e.programConfigurations.get(n.id), u)
                }
                function _n(e, i, n, r, o, s, a) {
                    const l = e.context.gl
                      , c = n.paint.get("fill-pattern")
                      , h = c && c.constantOr(1);
                    let u, d, f, p, m;
                    a ? (d = h && !n.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    u = l.LINES) : (d = h ? "fillPattern" : "fill",
                    u = l.TRIANGLES);
                    for (const g of r) {
                        const r = i.getTile(g);
                        if (h && !r.patternsLoaded())
                            continue;
                        const _ = r.getBucket(n);
                        if (!_)
                            continue;
                        e.prepareDrawTile();
                        const y = _.programConfigurations.get(n.id)
                          , v = e.useProgram(d, y);
                        h && (e.context.activeTexture.set(l.TEXTURE0),
                        r.imageAtlasTexture.bind(l.LINEAR, l.CLAMP_TO_EDGE),
                        y.updatePaintBuffers());
                        const x = c.constantOr(null);
                        if (x && r.imageAtlas) {
                            const t = r.imageAtlas.patternPositions[x.toString()];
                            t && y.setConstantPatternPositions(t)
                        }
                        const b = e.translatePosMatrix(g.projMatrix, r, n.paint.get("fill-translate"), n.paint.get("fill-translate-anchor"));
                        if (a) {
                            p = _.indexBuffer2,
                            m = _.segments2;
                            const t = e.terrain && e.terrain.renderingToTexture ? e.terrain.drapeBufferSize : [l.drawingBufferWidth, l.drawingBufferHeight];
                            f = "fillOutlinePattern" === d && h ? ji(b, e, r, t) : Ni(b, t)
                        } else
                            p = _.indexBuffer,
                            m = _.segments,
                            f = h ? Fi(b, e, r) : zi(b);
                        e.prepareDrawProgram(e.context, v, g.toUnwrapped()),
                        v.draw(e.context, u, o, e.stencilModeForClipping(g), s, t.CullFaceMode.disabled, f, n.id, _.layoutVertexBuffer, p, m, n.paint, e.transform.zoom, y)
                    }
                }
                function yn(e, i, n, r, o, s, a) {
                    const l = e.context
                      , c = l.gl
                      , h = e.transform
                      , u = n.paint.get("fill-extrusion-pattern")
                      , d = u.constantOr(1)
                      , f = n.paint.get("fill-extrusion-opacity")
                      , p = [n.paint.get("fill-extrusion-ambient-occlusion-intensity"), n.paint.get("fill-extrusion-ambient-occlusion-radius")]
                      , m = n.layout.get("fill-extrusion-edge-radius")
                      , g = m > 0 && !n.paint.get("fill-extrusion-rounded-roof")
                      , _ = g ? 0 : m
                      , y = "globe" === h.projection.name ? t.fillExtrusionHeightLift() : 0
                      , v = "globe" === h.projection.name
                      , x = v ? t.globeToMercatorTransition(h.zoom) : 0
                      , b = [t.mercatorXfromLng(h.center.lng), t.mercatorYfromLat(h.center.lat)]
                      , w = [];
                    v && w.push("PROJECTION_GLOBE_VIEW"),
                    p[0] > 0 && w.push("FAUX_AO"),
                    g && w.push("ZERO_ROOF_RADIUS");
                    for (const m of r) {
                        const r = i.getTile(m)
                          , g = r.getBucket(n);
                        if (!g || g.projection.name !== h.projection.name)
                            continue;
                        const E = g.programConfigurations.get(n.id)
                          , T = e.useProgram(d ? "fillExtrusionPattern" : "fillExtrusion", E, w);
                        if (e.terrain) {
                            const t = e.terrain;
                            if (e.style.terrainSetForDrapingOnly())
                                t.setupElevationDraw(r, T, {
                                    useMeterToDem: !0
                                });
                            else {
                                if (!g.enableTerrain)
                                    continue;
                                if (t.setupElevationDraw(r, T, {
                                    useMeterToDem: !0
                                }),
                                vn(l, i, m, g, n, t),
                                !g.centroidVertexBuffer) {
                                    const t = T.attributes.a_centroid_pos;
                                    void 0 !== t && c.vertexAttrib2f(t, 0, 0)
                                }
                            }
                        }
                        d && (e.context.activeTexture.set(c.TEXTURE0),
                        r.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE),
                        E.updatePaintBuffers());
                        const S = u.constantOr(null);
                        if (S && r.imageAtlas) {
                            const t = r.imageAtlas.patternPositions[S.toString()];
                            t && E.setConstantPatternPositions(t)
                        }
                        const C = e.translatePosMatrix(m.projMatrix, r, n.paint.get("fill-extrusion-translate"), n.paint.get("fill-extrusion-translate-anchor"))
                          , A = h.projection.createInversionMatrix(h, m.canonical)
                          , I = n.paint.get("fill-extrusion-vertical-gradient")
                          , M = d ? Bi(C, e, I, f, p, _, m, r, y, x, b, A) : Li(C, e, I, f, p, _, m, y, x, b, A);
                        e.prepareDrawProgram(l, T, m.toUnwrapped());
                        const P = [];
                        e.terrain && P.push(g.centroidVertexBuffer),
                        v && P.push(g.layoutVertexExtBuffer),
                        T.draw(l, l.gl.TRIANGLES, o, s, a, t.CullFaceMode.backCCW, M, n.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, n.paint, e.transform.zoom, E, P)
                    }
                }
                function vn(e, i, n, r, o, s) {
                    const a = [e => {
                        let i = e.canonical.x - 1
                          , n = e.wrap;
                        return i < 0 && (i = (1 << e.canonical.z) - 1,
                        n--),
                        new t.OverscaledTileID(e.overscaledZ,n,e.canonical.z,i,e.canonical.y)
                    }
                    , e => {
                        let i = e.canonical.x + 1
                          , n = e.wrap;
                        return i === 1 << e.canonical.z && (i = 0,
                        n++),
                        new t.OverscaledTileID(e.overscaledZ,n,e.canonical.z,i,e.canonical.y)
                    }
                    , e => new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,(0 === e.canonical.y ? 1 << e.canonical.z : e.canonical.y) - 1), e => new t.OverscaledTileID(e.overscaledZ,e.wrap,e.canonical.z,e.canonical.x,e.canonical.y === (1 << e.canonical.z) - 1 ? 0 : e.canonical.y + 1)]
                      , l = t => {
                        const e = i.getSource().minzoom
                          , n = t => {
                            const e = i.getTileByID(t);
                            if (e && e.hasData())
                                return e.getBucket(o)
                        }
                          , r = [0, -1, 1];
                        for (const i of r) {
                            if (t.overscaledZ + i < e)
                                continue;
                            const r = n(t.calculateScaledKey(t.overscaledZ + i));
                            if (r)
                                return r
                        }
                    }
                      , c = [0, 0, 0]
                      , h = (e, i) => (c[0] = Math.min(e.min.y, i.min.y),
                    c[1] = Math.max(e.max.y, i.max.y),
                    c[2] = t.EXTENT - i.min.x > e.max.x ? i.min.x - t.EXTENT : e.max.x,
                    c)
                      , u = (e, i) => (c[0] = Math.min(e.min.x, i.min.x),
                    c[1] = Math.max(e.max.x, i.max.x),
                    c[2] = t.EXTENT - i.min.y > e.max.y ? i.min.y - t.EXTENT : e.max.y,
                    c)
                      , d = [ (t, e) => h(t, e), (t, e) => h(e, t), (t, e) => u(t, e), (t, e) => u(e, t)]
                      , f = new t.Point(0,0);
                    let p, m, g;
                    const _ = (e, i, r, o, a) => {
                        const l = [[o ? r : e, o ? e : r, 0], [o ? r : i, o ? i : r, 0]]
                          , c = a < 0 ? t.EXTENT + a : a
                          , h = [o ? c : (e + i) / 2, o ? (e + i) / 2 : c, 0];
                        return 0 === r && a < 0 || 0 !== r && a > 0 ? s.getForTilePoints(g, [h], !0, m) : l.push(h),
                        s.getForTilePoints(n, l, !0, p),
                        Math.max(l[0][2], l[1][2], h[2]) / s.exaggeration()
                    }
                    ;
                    for (let e = 0; e < 4; e++) {
                        const i = (e < 2 ? 1 : 5) - e
                          , o = r.borders[e];
                        if (0 === o.length)
                            continue;
                        const c = g = a[e](n)
                          , h = l(c);
                        if (!(h && h instanceof t.FillExtrusionBucket && h.enableTerrain))
                            continue;
                        if (r.borderDoneWithNeighborZ[e] === h.canonical.z && h.borderDoneWithNeighborZ[i] === r.canonical.z)
                            continue;
                        if (m = s.findDEMTileFor(c),
                        !m || !m.dem)
                            continue;
                        if (!p) {
                            const t = s.findDEMTileFor(n);
                            if (!t || !t.dem)
                                return;
                            p = t
                        }
                        const u = h.borders[i];
                        let y = 0;
                        const v = h.borderDoneWithNeighborZ[i] !== r.canonical.z;
                        if (r.canonical.z === h.canonical.z) {
                            for (let n = 0; n < o.length; n++) {
                                const s = r.featuresOnBorder[o[n]]
                                  , a = s.borders[e];
                                let l;
                                for (; y < u.length && (l = h.featuresOnBorder[u[y]],
                                !(l.borders[i][1] > a[0] + 3)); )
                                    v && h.encodeCentroid(void 0, l, !1),
                                    y++;
                                if (l && y < u.length) {
                                    const n = y;
                                    let o = 0;
                                    for (; !(l.borders[i][0] > a[1] - 3) && (o++,
                                    ++y !== u.length); )
                                        l = h.featuresOnBorder[u[y]];
                                    if (l = h.featuresOnBorder[u[n]],
                                    s.intersectsCount() > 1 || l.intersectsCount() > 1 || 1 !== o) {
                                        1 !== o && (y = n),
                                        r.encodeCentroid(void 0, s, !1),
                                        v && h.encodeCentroid(void 0, l, !1);
                                        continue
                                    }
                                    const c = d[e](s, l)
                                      , p = e % 2 ? t.EXTENT - 1 : 0;
                                    f.x = _(c[0], Math.min(t.EXTENT - 1, c[1]), p, e < 2, c[2]),
                                    f.y = 0,
                                    r.encodeCentroid(f, s, !1),
                                    v && h.encodeCentroid(f, l, !1)
                                } else
                                    r.encodeCentroid(void 0, s, !1)
                            }
                            r.borderDoneWithNeighborZ[e] = h.canonical.z,
                            r.needsCentroidUpdate = !0,
                            v && (h.borderDoneWithNeighborZ[i] = r.canonical.z,
                            h.needsCentroidUpdate = !0)
                        } else {
                            for (const t of o)
                                r.encodeCentroid(void 0, r.featuresOnBorder[t], !1);
                            if (v) {
                                for (const t of u)
                                    h.encodeCentroid(void 0, h.featuresOnBorder[t], !1);
                                h.borderDoneWithNeighborZ[i] = r.canonical.z,
                                h.needsCentroidUpdate = !0
                            }
                            r.borderDoneWithNeighborZ[e] = h.canonical.z,
                            r.needsCentroidUpdate = !0
                        }
                    }
                    (r.needsCentroidUpdate || !r.centroidVertexBuffer && 0 !== r.centroidVertexArray.length) && r.uploadCentroid(e)
                }
                const xn = new t.Color(1,0,0,1)
                  , bn = new t.Color(0,1,0,1)
                  , wn = new t.Color(0,0,1,1)
                  , En = new t.Color(1,0,1,1)
                  , Tn = new t.Color(0,1,1,1);
                function Sn(e, i, n) {
                    const r = e.context
                      , o = e.transform
                      , s = r.gl
                      , a = "globe" === o.projection.name
                      , l = a ? ["PROJECTION_GLOBE_VIEW"] : null;
                    let c = n.projMatrix;
                    if (a && t.globeToMercatorTransition(o.zoom) > 0) {
                        const e = t.transitionTileAABBinECEF(n.canonical, o)
                          , i = t.globeDenormalizeECEF(e);
                        c = t.multiply(new Float32Array(16), o.globeMatrix, i),
                        t.multiply(c, o.projMatrix, c)
                    }
                    const h = e.useProgram("debug", null, l)
                      , u = i.getTileByID(n.key);
                    e.terrain && e.terrain.setupElevationDraw(u, h);
                    const d = t.DepthMode.disabled
                      , f = t.StencilMode.disabled
                      , p = e.colorModeForRenderPass()
                      , m = "$debug";
                    r.activeTexture.set(s.TEXTURE0),
                    e.emptyTexture.bind(s.LINEAR, s.CLAMP_TO_EDGE),
                    a ? u._makeGlobeTileDebugBuffers(e.context, o) : u._makeDebugTileBoundsBuffers(e.context, o.projection);
                    const g = u._tileDebugBuffer || e.debugBuffer
                      , _ = u._tileDebugIndexBuffer || e.debugIndexBuffer
                      , y = u._tileDebugSegments || e.debugSegments;
                    h.draw(r, s.LINE_STRIP, d, f, p, t.CullFaceMode.disabled, qi(c, t.Color.red), m, g, _, y, null, null, null, [u._globeTileDebugBorderBuffer]);
                    const v = u.latestRawTileData
                      , x = Math.floor((v && v.byteLength || 0) / 1024)
                      , b = i.getTile(n).tileSize
                      , w = 512 / Math.min(b, 512) * (n.overscaledZ / o.zoom) * .5;
                    let E = n.canonical.toString();
                    n.overscaledZ !== n.canonical.z && (E += ` => ${n.overscaledZ}`),
                    E += ` ${x}kb`,
                    function(t, e) {
                        t.initDebugOverlayCanvas();
                        const i = t.debugOverlayCanvas
                          , n = t.context.gl
                          , r = t.debugOverlayCanvas.getContext("2d");
                        r.clearRect(0, 0, i.width, i.height),
                        r.shadowColor = "white",
                        r.shadowBlur = 2,
                        r.lineWidth = 1.5,
                        r.strokeStyle = "white",
                        r.textBaseline = "top",
                        r.font = "bold 36px Open Sans, sans-serif",
                        r.fillText(e, 5, 5),
                        r.strokeText(e, 5, 5),
                        t.debugOverlayTexture.update(i),
                        t.debugOverlayTexture.bind(n.LINEAR, n.CLAMP_TO_EDGE)
                    }(e, E);
                    const T = u._tileDebugTextBuffer || e.debugBuffer
                      , S = u._tileDebugTextIndexBuffer || e.quadTriangleIndexBuffer
                      , C = u._tileDebugTextSegments || e.debugSegments;
                    h.draw(r, s.TRIANGLES, d, f, t.ColorMode.alphaBlended, t.CullFaceMode.disabled, qi(c, t.Color.transparent, w), m, T, S, C, null, null, null, [u._globeTileDebugTextBuffer])
                }
                function Cn(t, e, i, n) {
                    In(t, 0, e + i / 2, t.transform.width, i, n)
                }
                function An(t, e, i, n) {
                    In(t, e - i / 2, 0, i, t.transform.height, n)
                }
                function In(e, i, n, r, o, s) {
                    const a = e.context
                      , l = a.gl;
                    l.enable(l.SCISSOR_TEST),
                    l.scissor(i * t.exported.devicePixelRatio, n * t.exported.devicePixelRatio, r * t.exported.devicePixelRatio, o * t.exported.devicePixelRatio),
                    a.clear({
                        color: s
                    }),
                    l.disable(l.SCISSOR_TEST)
                }
                const Mn = t.createLayout([{
                    name: "a_pos_3f",
                    components: 3,
                    type: "Float32"
                }])
                  , {members: Pn} = Mn;
                function kn(t, e, i, n) {
                    t.emplaceBack(e, i, n)
                }
                class On {
                    constructor(e) {
                        this.vertexArray = new t.StructArrayLayout3f12,
                        this.indices = new t.StructArrayLayout3ui6,
                        kn(this.vertexArray, -1, -1, 1),
                        kn(this.vertexArray, 1, -1, 1),
                        kn(this.vertexArray, -1, 1, 1),
                        kn(this.vertexArray, 1, 1, 1),
                        kn(this.vertexArray, -1, -1, -1),
                        kn(this.vertexArray, 1, -1, -1),
                        kn(this.vertexArray, -1, 1, -1),
                        kn(this.vertexArray, 1, 1, -1),
                        this.indices.emplaceBack(5, 1, 3),
                        this.indices.emplaceBack(3, 7, 5),
                        this.indices.emplaceBack(6, 2, 0),
                        this.indices.emplaceBack(0, 4, 6),
                        this.indices.emplaceBack(2, 6, 7),
                        this.indices.emplaceBack(7, 3, 2),
                        this.indices.emplaceBack(5, 4, 0),
                        this.indices.emplaceBack(0, 1, 5),
                        this.indices.emplaceBack(0, 2, 3),
                        this.indices.emplaceBack(3, 1, 0),
                        this.indices.emplaceBack(7, 6, 4),
                        this.indices.emplaceBack(4, 5, 7),
                        this.vertexBuffer = e.createVertexBuffer(this.vertexArray, Pn),
                        this.indexBuffer = e.createIndexBuffer(this.indices),
                        this.segment = t.SegmentVector.simpleSegment(0, 0, 36, 12)
                    }
                }
                function Rn(e, i, n, r, o, s) {
                    const a = e.gl
                      , l = i.paint.get("sky-atmosphere-color")
                      , c = i.paint.get("sky-atmosphere-halo-color")
                      , h = i.paint.get("sky-atmosphere-sun-intensity")
                      , u = ( (t, e, i, n, r) => ({
                        u_matrix_3f: t,
                        u_sun_direction: e,
                        u_sun_intensity: i,
                        u_color_tint_r: [n.r, n.g, n.b, n.a],
                        u_color_tint_m: [r.r, r.g, r.b, r.a],
                        u_luminance: 5e-5
                    }))(t.fromMat4(t.create$1(), r), o, h, l, c);
                    a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + s, i.skyboxTexture, 0),
                    n.draw(e, a.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, t.ColorMode.unblended, t.CullFaceMode.frontCW, u, "skyboxCapture", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
                }
                const Dn = t.createLayout([{
                    type: "Float32",
                    name: "a_pos",
                    components: 3
                }, {
                    type: "Float32",
                    name: "a_uv",
                    components: 2
                }]);
                class Ln {
                    constructor(e) {
                        const i = new t.StructArrayLayout5f20;
                        i.emplaceBack(-1, 1, 1, 0, 0),
                        i.emplaceBack(1, 1, 1, 1, 0),
                        i.emplaceBack(1, -1, 1, 1, 1),
                        i.emplaceBack(-1, -1, 1, 0, 1);
                        const n = new t.StructArrayLayout3ui6;
                        n.emplaceBack(0, 1, 2),
                        n.emplaceBack(2, 3, 0),
                        this.vertexBuffer = e.createVertexBuffer(i, Dn.members),
                        this.indexBuffer = e.createIndexBuffer(n),
                        this.segments = t.SegmentVector.simpleSegment(0, 0, 4, 2)
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy()
                    }
                }
                const Bn = {
                    symbol: function(e, i, n, r, o) {
                        if ("translucent" !== e.renderPass)
                            return;
                        const s = t.StencilMode.disabled
                          , a = e.colorModeForRenderPass();
                        n.layout.get("text-variable-anchor") && function(e, i, n, r, o, s, a) {
                            const l = i.transform
                              , c = "map" === o
                              , h = "map" === s;
                            for (const i of e) {
                                const e = r.getTile(i)
                                  , o = e.getBucket(n);
                                if (!o || !o.text || !o.text.segments.get().length)
                                    continue;
                                const s = t.evaluateSizeForZoom(o.textSizeData, l.zoom)
                                  , u = xe(i, o.getProjection(), l)
                                  , d = l.calculatePixelsToTileUnitsMatrix(e)
                                  , f = ee(u, e.tileID.canonical, h, c, l, o.getProjection(), d)
                                  , p = "none" !== n.layout.get("icon-text-fit") && o.hasIconData();
                                if (s) {
                                    const n = Math.pow(2, l.zoom - e.tileID.overscaledZ);
                                    fn(o, c, h, a, t.symbolSize, l, f, i, n, s, p)
                                }
                            }
                        }(r, e, n, i, n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), o),
                        0 !== n.paint.get("icon-opacity").constantOr(1) && mn(e, i, n, r, !1, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), n.layout.get("icon-rotation-alignment"), n.layout.get("icon-pitch-alignment"), n.layout.get("icon-keep-upright"), s, a),
                        0 !== n.paint.get("text-opacity").constantOr(1) && mn(e, i, n, r, !0, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), n.layout.get("text-rotation-alignment"), n.layout.get("text-pitch-alignment"), n.layout.get("text-keep-upright"), s, a),
                        i.map.showCollisionBoxes && (hn(e, i, n, r, n.paint.get("text-translate"), n.paint.get("text-translate-anchor"), !0),
                        hn(e, i, n, r, n.paint.get("icon-translate"), n.paint.get("icon-translate-anchor"), !1))
                    },
                    circle: function(e, i, n, r) {
                        if ("translucent" !== e.renderPass)
                            return;
                        const o = n.paint.get("circle-opacity")
                          , s = n.paint.get("circle-stroke-width")
                          , a = n.paint.get("circle-stroke-opacity")
                          , l = void 0 !== n.layout.get("circle-sort-key").constantOr(1);
                        if (0 === o.constantOr(1) && (0 === s.constantOr(1) || 0 === a.constantOr(1)))
                            return;
                        const c = e.context
                          , h = c.gl
                          , u = e.transform
                          , d = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                          , f = t.StencilMode.disabled
                          , p = e.colorModeForRenderPass()
                          , m = "globe" === u.projection.name
                          , g = [t.mercatorXfromLng(u.center.lng), t.mercatorYfromLat(u.center.lat)]
                          , _ = [];
                        for (let o = 0; o < r.length; o++) {
                            const s = r[o]
                              , a = i.getTile(s)
                              , c = a.getBucket(n);
                            if (!c || c.projection.name !== u.projection.name)
                                continue;
                            const h = c.programConfigurations.get(n.id)
                              , d = Gi(n);
                            m && d.push("PROJECTION_GLOBE_VIEW");
                            const f = e.useProgram("circle", h, d)
                              , p = c.layoutVertexBuffer
                              , y = c.globeExtVertexBuffer
                              , v = c.indexBuffer
                              , x = u.projection.createInversionMatrix(u, s.canonical)
                              , b = {
                                programConfiguration: h,
                                program: f,
                                layoutVertexBuffer: p,
                                globeExtVertexBuffer: y,
                                indexBuffer: v,
                                uniformValues: Vi(e, s, a, x, g, n),
                                tile: a
                            };
                            if (l) {
                                const e = c.segments.get();
                                for (const i of e)
                                    _.push({
                                        segments: new t.SegmentVector([i]),
                                        sortKey: i.sortKey,
                                        state: b
                                    })
                            } else
                                _.push({
                                    segments: c.segments,
                                    sortKey: 0,
                                    state: b
                                })
                        }
                        l && _.sort(( (t, e) => t.sortKey - e.sortKey));
                        const y = {
                            useDepthForOcclusion: !m
                        };
                        for (const i of _) {
                            const {programConfiguration: r, program: o, layoutVertexBuffer: s, globeExtVertexBuffer: a, indexBuffer: l, uniformValues: m, tile: g} = i.state
                              , _ = i.segments;
                            e.terrain && e.terrain.setupElevationDraw(g, o, y),
                            e.prepareDrawProgram(c, o, g.tileID.toUnwrapped()),
                            o.draw(c, h.TRIANGLES, d, f, p, t.CullFaceMode.disabled, m, n.id, s, l, _, n.paint, u.zoom, r, [a])
                        }
                    },
                    heatmap: function(e, i, n, r) {
                        if (0 !== n.paint.get("heatmap-opacity"))
                            if ("offscreen" === e.renderPass) {
                                const o = e.context
                                  , s = o.gl
                                  , a = t.StencilMode.disabled
                                  , l = new t.ColorMode([s.ONE, s.ONE],t.Color.transparent,[!0, !0, !0, !0]);
                                !function(t, e, i, n) {
                                    const r = t.gl
                                      , o = e.width * n
                                      , s = e.height * n;
                                    t.activeTexture.set(r.TEXTURE1),
                                    t.viewport.set([0, 0, o, s]);
                                    let a = i.heatmapFbo;
                                    if (!a || a && (a.width !== o || a.height !== s)) {
                                        a && a.destroy();
                                        const e = r.createTexture();
                                        r.bindTexture(r.TEXTURE_2D, e),
                                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
                                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
                                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR),
                                        r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR),
                                        a = i.heatmapFbo = t.createFramebuffer(o, s, !1),
                                        function(t, e, i, n, r, o) {
                                            const s = t.gl;
                                            s.texImage2D(s.TEXTURE_2D, 0, t.isWebGL2 && t.extRenderToTextureHalfFloat ? s.RGBA16F : s.RGBA, r, o, 0, s.RGBA, t.extRenderToTextureHalfFloat ? t.isWebGL2 ? s.HALF_FLOAT : t.extTextureHalfFloat.HALF_FLOAT_OES : s.UNSIGNED_BYTE, null),
                                            n.colorAttachment.set(i)
                                        }(t, 0, e, a, o, s)
                                    } else
                                        r.bindTexture(r.TEXTURE_2D, a.colorAttachment.get()),
                                        t.bindFramebuffer.set(a.framebuffer)
                                }(o, e, n, "globe" === e.transform.projection.name ? .5 : .25),
                                o.clear({
                                    color: t.Color.transparent
                                });
                                const c = e.transform
                                  , h = "globe" === c.projection.name
                                  , u = h ? ["PROJECTION_GLOBE_VIEW"] : null
                                  , d = h ? t.CullFaceMode.frontCCW : t.CullFaceMode.disabled
                                  , f = [t.mercatorXfromLng(c.center.lng), t.mercatorYfromLat(c.center.lat)];
                                for (let p = 0; p < r.length; p++) {
                                    const m = r[p];
                                    if (i.hasRenderableParent(m))
                                        continue;
                                    const g = i.getTile(m)
                                      , _ = g.getBucket(n);
                                    if (!_ || _.projection.name !== c.projection.name)
                                        continue;
                                    const y = _.programConfigurations.get(n.id)
                                      , v = e.useProgram("heatmap", y, u)
                                      , {zoom: x} = e.transform;
                                    e.terrain && e.terrain.setupElevationDraw(g, v),
                                    e.prepareDrawProgram(o, v, m.toUnwrapped());
                                    const b = c.projection.createInversionMatrix(c, m.canonical);
                                    v.draw(o, s.TRIANGLES, t.DepthMode.disabled, a, l, d, Hi(e, m, g, b, f, x, n.paint.get("heatmap-intensity")), n.id, _.layoutVertexBuffer, _.indexBuffer, _.segments, n.paint, e.transform.zoom, y, h ? [_.globeExtVertexBuffer] : null)
                                }
                                o.viewport.set([0, 0, e.width, e.height])
                            } else
                                "translucent" === e.renderPass && (e.context.setColorMode(e.colorModeForRenderPass()),
                                function(e, i) {
                                    const n = e.context
                                      , r = n.gl
                                      , o = i.heatmapFbo;
                                    if (!o)
                                        return;
                                    n.activeTexture.set(r.TEXTURE0),
                                    r.bindTexture(r.TEXTURE_2D, o.colorAttachment.get()),
                                    n.activeTexture.set(r.TEXTURE1);
                                    let s = i.colorRampTexture;
                                    s || (s = i.colorRampTexture = new t.Texture(n,i.colorRamp,r.RGBA)),
                                    s.bind(r.LINEAR, r.CLAMP_TO_EDGE),
                                    e.useProgram("heatmapTexture").draw(n, r.TRIANGLES, t.DepthMode.disabled, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.disabled, ( (t, e, i, n) => ({
                                        u_image: 0,
                                        u_color_ramp: 1,
                                        u_opacity: e.paint.get("heatmap-opacity")
                                    }))(0, i), i.id, e.viewportBuffer, e.quadTriangleIndexBuffer, e.viewportSegments, i.paint, e.transform.zoom)
                                }(e, n))
                    },
                    line: function(e, i, n, r) {
                        if ("translucent" !== e.renderPass)
                            return;
                        const o = n.paint.get("line-opacity")
                          , s = n.paint.get("line-width");
                        if (0 === o.constantOr(1) || 0 === s.constantOr(1))
                            return;
                        const a = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                          , l = e.colorModeForRenderPass()
                          , c = e.terrain && e.terrain.renderingToTexture ? 1 : t.exported.devicePixelRatio
                          , h = n.paint.get("line-dasharray")
                          , u = h.constantOr(1)
                          , d = n.layout.get("line-cap")
                          , f = n.paint.get("line-pattern")
                          , p = f.constantOr(1)
                          , m = n.paint.get("line-gradient")
                          , g = p ? "linePattern" : "line"
                          , _ = e.context
                          , y = _.gl
                          , v = (t => {
                            const e = [];
                            Ji(t) && e.push("RENDER_LINE_DASH"),
                            t.paint.get("line-gradient") && e.push("RENDER_LINE_GRADIENT");
                            const i = t.paint.get("line-trim-offset");
                            0 === i[0] && 0 === i[1] || e.push("RENDER_LINE_TRIM_OFFSET");
                            const n = t.paint.get("line-pattern").constantOr(1)
                              , r = 1 !== t.paint.get("line-opacity").constantOr(1);
                            return !n && r && e.push("RENDER_LINE_ALPHA_DISCARD"),
                            e
                        }
                        )(n);
                        let x = v.includes("RENDER_LINE_ALPHA_DISCARD");
                        e.terrain && e.terrain.clipOrMaskOverlapStencilType() && (x = !1);
                        for (const o of r) {
                            const r = i.getTile(o);
                            if (p && !r.patternsLoaded())
                                continue;
                            const s = r.getBucket(n);
                            if (!s)
                                continue;
                            e.prepareDrawTile();
                            const b = s.programConfigurations.get(n.id)
                              , w = e.useProgram(g, b, v)
                              , E = f.constantOr(null);
                            if (E && r.imageAtlas) {
                                const t = r.imageAtlas.patternPositions[E.toString()];
                                t && b.setConstantPatternPositions(t)
                            }
                            const T = h.constantOr(null)
                              , S = d.constantOr(null);
                            if (!p && T && S && r.lineAtlas) {
                                const t = r.lineAtlas.getDash(T, S);
                                t && b.setConstantPatternPositions(t)
                            }
                            let[C,A] = n.paint.get("line-trim-offset");
                            if ("round" === S || "square" === S) {
                                const t = 1;
                                C !== A && (0 === C && (C -= t),
                                1 === A && (A += t))
                            }
                            const I = e.terrain ? o.projMatrix : null
                              , M = p ? Xi(e, r, n, I, c) : $i(e, r, n, I, s.lineClipsArray.length, c, [C, A]);
                            if (m) {
                                const r = s.gradients[n.id];
                                let a = r.texture;
                                if (n.gradientVersion !== r.version) {
                                    let l = 256;
                                    if (n.stepInterpolant) {
                                        const n = i.getSource().maxzoom
                                          , r = o.canonical.z === n ? Math.ceil(1 << e.transform.maxZoom - o.canonical.z) : 1;
                                        l = t.clamp(t.nextPowerOfTwo(s.maxLineLength / t.EXTENT * 1024 * r), 256, _.maxTextureSize)
                                    }
                                    r.gradient = t.renderColorRamp({
                                        expression: n.gradientExpression(),
                                        evaluationKey: "lineProgress",
                                        resolution: l,
                                        image: r.gradient || void 0,
                                        clips: s.lineClipsArray
                                    }),
                                    r.texture ? r.texture.update(r.gradient) : r.texture = new t.Texture(_,r.gradient,y.RGBA),
                                    r.version = n.gradientVersion,
                                    a = r.texture
                                }
                                _.activeTexture.set(y.TEXTURE1),
                                a.bind(n.stepInterpolant ? y.NEAREST : y.LINEAR, y.CLAMP_TO_EDGE)
                            }
                            u && (_.activeTexture.set(y.TEXTURE0),
                            r.lineAtlasTexture.bind(y.LINEAR, y.REPEAT),
                            b.updatePaintBuffers()),
                            p && (_.activeTexture.set(y.TEXTURE0),
                            r.imageAtlasTexture.bind(y.LINEAR, y.CLAMP_TO_EDGE),
                            b.updatePaintBuffers()),
                            e.prepareDrawProgram(_, w, o.toUnwrapped());
                            const P = i => {
                                w.draw(_, y.TRIANGLES, a, i, l, t.CullFaceMode.disabled, M, n.id, s.layoutVertexBuffer, s.indexBuffer, s.segments, n.paint, e.transform.zoom, b, [s.layoutVertexBuffer2])
                            }
                            ;
                            if (x) {
                                const i = e.stencilModeForClipping(o).ref;
                                0 === i && e.terrain && _.clear({
                                    stencil: 0
                                });
                                const n = {
                                    func: y.EQUAL,
                                    mask: 255
                                };
                                M.u_alpha_discard_threshold = .8,
                                P(new t.StencilMode(n,i,255,y.KEEP,y.KEEP,y.INVERT)),
                                M.u_alpha_discard_threshold = 0,
                                P(new t.StencilMode(n,i,255,y.KEEP,y.KEEP,y.KEEP))
                            } else
                                P(e.stencilModeForClipping(o))
                        }
                        x && (e.resetStencilClippingMasks(),
                        e.terrain && _.clear({
                            stencil: 0
                        }))
                    },
                    fill: function(e, i, n, r) {
                        const o = n.paint.get("fill-color")
                          , s = n.paint.get("fill-opacity");
                        if (0 === s.constantOr(1))
                            return;
                        const a = e.colorModeForRenderPass()
                          , l = n.paint.get("fill-pattern")
                          , c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && 1 === o.constantOr(t.Color.transparent).a && 1 === s.constantOr(0) ? "opaque" : "translucent";
                        if (e.renderPass === c) {
                            const o = e.depthModeForSublayer(1, "opaque" === e.renderPass ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly);
                            _n(e, i, n, r, o, a, !1)
                        }
                        if ("translucent" === e.renderPass && n.paint.get("fill-antialias")) {
                            const o = e.depthModeForSublayer(n.getPaintProperty("fill-outline-color") ? 2 : 0, t.DepthMode.ReadOnly);
                            _n(e, i, n, r, o, a, !0)
                        }
                    },
                    "fill-extrusion": function(e, i, n, r) {
                        const o = n.paint.get("fill-extrusion-opacity");
                        if (0 !== o && "translucent" === e.renderPass) {
                            const s = new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D);
                            if (1 !== o || n.paint.get("fill-extrusion-pattern").constantOr(1))
                                yn(e, i, n, r, s, t.StencilMode.disabled, t.ColorMode.disabled),
                                yn(e, i, n, r, s, e.stencilModeFor3D(), e.colorModeForRenderPass()),
                                e.resetStencilClippingMasks();
                            else {
                                const o = e.colorModeForRenderPass();
                                yn(e, i, n, r, s, t.StencilMode.disabled, o)
                            }
                        }
                    },
                    hillshade: function(e, i, n, r) {
                        if ("offscreen" !== e.renderPass && "translucent" !== e.renderPass)
                            return;
                        const o = e.context
                          , s = e.depthModeForSublayer(0, t.DepthMode.ReadOnly)
                          , a = e.colorModeForRenderPass()
                          , l = e.terrain && e.terrain.renderingToTexture
                          , [c,h] = "translucent" !== e.renderPass || l ? [{}, r] : e.stencilConfigForOverlap(r);
                        for (const r of h) {
                            const o = i.getTile(r);
                            if (o.needsHillshadePrepare && "offscreen" === e.renderPass)
                                _i(e, o, n, s, t.StencilMode.disabled, a);
                            else if ("translucent" === e.renderPass) {
                                const t = l && e.terrain ? e.terrain.stencilModeForRTTOverlap(r) : c[r.overscaledZ];
                                mi(e, r, o, n, s, t, a)
                            }
                        }
                        o.viewport.set([0, 0, e.width, e.height]),
                        e.resetStencilClippingMasks()
                    },
                    raster: function(e, i, n, r, o, s) {
                        if ("translucent" !== e.renderPass)
                            return;
                        if (0 === n.paint.get("raster-opacity"))
                            return;
                        if (!r.length)
                            return;
                        const a = e.context
                          , l = a.gl
                          , c = i.getSource()
                          , h = e.useProgram("raster")
                          , u = e.colorModeForRenderPass()
                          , d = e.terrain && e.terrain.renderingToTexture
                          , [f,p] = c instanceof Mt || d ? [{}, r] : e.stencilConfigForOverlap(r)
                          , m = p[p.length - 1].overscaledZ
                          , g = !e.options.moving;
                        for (const r of p) {
                            const o = d ? t.DepthMode.disabled : e.depthModeForSublayer(r.overscaledZ - m, 1 === n.paint.get("raster-opacity") ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly, l.LESS)
                              , p = r.toUnwrapped()
                              , _ = i.getTile(r);
                            if (d && (!_ || !_.hasData()))
                                continue;
                            const y = d ? r.projMatrix : e.transform.calculateProjMatrix(p, g)
                              , v = e.terrain && d ? e.terrain.stencilModeForRTTOverlap(r) : f[r.overscaledZ]
                              , x = s ? 0 : n.paint.get("raster-fade-duration");
                            _.registerFadeDuration(x);
                            const b = i.findLoadedParent(r, 0)
                              , w = Ai(_, b, i, e.transform, x);
                            let E, T;
                            e.terrain && e.terrain.prepareDrawTile();
                            const S = "nearest" === n.paint.get("raster-resampling") ? l.NEAREST : l.LINEAR;
                            a.activeTexture.set(l.TEXTURE0),
                            _.texture.bind(S, l.CLAMP_TO_EDGE),
                            a.activeTexture.set(l.TEXTURE1),
                            b ? (b.texture.bind(S, l.CLAMP_TO_EDGE),
                            E = Math.pow(2, b.tileID.overscaledZ - _.tileID.overscaledZ),
                            T = [_.tileID.canonical.x * E % 1, _.tileID.canonical.y * E % 1]) : _.texture.bind(S, l.CLAMP_TO_EDGE),
                            _.texture.useMipmap && a.extTextureFilterAnisotropic && e.transform.pitch > 20 && l.texParameterf(l.TEXTURE_2D, a.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, a.extTextureFilterAnisotropicMax);
                            const C = Qi(y, T || [0, 0], E || 1, w, n, c instanceof Mt ? c.perspectiveTransform : [0, 0]);
                            if (e.prepareDrawProgram(a, h, p),
                            c instanceof Mt)
                                c.boundsBuffer && c.boundsSegments && h.draw(a, l.TRIANGLES, o, t.StencilMode.disabled, u, t.CullFaceMode.disabled, C, n.id, c.boundsBuffer, e.quadTriangleIndexBuffer, c.boundsSegments);
                            else {
                                const {tileBoundsBuffer: i, tileBoundsIndexBuffer: r, tileBoundsSegments: s} = e.getTileBoundsBuffers(_);
                                h.draw(a, l.TRIANGLES, o, v, u, t.CullFaceMode.disabled, C, n.id, i, r, s)
                            }
                        }
                        e.resetStencilClippingMasks()
                    },
                    background: function(e, i, n, r) {
                        const o = n.paint.get("background-color")
                          , s = n.paint.get("background-opacity");
                        if (0 === s)
                            return;
                        const a = e.context
                          , l = a.gl
                          , c = e.transform
                          , h = c.tileSize
                          , u = n.paint.get("background-pattern");
                        if (e.isPatternMissing(u))
                            return;
                        const d = !u && 1 === o.a && 1 === s && e.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                        if (e.renderPass !== d)
                            return;
                        const f = t.StencilMode.disabled
                          , p = e.depthModeForSublayer(0, "opaque" === d ? t.DepthMode.ReadWrite : t.DepthMode.ReadOnly)
                          , m = e.colorModeForRenderPass()
                          , g = e.useProgram(u ? "backgroundPattern" : "background");
                        let _, y = r;
                        y || (_ = e.getBackgroundTiles(),
                        y = Object.values(_).map((t => t.tileID))),
                        u && (a.activeTexture.set(l.TEXTURE0),
                        e.imageManager.bind(e.context));
                        for (const d of y) {
                            const y = d.toUnwrapped()
                              , v = r ? d.projMatrix : e.transform.calculateProjMatrix(y);
                            e.prepareDrawTile();
                            const x = i ? i.getTile(d) : _ ? _[d.key] : new t.Tile(d,h,c.zoom,e)
                              , b = u ? an(v, s, e, u, {
                                tileID: d,
                                tileSize: h
                            }) : sn(v, s, o);
                            e.prepareDrawProgram(a, g, y);
                            const {tileBoundsBuffer: w, tileBoundsIndexBuffer: E, tileBoundsSegments: T} = e.getTileBoundsBuffers(x);
                            g.draw(a, l.TRIANGLES, p, f, m, t.CullFaceMode.disabled, b, n.id, w, E, T)
                        }
                    },
                    sky: function(e, i, n) {
                        const r = e.transform
                          , o = "mercator" === r.projection.name || "globe" === r.projection.name ? 1 : t.smoothstep(7, 8, r.zoom)
                          , s = n.paint.get("sky-opacity") * o;
                        if (0 === s)
                            return;
                        const a = e.context
                          , l = n.paint.get("sky-type")
                          , c = new t.DepthMode(a.gl.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                          , h = e.frameCounter / 1e3 % 1;
                        "atmosphere" === l ? "offscreen" === e.renderPass ? n.needsSkyboxCapture(e) && (function(e, i, n, r) {
                            const o = e.context
                              , s = o.gl;
                            let a = i.skyboxFbo;
                            if (!a) {
                                a = i.skyboxFbo = o.createFramebuffer(32, 32, !1),
                                i.skyboxGeometry = new On(o),
                                i.skyboxTexture = o.gl.createTexture(),
                                s.bindTexture(s.TEXTURE_CUBE_MAP, i.skyboxTexture),
                                s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                                s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                                s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, s.LINEAR),
                                s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, s.LINEAR);
                                for (let t = 0; t < 6; ++t)
                                    s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, s.RGBA, 32, 32, 0, s.RGBA, s.UNSIGNED_BYTE, null)
                            }
                            o.bindFramebuffer.set(a.framebuffer),
                            o.viewport.set([0, 0, 32, 32]);
                            const l = i.getCenter(e, !0)
                              , c = e.useProgram("skyboxCapture")
                              , h = new Float64Array(16);
                            t.identity(h),
                            t.rotateY(h, h, .5 * -Math.PI),
                            Rn(o, i, c, h, l, 0),
                            t.identity(h),
                            t.rotateY(h, h, .5 * Math.PI),
                            Rn(o, i, c, h, l, 1),
                            t.identity(h),
                            t.rotateX(h, h, .5 * -Math.PI),
                            Rn(o, i, c, h, l, 2),
                            t.identity(h),
                            t.rotateX(h, h, .5 * Math.PI),
                            Rn(o, i, c, h, l, 3),
                            t.identity(h),
                            Rn(o, i, c, h, l, 4),
                            t.identity(h),
                            t.rotateY(h, h, Math.PI),
                            Rn(o, i, c, h, l, 5),
                            o.viewport.set([0, 0, e.width, e.height])
                        }(e, n),
                        n.markSkyboxValid(e)) : "sky" === e.renderPass && function(e, i, n, r, o) {
                            const s = e.context
                              , a = s.gl
                              , l = e.transform
                              , c = e.useProgram("skybox");
                            s.activeTexture.set(a.TEXTURE0),
                            a.bindTexture(a.TEXTURE_CUBE_MAP, i.skyboxTexture);
                            const h = ( (t, e, i, n, r) => ({
                                u_matrix: t,
                                u_sun_direction: e,
                                u_cubemap: 0,
                                u_opacity: n,
                                u_temporal_offset: r
                            }))(l.skyboxMatrix, i.getCenter(e, !1), 0, r, o);
                            e.prepareDrawProgram(s, c),
                            c.draw(s, a.TRIANGLES, n, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, h, "skybox", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
                        }(e, n, c, s, h) : "gradient" === l && "sky" === e.renderPass && function(e, i, n, r, o) {
                            const s = e.context
                              , a = s.gl
                              , l = e.transform
                              , c = e.useProgram("skyboxGradient");
                            i.skyboxGeometry || (i.skyboxGeometry = new On(s)),
                            s.activeTexture.set(a.TEXTURE0);
                            let h = i.colorRampTexture;
                            h || (h = i.colorRampTexture = new t.Texture(s,i.colorRamp,a.RGBA)),
                            h.bind(a.LINEAR, a.CLAMP_TO_EDGE);
                            const u = ( (e, i, n, r, o) => ({
                                u_matrix: e,
                                u_color_ramp: 0,
                                u_center_direction: i,
                                u_radius: t.degToRad(n),
                                u_opacity: r,
                                u_temporal_offset: o
                            }))(l.skyboxMatrix, i.getCenter(e, !1), i.paint.get("sky-gradient-radius"), r, o);
                            e.prepareDrawProgram(s, c),
                            c.draw(s, a.TRIANGLES, n, t.StencilMode.disabled, e.colorModeForRenderPass(), t.CullFaceMode.backCW, u, "skyboxGradient", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment)
                        }(e, n, c, s, h)
                    },
                    debug: function(t, e, i) {
                        for (let n = 0; n < i.length; n++)
                            Sn(t, e, i[n])
                    },
                    custom: function(e, i, n, r) {
                        const o = e.context
                          , s = n.implementation;
                        if (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes("custom") || e.terrain && (e.terrain.renderingToTexture || "offscreen" === e.renderPass) && n.isLayerDraped()) {
                            if ("offscreen" === e.renderPass) {
                                const i = s.prerender;
                                if (i) {
                                    if (e.setCustomLayerDefaults(),
                                    o.setColorMode(e.colorModeForRenderPass()),
                                    "globe" === e.transform.projection.name) {
                                        const n = e.transform.pointMerc;
                                        i.call(s, o.gl, e.transform.customLayerMatrix(), e.transform.getProjection(), e.transform.globeToMercatorMatrix(), t.globeToMercatorTransition(e.transform.zoom), [n.x, n.y], e.transform.pixelsPerMeterRatio)
                                    } else
                                        i.call(s, o.gl, e.transform.customLayerMatrix());
                                    o.setDirty(),
                                    e.setBaseState()
                                }
                            } else if ("translucent" === e.renderPass) {
                                if (e.terrain && e.terrain.renderingToTexture) {
                                    const i = s.renderToTile;
                                    if (i) {
                                        const n = r[0].canonical
                                          , a = new t.MercatorCoordinate(n.x + r[0].wrap * (1 << n.z),n.y,n.z);
                                        o.setDepthMode(t.DepthMode.disabled),
                                        o.setStencilMode(t.StencilMode.disabled),
                                        o.setColorMode(e.colorModeForRenderPass()),
                                        e.setCustomLayerDefaults(),
                                        i.call(s, o.gl, a),
                                        o.setDirty(),
                                        e.setBaseState()
                                    }
                                    return
                                }
                                e.setCustomLayerDefaults(),
                                o.setColorMode(e.colorModeForRenderPass()),
                                o.setStencilMode(t.StencilMode.disabled);
                                const i = "3d" === s.renderingMode ? new t.DepthMode(e.context.gl.LEQUAL,t.DepthMode.ReadWrite,e.depthRangeFor3D) : e.depthModeForSublayer(0, t.DepthMode.ReadOnly);
                                if (o.setDepthMode(i),
                                "globe" === e.transform.projection.name) {
                                    const i = e.transform.pointMerc;
                                    s.render(o.gl, e.transform.customLayerMatrix(), e.transform.getProjection(), e.transform.globeToMercatorMatrix(), t.globeToMercatorTransition(e.transform.zoom), [i.x, i.y], e.transform.pixelsPerMeterRatio)
                                } else
                                    s.render(o.gl, e.transform.customLayerMatrix());
                                o.setDirty(),
                                e.setBaseState(),
                                o.bindFramebuffer.set(null)
                            }
                        } else
                            t.warnOnce("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.")
                    }
                };
                class zn {
                    constructor(e, i, n=!1) {
                        this.context = new St(e,n),
                        this.transform = i,
                        this._tileTextures = {},
                        this.frameCopies = [],
                        this.loadTimeStamps = [],
                        this.setup(),
                        this.numSublayers = t.SourceCache.maxUnderzooming + t.SourceCache.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.deferredRenderGpuTimeQueries = [],
                        this.gpuTimers = {},
                        this.frameCounter = 0,
                        this._backgroundTiles = {}
                    }
                    updateTerrain(t, e) {
                        const i = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
                        if (!(i || this._terrain && this._terrain.enabled))
                            return;
                        this._terrain || (this._terrain = new ki(this,t));
                        const n = this._terrain;
                        this.transform.elevation = i ? n : null,
                        n.update(t, this.transform, e)
                    }
                    _updateFog(t) {
                        const e = t.fog;
                        if (!e || "globe" === this.transform.projection.name || e.getOpacity(this.transform.pitch) < 1 || e.properties.get("horizon-blend") < .03)
                            return void (this.transform.fogCullDistSq = null);
                        const [i,n] = e.getFovAdjustedRange(this.transform._fov);
                        if (i > n)
                            return void (this.transform.fogCullDistSq = null);
                        const r = i + .78 * (n - i);
                        this.transform.fogCullDistSq = r * r
                    }
                    get terrain() {
                        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null
                    }
                    resize(e, i) {
                        if (this.width = e * t.exported.devicePixelRatio,
                        this.height = i * t.exported.devicePixelRatio,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const t of this.style.order)
                                this.style._layers[t].resize()
                    }
                    setup() {
                        const e = this.context
                          , i = new t.StructArrayLayout2i4;
                        i.emplaceBack(0, 0),
                        i.emplaceBack(t.EXTENT, 0),
                        i.emplaceBack(0, t.EXTENT),
                        i.emplaceBack(t.EXTENT, t.EXTENT),
                        this.tileExtentBuffer = e.createVertexBuffer(i, t.posAttributes.members),
                        this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                        const n = new t.StructArrayLayout2i4;
                        n.emplaceBack(0, 0),
                        n.emplaceBack(t.EXTENT, 0),
                        n.emplaceBack(0, t.EXTENT),
                        n.emplaceBack(t.EXTENT, t.EXTENT),
                        this.debugBuffer = e.createVertexBuffer(n, t.posAttributes.members),
                        this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
                        const r = new t.StructArrayLayout2i4;
                        r.emplaceBack(-1, -1),
                        r.emplaceBack(1, -1),
                        r.emplaceBack(-1, 1),
                        r.emplaceBack(1, 1),
                        this.viewportBuffer = e.createVertexBuffer(r, t.posAttributes.members),
                        this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                        const o = new t.StructArrayLayout4i8;
                        o.emplaceBack(0, 0, 0, 0),
                        o.emplaceBack(t.EXTENT, 0, t.EXTENT, 0),
                        o.emplaceBack(0, t.EXTENT, 0, t.EXTENT),
                        o.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT),
                        this.mercatorBoundsBuffer = e.createVertexBuffer(o, t.boundsAttributes.members),
                        this.mercatorBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
                        const s = new t.StructArrayLayout3ui6;
                        s.emplaceBack(0, 1, 2),
                        s.emplaceBack(2, 1, 3),
                        this.quadTriangleIndexBuffer = e.createIndexBuffer(s);
                        const a = new t.StructArrayLayout1ui2;
                        for (const t of [0, 1, 3, 2, 0])
                            a.emplaceBack(t);
                        this.debugIndexBuffer = e.createIndexBuffer(a),
                        this.emptyTexture = new t.Texture(e,new t.RGBAImage({
                            width: 1,
                            height: 1
                        },Uint8Array.of(0, 0, 0, 0)),e.gl.RGBA),
                        this.identityMat = t.create();
                        const l = this.context.gl;
                        this.stencilClearMode = new t.StencilMode({
                            func: l.ALWAYS,
                            mask: 0
                        },0,255,l.ZERO,l.ZERO,l.ZERO),
                        this.loadTimeStamps.push(t.window.performance.now()),
                        this.atmosphereBuffer = new Ln(this.context)
                    }
                    getMercatorTileBoundsBuffers() {
                        return {
                            tileBoundsBuffer: this.mercatorBoundsBuffer,
                            tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,
                            tileBoundsSegments: this.mercatorBoundsSegments
                        }
                    }
                    getTileBoundsBuffers(t) {
                        return t._makeTileBoundsBuffers(this.context, this.transform.projection),
                        t._tileBoundsBuffer ? {
                            tileBoundsBuffer: t._tileBoundsBuffer,
                            tileBoundsIndexBuffer: t._tileBoundsIndexBuffer,
                            tileBoundsSegments: t._tileBoundsSegments
                        } : this.getMercatorTileBoundsBuffers()
                    }
                    clearStencil() {
                        const e = this.context
                          , i = e.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0,
                        this._tileClippingMaskIDs = {},
                        this.useProgram("clippingMask").draw(e, i.TRIANGLES, t.DepthMode.disabled, this.stencilClearMode, t.ColorMode.disabled, t.CullFaceMode.disabled, Ci(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    resetStencilClippingMasks() {
                        this.terrain || (this.currentStencilSource = void 0,
                        this._tileClippingMaskIDs = {})
                    }
                    _renderTileClippingMasks(e, i, n) {
                        if (!i || this.currentStencilSource === i.id || !e.isTileClipped() || !n || 0 === n.length)
                            return;
                        if (this._tileClippingMaskIDs && !this.terrain) {
                            let t = !1;
                            for (const e of n)
                                if (void 0 === this._tileClippingMaskIDs[e.key]) {
                                    t = !0;
                                    break
                                }
                            if (!t)
                                return
                        }
                        this.currentStencilSource = i.id;
                        const r = this.context
                          , o = r.gl;
                        this.nextStencilID + n.length > 256 && this.clearStencil(),
                        r.setColorMode(t.ColorMode.disabled),
                        r.setDepthMode(t.DepthMode.disabled);
                        const s = this.useProgram("clippingMask");
                        this._tileClippingMaskIDs = {};
                        for (const e of n) {
                            const n = i.getTile(e)
                              , a = this._tileClippingMaskIDs[e.key] = this.nextStencilID++
                              , {tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: h} = this.getTileBoundsBuffers(n);
                            s.draw(r, o.TRIANGLES, t.DepthMode.disabled, new t.StencilMode({
                                func: o.ALWAYS,
                                mask: 0
                            },a,255,o.KEEP,o.KEEP,o.REPLACE), t.ColorMode.disabled, t.CullFaceMode.disabled, Ci(e.projMatrix), "$clipping", l, c, h)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const e = this.nextStencilID++
                          , i = this.context.gl;
                        return new t.StencilMode({
                            func: i.NOTEQUAL,
                            mask: 255
                        },e,255,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    stencilModeForClipping(e) {
                        if (this.terrain)
                            return this.terrain.stencilModeForRTTOverlap(e);
                        const i = this.context.gl;
                        return new t.StencilMode({
                            func: i.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[e.key],0,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    stencilConfigForOverlap(e) {
                        const i = this.context.gl
                          , n = e.sort(( (t, e) => e.overscaledZ - t.overscaledZ))
                          , r = n[n.length - 1].overscaledZ
                          , o = n[0].overscaledZ - r + 1;
                        if (o > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + o > 256 && this.clearStencil();
                            const e = {};
                            for (let n = 0; n < o; n++)
                                e[n + r] = new t.StencilMode({
                                    func: i.GEQUAL,
                                    mask: 255
                                },n + this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);
                            return this.nextStencilID += o,
                            [e, n]
                        }
                        return [{
                            [r]: t.StencilMode.disabled
                        }, n]
                    }
                    colorModeForRenderPass() {
                        const e = this.context.gl;
                        if (this._showOverdrawInspector) {
                            const i = 1 / 8;
                            return new t.ColorMode([e.CONSTANT_COLOR, e.ONE],new t.Color(i,i,i,0),[!0, !0, !0, !0])
                        }
                        return "opaque" === this.renderPass ? t.ColorMode.unblended : t.ColorMode.alphaBlended
                    }
                    depthModeForSublayer(e, i, n) {
                        if (!this.opaquePassEnabledForLayer())
                            return t.DepthMode.disabled;
                        const r = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                        return new t.DepthMode(n || this.context.gl.LEQUAL,i,[r, r])
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    render(e, i) {
                        this.style = e,
                        this.options = i,
                        this.imageManager = e.imageManager,
                        this.glyphManager = e.glyphManager,
                        this.symbolFadeChange = e.placement.symbolFadeChange(t.exported.now()),
                        this.imageManager.beginFrame();
                        const n = this.style.order
                          , r = this.style._sourceCaches;
                        for (const t in r) {
                            const e = r[t];
                            e.used && e.prepare(this.context)
                        }
                        const o = {}
                          , s = {}
                          , a = {};
                        for (const t in r) {
                            const e = r[t];
                            o[t] = e.getVisibleCoordinates(),
                            s[t] = o[t].slice().reverse(),
                            a[t] = e.getVisibleCoordinates(!0).reverse()
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let t = 0; t < n.length; t++)
                            if (this.style._layers[n[t]].is3D()) {
                                this.opaquePassCutoff = t;
                                break
                            }
                        if (this.terrain && (this.terrain.updateTileBinding(a),
                        this.opaquePassCutoff = 0),
                        "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new t.GlobeSharedBuffers(this.context)),
                        !t.isMapAuthenticated(this.context.gl))
                            return;
                        this.renderPass = "offscreen";
                        for (const t of n) {
                            const i = this.style._layers[t]
                              , n = e._getLayerSourceCache(i);
                            if (!i.hasOffscreenPass() || i.isHidden(this.transform.zoom))
                                continue;
                            const r = n ? s[n.id] : void 0;
                            ("custom" === i.type || i.isSky() || r && r.length) && this.renderLayer(this, n, i, r)
                        }
                        this.depthRangeFor3D = [0, 1 - (e.order.length + 2) * this.numSublayers * this.depthEpsilon];
                        const l = this.terrain;
                        if (l && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && l.drawDepth(),
                        this.context.bindFramebuffer.set(null),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.clear({
                            color: i.showOverdrawInspector ? t.Color.black : t.Color.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this._showOverdrawInspector = i.showOverdrawInspector,
                        this.renderPass = "opaque",
                        !this.terrain)
                            for (this.currentLayer = n.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const t = this.style._layers[n[this.currentLayer]]
                                  , i = e._getLayerSourceCache(t);
                                if (t.isSky())
                                    continue;
                                const r = i ? s[i.id] : void 0;
                                this._renderTileClippingMasks(t, i, r),
                                this.renderLayer(this, i, t, r)
                            }
                        if (this.style.fog && this.transform.projection.supportsFog && function(e, i) {
                            const n = e.context
                              , r = n.gl
                              , o = e.transform
                              , s = new t.DepthMode(r.LEQUAL,t.DepthMode.ReadOnly,[0, 1])
                              , a = e.useProgram("globeAtmosphere", null, "globe" === o.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"])
                              , l = t.globeToMercatorTransition(o.zoom)
                              , c = i.properties.get("color").toArray01()
                              , h = i.properties.get("high-color").toArray01()
                              , u = i.properties.get("space-color").toArray01PremultipliedAlpha()
                              , d = t.identity$1([]);
                            t.rotateY$1(d, d, -t.degToRad(o._center.lng)),
                            t.rotateX$1(d, d, t.degToRad(o._center.lat)),
                            t.rotateZ$1(d, d, o.angle),
                            t.rotateX$1(d, d, -o._pitch);
                            const f = t.fromQuat(new Float32Array(16), d)
                              , p = t.mapValue(i.properties.get("star-intensity"), 0, 1, 0, .25)
                              , m = 5e-4
                              , g = t.mapValue(i.properties.get("horizon-blend"), 0, 1, m, .25)
                              , _ = t.globeUseCustomAntiAliasing(e, n, o) && g === m ? o.worldSize / (2 * Math.PI * 1.025) - 1 : o.globeRadius
                              , y = e.frameCounter / 1e3 % 1
                              , v = t.length(o.globeCenterInViewSpace)
                              , x = Math.sqrt(Math.pow(v, 2) - Math.pow(_, 2))
                              , b = Math.acos(x / v)
                              , w = ( (e, i, n, r, o, s, a, l, c, h, u, d, f, p) => ({
                                u_frustum_tl: e,
                                u_frustum_tr: i,
                                u_frustum_br: n,
                                u_frustum_bl: r,
                                u_horizon: o,
                                u_transition: s,
                                u_fadeout_range: a,
                                u_color: l,
                                u_high_color: c,
                                u_space_color: h,
                                u_star_intensity: u,
                                u_star_size: 5 * t.exported.devicePixelRatio,
                                u_star_density: 0,
                                u_temporal_offset: d,
                                u_horizon_angle: f,
                                u_rotation_matrix: p
                            }))(o.frustumCorners.TL, o.frustumCorners.TR, o.frustumCorners.BR, o.frustumCorners.BL, o.frustumCorners.horizon, l, g, c, h, u, p, y, b, f);
                            e.prepareDrawProgram(n, a);
                            const E = e.atmosphereBuffer;
                            E && a.draw(n, r.TRIANGLES, s, t.StencilMode.disabled, t.ColorMode.alphaBlended, t.CullFaceMode.backCW, w, "skybox", E.vertexBuffer, E.indexBuffer, E.segments)
                        }(this, this.style.fog),
                        this.renderPass = "sky",
                        (t.globeToMercatorTransition(this.transform.zoom) > 0 || "globe" !== this.transform.projection.name) && this.transform.isHorizonVisible())
                            for (this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) {
                                const t = this.style._layers[n[this.currentLayer]]
                                  , i = e._getLayerSourceCache(t);
                                t.isSky() && this.renderLayer(this, i, t, i ? s[i.id] : void 0)
                            }
                        for (this.renderPass = "translucent",
                        this.currentLayer = 0; this.currentLayer < n.length; ) {
                            const t = this.style._layers[n[this.currentLayer]]
                              , i = e._getLayerSourceCache(t);
                            if (t.isSky()) {
                                ++this.currentLayer;
                                continue
                            }
                            if (this.terrain && this.style.isLayerDraped(t)) {
                                if (t.isHidden(this.transform.zoom)) {
                                    ++this.currentLayer;
                                    continue
                                }
                                this.currentLayer = this.terrain.renderBatch(this.currentLayer);
                                continue
                            }
                            const r = i ? ("symbol" === t.type ? a : s)[i.id] : void 0;
                            this._renderTileClippingMasks(t, i, i ? o[i.id] : void 0),
                            this.renderLayer(this, i, t, r),
                            ++this.currentLayer
                        }
                        if (this.terrain && this.terrain.postRender(),
                        this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                            let i = null;
                            t.values(this.style._layers).forEach((t => {
                                const n = e._getLayerSourceCache(t);
                                n && !t.isHidden(this.transform.zoom) && (!i || i.getSource().maxzoom < n.getSource().maxzoom) && (i = n)
                            }
                            )),
                            i && this.options.showTileBoundaries && Bn.debug(this, i, i.getVisibleCoordinates())
                        }
                        this.options.showPadding && function(t) {
                            const e = t.transform.padding;
                            Cn(t, t.transform.height - (e.top || 0), 3, xn),
                            Cn(t, e.bottom || 0, 3, bn),
                            An(t, e.left || 0, 3, wn),
                            An(t, t.transform.width - (e.right || 0), 3, En);
                            const i = t.transform.centerPoint;
                            !function(t, e, i, n) {
                                In(t, e - 1, i - 10, 2, 20, n),
                                In(t, e - 10, i - 1, 20, 2, n)
                            }(t, i.x, t.transform.height - i.y, Tn)
                        }(this),
                        this.context.setDefault(),
                        this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER,
                        this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(t.window.performance.now()),
                        this.saveCanvasCopy())
                    }
                    renderLayer(t, e, i, n) {
                        i.isHidden(this.transform.zoom) || ("background" === i.type || "sky" === i.type || "custom" === i.type || n && n.length) && (this.id = i.id,
                        this.gpuTimingStart(i),
                        (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(i.type) || t.terrain && "custom" === i.type) && Bn[i.type](t, e, i, n, this.style.placement.variableOffsets, this.options.isInitialLoad),
                        this.gpuTimingEnd())
                    }
                    gpuTimingStart(t) {
                        if (!this.options.gpuTiming)
                            return;
                        const e = this.context.extTimerQuery;
                        let i = this.gpuTimers[t.id];
                        i || (i = this.gpuTimers[t.id] = {
                            calls: 0,
                            cpuTime: 0,
                            query: e.createQueryEXT()
                        }),
                        i.calls++,
                        e.beginQueryEXT(e.TIME_ELAPSED_EXT, i.query)
                    }
                    gpuTimingDeferredRenderStart() {
                        if (this.options.gpuTimingDeferredRender) {
                            const t = this.context.extTimerQuery
                              , e = t.createQueryEXT();
                            this.deferredRenderGpuTimeQueries.push(e),
                            t.beginQueryEXT(t.TIME_ELAPSED_EXT, e)
                        }
                    }
                    gpuTimingDeferredRenderEnd() {
                        if (!this.options.gpuTimingDeferredRender)
                            return;
                        const t = this.context.extTimerQuery;
                        t.endQueryEXT(t.TIME_ELAPSED_EXT)
                    }
                    gpuTimingEnd() {
                        if (!this.options.gpuTiming)
                            return;
                        const t = this.context.extTimerQuery;
                        t.endQueryEXT(t.TIME_ELAPSED_EXT)
                    }
                    collectGpuTimers() {
                        const t = this.gpuTimers;
                        return this.gpuTimers = {},
                        t
                    }
                    collectDeferredRenderGpuQueries() {
                        const t = this.deferredRenderGpuTimeQueries;
                        return this.deferredRenderGpuTimeQueries = [],
                        t
                    }
                    queryGpuTimers(t) {
                        const e = {};
                        for (const i in t) {
                            const n = t[i]
                              , r = this.context.extTimerQuery
                              , o = r.getQueryObjectEXT(n.query, r.QUERY_RESULT_EXT) / 1e6;
                            r.deleteQueryEXT(n.query),
                            e[i] = o
                        }
                        return e
                    }
                    queryGpuTimeDeferredRender(t) {
                        if (!this.options.gpuTimingDeferredRender)
                            return 0;
                        const e = this.context.extTimerQuery;
                        let i = 0;
                        for (const n of t)
                            i += e.getQueryObjectEXT(n, e.QUERY_RESULT_EXT) / 1e6,
                            e.deleteQueryEXT(n);
                        return i
                    }
                    translatePosMatrix(e, i, n, r, o) {
                        if (!n[0] && !n[1])
                            return e;
                        const s = o ? "map" === r ? this.transform.angle : 0 : "viewport" === r ? -this.transform.angle : 0;
                        if (s) {
                            const t = Math.sin(s)
                              , e = Math.cos(s);
                            n = [n[0] * e - n[1] * t, n[0] * t + n[1] * e]
                        }
                        const a = [o ? n[0] : k(i, n[0], this.transform.zoom), o ? n[1] : k(i, n[1], this.transform.zoom), 0]
                          , l = new Float32Array(16);
                        return t.translate(l, e, a),
                        l
                    }
                    saveTileTexture(t) {
                        const e = this._tileTextures[t.size[0]];
                        e ? e.push(t) : this._tileTextures[t.size[0]] = [t]
                    }
                    getTileTexture(t) {
                        const e = this._tileTextures[t];
                        return e && e.length > 0 ? e.pop() : null
                    }
                    isPatternMissing(t) {
                        return null === t || void 0 !== t && !this.imageManager.getPattern(t.toString())
                    }
                    terrainRenderModeElevated() {
                        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture
                    }
                    currentGlobalDefines() {
                        const t = this.terrain && this.terrain.renderingToTexture
                          , e = this.terrain && 0 === this.terrain.exaggeration()
                          , i = this.style && this.style.fog
                          , n = [];
                        return this.terrainRenderModeElevated() && n.push("TERRAIN"),
                        "globe" === this.transform.projection.name && n.push("GLOBE"),
                        e && n.push("ZERO_EXAGGERATION"),
                        i && !t && 0 !== i.getOpacity(this.transform.pitch) && n.push("FOG"),
                        t && n.push("RENDER_TO_TEXTURE"),
                        this._showOverdrawInspector && n.push("OVERDRAW_INSPECTOR"),
                        n
                    }
                    useProgram(t, e, i) {
                        this.cache = this.cache || {};
                        const n = i || []
                          , r = this.currentGlobalDefines().concat(n)
                          , o = Oi.cacheKey(hi[t], t, r, e);
                        return this.cache[o] || (this.cache[o] = new Oi(this.context,t,hi[t],e,ln[t],r)),
                        this.cache[o]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.frontFace.setDefault(),
                        this.context.cullFaceSide.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const t = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(t.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new t.Texture(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                    }
                    destroy() {
                        this._terrain && this._terrain.destroy(),
                        this.globeSharedBuffers && this.globeSharedBuffers.destroy(),
                        this.emptyTexture.destroy(),
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy(),
                        this.atmosphereBuffer && this.atmosphereBuffer.destroy()
                    }
                    prepareDrawTile() {
                        this.terrain && this.terrain.prepareDrawTile()
                    }
                    prepareDrawProgram(e, i, n) {
                        if (this.terrain && this.terrain.renderingToTexture)
                            return;
                        const r = this.style.fog;
                        if (r) {
                            const o = r.getOpacity(this.transform.pitch)
                              , s = ( (e, i, n, r, o, s, a, l, c, h, u) => {
                                const d = e.transform
                                  , f = i.properties.get("color").toArray01();
                                f[3] = r;
                                const p = e.frameCounter / 1e3 % 1;
                                return {
                                    u_fog_matrix: n ? d.calculateFogTileMatrix(n) : e.identityMat,
                                    u_fog_range: i.getFovAdjustedRange(d._fov),
                                    u_fog_color: f,
                                    u_fog_horizon_blend: i.properties.get("horizon-blend"),
                                    u_fog_temporal_offset: p,
                                    u_frustum_tl: o,
                                    u_frustum_tr: s,
                                    u_frustum_br: a,
                                    u_frustum_bl: l,
                                    u_globe_pos: c,
                                    u_globe_radius: h,
                                    u_viewport: u,
                                    u_globe_transition: t.globeToMercatorTransition(d.zoom),
                                    u_is_globe: +("globe" === d.projection.name)
                                }
                            }
                            )(this, r, n, o, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * t.exported.devicePixelRatio, this.transform.height * t.exported.devicePixelRatio]);
                            i.setFogUniformValues(e, s)
                        }
                    }
                    setTileLoadedFlag(t) {
                        this.tileLoaded = t
                    }
                    saveCanvasCopy() {
                        const t = this.canvasCopy();
                        t && (this.frameCopies.push(t),
                        this.tileLoaded = !1)
                    }
                    canvasCopy() {
                        const t = this.context.gl
                          , e = t.createTexture();
                        return t.bindTexture(t.TEXTURE_2D, e),
                        t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0),
                        e
                    }
                    getCanvasCopiesAndTimestamps() {
                        return {
                            canvasCopies: this.frameCopies,
                            timeStamps: this.loadTimeStamps
                        }
                    }
                    averageElevationNeedsEasing() {
                        if (!this.transform._elevation)
                            return !1;
                        const t = this.style && this.style.fog;
                        return !!t && 0 !== t.getOpacity(this.transform.pitch)
                    }
                    getBackgroundTiles() {
                        const e = this._backgroundTiles
                          , i = this._backgroundTiles = {}
                          , n = this.transform.coveringTiles({
                            tileSize: 512
                        });
                        for (const r of n)
                            i[r.key] = e[r.key] || new t.Tile(r,512,this.transform.tileZoom,this);
                        return i
                    }
                    clearBackgroundTiles() {
                        this._backgroundTiles = {}
                    }
                }
                class Fn {
                    constructor(t=0, e=0, i=0, n=0) {
                        if (isNaN(t) || t < 0 || isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(n) || n < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = t,
                        this.bottom = e,
                        this.left = i,
                        this.right = n
                    }
                    interpolate(e, i, n) {
                        return null != i.top && null != e.top && (this.top = t.number(e.top, i.top, n)),
                        null != i.bottom && null != e.bottom && (this.bottom = t.number(e.bottom, i.bottom, n)),
                        null != i.left && null != e.left && (this.left = t.number(e.left, i.left, n)),
                        null != i.right && null != e.right && (this.right = t.number(e.right, i.right, n)),
                        this
                    }
                    getCenter(e, i) {
                        const n = t.clamp((this.left + e - this.right) / 2, 0, e)
                          , r = t.clamp((this.top + i - this.bottom) / 2, 0, i);
                        return new t.Point(n,r)
                    }
                    equals(t) {
                        return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right
                    }
                    clone() {
                        return new Fn(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                function Nn(e, i) {
                    const n = t.getColumn(e, 3);
                    t.fromQuat(e, i),
                    t.setColumn(e, 3, n)
                }
                function jn(e, i) {
                    const n = t.identity$1([]);
                    return t.rotateZ$1(n, n, -i),
                    t.rotateX$1(n, n, -e),
                    n
                }
                function Un(e, i) {
                    const n = [e[0], e[1], 0]
                      , r = [i[0], i[1], 0];
                    if (t.length(n) >= 1e-15) {
                        const e = t.normalize([], n);
                        t.scale$2(r, e, t.dot(r, e)),
                        i[0] = r[0],
                        i[1] = r[1]
                    }
                    const o = t.cross([], i, e);
                    if (t.len(o) < 1e-15)
                        return null;
                    const s = Math.atan2(-o[1], o[0]);
                    return jn(Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]), s)
                }
                class Vn {
                    constructor(t, e) {
                        this.position = t,
                        this.orientation = e
                    }
                    get position() {
                        return this._position
                    }
                    set position(e) {
                        if (e) {
                            const i = e instanceof t.MercatorCoordinate ? e : new t.MercatorCoordinate(e[0],e[1],e[2]);
                            this._renderWorldCopies && (i.x = t.wrap(i.x, 0, 1)),
                            this._position = i
                        } else
                            this._position = null
                    }
                    lookAtPoint(e, i) {
                        if (this.orientation = null,
                        !this.position)
                            return;
                        const n = this.position
                          , r = this._elevation ? this._elevation.getAtPointOrZero(t.MercatorCoordinate.fromLngLat(e)) : 0
                          , o = t.MercatorCoordinate.fromLngLat(e, r)
                          , s = [o.x - n.x, o.y - n.y, o.z - n.z];
                        i || (i = [0, 0, 1]),
                        i[2] = Math.abs(i[2]),
                        this.orientation = Un(s, i)
                    }
                    setPitchBearing(e, i) {
                        this.orientation = jn(t.degToRad(e), t.degToRad(-i))
                    }
                }
                class Gn {
                    constructor(e, i) {
                        this._transform = t.identity([]),
                        this.orientation = i,
                        this.position = e
                    }
                    get mercatorPosition() {
                        const e = this.position;
                        return new t.MercatorCoordinate(e[0],e[1],e[2])
                    }
                    get position() {
                        const e = t.getColumn(this._transform, 3);
                        return [e[0], e[1], e[2]]
                    }
                    set position(e) {
                        var i;
                        e && t.setColumn(this._transform, 3, [(i = e)[0], i[1], i[2], 1])
                    }
                    get orientation() {
                        return this._orientation
                    }
                    set orientation(e) {
                        this._orientation = e || t.identity$1([]),
                        e && Nn(this._transform, this._orientation)
                    }
                    getPitchBearing() {
                        const t = this.forward()
                          , e = this.right();
                        return {
                            bearing: Math.atan2(-e[1], e[0]),
                            pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2])
                        }
                    }
                    setPitchBearing(t, e) {
                        this._orientation = jn(t, e),
                        Nn(this._transform, this._orientation)
                    }
                    forward() {
                        const e = t.getColumn(this._transform, 2);
                        return [-e[0], -e[1], -e[2]]
                    }
                    up() {
                        const e = t.getColumn(this._transform, 1);
                        return [-e[0], -e[1], -e[2]]
                    }
                    right() {
                        const e = t.getColumn(this._transform, 0);
                        return [e[0], e[1], e[2]]
                    }
                    getCameraToWorld(e, i) {
                        const n = new Float64Array(16);
                        return t.invert(n, this.getWorldToCamera(e, i)),
                        n
                    }
                    getWorldToCameraPosition(e, i, n) {
                        const r = this.position;
                        t.scale$2(r, r, -e);
                        const o = new Float64Array(16);
                        return t.fromScaling(o, [n, n, n]),
                        t.translate(o, o, r),
                        o[10] *= i,
                        o
                    }
                    getWorldToCamera(e, i) {
                        const n = new Float64Array(16)
                          , r = new Float64Array(4)
                          , o = this.position;
                        return t.conjugate(r, this._orientation),
                        t.scale$2(o, o, -e),
                        t.fromQuat(n, r),
                        t.translate(n, n, o),
                        n[1] *= -1,
                        n[5] *= -1,
                        n[9] *= -1,
                        n[13] *= -1,
                        n[8] *= i,
                        n[9] *= i,
                        n[10] *= i,
                        n[11] *= i,
                        n
                    }
                    getCameraToClipPerspective(e, i, n, r) {
                        const o = new Float64Array(16);
                        return t.perspective(o, e, i, n, r),
                        o
                    }
                    getDistanceToElevation(e, i=!1) {
                        const n = 0 === e ? 0 : t.mercatorZfromAltitude(e, i ? t.latFromMercatorY(this.position[1]) : this.position[1])
                          , r = this.forward();
                        return (n - this.position[2]) / r[2]
                    }
                    clone() {
                        return new Gn([...this.position],[...this.orientation])
                    }
                }
                function Zn(e, i) {
                    const n = Wn(e.projection, e.zoom, e.width, e.height)
                      , r = function(e, i, n, r, o) {
                        const s = new t.LngLat(n.lng - 180 * Hn,n.lat)
                          , a = new t.LngLat(n.lng + 180 * Hn,n.lat)
                          , l = e.project(s.lng, s.lat)
                          , c = e.project(a.lng, a.lat)
                          , h = -Math.atan2(c.y - l.y, c.x - l.x)
                          , u = t.MercatorCoordinate.fromLngLat(n);
                        u.y = t.clamp(u.y, -1 + Hn, 1 - Hn);
                        const d = u.toLngLat()
                          , f = e.project(d.lng, d.lat)
                          , p = t.MercatorCoordinate.fromLngLat(d);
                        p.x += Hn;
                        const m = p.toLngLat()
                          , g = e.project(m.lng, m.lat)
                          , _ = Xn(g.x - f.x, g.y - f.y, h)
                          , y = t.MercatorCoordinate.fromLngLat(d);
                        y.y += Hn;
                        const v = y.toLngLat()
                          , x = e.project(v.lng, v.lat)
                          , b = Xn(x.x - f.x, x.y - f.y, h)
                          , w = Math.abs(_.x) / Math.abs(b.y)
                          , E = t.identity([]);
                        t.rotateZ(E, E, -h * (1 - (o ? 0 : r)));
                        const T = t.identity([]);
                        return t.scale(T, T, [1, 1 - (1 - w) * r, 1]),
                        T[4] = -b.x / b.y * r,
                        t.rotateZ(T, T, h),
                        t.multiply(T, E, T),
                        T
                    }(e.projection, 0, e.center, n, i)
                      , o = qn(e);
                    return t.scale(r, r, [o, o, 1]),
                    r
                }
                function qn(e) {
                    const i = e.projection
                      , n = Wn(e.projection, e.zoom, e.width, e.height)
                      , r = $n(i, e.center)
                      , o = $n(i, t.LngLat.convert(i.center));
                    return Math.pow(2, r * n + (1 - n) * o)
                }
                function Wn(e, i, n, r, o=1 / 0) {
                    const s = e.range;
                    if (!s)
                        return 0;
                    const a = Math.min(o, Math.max(n, r))
                      , l = Math.log(a / 1024) / Math.LN2;
                    return t.smoothstep(s[0] + l, s[1] + l, i)
                }
                const Hn = 1 / 4e4;
                function $n(e, i) {
                    const n = t.clamp(i.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
                      , r = new t.LngLat(i.lng - 180 * Hn,n)
                      , o = new t.LngLat(i.lng + 180 * Hn,n)
                      , s = e.project(r.lng, n)
                      , a = e.project(o.lng, n)
                      , l = t.MercatorCoordinate.fromLngLat(r)
                      , c = t.MercatorCoordinate.fromLngLat(o)
                      , h = a.x - s.x
                      , u = a.y - s.y
                      , d = c.x - l.x
                      , f = c.y - l.y
                      , p = Math.sqrt((d * d + f * f) / (h * h + u * u));
                    return Math.log(p) / Math.LN2
                }
                function Xn(t, e, i) {
                    const n = Math.cos(i)
                      , r = Math.sin(i);
                    return {
                        x: t * n - e * r,
                        y: t * r + e * n
                    }
                }
                class Yn {
                    constructor(e, i, n, r, o, s, a) {
                        this.tileSize = 512,
                        this._renderWorldCopies = void 0 === o || o,
                        this._minZoom = e || 0,
                        this._maxZoom = i || 22,
                        this._minPitch = null == n ? 0 : n,
                        this._maxPitch = null == r ? 60 : r,
                        this.setProjection(s),
                        this.setMaxBounds(a),
                        this.width = 0,
                        this.height = 0,
                        this._center = new t.LngLat(0,0),
                        this.zoom = 0,
                        this.angle = 0,
                        this._fov = .6435011087932844,
                        this._pitch = 0,
                        this._nearZ = 0,
                        this._farZ = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new Fn,
                        this._projMatrixCache = {},
                        this._alignedProjMatrixCache = {},
                        this._fogTileMatrixCache = {},
                        this._distanceTileDataCache = {},
                        this._camera = new Gn,
                        this._centerAltitude = 0,
                        this._averageElevation = 0,
                        this.cameraElevationReference = "ground",
                        this._pixelsPerMercatorPixel = 1,
                        this.globeRadius = 0,
                        this.globeCenterInViewSpace = [0, 0, 0],
                        this._horizonShift = .1
                    }
                    clone() {
                        const t = new Yn(this._minZoom,this._maxZoom,this._minPitch,this.maxPitch,this._renderWorldCopies,this.getProjection());
                        return t._elevation = this._elevation,
                        t._centerAltitude = this._centerAltitude,
                        t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration,
                        t.tileSize = this.tileSize,
                        t.mercatorFromTransition = this.mercatorFromTransition,
                        t.width = this.width,
                        t.height = this.height,
                        t.cameraElevationReference = this.cameraElevationReference,
                        t._center = this._center,
                        t._setZoom(this.zoom),
                        t._seaLevelZoom = this._seaLevelZoom,
                        t.angle = this.angle,
                        t._fov = this._fov,
                        t._pitch = this._pitch,
                        t._nearZ = this._nearZ,
                        t._farZ = this._farZ,
                        t._averageElevation = this._averageElevation,
                        t._unmodified = this._unmodified,
                        t._edgeInsets = this._edgeInsets.clone(),
                        t._camera = this._camera.clone(),
                        t._calcMatrices(),
                        t.freezeTileCoverage = this.freezeTileCoverage,
                        t.frustumCorners = this.frustumCorners,
                        t
                    }
                    get elevation() {
                        return this._elevation
                    }
                    set elevation(t) {
                        this._elevation !== t && (this._elevation = t,
                        this._updateCameraOnTerrain(),
                        this._calcMatrices())
                    }
                    updateElevation(t, e=!1) {
                        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
                        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(),
                        (t || i) && this._constrainCamera(e),
                        this._calcMatrices()
                    }
                    getProjection() {
                        return t.pick(this.projection, ["name", "center", "parallels"])
                    }
                    setProjection(i) {
                        this.projectionOptions = i || {
                            name: "mercator"
                        };
                        const n = this.projection ? this.getProjection() : void 0;
                        this.projection = t.getProjection(this.projectionOptions);
                        const r = !e(n, this.getProjection());
                        return r && this._calcMatrices(),
                        this.mercatorFromTransition = !1,
                        r
                    }
                    setMercatorFromTransition() {
                        const e = this.projection.name;
                        this.mercatorFromTransition = !0,
                        this.projectionOptions = {
                            name: "mercator"
                        },
                        this.projection = t.getProjection({
                            name: "mercator"
                        });
                        const i = e !== this.projection.name;
                        return i && this._calcMatrices(),
                        i
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    set minZoom(t) {
                        this._minZoom !== t && (this._minZoom = t,
                        this.zoom = Math.max(this.zoom, t))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    set maxZoom(t) {
                        this._maxZoom !== t && (this._maxZoom = t,
                        this.zoom = Math.min(this.zoom, t))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    set minPitch(t) {
                        this._minPitch !== t && (this._minPitch = t,
                        this.pitch = Math.max(this.pitch, t))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    set maxPitch(t) {
                        this._maxPitch !== t && (this._maxPitch = t,
                        this.pitch = Math.min(this.pitch, t))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies
                    }
                    set renderWorldCopies(t) {
                        void 0 === t ? t = !0 : null === t && (t = !1),
                        this._renderWorldCopies = t
                    }
                    get worldSize() {
                        return this.tileSize * this.scale
                    }
                    get cameraWorldSizeForFog() {
                        const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
                        return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                    }
                    get cameraWorldSize() {
                        const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
                        return this._worldSizeFromZoom(this._zoomFromMercatorZ(t))
                    }
                    get pixelsPerMeter() {
                        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize)
                    }
                    get cameraPixelsPerMeter() {
                        return t.mercatorZfromAltitude(this.center.lat, this.cameraWorldSizeForFog)
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new t.Point(this.width,this.height)
                    }
                    get bearing() {
                        return t.wrap(this.rotation, -180, 180)
                    }
                    set bearing(t) {
                        this.rotation = t
                    }
                    get rotation() {
                        return -this.angle / Math.PI * 180
                    }
                    set rotation(e) {
                        const i = -e * Math.PI / 180;
                        var n;
                        this.angle !== i && (this._unmodified = !1,
                        this.angle = i,
                        this._calcMatrices(),
                        this.rotationMatrix = (n = new t.ARRAY_TYPE(4),
                        t.ARRAY_TYPE != Float32Array && (n[1] = 0,
                        n[2] = 0),
                        n[0] = 1,
                        n[3] = 1,
                        n),
                        function(t, e, i) {
                            var n = e[0]
                              , r = e[1]
                              , o = e[2]
                              , s = e[3]
                              , a = Math.sin(i)
                              , l = Math.cos(i);
                            t[0] = n * l + o * a,
                            t[1] = r * l + s * a,
                            t[2] = n * -a + o * l,
                            t[3] = r * -a + s * l
                        }(this.rotationMatrix, this.rotationMatrix, this.angle))
                    }
                    get pitch() {
                        return this._pitch / Math.PI * 180
                    }
                    set pitch(e) {
                        const i = t.clamp(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitch !== i && (this._unmodified = !1,
                        this._pitch = i,
                        this._calcMatrices())
                    }
                    get aspect() {
                        return this.width / this.height
                    }
                    get fov() {
                        return this._fov / Math.PI * 180
                    }
                    get fovX() {
                        return this._fov
                    }
                    get fovY() {
                        const t = 1 / Math.tan(.5 * this.fovX);
                        return 2 * Math.atan(1 / this.aspect / t)
                    }
                    set fov(e) {
                        e = Math.max(.01, Math.min(60, e)),
                        this._fov !== e && (this._unmodified = !1,
                        this._fov = t.degToRad(e),
                        this._calcMatrices())
                    }
                    get averageElevation() {
                        return this._averageElevation
                    }
                    set averageElevation(t) {
                        this._averageElevation = t,
                        this._calcFogMatrices(),
                        this._distanceTileDataCache = {}
                    }
                    get zoom() {
                        return this._zoom
                    }
                    set zoom(t) {
                        const e = Math.min(Math.max(t, this.minZoom), this.maxZoom);
                        this._zoom !== e && (this._unmodified = !1,
                        this._setZoom(e),
                        this._updateSeaLevelZoom(),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    _setZoom(t) {
                        this._zoom = t,
                        this.scale = this.zoomScale(t),
                        this.tileZoom = Math.floor(t),
                        this.zoomFraction = t - this.tileZoom
                    }
                    _updateCameraOnTerrain() {
                        if (!this._elevation || !this._elevation.isDataAvailableAtPoint(this.locationCoordinate(this.center)))
                            return this._centerAltitude = 0,
                            this._seaLevelZoom = null,
                            void (this._centerAltitudeValidForExaggeration = void 0);
                        const t = this._elevation;
                        this._centerAltitude = t.getAtPointOrZero(this.locationCoordinate(this.center)),
                        this._centerAltitudeValidForExaggeration = t.exaggeration(),
                        this._updateSeaLevelZoom()
                    }
                    _updateSeaLevelZoom() {
                        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize))
                    }
                    sampleAverageElevation() {
                        if (!this._elevation)
                            return 0;
                        const e = this._elevation
                          , i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]]
                          , n = this.horizonLineFromTop();
                        let r = 0
                          , o = 0;
                        for (let s = 0; s < i.length; s++) {
                            const a = new t.Point(i[s][0] * this.width,n + i[s][1] * (this.height - n))
                              , l = e.pointCoordinate(a);
                            if (!l)
                                continue;
                            const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
                            r += l[3] * c,
                            o += c
                        }
                        return 0 === o ? NaN : r / o
                    }
                    get center() {
                        return this._center
                    }
                    set center(t) {
                        t.lat === this._center.lat && t.lng === this._center.lng || (this._unmodified = !1,
                        this._center = t,
                        this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    _updateZoomFromElevation() {
                        if (null == this._seaLevelZoom || !this._elevation)
                            return;
                        const t = this._seaLevelZoom
                          , e = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center))
                          , i = this.pixelsPerMeter / this.worldSize * e
                          , n = this._mercatorZfromZoom(t)
                          , r = this._mercatorZfromZoom(this._maxZoom)
                          , o = Math.max(n - i, r);
                        this._setZoom(this._zoomFromMercatorZ(o))
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    set padding(t) {
                        this._edgeInsets.equals(t) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, t, 1),
                        this._calcMatrices())
                    }
                    computeZoomRelativeTo(e) {
                        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, e.toAltitude()));
                        let n;
                        n = e.z < this._camera.position[2] ? [i.x, i.y, i.z] : [e.x, e.y, e.z];
                        const r = t.length(t.sub([], this._camera.position, n));
                        return t.clamp(this._zoomFromMercatorZ(r), this._minZoom, this._maxZoom)
                    }
                    setFreeCameraOptions(e) {
                        if (!this.height)
                            return;
                        if (!e.position && !e.orientation)
                            return;
                        this._updateCameraState();
                        let i = !1;
                        if (e.orientation && !t.exactEquals(e.orientation, this._camera.orientation) && (i = this._setCameraOrientation(e.orientation)),
                        e.position) {
                            const n = [e.position.x, e.position.y, e.position.z];
                            t.exactEquals$1(n, this._camera.position) || (this._setCameraPosition(n),
                            i = !0)
                        }
                        i && (this._updateStateFromCamera(),
                        this.recenterOnTerrain())
                    }
                    getFreeCameraOptions() {
                        this._updateCameraState();
                        const e = this._camera.position
                          , i = new Vn;
                        return i.position = new t.MercatorCoordinate(e[0],e[1],e[2]),
                        i.orientation = this._camera.orientation,
                        i._elevation = this.elevation,
                        i._renderWorldCopies = this.renderWorldCopies,
                        i
                    }
                    _setCameraOrientation(e) {
                        if (!t.length$1(e))
                            return !1;
                        t.normalize$1(e, e);
                        const i = t.transformQuat([], [0, 0, -1], e)
                          , n = t.transformQuat([], [0, -1, 0], e);
                        if (n[2] < 0)
                            return !1;
                        const r = Un(i, n);
                        return !!r && (this._camera.orientation = r,
                        !0)
                    }
                    _setCameraPosition(e) {
                        const i = this.zoomScale(this.minZoom) * this.tileSize
                          , n = this.zoomScale(this.maxZoom) * this.tileSize
                          , r = this.cameraToCenterDistance;
                        e[2] = t.clamp(e[2], r / n, r / i),
                        this._camera.position = e
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this.width, this.height)
                    }
                    get fovAboveCenter() {
                        return this._fov * (.5 + this.centerOffset.y / this.height)
                    }
                    isPaddingEqual(t) {
                        return this._edgeInsets.equals(t)
                    }
                    interpolatePadding(t, e, i) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(t, e, i),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    coveringZoomLevel(t) {
                        const e = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
                        return Math.max(0, e)
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        const i = [new t.UnwrappedTileID(0,e)];
                        if (this.renderWorldCopies) {
                            const n = this.pointCoordinate(new t.Point(0,0))
                              , r = this.pointCoordinate(new t.Point(this.width,0))
                              , o = this.pointCoordinate(new t.Point(this.width,this.height))
                              , s = this.pointCoordinate(new t.Point(0,this.height))
                              , a = Math.floor(Math.min(n.x, r.x, o.x, s.x))
                              , l = Math.floor(Math.max(n.x, r.x, o.x, s.x))
                              , c = 1;
                            for (let n = a - c; n <= l + c; n++)
                                0 !== n && i.push(new t.UnwrappedTileID(n,e))
                        }
                        return i
                    }
                    coveringTiles(e) {
                        let i = this.coveringZoomLevel(e);
                        const n = i
                          , r = this.elevation && !e.isTerrainDEM
                          , o = "mercator" === this.projection.name;
                        if (void 0 !== e.minzoom && i < e.minzoom)
                            return [];
                        void 0 !== e.maxzoom && i > e.maxzoom && (i = e.maxzoom);
                        const s = this.locationCoordinate(this.center)
                          , a = this.center.lat
                          , l = 1 << i
                          , c = [l * s.x, l * s.y, 0]
                          , h = "globe" === this.projection.name
                          , u = !h
                          , d = t.Frustum.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u)
                          , f = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint())
                          , p = l * t.mercatorZfromAltitude(1, this.center.lat)
                          , m = this._camera.position[2] / t.mercatorZfromAltitude(1, this.center.lat)
                          , g = [l * f.x, l * f.y, m * (u ? 1 : p)]
                          , _ = this.cameraToCenterDistance / e.tileSize * (e.roundZoom ? 1 : .502)
                          , y = this.pitch <= 60 && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace ? i : 0
                          , v = e.isTerrainDEM && this._elevation ? 1e4 * this._elevation.exaggeration() : this._centerAltitude
                          , x = e.isTerrainDEM ? -v : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0
                          , b = this.projection.isReprojectedInTileSpace ? qn(this) : 1
                          , w = e => {
                            const i = 1 / 4e4
                              , n = new t.MercatorCoordinate(e.x + i,e.y,e.z)
                              , r = new t.MercatorCoordinate(e.x,e.y + i,e.z)
                              , o = e.toLngLat()
                              , s = n.toLngLat()
                              , a = r.toLngLat()
                              , l = this.locationCoordinate(o)
                              , c = this.locationCoordinate(s)
                              , h = this.locationCoordinate(a)
                              , u = Math.hypot(c.x - l.x, c.y - l.y)
                              , d = Math.hypot(h.x - l.x, h.y - l.y);
                            return Math.sqrt(u * d) * b / i
                        }
                          , E = e => {
                            const i = v
                              , n = x;
                            return {
                                aabb: t.tileAABB(this, l, 0, 0, 0, e, n, i, this.projection),
                                zoom: 0,
                                x: 0,
                                y: 0,
                                minZ: n,
                                maxZ: i,
                                wrap: e,
                                fullyVisible: !1
                            }
                        }
                          , T = [];
                        let S = [];
                        const C = i
                          , A = e.reparseOverscaled ? n : i
                          , I = t => t * t
                          , M = I((m - this._centerAltitude) * p)
                          , P = t => {
                            if (!this._elevation || !t.tileID || !o)
                                return;
                            const e = this._elevation.getMinMaxForTile(t.tileID)
                              , i = t.aabb;
                            e ? (i.min[2] = e.min,
                            i.max[2] = e.max,
                            i.center[2] = (i.min[2] + i.max[2]) / 2) : (t.shouldSplit = k(t),
                            t.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude))
                        }
                          , k = e => {
                            if (e.zoom < y)
                                return !0;
                            if (e.zoom === C)
                                return !1;
                            if (null != e.shouldSplit)
                                return e.shouldSplit;
                            const i = e.aabb.distanceX(g)
                              , o = e.aabb.distanceY(g);
                            let s = M
                              , l = 1;
                            if (h) {
                                s = I(e.aabb.distanceZ(g));
                                const i = Math.pow(2, e.zoom)
                                  , n = t.latFromMercatorY((e.y + 1) / i)
                                  , r = t.latFromMercatorY(e.y / i)
                                  , o = Math.min(Math.max(a, n), r)
                                  , c = t.circumferenceAtLatitude(o) / t.circumferenceAtLatitude(a);
                                if (l = o === a ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, c / this._mercatorScaleRatio),
                                this.zoom <= t.GLOBE_ZOOM_THRESHOLD_MIN && e.zoom === C - 1 && c >= .9)
                                    return !0
                            } else if (r && (s = I(e.aabb.distanceZ(g) * p)),
                            this.projection.isReprojectedInTileSpace && n <= 5) {
                                const i = Math.pow(2, e.zoom)
                                  , n = w(new t.MercatorCoordinate((e.x + .5) / i,(e.y + .5) / i));
                                l = n > .85 ? 1 : n
                            }
                            const c = i * i + o * o + s
                              , u = I((1 << C - e.zoom) * _ * l * ( (t, e) => {
                                if (e * I(.707) < t)
                                    return 1;
                                const i = Math.sqrt(e / t);
                                return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1)
                            }
                            )(Math.max(s, M), c));
                            return c < u
                        }
                        ;
                        if (this.renderWorldCopies)
                            for (let t = 1; t <= 3; t++)
                                T.push(E(-t)),
                                T.push(E(t));
                        for (T.push(E(0)); T.length > 0; ) {
                            const n = T.pop()
                              , s = n.x
                              , a = n.y;
                            let u = n.fullyVisible;
                            if (!u) {
                                const t = n.aabb.intersects(d);
                                if (0 === t)
                                    continue;
                                u = 2 === t
                            }
                            if (n.zoom !== C && k(n))
                                for (let e = 0; e < 4; e++) {
                                    const i = (s << 1) + e % 2
                                      , c = (a << 1) + (e >> 1)
                                      , d = {
                                        aabb: o ? n.aabb.quadrant(e) : t.tileAABB(this, l, n.zoom + 1, i, c, n.wrap, n.minZ, n.maxZ, this.projection),
                                        zoom: n.zoom + 1,
                                        x: i,
                                        y: c,
                                        wrap: n.wrap,
                                        fullyVisible: u,
                                        tileID: void 0,
                                        shouldSplit: void 0,
                                        minZ: n.minZ,
                                        maxZ: n.maxZ
                                    };
                                    r && !h && (d.tileID = new t.OverscaledTileID(n.zoom + 1 === C ? A : n.zoom + 1,n.wrap,n.zoom + 1,i,c),
                                    P(d)),
                                    T.push(d)
                                }
                            else {
                                const r = n.zoom === C ? A : n.zoom;
                                if (e.minzoom && e.minzoom > r)
                                    continue;
                                const o = c[0] - (.5 + s + (n.wrap << n.zoom)) * (1 << i - n.zoom)
                                  , l = c[1] - .5 - a
                                  , h = n.tileID ? n.tileID : new t.OverscaledTileID(r,n.wrap,n.zoom,s,a);
                                S.push({
                                    tileID: h,
                                    distanceSq: o * o + l * l
                                })
                            }
                        }
                        if (this.fogCullDistSq) {
                            const i = this.fogCullDistSq
                              , n = this.horizonLineFromTop();
                            S = S.filter((r => {
                                const o = [0, 0, 0, 1]
                                  , s = [t.EXTENT, t.EXTENT, 0, 1]
                                  , a = this.calculateFogTileMatrix(r.tileID.toUnwrapped());
                                t.transformMat4$1(o, o, a),
                                t.transformMat4$1(s, s, a);
                                const l = t.getAABBPointSquareDist(o, s);
                                if (0 === l)
                                    return !0;
                                let c = !1;
                                const h = this._elevation;
                                if (h && l > i && 0 !== n) {
                                    const i = this.calculateProjMatrix(r.tileID.toUnwrapped());
                                    let o;
                                    e.isTerrainDEM || (o = h.getMinMaxForTile(r.tileID)),
                                    o || (o = {
                                        min: x,
                                        max: v
                                    });
                                    const s = t.furthestTileCorner(this.rotation)
                                      , a = [s[0] * t.EXTENT, s[1] * t.EXTENT, o.max];
                                    t.transformMat4(a, a, i),
                                    c = (1 - a[1]) * this.height * .5 < n
                                }
                                return l < i || c
                            }
                            ))
                        }
                        return S.sort(( (t, e) => t.distanceSq - e.distanceSq)).map((t => t.tileID))
                    }
                    resize(t, e) {
                        this.width = t,
                        this.height = e,
                        this.pixelsToGLUnits = [2 / t, -2 / e],
                        this._constrain(),
                        this._calcMatrices()
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    zoomScale(t) {
                        return Math.pow(2, t)
                    }
                    scaleZoom(t) {
                        return Math.log(t) / Math.LN2
                    }
                    project(e) {
                        const i = t.clamp(e.lat, -t.MAX_MERCATOR_LATITUDE, t.MAX_MERCATOR_LATITUDE)
                          , n = this.projection.project(e.lng, i);
                        return new t.Point(n.x * this.worldSize,n.y * this.worldSize)
                    }
                    unproject(t) {
                        return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize)
                    }
                    get point() {
                        return this.project(this.center)
                    }
                    get pointMerc() {
                        return this.point._div(this.worldSize)
                    }
                    get pixelsPerMeterRatio() {
                        return this.pixelsPerMeter / t.mercatorZfromAltitude(1, this.center.lat) / this.worldSize
                    }
                    setLocationAtPoint(e, i) {
                        let n, r;
                        const o = this.centerPoint;
                        if ("globe" === this.projection.name) {
                            const t = this.worldSize;
                            n = (i.x - o.x) / t,
                            r = (i.y - o.y) / t
                        } else {
                            const t = this.pointCoordinate(i)
                              , e = this.pointCoordinate(o);
                            n = t.x - e.x,
                            r = t.y - e.y
                        }
                        const s = this.locationCoordinate(e);
                        this.setLocation(new t.MercatorCoordinate(s.x - n,s.y - r))
                    }
                    setLocation(t) {
                        this.center = this.coordinateLocation(t),
                        this.projection.wrap && (this.center = this.center.wrap())
                    }
                    locationPoint(t) {
                        return this.projection.locationPoint(this, t)
                    }
                    locationPoint3D(t) {
                        return this.projection.locationPoint(this, t, !0)
                    }
                    pointLocation(t) {
                        return this.coordinateLocation(this.pointCoordinate(t))
                    }
                    pointLocation3D(t) {
                        return this.coordinateLocation(this.pointCoordinate3D(t))
                    }
                    locationCoordinate(e, i) {
                        const n = i ? t.mercatorZfromAltitude(i, e.lat) : void 0
                          , r = this.projection.project(e.lng, e.lat);
                        return new t.MercatorCoordinate(r.x,r.y,n)
                    }
                    coordinateLocation(t) {
                        return this.projection.unproject(t.x, t.y)
                    }
                    pointRayIntersection(e, i) {
                        const n = null != i ? i : this._centerAltitude
                          , r = [e.x, e.y, 0, 1]
                          , o = [e.x, e.y, 1, 1];
                        t.transformMat4$1(r, r, this.pixelMatrixInverse),
                        t.transformMat4$1(o, o, this.pixelMatrixInverse);
                        const s = o[3];
                        t.scale$1(r, r, 1 / r[3]),
                        t.scale$1(o, o, 1 / s);
                        const a = r[2]
                          , l = o[2];
                        return {
                            p0: r,
                            p1: o,
                            t: a === l ? 0 : (n - a) / (l - a)
                        }
                    }
                    screenPointToMercatorRay(e) {
                        const i = [e.x, e.y, 0, 1]
                          , n = [e.x, e.y, 1, 1];
                        return t.transformMat4$1(i, i, this.pixelMatrixInverse),
                        t.transformMat4$1(n, n, this.pixelMatrixInverse),
                        t.scale$1(i, i, 1 / i[3]),
                        t.scale$1(n, n, 1 / n[3]),
                        i[2] = t.mercatorZfromAltitude(i[2], this._center.lat) * this.worldSize,
                        n[2] = t.mercatorZfromAltitude(n[2], this._center.lat) * this.worldSize,
                        t.scale$1(i, i, 1 / this.worldSize),
                        t.scale$1(n, n, 1 / this.worldSize),
                        new t.Ray([i[0], i[1], i[2]],t.normalize([], t.sub([], n, i)))
                    }
                    rayIntersectionCoordinate(e) {
                        const {p0: i, p1: n, t: r} = e
                          , o = t.mercatorZfromAltitude(i[2], this._center.lat)
                          , s = t.mercatorZfromAltitude(n[2], this._center.lat);
                        return new t.MercatorCoordinate(t.number(i[0], n[0], r) / this.worldSize,t.number(i[1], n[1], r) / this.worldSize,t.number(o, s, r))
                    }
                    pointCoordinate(t, e=this._centerAltitude) {
                        return this.projection.pointCoordinate(this, t.x, t.y, e)
                    }
                    pointCoordinate3D(e) {
                        if (!this.elevation)
                            return this.pointCoordinate(e);
                        let i = this.projection.pointCoordinate3D(this, e.x, e.y);
                        if (i)
                            return new t.MercatorCoordinate(i[0],i[1],i[2]);
                        let n = 0
                          , r = this.horizonLineFromTop();
                        if (e.y > r)
                            return this.pointCoordinate(e);
                        const o = .02 * r
                          , s = e.clone();
                        for (let e = 0; e < 10 && r - n > o; e++) {
                            s.y = t.number(n, r, .66);
                            const e = this.projection.pointCoordinate3D(this, s.x, s.y);
                            e ? (r = s.y,
                            i = e) : n = s.y
                        }
                        return i ? new t.MercatorCoordinate(i[0],i[1],i[2]) : this.pointCoordinate(e)
                    }
                    isPointAboveHorizon(t) {
                        return this.projection.isPointAboveHorizon(this, t)
                    }
                    isPointOnSurface(e) {
                        if (e.y < 0 || e.y > this.height || e.x < 0 || e.x > this.width)
                            return !1;
                        if (this.elevation || this.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX)
                            return !this.isPointAboveHorizon(e);
                        const i = this.pointCoordinate(e);
                        return i.y >= 0 && i.y <= 1
                    }
                    _coordinatePoint(e, i) {
                        const n = i && this.elevation ? this.elevation.getAtPointOrZero(e, this._centerAltitude) : this._centerAltitude
                          , r = [e.x * this.worldSize, e.y * this.worldSize, n + e.toAltitude(), 1];
                        return t.transformMat4$1(r, r, this.pixelMatrix),
                        r[3] > 0 ? new t.Point(r[0] / r[3],r[1] / r[3]) : new t.Point(Number.MAX_VALUE,Number.MAX_VALUE)
                    }
                    _getBoundsNonRectangular() {
                        const {top: e, left: i} = this._edgeInsets
                          , n = this.height - this._edgeInsets.bottom
                          , r = this.width - this._edgeInsets.right
                          , o = this.pointLocation3D(new t.Point(i,e))
                          , s = this.pointLocation3D(new t.Point(r,e))
                          , a = this.pointLocation3D(new t.Point(r,n))
                          , l = this.pointLocation3D(new t.Point(i,n));
                        let c = Math.min(o.lng, s.lng, a.lng, l.lng)
                          , h = Math.max(o.lng, s.lng, a.lng, l.lng)
                          , u = Math.min(o.lat, s.lat, a.lat, l.lat)
                          , d = Math.max(o.lat, s.lat, a.lat, l.lat);
                        const f = Math.pow(2, -this.zoom) / 16 * 270
                          , p = "globe" === this.projection.name ? 1 : 4
                          , m = (e, i, n, r, o) => {
                            const s = (e + n) / 2
                              , a = (i + r) / 2
                              , l = new t.Point(s,a)
                              , {lng: g, lat: _} = this.pointLocation3D(l)
                              , y = Math.max(0, c - g, u - _, g - h, _ - d);
                            c = Math.min(c, g),
                            h = Math.max(h, g),
                            u = Math.min(u, _),
                            d = Math.max(d, _),
                            (o < p || y > f) && (m(e, i, s, a, o + 1),
                            m(s, a, n, r, o + 1))
                        }
                        ;
                        if (m(i, e, r, e, 1),
                        m(r, e, r, n, 1),
                        m(r, n, i, n, 1),
                        m(i, n, i, e, 1),
                        "globe" === this.projection.name) {
                            const [e,i] = t.polesInViewport(this);
                            e ? (d = 90,
                            h = 180,
                            c = -180) : i && (u = -90,
                            h = 180,
                            c = -180)
                        }
                        return new t.LngLatBounds(new t.LngLat(c,u),new t.LngLat(h,d))
                    }
                    _getBoundsRectangular(e, i) {
                        const {top: n, left: r} = this._edgeInsets
                          , o = this.height - this._edgeInsets.bottom
                          , s = this.width - this._edgeInsets.right
                          , a = new t.Point(r,n)
                          , l = new t.Point(s,n)
                          , c = new t.Point(s,o)
                          , h = new t.Point(r,o);
                        let u = this.pointCoordinate(a, e)
                          , d = this.pointCoordinate(l, e);
                        const f = this.pointCoordinate(c, i)
                          , p = this.pointCoordinate(h, i)
                          , m = (t, e) => (e.y - t.y) / (e.x - t.x);
                        return u.y > 1 && d.y >= 0 ? u = new t.MercatorCoordinate((1 - p.y) / m(p, u) + p.x,1) : u.y < 0 && d.y <= 1 && (u = new t.MercatorCoordinate(-p.y / m(p, u) + p.x,0)),
                        d.y > 1 && u.y >= 0 ? d = new t.MercatorCoordinate((1 - f.y) / m(f, d) + f.x,1) : d.y < 0 && u.y <= 1 && (d = new t.MercatorCoordinate(-f.y / m(f, d) + f.x,0)),
                        (new t.LngLatBounds).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(f))
                    }
                    _getBoundsRectangularTerrain() {
                        const t = this.elevation;
                        if (!t.visibleDemTiles.length || t.isUsingMockSource())
                            return this._getBoundsRectangular(0, 0);
                        const e = t.visibleDemTiles.reduce(( (t, e) => {
                            if (e.dem) {
                                const i = e.dem.tree;
                                t.min = Math.min(t.min, i.minimums[0]),
                                t.max = Math.max(t.max, i.maximums[0])
                            }
                            return t
                        }
                        ), {
                            min: Number.MAX_VALUE,
                            max: 0
                        });
                        return this._getBoundsRectangular(e.min * t.exaggeration(), e.max * t.exaggeration())
                    }
                    getBounds() {
                        return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular()
                    }
                    horizonLineFromTop(t=!0) {
                        const e = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) + this.centerOffset.y
                          , i = this.height / 2 - e * (1 - this._horizonShift);
                        return t ? Math.max(0, i) : i
                    }
                    getMaxBounds() {
                        return this.maxBounds
                    }
                    setMaxBounds(e) {
                        this.maxBounds = e,
                        this.minLat = -t.MAX_MERCATOR_LATITUDE,
                        this.maxLat = t.MAX_MERCATOR_LATITUDE,
                        this.minLng = -180,
                        this.maxLng = 180,
                        e && (this.minLat = e.getSouth(),
                        this.maxLat = e.getNorth(),
                        this.minLng = e.getWest(),
                        this.maxLng = e.getEast(),
                        this.maxLng < this.minLng && (this.maxLng += 360)),
                        this.worldMinX = t.mercatorXfromLng(this.minLng) * this.tileSize,
                        this.worldMaxX = t.mercatorXfromLng(this.maxLng) * this.tileSize,
                        this.worldMinY = t.mercatorYfromLat(this.maxLat) * this.tileSize,
                        this.worldMaxY = t.mercatorYfromLat(this.minLat) * this.tileSize,
                        this._constrain()
                    }
                    calculatePosMatrix(t, e) {
                        return this.projection.createTileMatrix(this, e, t)
                    }
                    calculateDistanceTileData(e) {
                        const i = e.key
                          , n = this._distanceTileDataCache;
                        if (n[i])
                            return n[i];
                        const r = e.canonical
                          , o = 1 / this.height
                          , s = this.cameraWorldSize
                          , a = s / this.zoomScale(r.z)
                          , l = (r.x + Math.pow(2, r.z) * e.wrap) * a
                          , c = r.y * a
                          , h = this.point;
                        h.x *= s / this.worldSize,
                        h.y *= s / this.worldSize;
                        const u = this.angle
                          , d = Math.sin(-u)
                          , f = -Math.cos(-u);
                        return n[i] = {
                            bearing: [d, f],
                            center: [(h.x - l) * o, (h.y - c) * o],
                            scale: a / t.EXTENT * o
                        },
                        n[i]
                    }
                    calculateFogTileMatrix(e) {
                        const i = e.key
                          , n = this._fogTileMatrixCache;
                        if (n[i])
                            return n[i];
                        const r = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, e);
                        return t.multiply(r, this.worldToFogMatrix, r),
                        n[i] = new Float32Array(r),
                        n[i]
                    }
                    calculateProjMatrix(e, i=!1) {
                        const n = e.key
                          , r = i ? this._alignedProjMatrixCache : this._projMatrixCache;
                        if (r[n])
                            return r[n];
                        const o = this.calculatePosMatrix(e, this.worldSize);
                        return t.multiply(o, this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : i ? this.alignedProjMatrix : this.projMatrix, o),
                        r[n] = new Float32Array(o),
                        r[n]
                    }
                    calculatePixelsToTileUnitsMatrix(e) {
                        const i = e.tileID.key
                          , n = this._pixelsToTileUnitsCache;
                        if (n[i])
                            return n[i];
                        const r = function(e, i) {
                            const {scale: n} = e.tileTransform
                              , r = n * t.EXTENT / (e.tileSize * Math.pow(2, i.zoom - e.tileID.overscaledZ + e.tileID.canonical.z));
                            return o = new Float32Array(4),
                            l = (s = i.inverseAdjustmentMatrix)[1],
                            c = s[2],
                            h = s[3],
                            d = (a = [r, r])[1],
                            o[0] = s[0] * (u = a[0]),
                            o[1] = l * u,
                            o[2] = c * d,
                            o[3] = h * d,
                            o;
                            var o, s, a, l, c, h, u, d
                        }(e, this);
                        return n[i] = r,
                        n[i]
                    }
                    customLayerMatrix() {
                        return this.mercatorMatrix.slice()
                    }
                    globeToMercatorMatrix() {
                        if ("globe" === this.projection.name) {
                            const e = 1 / this.worldSize
                              , i = t.fromScaling([], [e, e, e]);
                            return t.multiply(i, i, this.globeMatrix),
                            i
                        }
                    }
                    recenterOnTerrain() {
                        if (!this._elevation || "globe" === this.projection.name)
                            return;
                        const e = this._elevation;
                        this._updateCameraState();
                        const i = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                          , n = this._computeCameraPosition(i)
                          , r = this._camera.forward()
                          , o = t.mercatorZfromAltitude(1, this._center.lat);
                        n[2] /= o,
                        r[2] /= o,
                        t.normalize(r, r);
                        const s = e.raycast(n, r, e.exaggeration());
                        if (s) {
                            const e = t.scaleAndAdd([], n, r, s)
                              , i = new t.MercatorCoordinate(e[0],e[1],t.mercatorZfromAltitude(e[2], t.latFromMercatorY(e[1])))
                              , a = (i.z + t.length([i.x - n[0], i.y - n[1], i.z - n[2] * o])) * this._pixelsPerMercatorPixel;
                            this._seaLevelZoom = this._zoomFromMercatorZ(a),
                            this._centerAltitude = i.toAltitude(),
                            this._center = this.coordinateLocation(i),
                            this._updateZoomFromElevation(),
                            this._constrain(),
                            this._calcMatrices()
                        }
                    }
                    _constrainCamera(e=!1) {
                        if (!this._elevation)
                            return;
                        const i = this._elevation
                          , n = t.mercatorZfromAltitude(1, this._center.lat) * this.worldSize
                          , r = this._computeCameraPosition(n)
                          , o = i.getAtPointOrZero(new t.MercatorCoordinate(...r))
                          , s = this.pixelsPerMeter / this.worldSize * o
                          , a = this._minimumHeightOverTerrain()
                          , l = r[2] - s;
                        if (l <= a)
                            if (l < 0 || e) {
                                const e = this.locationCoordinate(this._center, this._centerAltitude)
                                  , i = [r[0], r[1], e.z - r[2]]
                                  , n = t.length(i);
                                i[2] -= (a - l) / this._pixelsPerMercatorPixel;
                                const o = t.length(i);
                                if (0 === o)
                                    return;
                                t.scale$2(i, i, n / o * this._pixelsPerMercatorPixel),
                                this._camera.position = [r[0], r[1], e.z * this._pixelsPerMercatorPixel - i[2]],
                                this._updateStateFromCamera()
                            } else
                                this._isCameraConstrained = !0
                    }
                    _constrain() {
                        if (!this.center || !this.width || !this.height || this._constraining)
                            return;
                        this._constraining = !0;
                        const e = "globe" === this.projection.name || this.mercatorFromTransition;
                        if (this.projection.isReprojectedInTileSpace || e) {
                            const i = this.center;
                            return i.lat = t.clamp(i.lat, this.minLat, this.maxLat),
                            (this.maxBounds || !this.renderWorldCopies && !e) && (i.lng = t.clamp(i.lng, this.minLng, this.maxLng)),
                            this.center = i,
                            void (this._constraining = !1)
                        }
                        const i = this._unmodified
                          , {x: n, y: r} = this.point;
                        let o = 0
                          , s = n
                          , a = r;
                        const l = this.width / 2
                          , c = this.height / 2
                          , h = this.worldMinY * this.scale
                          , u = this.worldMaxY * this.scale;
                        if (r - c < h && (a = h + c),
                        r + c > u && (a = u - c),
                        u - h < this.height && (o = Math.max(o, this.height / (u - h)),
                        a = (u + h) / 2),
                        this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                            const t = this.worldMinX * this.scale
                              , e = this.worldMaxX * this.scale
                              , i = this.worldSize / 2 - (t + e) / 2;
                            s = (n + i + this.worldSize) % this.worldSize - i,
                            s - l < t && (s = t + l),
                            s + l > e && (s = e - l),
                            e - t < this.width && (o = Math.max(o, this.width / (e - t)),
                            s = (e + t) / 2)
                        }
                        s === n && a === r || (this.center = this.unproject(new t.Point(s,a))),
                        o && (this.zoom += this.scaleZoom(o)),
                        this._constrainCamera(),
                        this._unmodified = i,
                        this._constraining = !1
                    }
                    _minZoomForBounds() {
                        let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
                        return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))),
                        t
                    }
                    _maxCameraBoundsDistance() {
                        return this._mercatorZfromZoom(this._minZoomForBounds())
                    }
                    _calcMatrices() {
                        if (!this.height)
                            return;
                        const e = this.centerOffset
                          , i = this.pixelsPerMeter;
                        "globe" === this.projection.name && (this._mercatorScaleRatio = t.mercatorZfromAltitude(1, this.center.lat) / t.mercatorZfromAltitude(1, t.GLOBE_SCALE_MATCH_LATITUDE));
                        const n = Wn(this.projection, this.zoom, this.width, this.height, 1024);
                        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, n),
                        this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel,
                        this._updateCameraState(),
                        this._farZ = this.projection.farthestPixelDistance(this),
                        this._nearZ = this.height / 50;
                        const r = "meters" === this.projection.zAxisUnit ? i : 1
                          , o = this._camera.getWorldToCamera(this.worldSize, r)
                          , s = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
                        s[8] = 2 * -e.x / this.width,
                        s[9] = 2 * e.y / this.height;
                        let a = t.mul([], s, o);
                        if (this.projection.isReprojectedInTileSpace) {
                            const e = this.locationCoordinate(this.center)
                              , i = t.identity([]);
                            t.translate(i, i, [e.x * this.worldSize, e.y * this.worldSize, 0]),
                            t.multiply(i, i, Zn(this)),
                            t.translate(i, i, [-e.x * this.worldSize, -e.y * this.worldSize, 0]),
                            t.multiply(a, a, i),
                            this.inverseAdjustmentMatrix = function(t) {
                                const e = Zn(t, !0);
                                return v([], [e[0], e[1], e[4], e[5]])
                            }(this)
                        } else
                            this.inverseAdjustmentMatrix = [1, 0, 0, 1];
                        this.mercatorMatrix = t.scale([], a, [this.worldSize, this.worldSize, this.worldSize / r, 1]),
                        this.projMatrix = a,
                        this.invProjMatrix = t.invert(new Float64Array(16), this.projMatrix);
                        const l = t.invert([], s);
                        this.frustumCorners = t.FrustumCorners.fromInvProjectionMatrix(l, this.horizonLineFromTop(), this.height);
                        const c = new Float32Array(16);
                        t.identity(c),
                        t.scale(c, c, [1, -1, 1]),
                        t.rotateX(c, c, this._pitch),
                        t.rotateZ(c, c, this.angle);
                        const h = t.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ)
                          , u = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
                        h[8] = 2 * -e.x / this.width,
                        h[9] = 2 * (e.y + u) / this.height,
                        this.skyboxMatrix = t.multiply(c, h, c);
                        const d = this.point
                          , f = d.x
                          , p = d.y
                          , m = this.width % 2 / 2
                          , g = this.height % 2 / 2
                          , _ = Math.cos(this.angle)
                          , y = Math.sin(this.angle)
                          , x = f - Math.round(f) + _ * m + y * g
                          , b = p - Math.round(p) + _ * g + y * m
                          , w = new Float64Array(a);
                        if (t.translate(w, w, [x > .5 ? x - 1 : x, b > .5 ? b - 1 : b, 0]),
                        this.alignedProjMatrix = w,
                        a = t.create(),
                        t.scale(a, a, [this.width / 2, -this.height / 2, 1]),
                        t.translate(a, a, [1, -1, 0]),
                        this.labelPlaneMatrix = a,
                        a = t.create(),
                        t.scale(a, a, [1, -1, 1]),
                        t.translate(a, a, [-1, -1, 0]),
                        t.scale(a, a, [2 / this.width, 2 / this.height, 1]),
                        this.glCoordMatrix = a,
                        this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix),
                        this._calcFogMatrices(),
                        this._distanceTileDataCache = {},
                        a = t.invert(new Float64Array(16), this.pixelMatrix),
                        !a)
                            throw new Error("failed to invert matrix");
                        if (this.pixelMatrixInverse = a,
                        "globe" === this.projection.name || this.mercatorFromTransition) {
                            this.globeMatrix = t.calculateGlobeMatrix(this);
                            const e = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                            this.globeCenterInViewSpace = t.transformMat4(e, e, o),
                            this.globeRadius = this.worldSize / 2 / Math.PI - 1
                        } else
                            this.globeMatrix = a;
                        this._projMatrixCache = {},
                        this._alignedProjMatrixCache = {},
                        this._pixelsToTileUnitsCache = {}
                    }
                    _calcFogMatrices() {
                        this._fogTileMatrixCache = {};
                        const e = this.cameraWorldSizeForFog
                          , i = this.cameraPixelsPerMeter
                          , n = this._camera.position
                          , r = 1 / this.height / this._pixelsPerMercatorPixel
                          , o = [e, e, i];
                        t.scale$2(o, o, r),
                        t.scale$2(n, n, -1),
                        t.multiply$2(n, n, o);
                        const s = t.create();
                        t.translate(s, s, n),
                        t.scale(s, s, o),
                        this.mercatorFogMatrix = s,
                        this.worldToFogMatrix = this._camera.getWorldToCameraPosition(e, i, r)
                    }
                    _computeCameraPosition(t) {
                        const e = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter
                          , i = this._camera.forward()
                          , n = this.point
                          , r = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * e - t / this.worldSize * this._centerAltitude;
                        return [n.x / this.worldSize - i[0] * r, n.y / this.worldSize - i[1] * r, t / this.worldSize * this._centerAltitude - i[2] * r]
                    }
                    _updateCameraState() {
                        this.height && (this._camera.setPitchBearing(this._pitch, this.angle),
                        this._camera.position = this._computeCameraPosition())
                    }
                    _translateCameraConstrained(e) {
                        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch)
                          , n = this._camera.position[2]
                          , r = e[2];
                        let o = 1;
                        this.projection.wrap && (this.center = this.center.wrap()),
                        r > 0 && (o = Math.min((i - n) / r, 1)),
                        this._camera.position = t.scaleAndAdd([], this._camera.position, e, o),
                        this._updateStateFromCamera()
                    }
                    _updateStateFromCamera() {
                        const e = this._camera.position
                          , i = this._camera.forward()
                          , {pitch: n, bearing: r} = this._camera.getPitchBearing()
                          , o = t.mercatorZfromAltitude(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel
                          , s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(t.degToRad(this._maxPitch))
                          , a = Math.max((e[2] - o) / Math.cos(n), s)
                          , l = this._zoomFromMercatorZ(a);
                        t.scaleAndAdd(e, e, i, a),
                        this._pitch = t.clamp(n, t.degToRad(this.minPitch), t.degToRad(this.maxPitch)),
                        this.angle = t.wrap(r, -Math.PI, Math.PI),
                        this._setZoom(t.clamp(l, this._minZoom, this._maxZoom)),
                        this._updateSeaLevelZoom(),
                        this._center = this.coordinateLocation(new t.MercatorCoordinate(e[0],e[1],e[2])),
                        this._unmodified = !1,
                        this._constrain(),
                        this._calcMatrices()
                    }
                    _worldSizeFromZoom(t) {
                        return Math.pow(2, t) * this.tileSize
                    }
                    _mercatorZfromZoom(t) {
                        return this.cameraToCenterDistance / this._worldSizeFromZoom(t)
                    }
                    _minimumHeightOverTerrain() {
                        const t = Math.min((null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
                        return this._mercatorZfromZoom(t)
                    }
                    _zoomFromMercatorZ(t) {
                        return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize))
                    }
                    zoomFromMercatorZAdjusted(e) {
                        let i = 0
                          , n = t.GLOBE_ZOOM_THRESHOLD_MAX
                          , r = 0
                          , o = 1 / 0;
                        for (; n - i > 1e-6 && n > i; ) {
                            const t = i + .5 * (n - i)
                              , s = this.tileSize * Math.pow(2, t)
                              , a = this.getCameraToCenterDistance(this.projection, t, s)
                              , l = this.scaleZoom(a / (e * this.tileSize))
                              , c = Math.abs(t - l);
                            c < o && (o = c,
                            r = t),
                            t < l ? i = t : n = t
                        }
                        return r
                    }
                    _terrainEnabled() {
                        return !(!this._elevation || !this.projection.supportsTerrain && (t.warnOnce("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."),
                        1))
                    }
                    anyCornerOffEdge(e, i) {
                        const n = Math.min(e.x, i.x)
                          , r = Math.max(e.x, i.x)
                          , o = Math.min(e.y, i.y)
                          , s = Math.max(e.y, i.y);
                        if (o < this.horizonLineFromTop(!1))
                            return !0;
                        if ("mercator" !== this.projection.name)
                            return !1;
                        const a = [new t.Point(n,o), new t.Point(r,s), new t.Point(n,s), new t.Point(r,o)]
                          , l = this.renderWorldCopies ? -3 : 0
                          , c = this.renderWorldCopies ? 4 : 1;
                        for (const t of a) {
                            const e = this.pointRayIntersection(t);
                            if (e.t < 0)
                                return !0;
                            const i = this.rayIntersectionCoordinate(e);
                            if (i.x < l || i.y < 0 || i.x > c || i.y > 1)
                                return !0
                        }
                        return !1
                    }
                    isHorizonVisible() {
                        return this.pitch + t.radToDeg(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new t.Point(0,0), new t.Point(this.width,this.height))
                    }
                    zoomDeltaToMovement(e, i) {
                        const n = t.length(t.sub([], this._camera.position, e))
                          , r = this._zoomFromMercatorZ(n) + i;
                        return n - this._mercatorZfromZoom(r)
                    }
                    getCameraPoint() {
                        if ("globe" === this.projection.name) {
                            const e = function([e,i,n], r) {
                                const o = [e, i, n, 1];
                                t.transformMat4$1(o, o, r);
                                const s = o[3] = Math.max(o[3], 1e-6);
                                return o[0] /= s,
                                o[1] /= s,
                                o[2] /= s,
                                o
                            }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                            return new t.Point(e[0],e[1])
                        }
                        {
                            const e = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                            return this.centerPoint.add(new t.Point(0,e))
                        }
                    }
                    getCameraToCenterDistance(t, e=this.zoom, i=this.worldSize) {
                        const n = Wn(t, e, this.width, this.height, 1024)
                          , r = t.pixelSpaceConversion(this.center.lat, i, n);
                        return .5 / Math.tan(.5 * this._fov) * this.height * r
                    }
                    getWorldToCameraMatrix() {
                        const e = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
                        return "globe" === this.projection.name && t.multiply(e, e, this.globeMatrix),
                        e
                    }
                }
                function Kn(t, e) {
                    let i = !1
                      , n = null;
                    const r = () => {
                        n = null,
                        i && (t(),
                        n = setTimeout(r, e),
                        i = !1)
                    }
                    ;
                    return () => (i = !0,
                    n || r(),
                    n)
                }
                class Jn {
                    constructor(e) {
                        this._hashName = e && encodeURIComponent(e),
                        t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this),
                        this._updateHash = Kn(this._updateHashUnthrottled.bind(this), 300)
                    }
                    addTo(e) {
                        return this._map = e,
                        t.window.addEventListener("hashchange", this._onHashChange, !1),
                        e.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return this._map ? (this._map.off("moveend", this._updateHash),
                        t.window.removeEventListener("hashchange", this._onHashChange, !1),
                        clearTimeout(this._updateHash()),
                        this._map = void 0,
                        this) : this
                    }
                    getHashString() {
                        const e = this._map;
                        if (!e)
                            return "";
                        const i = Qn(e);
                        if (this._hashName) {
                            const e = this._hashName;
                            let n = !1;
                            const r = t.window.location.hash.slice(1).split("&").map((t => {
                                const r = t.split("=")[0];
                                return r === e ? (n = !0,
                                `${r}=${i}`) : t
                            }
                            )).filter((t => t));
                            return n || r.push(`${e}=${i}`),
                            `#${r.join("&")}`
                        }
                        return `#${i}`
                    }
                    _getCurrentHash() {
                        const e = t.window.location.hash.replace("#", "");
                        if (this._hashName) {
                            let t;
                            return e.split("&").map((t => t.split("="))).forEach((e => {
                                e[0] === this._hashName && (t = e)
                            }
                            )),
                            (t && t[1] || "").split("/")
                        }
                        return e.split("/")
                    }
                    _onHashChange() {
                        const t = this._map;
                        if (!t)
                            return !1;
                        const e = this._getCurrentHash();
                        if (e.length >= 3 && !e.some((t => isNaN(t)))) {
                            const i = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(e[3] || 0) : t.getBearing();
                            return t.jumpTo({
                                center: [+e[2], +e[1]],
                                zoom: +e[0],
                                bearing: i,
                                pitch: +(e[4] || 0)
                            }),
                            !0
                        }
                        return !1
                    }
                    _updateHashUnthrottled() {
                        const e = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
                        t.window.history.replaceState(t.window.history.state, null, e)
                    }
                }
                function Qn(t, e) {
                    const i = t.getCenter()
                      , n = Math.round(100 * t.getZoom()) / 100
                      , r = Math.ceil((n * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                      , o = Math.pow(10, r)
                      , s = Math.round(i.lng * o) / o
                      , a = Math.round(i.lat * o) / o
                      , l = t.getBearing()
                      , c = t.getPitch();
                    let h = e ? `/${s}/${a}/${n}` : `${n}/${a}/${s}`;
                    return (l || c) && (h += "/" + Math.round(10 * l) / 10),
                    c && (h += `/${Math.round(c)}`),
                    h
                }
                const tr = {
                    linearity: .3,
                    easing: t.bezier(0, 0, .3, 1)
                }
                  , er = t.extend({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, tr)
                  , ir = t.extend({
                    deceleration: 20,
                    maxSpeed: 1400
                }, tr)
                  , nr = t.extend({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, tr)
                  , rr = t.extend({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, tr);
                class or {
                    constructor(t) {
                        this._map = t,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(e) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: t.exported.now(),
                            settings: e
                        })
                    }
                    _drainInertiaBuffer() {
                        const e = this._inertiaBuffer
                          , i = t.exported.now();
                        for (; e.length > 0 && i - e[0].time > 160; )
                            e.shift()
                    }
                    _onMoveEnd(e) {
                        if (this._map._prefersReducedMotion())
                            return;
                        if (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2)
                            return;
                        const i = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            pan: new t.Point(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: t} of this._inertiaBuffer)
                            i.zoom += t.zoomDelta || 0,
                            i.bearing += t.bearingDelta || 0,
                            i.pitch += t.pitchDelta || 0,
                            t.panDelta && i.pan._add(t.panDelta),
                            t.around && (i.around = t.around),
                            t.pinchAround && (i.pinchAround = t.pinchAround);
                        const n = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , r = {};
                        if (i.pan.mag()) {
                            const o = ar(i.pan.mag(), n, t.extend({}, er, e || {}));
                            r.offset = i.pan.mult(o.amount / i.pan.mag()),
                            r.center = this._map.transform.center,
                            sr(r, o)
                        }
                        if (i.zoom) {
                            const t = ar(i.zoom, n, ir);
                            r.zoom = this._map.transform.zoom + t.amount,
                            sr(r, t)
                        }
                        if (i.bearing) {
                            const e = ar(i.bearing, n, nr);
                            r.bearing = this._map.transform.bearing + t.clamp(e.amount, -179, 179),
                            sr(r, e)
                        }
                        if (i.pitch) {
                            const t = ar(i.pitch, n, rr);
                            r.pitch = this._map.transform.pitch + t.amount,
                            sr(r, t)
                        }
                        if (r.zoom || r.bearing) {
                            const t = void 0 === i.pinchAround ? i.around : i.pinchAround;
                            r.around = t ? this._map.unproject(t) : this._map.getCenter()
                        }
                        return this.clear(),
                        r.noMoveStart = !0,
                        r
                    }
                }
                function sr(t, e) {
                    (!t.duration || t.duration < e.duration) && (t.duration = e.duration,
                    t.easing = e.easing)
                }
                function ar(e, i, n) {
                    const {maxSpeed: r, linearity: o, deceleration: s} = n
                      , a = t.clamp(e * o / (i / 1e3), -r, r)
                      , l = Math.abs(a) / (s * o);
                    return {
                        easing: n.easing,
                        duration: 1e3 * l,
                        amount: a * (l / 2)
                    }
                }
                class lr extends t.Event {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, i, n, r={}) {
                        const o = m(i.getCanvasContainer(), n)
                          , s = i.unproject(o);
                        super(e, t.extend({
                            point: o,
                            lngLat: s,
                            originalEvent: n
                        }, r)),
                        this._defaultPrevented = !1,
                        this.target = i
                    }
                }
                class cr extends t.Event {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, i, n) {
                        const r = "touchend" === e ? n.changedTouches : n.touches
                          , o = g(i.getCanvasContainer(), r)
                          , s = o.map((t => i.unproject(t)))
                          , a = o.reduce(( (t, e, i, n) => t.add(e.div(n.length))), new t.Point(0,0));
                        super(e, {
                            points: o,
                            point: a,
                            lngLats: s,
                            lngLat: i.unproject(a),
                            originalEvent: n
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class hr extends t.Event {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(t, e, i) {
                        super(t, {
                            originalEvent: i
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class ur {
                    constructor(t, e) {
                        this._map = t,
                        this._clickTolerance = e.clickTolerance
                    }
                    reset() {
                        this._mousedownPos = void 0
                    }
                    wheel(t) {
                        return this._firePreventable(new hr(t.type,this._map,t))
                    }
                    mousedown(t, e) {
                        return this._mousedownPos = e,
                        this._firePreventable(new lr(t.type,this._map,t))
                    }
                    mouseup(t) {
                        this._map.fire(new lr(t.type,this._map,t))
                    }
                    preclick(e) {
                        const i = t.extend({}, e);
                        i.type = "preclick",
                        this._map.fire(new lr(i.type,this._map,i))
                    }
                    click(t, e) {
                        this._mousedownPos && this._mousedownPos.dist(e) >= this._clickTolerance || (this.preclick(t),
                        this._map.fire(new lr(t.type,this._map,t)))
                    }
                    dblclick(t) {
                        return this._firePreventable(new lr(t.type,this._map,t))
                    }
                    mouseover(t) {
                        this._map.fire(new lr(t.type,this._map,t))
                    }
                    mouseout(t) {
                        this._map.fire(new lr(t.type,this._map,t))
                    }
                    touchstart(t) {
                        return this._firePreventable(new cr(t.type,this._map,t))
                    }
                    touchmove(t) {
                        this._map.fire(new cr(t.type,this._map,t))
                    }
                    touchend(t) {
                        this._map.fire(new cr(t.type,this._map,t))
                    }
                    touchcancel(t) {
                        this._map.fire(new cr(t.type,this._map,t))
                    }
                    _firePreventable(t) {
                        if (this._map.fire(t),
                        t.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class dr {
                    constructor(t) {
                        this._map = t
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent = void 0
                    }
                    mousemove(t) {
                        this._map.fire(new lr(t.type,this._map,t))
                    }
                    mousedown() {
                        this._delayContextMenu = !0
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new lr("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(t) {
                        this._delayContextMenu ? this._contextMenuEvent = t : this._map.fire(new lr(t.type,this._map,t)),
                        this._map.listens("contextmenu") && t.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class fr {
                    constructor(t, e) {
                        this._map = t,
                        this._el = t.getCanvasContainer(),
                        this._container = t.getContainer(),
                        this._clickTolerance = e.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(t, e) {
                        this.isEnabled() && t.shiftKey && 0 === t.button && (u(),
                        this._startPos = this._lastPos = e,
                        this._active = !0)
                    }
                    mousemoveWindow(t, e) {
                        if (!this._active)
                            return;
                        const i = e
                          , n = this._startPos
                          , r = this._lastPos;
                        if (!n || !r || r.equals(i) || !this._box && i.dist(n) < this._clickTolerance)
                            return;
                        this._lastPos = i,
                        this._box || (this._box = s("div", "mapboxgl-boxzoom", this._container),
                        this._container.classList.add("mapboxgl-crosshair"),
                        this._fireEvent("boxzoomstart", t));
                        const o = Math.min(n.x, i.x)
                          , a = Math.max(n.x, i.x)
                          , l = Math.min(n.y, i.y)
                          , c = Math.max(n.y, i.y);
                        this._map._requestDomTask(( () => {
                            this._box && (this._box.style.transform = `translate(${o}px,${l}px)`,
                            this._box.style.width = a - o + "px",
                            this._box.style.height = c - l + "px")
                        }
                        ))
                    }
                    mouseupWindow(e, i) {
                        if (!this._active)
                            return;
                        const n = this._startPos
                          , r = i;
                        if (n && 0 === e.button) {
                            if (this.reset(),
                            p(),
                            n.x !== r.x || n.y !== r.y)
                                return this._map.fire(new t.Event("boxzoomend",{
                                    originalEvent: e
                                })),
                                {
                                    cameraAnimation: t => t.fitScreenCoordinates(n, r, this._map.getBearing(), {
                                        linear: !1
                                    })
                                };
                            this._fireEvent("boxzoomcancel", e)
                        }
                    }
                    keydown(t) {
                        this._active && 27 === t.keyCode && (this.reset(),
                        this._fireEvent("boxzoomcancel", t))
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("mapboxgl-crosshair"),
                        this._box && (this._box.remove(),
                        this._box = null),
                        d(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(e, i) {
                        return this._map.fire(new t.Event(e,{
                            originalEvent: i
                        }))
                    }
                }
                function pr(t, e) {
                    const i = {};
                    for (let n = 0; n < t.length; n++)
                        i[t[n].identifier] = e[n];
                    return i
                }
                class mr {
                    constructor(t) {
                        this.reset(),
                        this.numTouches = t.numTouches
                    }
                    reset() {
                        this.centroid = void 0,
                        this.startTime = 0,
                        this.touches = {},
                        this.aborted = !1
                    }
                    touchstart(e, i, n) {
                        (this.centroid || n.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (0 === this.startTime && (this.startTime = e.timeStamp),
                        n.length === this.numTouches && (this.centroid = function(e) {
                            const i = new t.Point(0,0);
                            for (const t of e)
                                i._add(t);
                            return i.div(e.length)
                        }(i),
                        this.touches = pr(n, i)))
                    }
                    touchmove(t, e, i) {
                        if (this.aborted || !this.centroid)
                            return;
                        const n = pr(i, e);
                        for (const t in this.touches) {
                            const e = n[t];
                            (!e || e.dist(this.touches[t]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(t, e, i) {
                        if ((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        0 === i.length) {
                            const t = !this.aborted && this.centroid;
                            if (this.reset(),
                            t)
                                return t
                        }
                    }
                }
                class gr {
                    constructor(t) {
                        this.singleTap = new mr(t),
                        this.numTaps = t.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        this.lastTap = void 0,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(t, e, i) {
                        this.singleTap.touchstart(t, e, i)
                    }
                    touchmove(t, e, i) {
                        this.singleTap.touchmove(t, e, i)
                    }
                    touchend(t, e, i) {
                        const n = this.singleTap.touchend(t, e, i);
                        if (n) {
                            const e = t.timeStamp - this.lastTime < 500
                              , i = !this.lastTap || this.lastTap.dist(n) < 30;
                            if (e && i || this.reset(),
                            this.count++,
                            this.lastTime = t.timeStamp,
                            this.lastTap = n,
                            this.count === this.numTaps)
                                return this.reset(),
                                n
                        }
                    }
                }
                class _r {
                    constructor() {
                        this._zoomIn = new gr({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new gr({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(t, e, i) {
                        this._zoomIn.touchstart(t, e, i),
                        this._zoomOut.touchstart(t, e, i)
                    }
                    touchmove(t, e, i) {
                        this._zoomIn.touchmove(t, e, i),
                        this._zoomOut.touchmove(t, e, i)
                    }
                    touchend(t, e, i) {
                        const n = this._zoomIn.touchend(t, e, i)
                          , r = this._zoomOut.touchend(t, e, i);
                        return n ? (this._active = !0,
                        t.preventDefault(),
                        setTimeout(( () => this.reset()), 0),
                        {
                            cameraAnimation: e => e.easeTo({
                                duration: 300,
                                zoom: e.getZoom() + 1,
                                around: e.unproject(n)
                            }, {
                                originalEvent: t
                            })
                        }) : r ? (this._active = !0,
                        t.preventDefault(),
                        setTimeout(( () => this.reset()), 0),
                        {
                            cameraAnimation: e => e.easeTo({
                                duration: 300,
                                zoom: e.getZoom() - 1,
                                around: e.unproject(r)
                            }, {
                                originalEvent: t
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                const yr = {
                    0: 1,
                    2: 2
                };
                class vr {
                    constructor(t) {
                        this.reset(),
                        this._clickTolerance = t.clickTolerance || 1
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._moved = !1,
                        this._lastPoint = void 0,
                        this._eventButton = void 0
                    }
                    _correctButton(t, e) {
                        return !1
                    }
                    _move(t, e) {
                        return {}
                    }
                    mousedown(t, e) {
                        if (this._lastPoint)
                            return;
                        const i = _(t);
                        this._correctButton(t, i) && (this._lastPoint = e,
                        this._eventButton = i)
                    }
                    mousemoveWindow(t, e) {
                        const i = this._lastPoint;
                        if (i)
                            if (t.preventDefault(),
                            null != this._eventButton && function(t, e) {
                                const i = yr[e];
                                return void 0 === t.buttons || (t.buttons & i) !== i
                            }(t, this._eventButton))
                                this.reset();
                            else if (this._moved || !(e.dist(i) < this._clickTolerance))
                                return this._moved = !0,
                                this._lastPoint = e,
                                this._move(i, e)
                    }
                    mouseupWindow(t) {
                        this._lastPoint && _(t) === this._eventButton && (this._moved && p(),
                        this.reset())
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class xr extends vr {
                    mousedown(t, e) {
                        super.mousedown(t, e),
                        this._lastPoint && (this._active = !0)
                    }
                    _correctButton(t, e) {
                        return 0 === e && !t.ctrlKey
                    }
                    _move(t, e) {
                        return {
                            around: e,
                            panDelta: e.sub(t)
                        }
                    }
                }
                class br extends vr {
                    _correctButton(t, e) {
                        return 0 === e && t.ctrlKey || 2 === e
                    }
                    _move(t, e) {
                        const i = .8 * (e.x - t.x);
                        if (i)
                            return this._active = !0,
                            {
                                bearingDelta: i
                            }
                    }
                    contextmenu(t) {
                        t.preventDefault()
                    }
                }
                class wr extends vr {
                    _correctButton(t, e) {
                        return 0 === e && t.ctrlKey || 2 === e
                    }
                    _move(t, e) {
                        const i = -.5 * (e.y - t.y);
                        if (i)
                            return this._active = !0,
                            {
                                pitchDelta: i
                            }
                    }
                    contextmenu(t) {
                        t.preventDefault()
                    }
                }
                class Er {
                    constructor(e, i) {
                        this._map = e,
                        this._el = e.getCanvasContainer(),
                        this._minTouches = 1,
                        this._clickTolerance = i.clickTolerance || 1,
                        this.reset(),
                        t.bindAll(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this)
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new t.Point(0,0)
                    }
                    touchstart(t, e, i) {
                        return this._calculateTransform(t, e, i)
                    }
                    touchmove(e, i, n) {
                        if (this._active && !(n.length < this._minTouches)) {
                            if (this._map._cooperativeGestures && !this._map.isMoving()) {
                                if (1 === n.length && !t.isFullscreen())
                                    return void this._showTouchPanBlockerAlert();
                                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                                clearTimeout(this._alertTimer))
                            }
                            return e.cancelable && e.preventDefault(),
                            this._calculateTransform(e, i, n)
                        }
                    }
                    touchend(t, e, i) {
                        this._calculateTransform(t, e, i),
                        this._active && i.length < this._minTouches && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(e, i, n) {
                        n.length > 0 && (this._active = !0);
                        const r = pr(n, i)
                          , o = new t.Point(0,0)
                          , s = new t.Point(0,0);
                        let a = 0;
                        for (const t in r) {
                            const e = r[t]
                              , i = this._touches[t];
                            i && (o._add(e),
                            s._add(e.sub(i)),
                            a++,
                            r[t] = e)
                        }
                        if (this._touches = r,
                        a < this._minTouches || !s.mag())
                            return;
                        const l = s.div(a);
                        return this._sum._add(l),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: o.div(a),
                            panDelta: l
                        }
                    }
                    enable() {
                        this._enabled = !0,
                        this._map._cooperativeGestures && (this._addTouchPanBlocker(),
                        this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"))
                    }
                    disable() {
                        this._enabled = !1,
                        this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                        this._alertContainer.remove(),
                        this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")),
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    _addTouchPanBlocker() {
                        this._map && !this._alertContainer && (this._alertContainer = s("div", "mapboxgl-touch-pan-blocker", this._map._container),
                        this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"),
                        this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                    }
                    _showTouchPanBlockerAlert() {
                        this._alertContainer.style.visibility = "visible",
                        this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"),
                        this._alertContainer.setAttribute("role", "alert"),
                        clearTimeout(this._alertTimer),
                        this._alertTimer = setTimeout(( () => {
                            this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"),
                            this._alertContainer.setAttribute("role", "null")
                        }
                        ), 500)
                    }
                }
                class Tr {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._firstTwoTouches = void 0
                    }
                    _start(t) {}
                    _move(t, e, i) {
                        return {}
                    }
                    touchstart(t, e, i) {
                        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier],
                        this._start([e[0], e[1]]))
                    }
                    touchmove(t, e, i) {
                        const n = this._firstTwoTouches;
                        if (!n)
                            return;
                        t.preventDefault();
                        const [r,o] = n
                          , s = Sr(i, e, r)
                          , a = Sr(i, e, o);
                        if (!s || !a)
                            return;
                        const l = this._aroundCenter ? null : s.add(a).div(2);
                        return this._move([s, a], l, t)
                    }
                    touchend(t, e, i) {
                        if (!this._firstTwoTouches)
                            return;
                        const [n,r] = this._firstTwoTouches
                          , o = Sr(i, e, n)
                          , s = Sr(i, e, r);
                        o && s || (this._active && p(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(t) {
                        this._enabled = !0,
                        this._aroundCenter = !!t && "center" === t.around
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                function Sr(t, e, i) {
                    for (let n = 0; n < t.length; n++)
                        if (t[n].identifier === i)
                            return e[n]
                }
                function Cr(t, e) {
                    return Math.log(t / e) / Math.LN2
                }
                class Ar extends Tr {
                    reset() {
                        super.reset(),
                        this._distance = 0,
                        this._startDistance = 0
                    }
                    _start(t) {
                        this._startDistance = this._distance = t[0].dist(t[1])
                    }
                    _move(t, e) {
                        const i = this._distance;
                        if (this._distance = t[0].dist(t[1]),
                        this._active || !(Math.abs(Cr(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: Cr(this._distance, i),
                                pinchAround: e
                            }
                    }
                }
                function Ir(t, e) {
                    return 180 * t.angleWith(e) / Math.PI
                }
                class Mr extends Tr {
                    reset() {
                        super.reset(),
                        this._minDiameter = 0,
                        this._startVector = void 0,
                        this._vector = void 0
                    }
                    _start(t) {
                        this._startVector = this._vector = t[0].sub(t[1]),
                        this._minDiameter = t[0].dist(t[1])
                    }
                    _move(t, e) {
                        const i = this._vector;
                        if (this._vector = t[0].sub(t[1]),
                        i && (this._active || !this._isBelowThreshold(this._vector)))
                            return this._active = !0,
                            {
                                bearingDelta: Ir(this._vector, i),
                                pinchAround: e
                            }
                    }
                    _isBelowThreshold(t) {
                        this._minDiameter = Math.min(this._minDiameter, t.mag());
                        const e = 25 / (Math.PI * this._minDiameter) * 360
                          , i = this._startVector;
                        if (!i)
                            return !1;
                        const n = Ir(t, i);
                        return Math.abs(n) < e
                    }
                }
                function Pr(t) {
                    return Math.abs(t.y) > Math.abs(t.x)
                }
                class kr extends Tr {
                    constructor(t) {
                        super(),
                        this._map = t
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        this._firstMove = void 0,
                        this._lastPoints = void 0
                    }
                    _start(t) {
                        this._lastPoints = t,
                        Pr(t[0].sub(t[1])) && (this._valid = !1)
                    }
                    _move(e, i, n) {
                        const r = this._lastPoints;
                        if (!r)
                            return;
                        const o = e[0].sub(r[0])
                          , s = e[1].sub(r[1]);
                        return this._map._cooperativeGestures && !t.isFullscreen() && n.touches.length < 3 || (this._valid = this.gestureBeginsVertically(o, s, n.timeStamp),
                        !this._valid) ? void 0 : (this._lastPoints = e,
                        this._active = !0,
                        {
                            pitchDelta: (o.y + s.y) / 2 * -.5
                        })
                    }
                    gestureBeginsVertically(t, e, i) {
                        if (void 0 !== this._valid)
                            return this._valid;
                        const n = t.mag() >= 2
                          , r = e.mag() >= 2;
                        if (!n && !r)
                            return;
                        if (!n || !r)
                            return null == this._firstMove && (this._firstMove = i),
                            i - this._firstMove < 100 && void 0;
                        const o = t.y > 0 == e.y > 0;
                        return Pr(t) && Pr(e) && o
                    }
                }
                const Or = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class Rr {
                    constructor() {
                        const t = Or;
                        this._panStep = t.panStep,
                        this._bearingStep = t.bearingStep,
                        this._pitchStep = t.pitchStep,
                        this._rotationDisabled = !1
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(t) {
                        if (t.altKey || t.ctrlKey || t.metaKey)
                            return;
                        let e = 0
                          , i = 0
                          , n = 0
                          , r = 0
                          , o = 0;
                        switch (t.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            e = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            e = -1;
                            break;
                        case 37:
                            t.shiftKey ? i = -1 : (t.preventDefault(),
                            r = -1);
                            break;
                        case 39:
                            t.shiftKey ? i = 1 : (t.preventDefault(),
                            r = 1);
                            break;
                        case 38:
                            t.shiftKey ? n = 1 : (t.preventDefault(),
                            o = -1);
                            break;
                        case 40:
                            t.shiftKey ? n = -1 : (t.preventDefault(),
                            o = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (i = 0,
                        n = 0),
                        {
                            cameraAnimation: s => {
                                const a = s.getZoom();
                                s.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: Dr,
                                    zoom: e ? Math.round(a) + e * (t.shiftKey ? 2 : 1) : a,
                                    bearing: s.getBearing() + i * this._bearingStep,
                                    pitch: s.getPitch() + n * this._pitchStep,
                                    offset: [-r * this._panStep, -o * this._panStep],
                                    center: s.getCenter()
                                }, {
                                    originalEvent: t
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function Dr(t) {
                    return t * (2 - t)
                }
                const Lr = 4.000244140625;
                class Br {
                    constructor(e, i) {
                        this._map = e,
                        this._el = e.getCanvasContainer(),
                        this._handler = i,
                        this._delta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = .0022222222222222222,
                        t.bindAll(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this)
                    }
                    setZoomRate(t) {
                        this._defaultZoomRate = t
                    }
                    setWheelZoomRate(t) {
                        this._wheelZoomRate = t
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return this._active || void 0 !== this._finishTimeout
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(t) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!t && "center" === t.around,
                        this._map._cooperativeGestures && this._addScrollZoomBlocker())
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1,
                        this._map._cooperativeGestures && (clearTimeout(this._alertTimer),
                        this._alertContainer.remove()))
                    }
                    wheel(e) {
                        if (!this.isEnabled())
                            return;
                        if (this._map._cooperativeGestures) {
                            if (!(e.ctrlKey || e.metaKey || this.isZooming() || t.isFullscreen()))
                                return void this._showBlockerAlert();
                            "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden",
                            clearTimeout(this._alertTimer))
                        }
                        let i = e.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                        const n = t.exported.now()
                          , r = n - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = n,
                        0 !== i && i % Lr == 0 ? this._type = "wheel" : 0 !== i && Math.abs(i) < 4 ? this._type = "trackpad" : r > 400 ? (this._type = null,
                        this._lastValue = i,
                        this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(r * i) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        i += this._lastValue)),
                        e.shiftKey && i && (i /= 4),
                        this._type && (this._lastWheelEvent = e,
                        this._delta -= i,
                        this._active || this._start(e)),
                        e.preventDefault()
                    }
                    _onTimeout(t) {
                        this._type = "wheel",
                        this._delta -= this._lastValue,
                        this._active || this._start(t)
                    }
                    _start(t) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const e = m(this._el, t);
                        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : e,
                        this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint),
                        this._targetZoom = void 0,
                        this._frameId || (this._frameId = !0,
                        this._handler._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId)
                            return;
                        if (this._frameId = null,
                        !this.isActive())
                            return;
                        const e = this._map.transform;
                        "wheel" === this._type && e.projection.wrap && (e._center.lng >= 180 || e._center.lng <= -180) && (this._prevEase = null,
                        this._easing = null,
                        this._lastWheelEvent = null,
                        this._lastWheelEventTime = 0);
                        const i = () => e._terrainEnabled() && this._aroundCoord ? e.computeZoomRelativeTo(this._aroundCoord) : e.zoom;
                        if (0 !== this._delta) {
                            const t = "wheel" === this._type && Math.abs(this._delta) > Lr ? this._wheelZoomRate : this._defaultZoomRate;
                            let n = 2 / (1 + Math.exp(-Math.abs(this._delta * t)));
                            this._delta < 0 && 0 !== n && (n = 1 / n);
                            const r = i()
                              , o = Math.pow(2, r)
                              , s = "number" == typeof this._targetZoom ? e.zoomScale(this._targetZoom) : o;
                            this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, e.scaleZoom(s * n))),
                            "wheel" === this._type && (this._startZoom = r,
                            this._easing = this._smoothOutEasing(200)),
                            this._delta = 0
                        }
                        const n = "number" == typeof this._targetZoom ? this._targetZoom : i()
                          , r = this._startZoom
                          , o = this._easing;
                        let s, a = !1;
                        if ("wheel" === this._type && r && o) {
                            const e = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1)
                              , i = o(e);
                            s = t.number(r, n, i),
                            e < 1 ? this._frameId || (this._frameId = !0) : a = !0
                        } else
                            s = n,
                            a = !0;
                        return this._active = !0,
                        a && (this._active = !1,
                        this._finishTimeout = setTimeout(( () => {
                            this._zooming = !1,
                            this._handler._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._finishTimeout
                        }
                        ), 200)),
                        {
                            noInertia: !0,
                            needsRenderFrame: !a,
                            zoomDelta: s - i(),
                            around: this._aroundPoint,
                            aroundCoord: this._aroundCoord,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(e) {
                        let i = t.ease;
                        if (this._prevEase) {
                            const e = this._prevEase
                              , n = (t.exported.now() - e.start) / e.duration
                              , r = e.easing(n + .01) - e.easing(n)
                              , o = .27 / Math.sqrt(r * r + 1e-4) * .01
                              , s = Math.sqrt(.0729 - o * o);
                            i = t.bezier(o, s, .25, 1)
                        }
                        return this._prevEase = {
                            start: t.exported.now(),
                            duration: e,
                            easing: i
                        },
                        i
                    }
                    blur() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    _addScrollZoomBlocker() {
                        this._map && !this._alertContainer && (this._alertContainer = s("div", "mapboxgl-scroll-zoom-blocker", this._map._container),
                        this._alertContainer.textContent = /(Mac|iPad)/i.test(t.window.navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"),
                        this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`)
                    }
                    _showBlockerAlert() {
                        this._alertContainer.style.visibility = "visible",
                        this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"),
                        this._alertContainer.setAttribute("role", "alert"),
                        clearTimeout(this._alertTimer),
                        this._alertTimer = setTimeout(( () => {
                            this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"),
                            this._alertContainer.setAttribute("role", "null")
                        }
                        ), 200)
                    }
                }
                class zr {
                    constructor(t, e) {
                        this._clickZoom = t,
                        this._tapZoom = e
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class Fr {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    blur() {
                        this.reset()
                    }
                    dblclick(t, e) {
                        return t.preventDefault(),
                        {
                            cameraAnimation: i => {
                                i.easeTo({
                                    duration: 300,
                                    zoom: i.getZoom() + (t.shiftKey ? -1 : 1),
                                    around: i.unproject(e)
                                }, {
                                    originalEvent: t
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Nr {
                    constructor() {
                        this._tap = new gr({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._swipePoint = void 0,
                        this._swipeTouch = 0,
                        this._tapTime = 0,
                        this._tap.reset()
                    }
                    touchstart(t, e, i) {
                        this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(),
                        this._tapTime ? i.length > 0 && (this._swipePoint = e[0],
                        this._swipeTouch = i[0].identifier) : this._tap.touchstart(t, e, i))
                    }
                    touchmove(t, e, i) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (i[0].identifier !== this._swipeTouch)
                                    return;
                                const n = e[0]
                                  , r = n.y - this._swipePoint.y;
                                return this._swipePoint = n,
                                t.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: r / 128
                                }
                            }
                        } else
                            this._tap.touchmove(t, e, i)
                    }
                    touchend(t, e, i) {
                        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(t, e, i) && (this._tapTime = t.timeStamp)
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class jr {
                    constructor(t, e, i) {
                        this._el = t,
                        this._mousePan = e,
                        this._touchPan = i
                    }
                    enable(t) {
                        this._inertiaOptions = t || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("mapboxgl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("mapboxgl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class Ur {
                    constructor(t, e, i) {
                        this._pitchWithRotate = t.pitchWithRotate,
                        this._mouseRotate = e,
                        this._mousePitch = i
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive()
                    }
                }
                class Vr {
                    constructor(t, e, i, n) {
                        this._el = t,
                        this._touchZoom = e,
                        this._touchRotate = i,
                        this._tapDragZoom = n,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(t) {
                        this._touchZoom.enable(t),
                        this._rotationDisabled || this._touchRotate.enable(t),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("mapboxgl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("mapboxgl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                const Gr = t => t.zoom || t.drag || t.pitch || t.rotate;
                class Zr extends t.Event {
                }
                class qr {
                    constructor() {
                        this.constants = [1, 1, .01],
                        this.radius = 0
                    }
                    setup(e, i) {
                        const n = t.sub([], i, e);
                        this.radius = t.length(n[2] < 0 ? t.div([], n, this.constants) : [n[0], n[1], 0])
                    }
                    projectRay(e) {
                        t.div(e, e, this.constants),
                        t.normalize(e, e),
                        t.mul$1(e, e, this.constants);
                        const i = t.scale$2([], e, this.radius);
                        if (i[2] > 0) {
                            const e = t.scale$2([], [0, 0, 1], t.dot(i, [0, 0, 1]))
                              , n = t.scale$2([], t.normalize([], [i[0], i[1], 0]), this.radius)
                              , r = t.add([], i, t.scale$2([], t.sub([], t.add([], n, e), i), 2));
                            i[0] = r[0],
                            i[1] = r[1]
                        }
                        return i
                    }
                }
                function Wr(t) {
                    return t.panDelta && t.panDelta.mag() || t.zoomDelta || t.bearingDelta || t.pitchDelta
                }
                class Hr {
                    constructor(e, i) {
                        this._map = e,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new or(e),
                        this._bearingSnap = i.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._trackingEllipsoid = new qr,
                        this._dragOrigin = null,
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(i),
                        t.bindAll(["handleEvent", "handleWindowEvent"], this);
                        const n = this._el;
                        this._listeners = [[n, "touchstart", {
                            passive: !0
                        }], [n, "touchmove", {
                            passive: !1
                        }], [n, "touchend", void 0], [n, "touchcancel", void 0], [n, "mousedown", void 0], [n, "mousemove", void 0], [n, "mouseup", void 0], [t.window.document, "mousemove", {
                            capture: !0
                        }], [t.window.document, "mouseup", void 0], [n, "mouseover", void 0], [n, "mouseout", void 0], [n, "dblclick", void 0], [n, "click", void 0], [n, "keydown", {
                            capture: !1
                        }], [n, "keyup", void 0], [n, "wheel", {
                            passive: !1
                        }], [n, "contextmenu", void 0], [t.window, "blur", void 0]];
                        for (const [e,i,n] of this._listeners)
                            e.addEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, n)
                    }
                    destroy() {
                        for (const [e,i,n] of this._listeners)
                            e.removeEventListener(i, e === t.window.document ? this.handleWindowEvent : this.handleEvent, n)
                    }
                    _addDefaultHandlers(t) {
                        const e = this._map
                          , i = e.getCanvasContainer();
                        this._add("mapEvent", new ur(e,t));
                        const n = e.boxZoom = new fr(e,t);
                        this._add("boxZoom", n);
                        const r = new _r
                          , o = new Fr;
                        e.doubleClickZoom = new zr(o,r),
                        this._add("tapZoom", r),
                        this._add("clickZoom", o);
                        const s = new Nr;
                        this._add("tapDragZoom", s);
                        const a = e.touchPitch = new kr(e);
                        this._add("touchPitch", a);
                        const l = new br(t)
                          , c = new wr(t);
                        e.dragRotate = new Ur(t,l,c),
                        this._add("mouseRotate", l, ["mousePitch"]),
                        this._add("mousePitch", c, ["mouseRotate"]);
                        const h = new xr(t)
                          , u = new Er(e,t);
                        e.dragPan = new jr(i,h,u),
                        this._add("mousePan", h),
                        this._add("touchPan", u, ["touchZoom", "touchRotate"]);
                        const d = new Mr
                          , f = new Ar;
                        e.touchZoomRotate = new Vr(i,f,d,s),
                        this._add("touchRotate", d, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", f, ["touchPan", "touchRotate"]),
                        this._add("blockableMapEvent", new dr(e));
                        const p = e.scrollZoom = new Br(e,this);
                        this._add("scrollZoom", p, ["mousePan"]);
                        const m = e.keyboard = new Rr;
                        this._add("keyboard", m);
                        for (const i of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                            t.interactive && t[i] && e[i].enable(t[i])
                    }
                    _add(t, e, i) {
                        this._handlers.push({
                            handlerName: t,
                            handler: e,
                            allowed: i
                        }),
                        this._handlersById[t] = e
                    }
                    stop(t) {
                        if (!this._updatingCamera) {
                            for (const {handler: t} of this._handlers)
                                t.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, t),
                            this._changes = []
                        }
                    }
                    isActive() {
                        for (const {handler: t} of this._handlers)
                            if (t.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!Gr(this._eventsInProgress) || this.isZooming()
                    }
                    _isDragging() {
                        return !!this._eventsInProgress.drag
                    }
                    _blockedByActive(t, e, i) {
                        for (const n in t)
                            if (n !== i && (!e || e.indexOf(n) < 0))
                                return !0;
                        return !1
                    }
                    handleWindowEvent(t) {
                        this.handleEvent(t, `${t.type}Window`)
                    }
                    _getMapTouches(t) {
                        const e = [];
                        for (const i of t)
                            this._el.contains(i.target) && e.push(i);
                        return e
                    }
                    handleEvent(t, e) {
                        this._updatingCamera = !0;
                        const i = "renderFrame" === t.type
                          , n = i ? void 0 : t
                          , r = {
                            needsRenderFrame: !1
                        }
                          , o = {}
                          , s = {}
                          , a = t.touches ? this._getMapTouches(t.touches) : void 0
                          , l = a ? g(this._el, a) : i ? void 0 : m(this._el, t);
                        for (const {handlerName: i, handler: c, allowed: h} of this._handlers) {
                            if (!c.isEnabled())
                                continue;
                            let u;
                            this._blockedByActive(s, h, i) ? c.reset() : c[e || t.type] && (u = c[e || t.type](t, l, a),
                            this.mergeHandlerResult(r, o, u, i, n),
                            u && u.needsRenderFrame && this._triggerRenderFrame()),
                            (u || c.isActive()) && (s[i] = c)
                        }
                        const c = {};
                        for (const t in this._previousActiveHandlers)
                            s[t] || (c[t] = n);
                        this._previousActiveHandlers = s,
                        (Object.keys(c).length || Wr(r)) && (this._changes.push([r, o, c]),
                        this._triggerRenderFrame()),
                        (Object.keys(s).length || Wr(r)) && this._map._stop(!0),
                        this._updatingCamera = !1;
                        const {cameraAnimation: h} = r;
                        h && (this._inertia.clear(),
                        this._fireEvents({}, {}, !0),
                        this._changes = [],
                        h(this._map))
                    }
                    mergeHandlerResult(e, i, n, r, o) {
                        if (!n)
                            return;
                        t.extend(e, n);
                        const s = {
                            handlerName: r,
                            originalEvent: n.originalEvent || o
                        };
                        void 0 !== n.zoomDelta && (i.zoom = s),
                        void 0 !== n.panDelta && (i.drag = s),
                        void 0 !== n.pitchDelta && (i.pitch = s),
                        void 0 !== n.bearingDelta && (i.rotate = s)
                    }
                    _applyChanges() {
                        const e = {}
                          , i = {}
                          , n = {};
                        for (const [r,o,s] of this._changes)
                            r.panDelta && (e.panDelta = (e.panDelta || new t.Point(0,0))._add(r.panDelta)),
                            r.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + r.zoomDelta),
                            r.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + r.bearingDelta),
                            r.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + r.pitchDelta),
                            void 0 !== r.around && (e.around = r.around),
                            void 0 !== r.aroundCoord && (e.aroundCoord = r.aroundCoord),
                            void 0 !== r.pinchAround && (e.pinchAround = r.pinchAround),
                            r.noInertia && (e.noInertia = r.noInertia),
                            t.extend(i, o),
                            t.extend(n, s);
                        this._updateMapTransform(e, i, n),
                        this._changes = []
                    }
                    _updateMapTransform(e, i, n) {
                        const r = this._map
                          , o = r.transform
                          , s = t => [t.x, t.y, t.z];
                        if ((t => {
                            const e = this._eventsInProgress.drag;
                            return e && !this._handlersById[e.handlerName].isActive()
                        }
                        )() && !Wr(e)) {
                            const t = o.zoom;
                            o.cameraElevationReference = "sea",
                            o.recenterOnTerrain(),
                            o.cameraElevationReference = "ground",
                            t !== o.zoom && this._map._update(!0)
                        }
                        if (o._isCameraConstrained && r._stop(!0),
                        !Wr(e))
                            return void this._fireEvents(i, n, !0);
                        let {panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: h, around: u, aroundCoord: d, pinchAround: f} = e;
                        o._isCameraConstrained && (l > 0 && (l = 0),
                        o._isCameraConstrained = !1),
                        void 0 !== f && (u = f),
                        (l || (t => i[t] && !this._eventsInProgress[t])("drag")) && u && (this._dragOrigin = s(o.pointCoordinate3D(u)),
                        this._trackingEllipsoid.setup(o._camera.position, this._dragOrigin)),
                        o.cameraElevationReference = "sea",
                        r._stop(!0),
                        u = u || r.transform.centerPoint,
                        c && (o.bearing += c),
                        h && (o.pitch += h),
                        o._updateCameraState();
                        const p = [0, 0, 0];
                        if (a)
                            if ("mercator" === o.projection.name) {
                                const t = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(u).dir)
                                  , e = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(u.sub(a)).dir);
                                p[0] = e[0] - t[0],
                                p[1] = e[1] - t[1]
                            } else {
                                const e = o.pointCoordinate(u);
                                if ("globe" === o.projection.name) {
                                    a = a.rotate(-o.angle);
                                    const i = o._pixelsPerMercatorPixel / o.worldSize;
                                    p[0] = -a.x * t.mercatorScale(t.latFromMercatorY(e.y)) * i,
                                    p[1] = -a.y * t.mercatorScale(o.center.lat) * i
                                } else {
                                    const t = o.pointCoordinate(u.sub(a));
                                    e && t && (p[0] = t.x - e.x,
                                    p[1] = t.y - e.y)
                                }
                            }
                        const m = o.zoom
                          , g = [0, 0, 0];
                        if (l) {
                            const e = s(d || o.pointCoordinate3D(u))
                              , i = {
                                dir: t.normalize([], t.sub([], e, o._camera.position))
                            };
                            if (i.dir[2] < 0) {
                                const n = o.zoomDeltaToMovement(e, l);
                                t.scale$2(g, i.dir, n)
                            }
                        }
                        const _ = t.add(p, p, g);
                        o._translateCameraConstrained(_),
                        l && Math.abs(o.zoom - m) > 1e-4 && o.recenterOnTerrain(),
                        o.cameraElevationReference = "ground",
                        this._map._update(),
                        e.noInertia || this._inertia.record(e),
                        this._fireEvents(i, n, !0)
                    }
                    _fireEvents(e, i, n) {
                        const r = Gr(this._eventsInProgress)
                          , o = Gr(e)
                          , s = {};
                        for (const t in e) {
                            const {originalEvent: i} = e[t];
                            this._eventsInProgress[t] || (s[`${t}start`] = i),
                            this._eventsInProgress[t] = e[t]
                        }
                        !r && o && this._fireEvent("movestart", o.originalEvent);
                        for (const t in s)
                            this._fireEvent(t, s[t]);
                        o && this._fireEvent("move", o.originalEvent);
                        for (const t in e) {
                            const {originalEvent: i} = e[t];
                            this._fireEvent(t, i)
                        }
                        const a = {};
                        let l;
                        for (const t in this._eventsInProgress) {
                            const {handlerName: e, originalEvent: n} = this._eventsInProgress[t];
                            this._handlersById[e].isActive() || (delete this._eventsInProgress[t],
                            l = i[e] || n,
                            a[`${t}end`] = l)
                        }
                        for (const t in a)
                            this._fireEvent(t, a[t]);
                        const c = Gr(this._eventsInProgress);
                        if (n && (r || o) && !c) {
                            this._updatingCamera = !0;
                            const e = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , i = t => 0 !== t && -this._bearingSnap < t && t < this._bearingSnap;
                            e ? (i(e.bearing || this._map.getBearing()) && (e.bearing = 0),
                            this._map.easeTo(e, {
                                originalEvent: l
                            })) : (this._map.fire(new t.Event("moveend",{
                                originalEvent: l
                            })),
                            i(this._map.getBearing()) && this._map.resetNorth()),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(e, i) {
                        this._map.fire(new t.Event(e,i ? {
                            originalEvent: i
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add((t => {
                            this._frameId = void 0,
                            this.handleEvent(new Zr("renderFrame",{
                                timeStamp: t
                            })),
                            this._applyChanges()
                        }
                        ))
                    }
                    _triggerRenderFrame() {
                        void 0 === this._frameId && (this._frameId = this._requestFrame())
                    }
                }
                const $r = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
                class Xr extends t.Evented {
                    constructor(e, i) {
                        super(),
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = e,
                        this._bearingSnap = i.bearingSnap,
                        this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion,
                        t.bindAll(["_renderFrameCallback"], this)
                    }
                    getCenter() {
                        return new t.LngLat(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(t, e) {
                        return this.jumpTo({
                            center: t
                        }, e)
                    }
                    panBy(e, i, n) {
                        return e = t.Point.convert(e).mult(-1),
                        this.panTo(this.transform.center, t.extend({
                            offset: e
                        }, i), n)
                    }
                    panTo(e, i, n) {
                        return this.easeTo(t.extend({
                            center: e
                        }, i), n)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(t, e) {
                        return this.jumpTo({
                            zoom: t
                        }, e),
                        this
                    }
                    zoomTo(e, i, n) {
                        return this.easeTo(t.extend({
                            zoom: e
                        }, i), n)
                    }
                    zoomIn(t, e) {
                        return this.zoomTo(this.getZoom() + 1, t, e),
                        this
                    }
                    zoomOut(t, e) {
                        return this.zoomTo(this.getZoom() - 1, t, e),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(t, e) {
                        return this.jumpTo({
                            bearing: t
                        }, e),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(t, e) {
                        return this.jumpTo({
                            padding: t
                        }, e),
                        this
                    }
                    rotateTo(e, i, n) {
                        return this.easeTo(t.extend({
                            bearing: e
                        }, i), n)
                    }
                    resetNorth(e, i) {
                        return this.rotateTo(0, t.extend({
                            duration: 1e3
                        }, e), i),
                        this
                    }
                    resetNorthPitch(e, i) {
                        return this.easeTo(t.extend({
                            bearing: 0,
                            pitch: 0,
                            duration: 1e3
                        }, e), i),
                        this
                    }
                    snapToNorth(t, e) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, e) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(t, e) {
                        return this.jumpTo({
                            pitch: t
                        }, e),
                        this
                    }
                    cameraForBounds(e, i) {
                        e = t.LngLatBounds.convert(e);
                        const n = i && i.bearing || 0
                          , r = i && i.pitch || 0
                          , o = e.getNorthWest()
                          , s = e.getSouthEast();
                        return this._cameraForBounds(this.transform, o, s, n, r, i)
                    }
                    _extendCameraOptions(e) {
                        const i = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        if ("number" == typeof (e = t.extend({
                            padding: i,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, e)).padding) {
                            const t = e.padding;
                            e.padding = {
                                top: t,
                                bottom: t,
                                right: t,
                                left: t
                            }
                        }
                        return e.padding = t.extend(i, e.padding),
                        e
                    }
                    _minimumAABBFrustumDistance(t, e) {
                        const i = e.max[0] - e.min[0]
                          , n = e.max[1] - e.min[1];
                        return i / n > t.aspect ? i / (2 * Math.tan(.5 * t.fovX) * t.aspect) : n / (2 * Math.tan(.5 * t.fovY) * t.aspect)
                    }
                    _cameraForBoundsOnGlobe(e, i, n, r, o, s) {
                        const a = e.clone()
                          , l = this._extendCameraOptions(s);
                        a.bearing = r,
                        a.pitch = o;
                        const c = t.LngLat.convert(i)
                          , h = t.LngLat.convert(n)
                          , u = .5 * (c.lat + h.lat)
                          , d = .5 * (c.lng + h.lng)
                          , f = t.latLngToECEF(u, d)
                          , p = t.normalize([], f)
                          , m = t.normalize([], t.cross([], p, [0, 1, 0]))
                          , g = t.cross([], m, p)
                          , _ = [m[0], m[1], m[2], 0, g[0], g[1], g[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1]
                          , y = [f, t.latLngToECEF(c.lat, c.lng), t.latLngToECEF(h.lat, c.lng), t.latLngToECEF(h.lat, h.lng), t.latLngToECEF(c.lat, h.lng), t.latLngToECEF(u, c.lng), t.latLngToECEF(u, h.lng), t.latLngToECEF(c.lat, d), t.latLngToECEF(h.lat, d)];
                        let v = t.Aabb.fromPoints(y.map((e => [t.dot(m, e), t.dot(g, e), t.dot(p, e)])));
                        const x = t.transformMat4([], v.center, _);
                        0 === t.squaredLength(x) && t.set(x, 0, 0, 1),
                        t.normalize(x, x),
                        t.scale$2(x, x, t.GLOBE_RADIUS),
                        a.center = t.ecefToLatLng(x);
                        const b = a.getWorldToCameraMatrix()
                          , w = t.invert(new Float64Array(16), b);
                        v = t.Aabb.applyTransform(v, t.multiply([], b, _)),
                        t.transformMat4(x, x, b);
                        const E = .5 * (v.max[2] - v.min[2])
                          , T = this._minimumAABBFrustumDistance(a, v)
                          , S = t.scale$2([], [0, 0, 1], E)
                          , C = t.add(S, x, S)
                          , A = T + (0 === a.pitch ? 0 : t.distance(x, C))
                          , I = a.globeCenterInViewSpace
                          , M = t.sub([], x, [I[0], I[1], I[2]]);
                        t.normalize(M, M),
                        t.scale$2(M, M, A);
                        const P = t.add([], x, M);
                        t.transformMat4(P, P, w);
                        const k = t.earthRadius / t.GLOBE_RADIUS
                          , O = t.length(P)
                          , R = t.mercatorZfromAltitude(Math.max(O * k - t.earthRadius, Number.EPSILON), 0)
                          , D = Math.min(a.zoomFromMercatorZAdjusted(R), l.maxZoom);
                        return D > .5 * (t.GLOBE_ZOOM_THRESHOLD_MIN + t.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                            name: "mercator"
                        }),
                        a.zoom = D,
                        this._cameraForBounds(a, i, n, r, o, s)) : {
                            center: a.center,
                            zoom: D,
                            bearing: r,
                            pitch: o
                        }
                    }
                    queryTerrainElevation(e, i) {
                        const n = this.transform.elevation;
                        return n ? (i = t.extend({}, {
                            exaggerated: !0
                        }, i),
                        n.getAtPoint(t.MercatorCoordinate.fromLngLat(e), null, i.exaggerated)) : null
                    }
                    _cameraForBounds(e, i, n, r, o, s) {
                        if ("globe" === e.projection.name)
                            return this._cameraForBoundsOnGlobe(e, i, n, r, o, s);
                        const a = e.clone()
                          , l = this._extendCameraOptions(s)
                          , c = a.padding;
                        a.bearing = r,
                        a.pitch = o;
                        const h = t.LngLat.convert(i)
                          , u = t.LngLat.convert(n)
                          , d = new t.LngLat(h.lng,u.lat)
                          , f = new t.LngLat(u.lng,h.lat)
                          , p = a.project(h)
                          , m = a.project(u)
                          , g = this.queryTerrainElevation(h)
                          , _ = this.queryTerrainElevation(u)
                          , y = this.queryTerrainElevation(d)
                          , v = this.queryTerrainElevation(f)
                          , x = [[p.x, p.y, Math.min(g || 0, _ || 0, y || 0, v || 0)], [m.x, m.y, Math.max(g || 0, _ || 0, y || 0, v || 0)]];
                        let b = t.Aabb.fromPoints(x);
                        const w = a.getWorldToCameraMatrix()
                          , E = t.invert(new Float64Array(16), w);
                        b = t.Aabb.applyTransform(b, w);
                        const T = t.sub([], b.max, b.min)
                          , S = c.left || 0
                          , C = c.right || 0
                          , A = c.bottom || 0
                          , I = c.top || 0
                          , {left: M, right: P, top: k, bottom: O} = l.padding
                          , R = .5 * (S + C)
                          , D = .5 * (I + A)
                          , L = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (S + C + M + P)) / T[0], (a.height - (A + I + O + k)) / T[1])), l.maxZoom)
                          , B = a.scale / a.zoomScale(L);
                        b = new t.Aabb([b.min[0] - (M + R) * B, b.min[1] - (O + D) * B, b.min[2]],[b.max[0] + (P + R) * B, b.max[1] + (k + D) * B, b.max[2]]);
                        const z = .5 * T[2]
                          , F = this._minimumAABBFrustumDistance(a, b)
                          , N = [0, 0, 1, 0];
                        t.transformMat4$1(N, N, w),
                        t.normalize$2(N, N);
                        const j = t.scale$2([], N, F + z)
                          , U = t.add([], b.center, j)
                          , V = ("number" == typeof l.offset.x && "number" == typeof l.offset.y ? new t.Point(l.offset.x,l.offset.y) : t.Point.convert(l.offset)).rotate(-t.degToRad(r));
                        b.center[0] -= V.x * B,
                        b.center[1] += V.y * B,
                        t.transformMat4(b.center, b.center, E),
                        t.transformMat4(U, U, E);
                        const G = [b.center[0], b.center[1], U[2] * a.pixelsPerMeter];
                        t.scale$2(G, G, 1 / a.worldSize);
                        const Z = t.lngFromMercatorX(G[0])
                          , q = t.latFromMercatorY(G[1])
                          , W = Math.min(a._zoomFromMercatorZ(G[2]), l.maxZoom)
                          , H = new t.LngLat(Z,q);
                        return a.mercatorFromTransition && W < .5 * (t.GLOBE_ZOOM_THRESHOLD_MIN + t.GLOBE_ZOOM_THRESHOLD_MAX) ? (a.setProjection({
                            name: "globe"
                        }),
                        a.zoom = W,
                        this._cameraForBounds(a, i, n, r, o, s)) : {
                            center: H,
                            zoom: W,
                            bearing: r,
                            pitch: o
                        }
                    }
                    fitBounds(t, e, i) {
                        const n = this.cameraForBounds(t, e);
                        return this._fitInternal(n, e, i)
                    }
                    fitScreenCoordinates(e, i, n, r, o) {
                        const s = t.Point.convert(e)
                          , a = t.Point.convert(i)
                          , l = new t.Point(Math.min(s.x, a.x),Math.min(s.y, a.y))
                          , c = new t.Point(Math.max(s.x, a.x),Math.max(s.y, a.y));
                        if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(s, a))
                            return this;
                        const h = this.transform.pointLocation3D(l)
                          , u = this.transform.pointLocation3D(c)
                          , d = this.transform.pointLocation3D(new t.Point(l.x,c.y))
                          , f = this.transform.pointLocation3D(new t.Point(c.x,l.y))
                          , p = [Math.min(h.lng, u.lng, d.lng, f.lng), Math.min(h.lat, u.lat, d.lat, f.lat)]
                          , m = [Math.max(h.lng, u.lng, d.lng, f.lng), Math.max(h.lat, u.lat, d.lat, f.lat)]
                          , g = r && r.pitch ? r.pitch : this.getPitch()
                          , _ = this._cameraForBounds(this.transform, p, m, n, g, r);
                        return this._fitInternal(_, r, o)
                    }
                    _fitInternal(e, i, n) {
                        return e ? (delete (i = t.extend(e, i)).padding,
                        i.linear ? this.easeTo(i, n) : this.flyTo(i, n)) : this
                    }
                    jumpTo(e, i) {
                        this.stop();
                        const n = e.preloadOnly ? this.transform.clone() : this.transform;
                        let r = !1
                          , o = !1
                          , s = !1;
                        return "zoom"in e && n.zoom !== +e.zoom && (r = !0,
                        n.zoom = +e.zoom),
                        void 0 !== e.center && (n.center = t.LngLat.convert(e.center)),
                        "bearing"in e && n.bearing !== +e.bearing && (o = !0,
                        n.bearing = +e.bearing),
                        "pitch"in e && n.pitch !== +e.pitch && (s = !0,
                        n.pitch = +e.pitch),
                        null == e.padding || n.isPaddingEqual(e.padding) || (n.padding = e.padding),
                        e.preloadOnly ? (this._preloadTiles(n),
                        this) : (this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                        r && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                        o && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                        s && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                        this.fire(new t.Event("moveend",i)))
                    }
                    getFreeCameraOptions() {
                        return this.transform.projection.supportsFreeCamera || t.warnOnce($r),
                        this.transform.getFreeCameraOptions()
                    }
                    setFreeCameraOptions(e, i) {
                        const n = this.transform;
                        if (!n.projection.supportsFreeCamera)
                            return t.warnOnce($r),
                            this;
                        this.stop();
                        const r = n.zoom
                          , o = n.pitch
                          , s = n.bearing;
                        n.setFreeCameraOptions(e);
                        const a = r !== n.zoom
                          , l = o !== n.pitch
                          , c = s !== n.bearing;
                        return this.fire(new t.Event("movestart",i)).fire(new t.Event("move",i)),
                        a && this.fire(new t.Event("zoomstart",i)).fire(new t.Event("zoom",i)).fire(new t.Event("zoomend",i)),
                        c && this.fire(new t.Event("rotatestart",i)).fire(new t.Event("rotate",i)).fire(new t.Event("rotateend",i)),
                        l && this.fire(new t.Event("pitchstart",i)).fire(new t.Event("pitch",i)).fire(new t.Event("pitchend",i)),
                        this.fire(new t.Event("moveend",i)),
                        this
                    }
                    easeTo(e, i) {
                        this._stop(!1, e.easeId),
                        (!1 === (e = t.extend({
                            offset: [0, 0],
                            duration: 500,
                            easing: t.ease
                        }, e)).animate || this._prefersReducedMotion(e)) && (e.duration = 0);
                        const n = this.transform
                          , r = this.getZoom()
                          , o = this.getBearing()
                          , s = this.getPitch()
                          , a = this.getPadding()
                          , l = "zoom"in e ? +e.zoom : r
                          , c = "bearing"in e ? this._normalizeBearing(e.bearing, o) : o
                          , h = "pitch"in e ? +e.pitch : s
                          , u = "padding"in e ? e.padding : n.padding
                          , d = t.Point.convert(e.offset);
                        let f, p, m;
                        if ("globe" === n.projection.name) {
                            const i = t.MercatorCoordinate.fromLngLat(n.center)
                              , r = d.rotate(-n.angle);
                            i.x += r.x / n.worldSize,
                            i.y += r.y / n.worldSize;
                            const o = i.toLngLat()
                              , s = t.LngLat.convert(e.center || o);
                            this._normalizeCenter(s),
                            f = n.centerPoint.add(r),
                            p = new t.Point(i.x,i.y).mult(n.worldSize),
                            m = new t.Point(t.mercatorXfromLng(s.lng),t.mercatorYfromLat(s.lat)).mult(n.worldSize).sub(p)
                        } else {
                            f = n.centerPoint.add(d);
                            const i = n.pointLocation(f)
                              , r = t.LngLat.convert(e.center || i);
                            this._normalizeCenter(r),
                            p = n.project(i),
                            m = n.project(r).sub(p)
                        }
                        const g = n.zoomScale(l - r);
                        let _, y;
                        e.around && (_ = t.LngLat.convert(e.around),
                        y = n.locationPoint(_));
                        const v = this._zooming || l !== r
                          , x = this._rotating || o !== c
                          , b = this._pitching || h !== s
                          , w = !n.isPaddingEqual(u)
                          , E = n => E => {
                            if (v && (n.zoom = t.number(r, l, E)),
                            x && (n.bearing = t.number(o, c, E)),
                            b && (n.pitch = t.number(s, h, E)),
                            w && (n.interpolatePadding(a, u, E),
                            f = n.centerPoint.add(d)),
                            _)
                                n.setLocationAtPoint(_, y);
                            else {
                                const t = n.zoomScale(n.zoom - r)
                                  , e = l > r ? Math.min(2, g) : Math.max(.5, g)
                                  , i = Math.pow(e, 1 - E)
                                  , o = n.unproject(p.add(m.mult(E * i)).mult(t));
                                n.setLocationAtPoint(n.renderWorldCopies ? o.wrap() : o, f)
                            }
                            return e.preloadOnly || this._fireMoveEvents(i),
                            n
                        }
                        ;
                        if (e.preloadOnly) {
                            const t = this._emulate(E, e.duration, n);
                            return this._preloadTiles(t),
                            this
                        }
                        const T = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching
                        };
                        return this._zooming = v,
                        this._rotating = x,
                        this._pitching = b,
                        this._padding = w,
                        this._easeId = e.easeId,
                        this._prepareEase(i, e.noMoveStart, T),
                        this._ease(E(n), (t => {
                            n.recenterOnTerrain(),
                            this._afterEase(i, t)
                        }
                        ), e),
                        this
                    }
                    _prepareEase(e, i, n={}) {
                        this._moving = !0,
                        this.transform.cameraElevationReference = "sea",
                        i || n.moving || this.fire(new t.Event("movestart",e)),
                        this._zooming && !n.zooming && this.fire(new t.Event("zoomstart",e)),
                        this._rotating && !n.rotating && this.fire(new t.Event("rotatestart",e)),
                        this._pitching && !n.pitching && this.fire(new t.Event("pitchstart",e))
                    }
                    _fireMoveEvents(e) {
                        this.fire(new t.Event("move",e)),
                        this._zooming && this.fire(new t.Event("zoom",e)),
                        this._rotating && this.fire(new t.Event("rotate",e)),
                        this._pitching && this.fire(new t.Event("pitch",e))
                    }
                    _afterEase(e, i) {
                        if (this._easeId && i && this._easeId === i)
                            return;
                        this._easeId = void 0,
                        this.transform.cameraElevationReference = "ground";
                        const n = this._zooming
                          , r = this._rotating
                          , o = this._pitching;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._padding = !1,
                        n && this.fire(new t.Event("zoomend",e)),
                        r && this.fire(new t.Event("rotateend",e)),
                        o && this.fire(new t.Event("pitchend",e)),
                        this.fire(new t.Event("moveend",e))
                    }
                    flyTo(e, i) {
                        if (this._prefersReducedMotion(e)) {
                            const n = t.pick(e, ["center", "zoom", "bearing", "pitch", "around"]);
                            return this.jumpTo(n, i)
                        }
                        this.stop(),
                        e = t.extend({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: t.ease
                        }, e);
                        const n = this.transform
                          , r = this.getZoom()
                          , o = this.getBearing()
                          , s = this.getPitch()
                          , a = this.getPadding()
                          , l = "zoom"in e ? t.clamp(+e.zoom, n.minZoom, n.maxZoom) : r
                          , c = "bearing"in e ? this._normalizeBearing(e.bearing, o) : o
                          , h = "pitch"in e ? +e.pitch : s
                          , u = "padding"in e ? e.padding : n.padding
                          , d = n.zoomScale(l - r)
                          , f = t.Point.convert(e.offset);
                        let p = n.centerPoint.add(f);
                        const m = n.pointLocation(p)
                          , g = t.LngLat.convert(e.center || m);
                        this._normalizeCenter(g);
                        const _ = n.project(m)
                          , y = n.project(g).sub(_);
                        let v = e.curve;
                        const x = Math.max(n.width, n.height)
                          , b = x / d
                          , w = y.mag();
                        if ("minZoom"in e) {
                            const i = t.clamp(Math.min(e.minZoom, r, l), n.minZoom, n.maxZoom)
                              , o = x / n.zoomScale(i - r);
                            v = Math.sqrt(o / w * 2)
                        }
                        const E = v * v;
                        function T(t) {
                            const e = (b * b - x * x + (t ? -1 : 1) * E * E * w * w) / (2 * (t ? b : x) * E * w);
                            return Math.log(Math.sqrt(e * e + 1) - e)
                        }
                        function S(t) {
                            return (Math.exp(t) - Math.exp(-t)) / 2
                        }
                        function C(t) {
                            return (Math.exp(t) + Math.exp(-t)) / 2
                        }
                        const A = T(0);
                        let I = function(t) {
                            return C(A) / C(A + v * t)
                        }
                          , M = function(t) {
                            return x * ((C(A) * (S(e = A + v * t) / C(e)) - S(A)) / E) / w;
                            var e
                        }
                          , P = (T(1) - A) / v;
                        if (Math.abs(w) < 1e-6 || !isFinite(P)) {
                            if (Math.abs(x - b) < 1e-6)
                                return this.easeTo(e, i);
                            const t = b < x ? -1 : 1;
                            P = Math.abs(Math.log(b / x)) / v,
                            M = function() {
                                return 0
                            }
                            ,
                            I = function(e) {
                                return Math.exp(t * v * e)
                            }
                        }
                        e.duration = "duration"in e ? +e.duration : 1e3 * P / ("screenSpeed"in e ? +e.screenSpeed / v : +e.speed),
                        e.maxDuration && e.duration > e.maxDuration && (e.duration = 0);
                        const k = o !== c
                          , O = h !== s
                          , R = !n.isPaddingEqual(u)
                          , D = n => d => {
                            const m = d * P
                              , v = 1 / I(m);
                            n.zoom = 1 === d ? l : r + n.scaleZoom(v),
                            k && (n.bearing = t.number(o, c, d)),
                            O && (n.pitch = t.number(s, h, d)),
                            R && (n.interpolatePadding(a, u, d),
                            p = n.centerPoint.add(f));
                            const x = 1 === d ? g : n.unproject(_.add(y.mult(M(m))).mult(v));
                            return n.setLocationAtPoint(n.renderWorldCopies ? x.wrap() : x, p),
                            n._updateCameraOnTerrain(),
                            e.preloadOnly || this._fireMoveEvents(i),
                            n
                        }
                        ;
                        if (e.preloadOnly) {
                            const t = this._emulate(D, e.duration, n);
                            return this._preloadTiles(t),
                            this
                        }
                        return this._zooming = !0,
                        this._rotating = k,
                        this._pitching = O,
                        this._padding = R,
                        this._prepareEase(i, !1),
                        this._ease(D(n), ( () => this._afterEase(i)), e),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _stop(t, e) {
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        this._easeFrameId = void 0,
                        this._onEaseFrame = void 0),
                        this._onEaseEnd) {
                            const t = this._onEaseEnd;
                            this._onEaseEnd = void 0,
                            t.call(this, e)
                        }
                        if (!t) {
                            const t = this.handlers;
                            t && t.stop(!1)
                        }
                        return this
                    }
                    _ease(e, i, n) {
                        !1 === n.animate || 0 === n.duration ? (e(1),
                        i()) : (this._easeStart = t.exported.now(),
                        this._easeOptions = n,
                        this._onEaseFrame = e,
                        this._onEaseEnd = i,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _renderFrameCallback() {
                        const e = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1)
                          , i = this._onEaseFrame;
                        i && i(this._easeOptions.easing(e)),
                        e < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                    }
                    _normalizeBearing(e, i) {
                        e = t.wrap(e, -180, 180);
                        const n = Math.abs(e - i);
                        return Math.abs(e - 360 - i) < n && (e -= 360),
                        Math.abs(e + 360 - i) < n && (e += 360),
                        e
                    }
                    _normalizeCenter(t) {
                        const e = this.transform;
                        if (!e.renderWorldCopies || e.maxBounds)
                            return;
                        const i = t.lng - e.center.lng;
                        t.lng += i > 180 ? -360 : i < -180 ? 360 : 0
                    }
                    _prefersReducedMotion(e) {
                        return this._respectPrefersReducedMotion && t.exported.prefersReducedMotion && !(e && e.essential)
                    }
                    _emulate(t, e, i) {
                        const n = Math.ceil(15 * e / 1e3)
                          , r = []
                          , o = t(i.clone());
                        for (let t = 0; t <= n; t++) {
                            const e = o(t / n);
                            r.push(e.clone())
                        }
                        return r
                    }
                }
                class Yr {
                    constructor(e={}) {
                        this.options = e,
                        t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this)
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(t) {
                        const e = this.options && this.options.compact;
                        return this._map = t,
                        this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"),
                        this._compactButton = s("button", "mapboxgl-ctrl-attrib-button", this._container),
                        s("span", "mapboxgl-ctrl-icon", this._compactButton).setAttribute("aria-hidden", "true"),
                        this._compactButton.type = "button",
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._setElementTitle(this._compactButton, "ToggleAttribution"),
                        this._innerContainer = s("div", "mapboxgl-ctrl-attrib-inner", this._container),
                        this._innerContainer.setAttribute("role", "list"),
                        e && this._container.classList.add("mapboxgl-compact"),
                        this._updateAttributions(),
                        this._updateEditLink(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("moveend", this._updateEditLink),
                        void 0 === e && (this._map.on("resize", this._updateCompact),
                        this._updateCompact()),
                        this._container
                    }
                    onRemove() {
                        this._container.remove(),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("moveend", this._updateEditLink),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._attribHTML = void 0
                    }
                    _setElementTitle(t, e) {
                        const i = this._map._getUIString(`AttributionControl.${e}`);
                        t.setAttribute("aria-label", i),
                        t.removeAttribute("title"),
                        t.firstElementChild && t.firstElementChild.setAttribute("title", i)
                    }
                    _toggleAttribution() {
                        this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"),
                        this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"),
                        this._compactButton.setAttribute("aria-expanded", "true"))
                    }
                    _updateEditLink() {
                        let e = this._editLink;
                        e || (e = this._editLink = this._container.querySelector(".mapbox-improve-map"));
                        const i = [{
                            key: "owner",
                            value: this.styleOwner
                        }, {
                            key: "id",
                            value: this.styleId
                        }, {
                            key: "access_token",
                            value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN
                        }];
                        if (e) {
                            const n = i.reduce(( (t, e, n) => (e.value && (t += `${e.key}=${e.value}${n < i.length - 1 ? "&" : ""}`),
                            t)), "?");
                            e.href = `${t.config.FEEDBACK_URL}/${n}#${Qn(this._map, !0)}`,
                            e.rel = "noopener nofollow",
                            this._setElementTitle(e, "MapFeedback")
                        }
                    }
                    _updateData(t) {
                        !t || "metadata" !== t.sourceDataType && "visibility" !== t.sourceDataType && "style" !== t.dataType || (this._updateAttributions(),
                        this._updateEditLink())
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let t = [];
                        if (this._map.style.stylesheet) {
                            const t = this._map.style.stylesheet;
                            this.styleOwner = t.owner,
                            this.styleId = t.id
                        }
                        const e = this._map.style._sourceCaches;
                        for (const i in e) {
                            const n = e[i];
                            if (n.used) {
                                const e = n.getSource();
                                e.attribution && t.indexOf(e.attribution) < 0 && t.push(e.attribution)
                            }
                        }
                        t.sort(( (t, e) => t.length - e.length)),
                        t = t.filter(( (e, i) => {
                            for (let n = i + 1; n < t.length; n++)
                                if (t[n].indexOf(e) >= 0)
                                    return !1;
                            return !0
                        }
                        )),
                        this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t = [...this.options.customAttribution, ...t] : t.unshift(this.options.customAttribution));
                        const i = t.join(" | ");
                        i !== this._attribHTML && (this._attribHTML = i,
                        t.length ? (this._innerContainer.innerHTML = i,
                        this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"),
                        this._editLink = null)
                    }
                    _updateCompact() {
                        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show")
                    }
                }
                class Kr {
                    constructor() {
                        t.bindAll(["_updateLogo", "_updateCompact"], this)
                    }
                    onAdd(t) {
                        this._map = t,
                        this._container = s("div", "mapboxgl-ctrl");
                        const e = s("a", "mapboxgl-ctrl-logo");
                        return e.target = "_blank",
                        e.rel = "noopener nofollow",
                        e.href = "https://www.mapbox.com/",
                        e.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        e.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(e),
                        this._container.style.display = "none",
                        this._map.on("sourcedata", this._updateLogo),
                        this._updateLogo(),
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        this._container.remove(),
                        this._map.off("sourcedata", this._updateLogo),
                        this._map.off("resize", this._updateCompact)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    _updateLogo(t) {
                        t && "metadata" !== t.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none")
                    }
                    _logoRequired() {
                        if (!this._map.style)
                            return !0;
                        const t = this._map.style._sourceCaches;
                        if (0 === Object.entries(t).length)
                            return !0;
                        for (const e in t) {
                            const i = t[e].getSource();
                            if (i.hasOwnProperty("mapbox_logo") && !i.mapbox_logo)
                                return !1
                        }
                        return !0
                    }
                    _updateCompact() {
                        const t = this._container.children;
                        if (t.length) {
                            const e = t[0];
                            this._map.getCanvasContainer().offsetWidth < 250 ? e.classList.add("mapboxgl-compact") : e.classList.remove("mapboxgl-compact")
                        }
                    }
                }
                class Jr {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(t) {
                        const e = ++this._id;
                        return this._queue.push({
                            callback: t,
                            id: e,
                            cancelled: !1
                        }),
                        e
                    }
                    remove(t) {
                        const e = this._currentlyRunning
                          , i = e ? this._queue.concat(e) : this._queue;
                        for (const e of i)
                            if (e.id === t)
                                return void (e.cancelled = !0)
                    }
                    run(t=0) {
                        const e = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const i of e)
                            if (!i.cancelled && (i.callback(t),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                function Qr(e, i, n) {
                    if (e = new t.LngLat(e.lng,e.lat),
                    i) {
                        const r = new t.LngLat(e.lng - 360,e.lat)
                          , o = new t.LngLat(e.lng + 360,e.lat)
                          , s = 360 * Math.ceil(Math.abs(e.lng - n.center.lng) / 360)
                          , a = n.locationPoint(e).distSqr(i)
                          , l = i.x < 0 || i.y < 0 || i.x > n.width || i.y > n.height;
                        n.locationPoint(r).distSqr(i) < a && (l || Math.abs(r.lng - n.center.lng) < s) ? e = r : n.locationPoint(o).distSqr(i) < a && (l || Math.abs(o.lng - n.center.lng) < s) && (e = o)
                    }
                    for (; Math.abs(e.lng - n.center.lng) > 180; ) {
                        const t = n.locationPoint(e);
                        if (t.x >= 0 && t.y >= 0 && t.x <= n.width && t.y <= n.height)
                            break;
                        e.lng > n.center.lng ? e.lng -= 360 : e.lng += 360
                    }
                    return e
                }
                const to = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                class eo extends t.Evented {
                    constructor(e, i) {
                        if (super(),
                        (e instanceof t.window.HTMLElement || i) && (e = t.extend({
                            element: e
                        }, i)),
                        t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this),
                        this._anchor = e && e.anchor || "center",
                        this._color = e && e.color || "#3FB1CE",
                        this._scale = e && e.scale || 1,
                        this._draggable = e && e.draggable || !1,
                        this._clickTolerance = e && e.clickTolerance || 0,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = e && e.rotation || 0,
                        this._rotationAlignment = e && e.rotationAlignment || "auto",
                        this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment || "auto",
                        this._updateMoving = () => this._update(!0),
                        this._occludedOpacity = e && e.occludedOpacity || .2,
                        e && e.element)
                            this._element = e.element,
                            this._offset = t.Point.convert(e && e.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = s("div");
                            const i = 41
                              , n = 27
                              , r = a("svg", {
                                display: "block",
                                height: i * this._scale + "px",
                                width: n * this._scale + "px",
                                viewBox: `0 0 ${n} ${i}`
                            }, this._element)
                              , o = a("radialGradient", {
                                id: "shadowGradient"
                            }, a("defs", {}, r));
                            a("stop", {
                                offset: "10%",
                                "stop-opacity": .4
                            }, o),
                            a("stop", {
                                offset: "100%",
                                "stop-opacity": .05
                            }, o),
                            a("ellipse", {
                                cx: 13.5,
                                cy: 34.8,
                                rx: 10.5,
                                ry: 5.25,
                                fill: "url(#shadowGradient)"
                            }, r),
                            a("path", {
                                fill: this._color,
                                d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z"
                            }, r),
                            a("path", {
                                opacity: .25,
                                d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z"
                            }, r),
                            a("circle", {
                                fill: "white",
                                cx: 13.5,
                                cy: 13.5,
                                r: 5.5
                            }, r),
                            this._offset = t.Point.convert(e && e.offset || [0, -14])
                        }
                        this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"),
                        this._element.classList.add("mapboxgl-marker"),
                        this._element.addEventListener("dragstart", (t => {
                            t.preventDefault()
                        }
                        )),
                        this._element.addEventListener("mousedown", (t => {
                            t.preventDefault()
                        }
                        ));
                        const n = this._element.classList;
                        for (const t in to)
                            n.remove(`mapboxgl-marker-anchor-${t}`);
                        n.add(`mapboxgl-marker-anchor-${this._anchor}`),
                        this._popup = null
                    }
                    addTo(t) {
                        return t === this._map || (this.remove(),
                        this._map = t,
                        t.getCanvasContainer().appendChild(this._element),
                        t.on("move", this._updateMoving),
                        t.on("moveend", this._update),
                        t.on("remove", this._clearFadeTimer),
                        t._addMarker(this),
                        this.setDraggable(this._draggable),
                        this._update(),
                        t.on("click", this._onMapClick)),
                        this
                    }
                    remove() {
                        const t = this._map;
                        return t && (t.off("click", this._onMapClick),
                        t.off("move", this._updateMoving),
                        t.off("moveend", this._update),
                        t.off("mousedown", this._addDragHandler),
                        t.off("touchstart", this._addDragHandler),
                        t.off("mouseup", this._onUp),
                        t.off("touchend", this._onUp),
                        t.off("mousemove", this._onMove),
                        t.off("touchmove", this._onMove),
                        t.off("remove", this._clearFadeTimer),
                        t._removeMarker(this),
                        this._map = void 0),
                        this._clearFadeTimer(),
                        this._element.remove(),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(e) {
                        return this._lngLat = t.LngLat.convert(e),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(!0),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(t) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeAttribute("role"),
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        t) {
                            if (!("offset"in t.options)) {
                                const e = 38.1
                                  , i = 13.5
                                  , n = Math.sqrt(Math.pow(i, 2) / 2);
                                t.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -e],
                                    "bottom-left": [n, -1 * (e - i + n)],
                                    "bottom-right": [-n, -1 * (e - i + n)],
                                    left: [i, -1 * (e - i)],
                                    right: [-i, -1 * (e - i)]
                                } : this._offset
                            }
                            this._popup = t,
                            t._marker = this,
                            this._lngLat && this._popup.setLngLat(this._lngLat),
                            this._element.setAttribute("role", "button"),
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress),
                            this._element.setAttribute("aria-expanded", "false")
                        }
                        return this
                    }
                    _onKeyPress(t) {
                        const e = t.code
                          , i = t.charCode || t.keyCode;
                        "Space" !== e && "Enter" !== e && 32 !== i && 13 !== i || this.togglePopup()
                    }
                    _onMapClick(t) {
                        const e = t.originalEvent.target
                          , i = this._element;
                        this._popup && (e === i || i.contains(e)) && this.togglePopup()
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const t = this._popup;
                        return t ? (t.isOpen() ? (t.remove(),
                        this._element.setAttribute("aria-expanded", "false")) : this._map && (t.addTo(this._map),
                        this._element.setAttribute("aria-expanded", "true")),
                        this) : this
                    }
                    _behindTerrain() {
                        const t = this._map
                          , e = this._pos;
                        if (!t || !e)
                            return !1;
                        const i = t.unproject(e)
                          , n = t.getFreeCameraOptions();
                        if (!n.position)
                            return !1;
                        const r = n.position.toLngLat();
                        return r.distanceTo(i) < .9 * r.distanceTo(this._lngLat)
                    }
                    _evaluateOpacity() {
                        const e = this._map;
                        if (!e)
                            return;
                        const i = this._pos;
                        if (!i || i.x < 0 || i.x > e.transform.width || i.y < 0 || i.y > e.transform.height)
                            return void this._clearFadeTimer();
                        const n = e.unproject(i);
                        let r;
                        e._showingGlobe() && t.isLngLatBehindGlobe(e.transform, this._lngLat) ? r = 0 : (r = 1 - e._queryFogOpacity(n),
                        e.transform._terrainEnabled() && e.getTerrain() && this._behindTerrain() && (r *= this._occludedOpacity)),
                        this._element.style.opacity = `${r}`,
                        this._element.style.pointerEvents = r > 0 ? "auto" : "none",
                        this._popup && this._popup._setOpacity(r),
                        this._fadeTimer = null
                    }
                    _clearFadeTimer() {
                        this._fadeTimer && (clearTimeout(this._fadeTimer),
                        this._fadeTimer = null)
                    }
                    _updateDOM() {
                        const t = this._pos;
                        if (!t || !this._map)
                            return;
                        const e = this._offset.mult(this._scale);
                        this._element.style.transform = `\n            translate(${t.x}px,${t.y}px)\n            ${to[this._anchor]}\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\n            translate(${e.x}px,${e.y}px)\n        `
                    }
                    _calculateXYTransform() {
                        const e = this._pos
                          , i = this._map
                          , n = this.getPitchAlignment();
                        if (!i || !e || "map" !== n)
                            return "";
                        if (!i._showingGlobe()) {
                            const t = i.getPitch();
                            return t ? `rotateX(${t}deg)` : ""
                        }
                        const r = t.radToDeg(t.globeTiltAtLngLat(i.transform, this._lngLat))
                          , o = e.sub(t.globeCenterToScreenPoint(i.transform))
                          , s = Math.abs(o.x) + Math.abs(o.y);
                        if (0 === s)
                            return "";
                        const a = r / s;
                        return `rotateX(${-o.y * a}deg) rotateY(${o.x * a}deg)`
                    }
                    _calculateZTransform() {
                        const e = this._pos
                          , i = this._map;
                        if (!i || !e)
                            return "";
                        let n = 0;
                        const r = this.getRotationAlignment();
                        if ("map" === r)
                            if (i._showingGlobe()) {
                                const e = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat + .001))
                                  , r = i.project(new t.LngLat(this._lngLat.lng,this._lngLat.lat - .001)).sub(e);
                                n = t.radToDeg(Math.atan2(r.y, r.x)) - 90
                            } else
                                n = -i.getBearing();
                        else if ("horizon" === r) {
                            const r = t.smoothstep(4, 6, i.getZoom())
                              , o = t.globeCenterToScreenPoint(i.transform);
                            o.y += r * i.transform.height;
                            const s = e.sub(o)
                              , a = t.radToDeg(Math.atan2(s.y, s.x));
                            n = (a > 90 ? a - 270 : a + 90) * (1 - r)
                        }
                        return n += this._rotation,
                        n ? `rotateZ(${n}deg)` : ""
                    }
                    _update(e) {
                        t.window.cancelAnimationFrame(this._updateFrameId);
                        const i = this._map;
                        i && (i.transform.renderWorldCopies && (this._lngLat = Qr(this._lngLat, this._pos, i.transform)),
                        this._pos = i.project(this._lngLat),
                        !0 === e ? this._updateFrameId = t.window.requestAnimationFrame(( () => {
                            this._element && this._pos && this._anchor && (this._pos = this._pos.round(),
                            this._updateDOM())
                        }
                        )) : this._pos = this._pos.round(),
                        i._requestDomTask(( () => {
                            this._map && (this._element && this._pos && this._anchor && this._updateDOM(),
                            (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)))
                        }
                        )))
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(e) {
                        return this._offset = t.Point.convert(e),
                        this._update(),
                        this
                    }
                    _onMove(e) {
                        const i = this._map;
                        if (!i)
                            return;
                        const n = this._pointerdownPos
                          , r = this._positionDelta;
                        if (n && r) {
                            if (!this._isDragging) {
                                const t = this._clickTolerance || i._clickTolerance;
                                if (e.point.dist(n) < t)
                                    return;
                                this._isDragging = !0
                            }
                            this._pos = e.point.sub(r),
                            this._lngLat = i.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            "pending" === this._state && (this._state = "active",
                            this.fire(new t.Event("dragstart"))),
                            this.fire(new t.Event("drag"))
                        }
                    }
                    _onUp() {
                        this._element.style.pointerEvents = "auto",
                        this._positionDelta = null,
                        this._pointerdownPos = null,
                        this._isDragging = !1;
                        const e = this._map;
                        e && (e.off("mousemove", this._onMove),
                        e.off("touchmove", this._onMove)),
                        "active" === this._state && this.fire(new t.Event("dragend")),
                        this._state = "inactive"
                    }
                    _addDragHandler(t) {
                        const e = this._map
                          , i = this._pos;
                        e && i && this._element.contains(t.originalEvent.target) && (t.preventDefault(),
                        this._positionDelta = t.point.sub(i),
                        this._pointerdownPos = t.point,
                        this._state = "pending",
                        e.on("mousemove", this._onMove),
                        e.on("touchmove", this._onMove),
                        e.once("mouseup", this._onUp),
                        e.once("touchend", this._onUp))
                    }
                    setDraggable(t) {
                        this._draggable = !!t;
                        const e = this._map;
                        return e && (t ? (e.on("mousedown", this._addDragHandler),
                        e.on("touchstart", this._addDragHandler)) : (e.off("mousedown", this._addDragHandler),
                        e.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(t) {
                        return this._rotation = t || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(t) {
                        return this._rotationAlignment = t || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment
                    }
                    setPitchAlignment(t) {
                        return this._pitchAlignment = t || "auto",
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment
                    }
                    setOccludedOpacity(t) {
                        return this._occludedOpacity = t || .2,
                        this._update(),
                        this
                    }
                    getOccludedOpacity() {
                        return this._occludedOpacity
                    }
                }
                const io = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px"
                }
                  , no = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function ro(e=new t.Point(0,0), i="bottom") {
                    if ("number" == typeof e) {
                        const n = Math.round(Math.sqrt(.5 * Math.pow(e, 2)));
                        switch (i) {
                        case "top":
                            return new t.Point(0,e);
                        case "top-left":
                            return new t.Point(n,n);
                        case "top-right":
                            return new t.Point(-n,n);
                        case "bottom":
                            return new t.Point(0,-e);
                        case "bottom-left":
                            return new t.Point(n,-n);
                        case "bottom-right":
                            return new t.Point(-n,-n);
                        case "left":
                            return new t.Point(e,0);
                        case "right":
                            return new t.Point(-e,0)
                        }
                        return new t.Point(0,0)
                    }
                    return e instanceof t.Point || Array.isArray(e) ? t.Point.convert(e) : t.Point.convert(e[i] || [0, 0])
                }
                class oo {
                    constructor(t) {
                        this.jumpTo(t)
                    }
                    getValue(e) {
                        if (e <= this._startTime)
                            return this._start;
                        if (e >= this._endTime)
                            return this._end;
                        const i = t.easeCubicInOut((e - this._startTime) / (this._endTime - this._startTime));
                        return this._start * (1 - i) + this._end * i
                    }
                    isEasing(t) {
                        return t >= this._startTime && t <= this._endTime
                    }
                    jumpTo(t) {
                        this._startTime = -1 / 0,
                        this._endTime = -1 / 0,
                        this._start = t,
                        this._end = t
                    }
                    easeTo(t, e, i) {
                        this._start = this.getValue(e),
                        this._end = t,
                        this._startTime = e,
                        this._endTime = e + i
                    }
                }
                const so = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "Mapbox logo",
                    "Map.Title": "Map",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map",
                    "ScrollZoomBlocker.CmdMessage": "Use  + scroll to zoom the map",
                    "TouchPanBlocker.Message": "Use two fingers to move the map"
                }
                  , ao = {
                    center: [0, 0],
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 85,
                    interactive: !0,
                    scrollZoom: !0,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    performanceMetricsCollection: !0,
                    bearingSnap: 7,
                    clickTolerance: 3,
                    pitchWithRotate: !0,
                    hash: !1,
                    attributionControl: !0,
                    failIfMajorPerformanceCaveat: !1,
                    preserveDrawingBuffer: !1,
                    trackResize: !0,
                    optimizeForTerrain: !0,
                    renderWorldCopies: !0,
                    refreshExpiredTiles: !0,
                    minTileCacheSize: null,
                    maxTileCacheSize: null,
                    localIdeographFontFamily: "sans-serif",
                    localFontFamily: null,
                    transformRequest: null,
                    accessToken: null,
                    fadeDuration: 300,
                    respectPrefersReducedMotion: !0,
                    crossSourceCollisions: !0
                }
                  , lo = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1
                };
                class co {
                    constructor(e, i, n=!1) {
                        this._clickTolerance = 10,
                        this.element = i,
                        this.mouseRotate = new br({
                            clickTolerance: e.dragRotate._mouseRotate._clickTolerance
                        }),
                        this.map = e,
                        n && (this.mousePitch = new wr({
                            clickTolerance: e.dragRotate._mousePitch._clickTolerance
                        })),
                        t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this),
                        i.addEventListener("mousedown", this.mousedown),
                        i.addEventListener("touchstart", this.touchstart, {
                            passive: !1
                        }),
                        i.addEventListener("touchmove", this.touchmove),
                        i.addEventListener("touchend", this.touchend),
                        i.addEventListener("touchcancel", this.reset)
                    }
                    down(t, e) {
                        this.mouseRotate.mousedown(t, e),
                        this.mousePitch && this.mousePitch.mousedown(t, e),
                        u()
                    }
                    move(t, e) {
                        const i = this.map
                          , n = this.mouseRotate.mousemoveWindow(t, e)
                          , r = n && n.bearingDelta;
                        if (r && i.setBearing(i.getBearing() + r),
                        this.mousePitch) {
                            const n = this.mousePitch.mousemoveWindow(t, e)
                              , r = n && n.pitchDelta;
                            r && i.setPitch(i.getPitch() + r)
                        }
                    }
                    off() {
                        const t = this.element;
                        t.removeEventListener("mousedown", this.mousedown),
                        t.removeEventListener("touchstart", this.touchstart, {
                            passive: !1
                        }),
                        t.removeEventListener("touchmove", this.touchmove),
                        t.removeEventListener("touchend", this.touchend),
                        t.removeEventListener("touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        d(),
                        t.window.removeEventListener("mousemove", this.mousemove),
                        t.window.removeEventListener("mouseup", this.mouseup)
                    }
                    mousedown(e) {
                        this.down(t.extend({}, e, {
                            ctrlKey: !0,
                            preventDefault: () => e.preventDefault()
                        }), m(this.element, e)),
                        t.window.addEventListener("mousemove", this.mousemove),
                        t.window.addEventListener("mouseup", this.mouseup)
                    }
                    mousemove(t) {
                        this.move(t, m(this.element, t))
                    }
                    mouseup(t) {
                        this.mouseRotate.mouseupWindow(t),
                        this.mousePitch && this.mousePitch.mouseupWindow(t),
                        this.offTemp()
                    }
                    touchstart(t) {
                        1 !== t.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = g(this.element, t.targetTouches)[0],
                        this.down({
                            type: "mousedown",
                            button: 0,
                            ctrlKey: !0,
                            preventDefault: () => t.preventDefault()
                        }, this._startPos))
                    }
                    touchmove(t) {
                        1 !== t.targetTouches.length ? this.reset() : (this._lastPos = g(this.element, t.targetTouches)[0],
                        this.move({
                            preventDefault: () => t.preventDefault()
                        }, this._lastPos))
                    }
                    touchend(t) {
                        0 === t.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                        this.reset()
                    }
                    reset() {
                        this.mouseRotate.reset(),
                        this.mousePitch && this.mousePitch.reset(),
                        delete this._startPos,
                        delete this._lastPos,
                        this.offTemp()
                    }
                }
                const ho = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0,
                    showUserHeading: !1
                }
                  , uo = {
                    maxWidth: 100,
                    unit: "metric"
                }
                  , fo = {
                    kilometer: "km",
                    meter: "m",
                    mile: "mi",
                    foot: "ft",
                    "nautical-mile": "nm"
                }
                  , po = {
                    version: t.version,
                    supported: i,
                    setRTLTextPlugin: t.setRTLTextPlugin,
                    getRTLTextPluginStatus: t.getRTLTextPluginStatus,
                    Map: class extends Xr {
                        constructor(e) {
                            if (t.LivePerformanceUtils.mark(t.PerformanceMarkers.create),
                            null != (e = t.extend({}, ao, e)).minZoom && null != e.maxZoom && e.minZoom > e.maxZoom)
                                throw new Error("maxZoom must be greater than or equal to minZoom");
                            if (null != e.minPitch && null != e.maxPitch && e.minPitch > e.maxPitch)
                                throw new Error("maxPitch must be greater than or equal to minPitch");
                            if (null != e.minPitch && e.minPitch < 0)
                                throw new Error("minPitch must be greater than or equal to 0");
                            if (null != e.maxPitch && e.maxPitch > 85)
                                throw new Error("maxPitch must be less than or equal to 85");
                            if (e.antialias && t.isSafariWithAntialiasingBug(t.window) && (e.antialias = !1,
                            t.warnOnce("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")),
                            super(new Yn(e.minZoom,e.maxZoom,e.minPitch,e.maxPitch,e.renderWorldCopies), e),
                            this._interactive = e.interactive,
                            this._minTileCacheSize = e.minTileCacheSize,
                            this._maxTileCacheSize = e.maxTileCacheSize,
                            this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat,
                            this._preserveDrawingBuffer = e.preserveDrawingBuffer,
                            this._antialias = e.antialias,
                            this._useWebGL2 = e.useWebGL2,
                            this._trackResize = e.trackResize,
                            this._bearingSnap = e.bearingSnap,
                            this._refreshExpiredTiles = e.refreshExpiredTiles,
                            this._fadeDuration = e.fadeDuration,
                            this._isInitialLoad = !0,
                            this._crossSourceCollisions = e.crossSourceCollisions,
                            this._collectResourceTiming = e.collectResourceTiming,
                            this._optimizeForTerrain = e.optimizeForTerrain,
                            this._language = this._parseLanguage(e.language),
                            this._worldview = e.worldview,
                            this._renderTaskQueue = new Jr,
                            this._domRenderTaskQueue = new Jr,
                            this._controls = [],
                            this._markers = [],
                            this._popups = [],
                            this._mapId = t.uniqueId(),
                            this._locale = t.extend({}, so, e.locale),
                            this._clickTolerance = e.clickTolerance,
                            this._cooperativeGestures = e.cooperativeGestures,
                            this._performanceMetricsCollection = e.performanceMetricsCollection,
                            this._containerWidth = 0,
                            this._containerHeight = 0,
                            this._averageElevationLastSampledAt = -1 / 0,
                            this._averageElevationExaggeration = 0,
                            this._averageElevation = new oo(0),
                            this._interactionRange = [1 / 0, -1 / 0],
                            this._visibilityHidden = 0,
                            this._useExplicitProjection = !1,
                            this._requestManager = new t.RequestManager(e.transformRequest,e.accessToken,e.testMode),
                            this._silenceAuthErrors = !!e.testMode,
                            "string" == typeof e.container) {
                                if (this._container = t.window.document.getElementById(e.container),
                                !this._container)
                                    throw new Error(`Container '${e.container}' not found.`)
                            } else {
                                if (!(e.container instanceof t.window.HTMLElement))
                                    throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                                this._container = e.container
                            }
                            if (this._container.childNodes.length > 0 && t.warnOnce("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."),
                            e.maxBounds && this.setMaxBounds(e.maxBounds),
                            t.bindAll(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this),
                            this._setupContainer(),
                            this._setupPainter(),
                            void 0 === this.painter)
                                throw new Error("Failed to initialize WebGL.");
                            this.on("move", ( () => this._update(!1))),
                            this.on("moveend", ( () => this._update(!1))),
                            this.on("zoom", ( () => this._update(!0))),
                            void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, !1),
                            t.window.addEventListener("resize", this._onWindowResize, !1),
                            t.window.addEventListener("orientationchange", this._onWindowResize, !1),
                            t.window.addEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                            t.window.addEventListener("visibilitychange", this._onVisibilityChange, !1)),
                            this.handlers = new Hr(this,e),
                            this._localFontFamily = e.localFontFamily,
                            this._localIdeographFontFamily = e.localIdeographFontFamily,
                            e.style && this.setStyle(e.style, {
                                localFontFamily: this._localFontFamily,
                                localIdeographFontFamily: this._localIdeographFontFamily
                            }),
                            e.projection && this.setProjection(e.projection),
                            this._hash = e.hash && new Jn("string" == typeof e.hash && e.hash || void 0).addTo(this),
                            this._hash && this._hash._onHashChange() || (this.jumpTo({
                                center: e.center,
                                zoom: e.zoom,
                                bearing: e.bearing,
                                pitch: e.pitch
                            }),
                            e.bounds && (this.resize(),
                            this.fitBounds(e.bounds, t.extend({}, e.fitBoundsOptions, {
                                duration: 0
                            })))),
                            this.resize(),
                            e.attributionControl && this.addControl(new Yr({
                                customAttribution: e.customAttribution
                            })),
                            this._logoControl = new Kr,
                            this.addControl(this._logoControl, e.logoPosition),
                            this.on("style.load", ( () => {
                                this.transform.unmodified && this.jumpTo(this.style.stylesheet)
                            }
                            )),
                            this.on("data", (e => {
                                this._update("style" === e.dataType),
                                this.fire(new t.Event(`${e.dataType}data`,e))
                            }
                            )),
                            this.on("dataloading", (e => {
                                this.fire(new t.Event(`${e.dataType}dataloading`,e))
                            }
                            ))
                        }
                        _getMapId() {
                            return this._mapId
                        }
                        addControl(e, i) {
                            if (void 0 === i && (i = e.getDefaultPosition ? e.getDefaultPosition() : "top-right"),
                            !e || !e.onAdd)
                                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const n = e.onAdd(this);
                            this._controls.push(e);
                            const r = this._controlPositions[i];
                            return -1 !== i.indexOf("bottom") ? r.insertBefore(n, r.firstChild) : r.appendChild(n),
                            this
                        }
                        removeControl(e) {
                            if (!e || !e.onRemove)
                                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                            const i = this._controls.indexOf(e);
                            return i > -1 && this._controls.splice(i, 1),
                            e.onRemove(this),
                            this
                        }
                        hasControl(t) {
                            return this._controls.indexOf(t) > -1
                        }
                        getContainer() {
                            return this._container
                        }
                        getCanvasContainer() {
                            return this._canvasContainer
                        }
                        getCanvas() {
                            return this._canvas
                        }
                        resize(e) {
                            if (this._updateContainerDimensions(),
                            this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)
                                return this;
                            this._resizeCanvas(this._containerWidth, this._containerHeight),
                            this.transform.resize(this._containerWidth, this._containerHeight),
                            this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
                            const i = !this._moving;
                            return i && this.fire(new t.Event("movestart",e)).fire(new t.Event("move",e)),
                            this.fire(new t.Event("resize",e)),
                            i && this.fire(new t.Event("moveend",e)),
                            this
                        }
                        getBounds() {
                            return this.transform.getBounds()
                        }
                        getMaxBounds() {
                            return this.transform.getMaxBounds() || null
                        }
                        setMaxBounds(e) {
                            return this.transform.setMaxBounds(t.LngLatBounds.convert(e)),
                            this._update()
                        }
                        setMinZoom(e) {
                            if ((e = null == e ? -2 : e) >= -2 && e <= this.transform.maxZoom)
                                return this.transform.minZoom = e,
                                this._update(),
                                this.getZoom() < e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                                this;
                            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                        }
                        getMinZoom() {
                            return this.transform.minZoom
                        }
                        setMaxZoom(e) {
                            if ((e = null == e ? 22 : e) >= this.transform.minZoom)
                                return this.transform.maxZoom = e,
                                this._update(),
                                this.getZoom() > e ? this.setZoom(e) : this.fire(new t.Event("zoomstart")).fire(new t.Event("zoom")).fire(new t.Event("zoomend")),
                                this;
                            throw new Error("maxZoom must be greater than the current minZoom")
                        }
                        getMaxZoom() {
                            return this.transform.maxZoom
                        }
                        setMinPitch(e) {
                            if ((e = null == e ? 0 : e) < 0)
                                throw new Error("minPitch must be greater than or equal to 0");
                            if (e >= 0 && e <= this.transform.maxPitch)
                                return this.transform.minPitch = e,
                                this._update(),
                                this.getPitch() < e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                                this;
                            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                        }
                        getMinPitch() {
                            return this.transform.minPitch
                        }
                        setMaxPitch(e) {
                            if ((e = null == e ? 85 : e) > 85)
                                throw new Error("maxPitch must be less than or equal to 85");
                            if (e >= this.transform.minPitch)
                                return this.transform.maxPitch = e,
                                this._update(),
                                this.getPitch() > e ? this.setPitch(e) : this.fire(new t.Event("pitchstart")).fire(new t.Event("pitch")).fire(new t.Event("pitchend")),
                                this;
                            throw new Error("maxPitch must be greater than or equal to minPitch")
                        }
                        getMaxPitch() {
                            return this.transform.maxPitch
                        }
                        getRenderWorldCopies() {
                            return this.transform.renderWorldCopies
                        }
                        setRenderWorldCopies(t) {
                            return this.transform.renderWorldCopies = t,
                            this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0),
                            this._update()
                        }
                        getLanguage() {
                            return this._language
                        }
                        _parseLanguage(e) {
                            return "auto" === e ? t.window.navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map((e => "auto" === e ? t.window.navigator.language : e)) : e
                        }
                        setLanguage(t) {
                            const e = this._parseLanguage(t);
                            if (!this.style || e === this._language)
                                return this;
                            this._language = e,
                            this.style._reloadSources();
                            for (const t of this._controls)
                                t._setLanguage && t._setLanguage(this._language);
                            return this
                        }
                        getWorldview() {
                            return this._worldview
                        }
                        setWorldview(t) {
                            return this.style && t !== this._worldview ? (this._worldview = t,
                            this.style._reloadSources(),
                            this) : this
                        }
                        getProjection() {
                            return this.transform.mercatorFromTransition ? {
                                name: "globe",
                                center: [0, 0]
                            } : this.transform.getProjection()
                        }
                        _showingGlobe() {
                            return "globe" === this.transform.projection.name
                        }
                        setProjection(t) {
                            return this._lazyInitEmptyStyle(),
                            t ? "string" == typeof t && (t = {
                                name: t
                            }) : t = null,
                            this._useExplicitProjection = !!t,
                            this._prioritizeAndUpdateProjection(t, this.style.stylesheet ? this.style.stylesheet.projection : null)
                        }
                        _updateProjectionTransition() {
                            if ("globe" !== this.getProjection().name)
                                return;
                            const e = this.transform
                              , i = e.projection.name;
                            let n;
                            "globe" === i && e.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? (e.setMercatorFromTransition(),
                            n = !0) : "mercator" === i && e.zoom < t.GLOBE_ZOOM_THRESHOLD_MAX && (e.setProjection({
                                name: "globe"
                            }),
                            n = !0),
                            n && (this.style.applyProjectionUpdate(),
                            this.style._forceSymbolLayerUpdate())
                        }
                        _prioritizeAndUpdateProjection(t, e) {
                            return this._updateProjection(t || e || {
                                name: "mercator"
                            })
                        }
                        _updateProjection(e) {
                            let i;
                            if (i = "globe" === e.name && this.transform.zoom >= t.GLOBE_ZOOM_THRESHOLD_MAX ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e),
                            this.style.applyProjectionUpdate(),
                            i) {
                                this.painter.clearBackgroundTiles();
                                for (const t in this.style._sourceCaches)
                                    this.style._sourceCaches[t].clearTiles();
                                this._update(!0),
                                this._forceMarkerAndPopupUpdate(!0)
                            }
                            return this
                        }
                        project(e) {
                            return this.transform.locationPoint3D(t.LngLat.convert(e))
                        }
                        unproject(e) {
                            return this.transform.pointLocation3D(t.Point.convert(e))
                        }
                        isMoving() {
                            return this._moving || this.handlers && this.handlers.isMoving() || !1
                        }
                        isZooming() {
                            return this._zooming || this.handlers && this.handlers.isZooming() || !1
                        }
                        isRotating() {
                            return this._rotating || this.handlers && this.handlers.isRotating() || !1
                        }
                        _isDragging() {
                            return this.handlers && this.handlers._isDragging() || !1
                        }
                        _createDelegatedListener(t, e, i) {
                            if ("mouseenter" === t || "mouseover" === t) {
                                let n = !1;
                                const r = r => {
                                    const o = e.filter((t => this.getLayer(t)))
                                      , s = o.length ? this.queryRenderedFeatures(r.point, {
                                        layers: o
                                    }) : [];
                                    s.length ? n || (n = !0,
                                    i.call(this, new lr(t,this,r.originalEvent,{
                                        features: s
                                    }))) : n = !1
                                }
                                  , o = () => {
                                    n = !1
                                }
                                ;
                                return {
                                    layers: new Set(e),
                                    listener: i,
                                    delegates: {
                                        mousemove: r,
                                        mouseout: o
                                    }
                                }
                            }
                            if ("mouseleave" === t || "mouseout" === t) {
                                let n = !1;
                                const r = r => {
                                    const o = e.filter((t => this.getLayer(t)));
                                    (o.length ? this.queryRenderedFeatures(r.point, {
                                        layers: o
                                    }) : []).length ? n = !0 : n && (n = !1,
                                    i.call(this, new lr(t,this,r.originalEvent)))
                                }
                                  , o = e => {
                                    n && (n = !1,
                                    i.call(this, new lr(t,this,e.originalEvent)))
                                }
                                ;
                                return {
                                    layers: new Set(e),
                                    listener: i,
                                    delegates: {
                                        mousemove: r,
                                        mouseout: o
                                    }
                                }
                            }
                            {
                                const n = t => {
                                    const n = e.filter((t => this.getLayer(t)))
                                      , r = n.length ? this.queryRenderedFeatures(t.point, {
                                        layers: n
                                    }) : [];
                                    r.length && (t.features = r,
                                    i.call(this, t),
                                    delete t.features)
                                }
                                ;
                                return {
                                    layers: new Set(e),
                                    listener: i,
                                    delegates: {
                                        [t]: n
                                    }
                                }
                            }
                        }
                        on(t, e, i) {
                            if (void 0 === i)
                                return super.on(t, e);
                            Array.isArray(e) || (e = [e]);
                            const n = this._createDelegatedListener(t, e, i);
                            this._delegatedListeners = this._delegatedListeners || {},
                            this._delegatedListeners[t] = this._delegatedListeners[t] || [],
                            this._delegatedListeners[t].push(n);
                            for (const t in n.delegates)
                                this.on(t, n.delegates[t]);
                            return this
                        }
                        once(t, e, i) {
                            if (void 0 === i)
                                return super.once(t, e);
                            Array.isArray(e) || (e = [e]);
                            const n = this._createDelegatedListener(t, e, i);
                            for (const t in n.delegates)
                                this.once(t, n.delegates[t]);
                            return this
                        }
                        off(t, e, i) {
                            if (void 0 === i)
                                return super.off(t, e);
                            e = new Set(Array.isArray(e) ? e : [e]);
                            const n = (t, e) => {
                                if (t.size !== e.size)
                                    return !1;
                                for (const i of t)
                                    if (!e.has(i))
                                        return !1;
                                return !0
                            }
                              , r = this._delegatedListeners ? this._delegatedListeners[t] : void 0;
                            return r && (t => {
                                for (let r = 0; r < t.length; r++) {
                                    const o = t[r];
                                    if (o.listener === i && n(o.layers, e)) {
                                        for (const t in o.delegates)
                                            this.off(t, o.delegates[t]);
                                        return t.splice(r, 1),
                                        this
                                    }
                                }
                            }
                            )(r),
                            this
                        }
                        queryRenderedFeatures(e, i) {
                            return this.style ? (void 0 !== i || void 0 === e || e instanceof t.Point || Array.isArray(e) || (i = e,
                            e = void 0),
                            this.style.queryRenderedFeatures(e = e || [[0, 0], [this.transform.width, this.transform.height]], i = i || {}, this.transform)) : []
                        }
                        querySourceFeatures(t, e) {
                            return this.style.querySourceFeatures(t, e)
                        }
                        isPointOnSurface(e) {
                            const {name: i} = this.transform.projection;
                            return "globe" !== i && "mercator" !== i && t.warnOnce(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`),
                            this.transform.isPointOnSurface(t.Point.convert(e))
                        }
                        setStyle(e, i) {
                            return !1 !== (i = t.extend({}, {
                                localIdeographFontFamily: this._localIdeographFontFamily,
                                localFontFamily: this._localFontFamily
                            }, i)).diff && i.localIdeographFontFamily === this._localIdeographFontFamily && i.localFontFamily === this._localFontFamily && this.style && e ? (this._diffStyle(e, i),
                            this) : (this._localIdeographFontFamily = i.localIdeographFontFamily,
                            this._localFontFamily = i.localFontFamily,
                            this._updateStyle(e, i))
                        }
                        _getUIString(t) {
                            const e = this._locale[t];
                            if (null == e)
                                throw new Error(`Missing UI string '${t}'`);
                            return e
                        }
                        _updateStyle(t, e) {
                            return this.style && (this.style.setEventedParent(null),
                            this.style._remove(),
                            this.style = void 0),
                            t && (this.style = new Je(this,e || {}),
                            this.style.setEventedParent(this, {
                                style: this.style
                            }),
                            "string" == typeof t ? this.style.loadURL(t) : this.style.loadJSON(t)),
                            this._updateTerrain(),
                            this
                        }
                        _lazyInitEmptyStyle() {
                            this.style || (this.style = new Je(this,{}),
                            this.style.setEventedParent(this, {
                                style: this.style
                            }),
                            this.style.loadEmpty())
                        }
                        _diffStyle(e, i) {
                            if ("string" == typeof e) {
                                const n = this._requestManager.normalizeStyleURL(e)
                                  , r = this._requestManager.transformRequest(n, t.ResourceType.Style);
                                t.getJSON(r, ( (e, n) => {
                                    e ? this.fire(new t.ErrorEvent(e)) : n && this._updateDiff(n, i)
                                }
                                ))
                            } else
                                "object" == typeof e && this._updateDiff(e, i)
                        }
                        _updateDiff(e, i) {
                            try {
                                this.style.setState(e) && this._update(!0)
                            } catch (n) {
                                t.warnOnce(`Unable to perform style diff: ${n.message || n.error || n}.  Rebuilding the style from scratch.`),
                                this._updateStyle(e, i)
                            }
                        }
                        getStyle() {
                            if (this.style)
                                return this.style.serialize()
                        }
                        isStyleLoaded() {
                            return this.style ? this.style.loaded() : (t.warnOnce("There is no style added to the map."),
                            !1)
                        }
                        addSource(t, e) {
                            return this._lazyInitEmptyStyle(),
                            this.style.addSource(t, e),
                            this._update(!0)
                        }
                        isSourceLoaded(t) {
                            return !!this.style && this.style._isSourceCacheLoaded(t)
                        }
                        areTilesLoaded() {
                            const t = this.style && this.style._sourceCaches;
                            for (const e in t) {
                                const i = t[e]._tiles;
                                for (const t in i) {
                                    const e = i[t];
                                    if ("loaded" !== e.state && "errored" !== e.state)
                                        return !1
                                }
                            }
                            return !0
                        }
                        addSourceType(t, e, i) {
                            this._lazyInitEmptyStyle(),
                            this.style.addSourceType(t, e, i)
                        }
                        removeSource(t) {
                            return this.style.removeSource(t),
                            this._updateTerrain(),
                            this._update(!0)
                        }
                        getSource(t) {
                            return this.style.getSource(t)
                        }
                        addImage(e, i, {pixelRatio: n=1, sdf: r=!1, stretchX: o, stretchY: s, content: a}={}) {
                            if (this._lazyInitEmptyStyle(),
                            i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap) {
                                const {width: l, height: c, data: h} = t.exported.getImageData(i);
                                this.style.addImage(e, {
                                    data: new t.RGBAImage({
                                        width: l,
                                        height: c
                                    },h),
                                    pixelRatio: n,
                                    stretchX: o,
                                    stretchY: s,
                                    content: a,
                                    sdf: r,
                                    version: 0
                                })
                            } else if (void 0 === i.width || void 0 === i.height)
                                this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            else {
                                const {width: l, height: c} = i
                                  , h = i;
                                this.style.addImage(e, {
                                    data: new t.RGBAImage({
                                        width: l,
                                        height: c
                                    },new Uint8Array(h.data)),
                                    pixelRatio: n,
                                    stretchX: o,
                                    stretchY: s,
                                    content: a,
                                    sdf: r,
                                    version: 0,
                                    userImage: h
                                }),
                                h.onAdd && h.onAdd(this, e)
                            }
                        }
                        updateImage(e, i) {
                            const n = this.style.getImage(e);
                            if (!n)
                                return void this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                            const r = i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap ? t.exported.getImageData(i) : i
                              , {width: o, height: s} = r;
                            void 0 !== o && void 0 !== s ? o === n.data.width && s === n.data.height ? (n.data.replace(r.data, !(i instanceof t.window.HTMLImageElement || t.window.ImageBitmap && i instanceof t.window.ImageBitmap)),
                            this.style.updateImage(e, n)) : this.fire(new t.ErrorEvent(new Error(`The width and height of the updated image (${o}, ${s})\n                must be that same as the previous version of the image\n                (${n.data.width}, ${n.data.height})`))) : this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")))
                        }
                        hasImage(e) {
                            return e ? !!this.style.getImage(e) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))),
                            !1)
                        }
                        removeImage(t) {
                            this.style.removeImage(t)
                        }
                        loadImage(e, i) {
                            t.getImage(this._requestManager.transformRequest(e, t.ResourceType.Image), ( (e, n) => {
                                i(e, n instanceof t.window.HTMLImageElement ? t.exported.getImageData(n) : n)
                            }
                            ))
                        }
                        listImages() {
                            return this.style.listImages()
                        }
                        addLayer(t, e) {
                            return this._lazyInitEmptyStyle(),
                            this.style.addLayer(t, e),
                            this._update(!0)
                        }
                        moveLayer(t, e) {
                            return this.style.moveLayer(t, e),
                            this._update(!0)
                        }
                        removeLayer(t) {
                            return this.style.removeLayer(t),
                            this._update(!0)
                        }
                        getLayer(t) {
                            return this.style.getLayer(t)
                        }
                        setLayerZoomRange(t, e, i) {
                            return this.style.setLayerZoomRange(t, e, i),
                            this._update(!0)
                        }
                        setFilter(t, e, i={}) {
                            return this.style.setFilter(t, e, i),
                            this._update(!0)
                        }
                        getFilter(t) {
                            return this.style.getFilter(t)
                        }
                        setPaintProperty(t, e, i, n={}) {
                            return this.style.setPaintProperty(t, e, i, n),
                            this._update(!0)
                        }
                        getPaintProperty(t, e) {
                            return this.style.getPaintProperty(t, e)
                        }
                        setLayoutProperty(t, e, i, n={}) {
                            return this.style.setLayoutProperty(t, e, i, n),
                            this._update(!0)
                        }
                        getLayoutProperty(t, e) {
                            return this.style.getLayoutProperty(t, e)
                        }
                        setLight(t, e={}) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setLight(t, e),
                            this._update(!0)
                        }
                        getLight() {
                            return this.style.getLight()
                        }
                        setTerrain(t) {
                            return this._lazyInitEmptyStyle(),
                            !t && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(t),
                            this._averageElevationLastSampledAt = -1 / 0,
                            this._update(!0)
                        }
                        getTerrain() {
                            return this.style ? this.style.getTerrain() : null
                        }
                        setFog(t) {
                            return this._lazyInitEmptyStyle(),
                            this.style.setFog(t),
                            this._update(!0)
                        }
                        getFog() {
                            return this.style ? this.style.getFog() : null
                        }
                        _queryFogOpacity(e) {
                            return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(t.LngLat.convert(e), this.transform) : 0
                        }
                        setFeatureState(t, e) {
                            return this.style.setFeatureState(t, e),
                            this._update()
                        }
                        removeFeatureState(t, e) {
                            return this.style.removeFeatureState(t, e),
                            this._update()
                        }
                        getFeatureState(t) {
                            return this.style.getFeatureState(t)
                        }
                        _updateContainerDimensions() {
                            if (!this._container)
                                return;
                            const e = this._container.getBoundingClientRect().width || 400
                              , i = this._container.getBoundingClientRect().height || 300;
                            let n, r, o, s = this._container;
                            for (; s && (!r || !o); ) {
                                const e = t.window.getComputedStyle(s).transform;
                                e && "none" !== e && (n = e.match(/matrix.*\((.+)\)/)[1].split(", "),
                                n[0] && "0" !== n[0] && "1" !== n[0] && (r = n[0]),
                                n[3] && "0" !== n[3] && "1" !== n[3] && (o = n[3])),
                                s = s.parentElement
                            }
                            this._containerWidth = r ? Math.abs(e / r) : e,
                            this._containerHeight = o ? Math.abs(i / o) : i
                        }
                        _detectMissingCSS() {
                            "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.")
                        }
                        _setupContainer() {
                            const t = this._container;
                            t.classList.add("mapboxgl-map"),
                            (this._missingCSSCanary = s("div", "mapboxgl-canary", t)).style.visibility = "hidden",
                            this._detectMissingCSS();
                            const e = this._canvasContainer = s("div", "mapboxgl-canvas-container", t);
                            this._interactive && e.classList.add("mapboxgl-interactive"),
                            this._canvas = s("canvas", "mapboxgl-canvas", e),
                            this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                            this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                            this._canvas.setAttribute("tabindex", "0"),
                            this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                            this._canvas.setAttribute("role", "region"),
                            this._updateContainerDimensions(),
                            this._resizeCanvas(this._containerWidth, this._containerHeight);
                            const i = this._controlContainer = s("div", "mapboxgl-control-container", t)
                              , n = this._controlPositions = {};
                            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t => {
                                n[t] = s("div", `mapboxgl-ctrl-${t}`, i)
                            }
                            )),
                            this._container.addEventListener("scroll", this._onMapScroll, !1)
                        }
                        _resizeCanvas(e, i) {
                            const n = t.exported.devicePixelRatio || 1;
                            this._canvas.width = n * Math.ceil(e),
                            this._canvas.height = n * Math.ceil(i),
                            this._canvas.style.width = `${e}px`,
                            this._canvas.style.height = `${i}px`
                        }
                        _addMarker(t) {
                            this._markers.push(t)
                        }
                        _removeMarker(t) {
                            const e = this._markers.indexOf(t);
                            -1 !== e && this._markers.splice(e, 1)
                        }
                        _addPopup(t) {
                            this._popups.push(t)
                        }
                        _removePopup(t) {
                            const e = this._popups.indexOf(t);
                            -1 !== e && this._popups.splice(e, 1)
                        }
                        _setupPainter() {
                            const e = t.extend({}, i.webGLContextAttributes, {
                                failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
                                preserveDrawingBuffer: this._preserveDrawingBuffer,
                                antialias: this._antialias || !1
                            })
                              , n = this._useWebGL2 && this._canvas.getContext("webgl2", e)
                              , r = n || this._canvas.getContext("webgl", e) || this._canvas.getContext("experimental-webgl", e);
                            r ? (this._useWebGL2 && !n && t.warnOnce("Failed to create WebGL 2 context. Using WebGL 1."),
                            t.storeAuthState(r, !0),
                            this.painter = new zn(r,this.transform,!!n),
                            this.on("data", (t => {
                                "source" === t.dataType && this.painter.setTileLoadedFlag(!0)
                            }
                            )),
                            t.exported$1.testSupport(r)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")))
                        }
                        _contextLost(e) {
                            e.preventDefault(),
                            this._frame && (this._frame.cancel(),
                            this._frame = null),
                            this.fire(new t.Event("webglcontextlost",{
                                originalEvent: e
                            }))
                        }
                        _contextRestored(e) {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new t.Event("webglcontextrestored",{
                                originalEvent: e
                            }))
                        }
                        _onMapScroll(t) {
                            if (t.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        loaded() {
                            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                        }
                        _update(t) {
                            return this.style ? (this._styleDirty = this._styleDirty || t,
                            this._sourcesDirty = !0,
                            this.triggerRepaint(),
                            this) : this
                        }
                        _requestRenderFrame(t) {
                            return this._update(),
                            this._renderTaskQueue.add(t)
                        }
                        _cancelRenderFrame(t) {
                            this._renderTaskQueue.remove(t)
                        }
                        _requestDomTask(t) {
                            !this.loaded() || this.loaded() && !this.isMoving() ? t() : this._domRenderTaskQueue.add(t)
                        }
                        _render(e) {
                            let i;
                            const n = this.painter.context.extTimerQuery
                              , r = t.exported.now();
                            if (this.listens("gpu-timing-frame") && (i = n.createQueryEXT(),
                            n.beginQueryEXT(n.TIME_ELAPSED_EXT, i)),
                            this.painter.context.setDirty(),
                            this.painter.setBaseState(),
                            (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], t.window.performance.now()),
                            this._interactionRange[1] = Math.max(this._interactionRange[1], t.window.performance.now())),
                            this._renderTaskQueue.run(e),
                            this._domRenderTaskQueue.run(e),
                            this._removed)
                                return;
                            this._updateProjectionTransition();
                            const o = this._isInitialLoad ? 0 : this._fadeDuration;
                            if (this.style && this._styleDirty) {
                                this._styleDirty = !1;
                                const e = this.transform.zoom
                                  , i = this.transform.pitch
                                  , n = t.exported.now()
                                  , r = new t.EvaluationParameters(e,{
                                    now: n,
                                    fadeDuration: o,
                                    pitch: i,
                                    transition: this.style.getTransition()
                                });
                                this.style.update(r)
                            }
                            this.style && this.style.fog && this.style.fog.hasTransition() && (this.style._markersNeedUpdate = !0,
                            this._sourcesDirty = !0);
                            let s = !1;
                            if (this.style && this._sourcesDirty ? (this._sourcesDirty = !1,
                            this.painter._updateFog(this.style),
                            this._updateTerrain(),
                            s = this._updateAverageElevation(r),
                            this.style._updateSources(this.transform),
                            this._forceMarkerAndPopupUpdate()) : s = this._updateAverageElevation(r),
                            this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, o, this._crossSourceCollisions),
                            this.style && this.painter.render(this.style, {
                                showTileBoundaries: this.showTileBoundaries,
                                showTerrainWireframe: this.showTerrainWireframe,
                                showOverdrawInspector: this._showOverdrawInspector,
                                showQueryGeometry: !!this._showQueryGeometry,
                                showTileAABBs: this.showTileAABBs,
                                rotating: this.isRotating(),
                                zooming: this.isZooming(),
                                moving: this.isMoving(),
                                fadeDuration: o,
                                isInitialLoad: this._isInitialLoad,
                                showPadding: this.showPadding,
                                gpuTiming: !!this.listens("gpu-timing-layer"),
                                gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"),
                                speedIndexTiming: this.speedIndexTiming
                            }),
                            this.fire(new t.Event("render")),
                            this.loaded() && !this._loaded && (this._loaded = !0,
                            this.fire(new t.Event("load"))),
                            this.style && this.style.hasTransitions() && (this._styleDirty = !0),
                            this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(),
                            i) {
                                const e = t.exported.now() - r;
                                n.endQueryEXT(n.TIME_ELAPSED_EXT, i),
                                setTimeout(( () => {
                                    const o = n.getQueryObjectEXT(i, n.QUERY_RESULT_EXT) / 1e6;
                                    n.deleteQueryEXT(i),
                                    this.fire(new t.Event("gpu-timing-frame",{
                                        cpuTime: e,
                                        gpuTime: o
                                    })),
                                    t.window.performance.mark("frame-gpu", {
                                        startTime: r,
                                        detail: {
                                            gpuTime: o
                                        }
                                    })
                                }
                                ), 50)
                            }
                            if (this.listens("gpu-timing-layer")) {
                                const e = this.painter.collectGpuTimers();
                                setTimeout(( () => {
                                    const i = this.painter.queryGpuTimers(e);
                                    this.fire(new t.Event("gpu-timing-layer",{
                                        layerTimes: i
                                    }))
                                }
                                ), 50)
                            }
                            if (this.listens("gpu-timing-deferred-render")) {
                                const e = this.painter.collectDeferredRenderGpuQueries();
                                setTimeout(( () => {
                                    const i = this.painter.queryGpuTimeDeferredRender(e);
                                    this.fire(new t.Event("gpu-timing-deferred-render",{
                                        gpuTime: i
                                    }))
                                }
                                ), 50)
                            }
                            const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
                            if (a || this._repaint)
                                this.triggerRepaint();
                            else {
                                const e = !this.isMoving() && this.loaded();
                                if (e && (s = this._updateAverageElevation(r, !0)),
                                s)
                                    this.triggerRepaint();
                                else if (this._triggerFrame(!1),
                                e && (this.fire(new t.Event("idle")),
                                this._isInitialLoad = !1,
                                this.speedIndexTiming)) {
                                    const e = this._calculateSpeedIndex();
                                    this.fire(new t.Event("speedindexcompleted",{
                                        speedIndex: e
                                    })),
                                    this.speedIndexTiming = !1
                                }
                            }
                            !this._loaded || this._fullyLoaded || a || (this._fullyLoaded = !0,
                            t.LivePerformanceUtils.mark(t.PerformanceMarkers.fullLoad),
                            this._performanceMetricsCollection && t.postPerformanceEvent(this._requestManager._customAccessToken, {
                                width: this.painter.width,
                                height: this.painter.height,
                                interactionRange: this._interactionRange,
                                visibilityHidden: this._visibilityHidden,
                                terrainEnabled: !!this.painter.style.getTerrain(),
                                fogEnabled: !!this.painter.style.getFog(),
                                projection: this.getProjection().name,
                                zoom: this.transform.zoom,
                                renderer: this.painter.context.renderer,
                                vendor: this.painter.context.vendor
                            }),
                            this._authenticate())
                        }
                        _forceMarkerAndPopupUpdate(t) {
                            for (const e of this._markers)
                                t && !this.getRenderWorldCopies() && (e._lngLat = e._lngLat.wrap()),
                                e._update();
                            for (const e of this._popups)
                                !t || this.getRenderWorldCopies() || e._trackPointer || (e._lngLat = e._lngLat.wrap()),
                                e._update()
                        }
                        _updateAverageElevation(t, e=!1) {
                            const i = t => (this.transform.averageElevation = t,
                            this._update(!1),
                            !0);
                            if (!this.painter.averageElevationNeedsEasing())
                                return 0 !== this.transform.averageElevation && i(0);
                            if ((e || t - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(t)) {
                                const e = this.transform.averageElevation;
                                let n = this.transform.sampleAverageElevation()
                                  , r = !1;
                                this.transform.elevation && (r = this.transform.elevation.exaggeration() !== this._averageElevationExaggeration,
                                this._averageElevationExaggeration = this.transform.elevation.exaggeration()),
                                isNaN(n) ? n = 0 : this._averageElevationLastSampledAt = t;
                                const o = Math.abs(e - n);
                                if (o > 1) {
                                    if (this._isInitialLoad || r)
                                        return this._averageElevation.jumpTo(n),
                                        i(n);
                                    this._averageElevation.easeTo(n, t, 300)
                                } else if (o > 1e-4)
                                    return this._averageElevation.jumpTo(n),
                                    i(n)
                            }
                            return !!this._averageElevation.isEasing(t) && i(this._averageElevation.getValue(t))
                        }
                        _authenticate() {
                            t.getMapSessionAPI(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e => {
                                if (e && (e.message === t.AUTH_ERR_MSG || 401 === e.status)) {
                                    const e = this.painter.context.gl;
                                    t.storeAuthState(e, !1),
                                    this._logoControl instanceof Kr && this._logoControl._updateLogo(),
                                    e && e.clear(e.DEPTH_BUFFER_BIT | e.COLOR_BUFFER_BIT | e.STENCIL_BUFFER_BIT),
                                    this._silenceAuthErrors || this.fire(new t.ErrorEvent(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")))
                                }
                            }
                            )),
                            t.postMapLoadEvent(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, ( () => {}
                            ))
                        }
                        _updateTerrain() {
                            const t = this._isDragging();
                            this.painter.updateTerrain(this.style, t)
                        }
                        _calculateSpeedIndex() {
                            const t = this.painter.canvasCopy()
                              , e = this.painter.getCanvasCopiesAndTimestamps();
                            e.timeStamps.push(performance.now());
                            const i = this.painter.context.gl
                              , n = i.createFramebuffer();
                            function r(t) {
                                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t, 0);
                                const e = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                                return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, e),
                                e
                            }
                            return i.bindFramebuffer(i.FRAMEBUFFER, n),
                            this._canvasPixelComparison(r(t), e.canvasCopies.map(r), e.timeStamps)
                        }
                        _canvasPixelComparison(t, e, i) {
                            let n = i[1] - i[0];
                            const r = t.length / 4;
                            for (let o = 0; o < e.length; o++) {
                                const s = e[o];
                                let a = 0;
                                for (let e = 0; e < s.length; e += 4)
                                    s[e] === t[e] && s[e + 1] === t[e + 1] && s[e + 2] === t[e + 2] && s[e + 3] === t[e + 3] && (a += 1);
                                n += (i[o + 2] - i[o + 1]) * (1 - a / r)
                            }
                            return n
                        }
                        remove() {
                            this._hash && this._hash.remove();
                            for (const t of this._controls)
                                t.onRemove(this);
                            this._controls = [],
                            this._frame && (this._frame.cancel(),
                            this._frame = null),
                            this._renderTaskQueue.clear(),
                            this._domRenderTaskQueue.clear(),
                            this.style && this.style.destroy(),
                            this.painter.destroy(),
                            this.handlers && this.handlers.destroy(),
                            this.handlers = void 0,
                            this.setStyle(null),
                            void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, !1),
                            t.window.removeEventListener("orientationchange", this._onWindowResize, !1),
                            t.window.removeEventListener("webkitfullscreenchange", this._onWindowResize, !1),
                            t.window.removeEventListener("online", this._onWindowOnline, !1),
                            t.window.removeEventListener("visibilitychange", this._onVisibilityChange, !1));
                            const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                            e && e.loseContext(),
                            this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                            this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                            this._canvasContainer.remove(),
                            this._controlContainer.remove(),
                            this._missingCSSCanary.remove(),
                            this._canvas = void 0,
                            this._canvasContainer = void 0,
                            this._controlContainer = void 0,
                            this._missingCSSCanary = void 0,
                            this._container.classList.remove("mapboxgl-map"),
                            this._container.removeEventListener("scroll", this._onMapScroll, !1),
                            t.removeAuthState(this.painter.context.gl),
                            this._removed = !0,
                            this.fire(new t.Event("remove"))
                        }
                        triggerRepaint() {
                            this._triggerFrame(!0)
                        }
                        _triggerFrame(e) {
                            this._renderNextFrame = this._renderNextFrame || e,
                            this.style && !this._frame && (this._frame = t.exported.frame((t => {
                                const e = !!this._renderNextFrame;
                                this._frame = null,
                                this._renderNextFrame = null,
                                e && this._render(t)
                            }
                            )))
                        }
                        _preloadTiles(e) {
                            const i = this.style ? Object.values(this.style._sourceCaches) : [];
                            return t.asyncAll(i, ( (t, i) => t._preloadTiles(e, i)), ( () => {
                                this.triggerRepaint()
                            }
                            )),
                            this
                        }
                        _onWindowOnline() {
                            this._update()
                        }
                        _onWindowResize(t) {
                            this._trackResize && this.resize({
                                originalEvent: t
                            })._update()
                        }
                        _onVisibilityChange() {
                            "hidden" === t.window.document.visibilityState && this._visibilityHidden++
                        }
                        get showTileBoundaries() {
                            return !!this._showTileBoundaries
                        }
                        set showTileBoundaries(t) {
                            this._showTileBoundaries !== t && (this._showTileBoundaries = t,
                            this._update())
                        }
                        get showTerrainWireframe() {
                            return !!this._showTerrainWireframe
                        }
                        set showTerrainWireframe(t) {
                            this._showTerrainWireframe !== t && (this._showTerrainWireframe = t,
                            this._update())
                        }
                        get speedIndexTiming() {
                            return !!this._speedIndexTiming
                        }
                        set speedIndexTiming(t) {
                            this._speedIndexTiming !== t && (this._speedIndexTiming = t,
                            this._update())
                        }
                        get showPadding() {
                            return !!this._showPadding
                        }
                        set showPadding(t) {
                            this._showPadding !== t && (this._showPadding = t,
                            this._update())
                        }
                        get showCollisionBoxes() {
                            return !!this._showCollisionBoxes
                        }
                        set showCollisionBoxes(t) {
                            this._showCollisionBoxes !== t && (this._showCollisionBoxes = t,
                            t ? this.style._generateCollisionBoxes() : this._update())
                        }
                        get showOverdrawInspector() {
                            return !!this._showOverdrawInspector
                        }
                        set showOverdrawInspector(t) {
                            this._showOverdrawInspector !== t && (this._showOverdrawInspector = t,
                            this._update())
                        }
                        get repaint() {
                            return !!this._repaint
                        }
                        set repaint(t) {
                            this._repaint !== t && (this._repaint = t,
                            this.triggerRepaint())
                        }
                        get vertices() {
                            return !!this._vertices
                        }
                        set vertices(t) {
                            this._vertices = t,
                            this._update()
                        }
                        get showTileAABBs() {
                            return !!this._showTileAABBs
                        }
                        set showTileAABBs(t) {
                            this._showTileAABBs !== t && (this._showTileAABBs = t,
                            t && this._update())
                        }
                        _setCacheLimits(e, i) {
                            t.setCacheLimits(e, i)
                        }
                        get version() {
                            return t.version
                        }
                    }
                    ,
                    NavigationControl: class {
                        constructor(e) {
                            this.options = t.extend({}, lo, e),
                            this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._container.addEventListener("contextmenu", (t => t.preventDefault())),
                            this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this),
                            this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (t => {
                                this._map && this._map.zoomIn({}, {
                                    originalEvent: t
                                })
                            }
                            )),
                            s("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                            this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (t => {
                                this._map && this._map.zoomOut({}, {
                                    originalEvent: t
                                })
                            }
                            )),
                            s("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                            this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this),
                            this._compass = this._createButton("mapboxgl-ctrl-compass", (t => {
                                const e = this._map;
                                e && (this.options.visualizePitch ? e.resetNorthPitch({}, {
                                    originalEvent: t
                                }) : e.resetNorth({}, {
                                    originalEvent: t
                                }))
                            }
                            )),
                            this._compassIcon = s("span", "mapboxgl-ctrl-icon", this._compass),
                            this._compassIcon.setAttribute("aria-hidden", "true"))
                        }
                        _updateZoomButtons() {
                            const t = this._map;
                            if (!t)
                                return;
                            const e = t.getZoom()
                              , i = e === t.getMaxZoom()
                              , n = e === t.getMinZoom();
                            this._zoomInButton.disabled = i,
                            this._zoomOutButton.disabled = n,
                            this._zoomInButton.setAttribute("aria-disabled", i.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", n.toString())
                        }
                        _rotateCompassArrow() {
                            const t = this._map;
                            if (!t)
                                return;
                            const e = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(t.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${t.transform.pitch}deg) rotateZ(${t.transform.angle * (180 / Math.PI)}deg)` : `rotate(${t.transform.angle * (180 / Math.PI)}deg)`;
                            t._requestDomTask(( () => {
                                this._compassIcon && (this._compassIcon.style.transform = e)
                            }
                            ))
                        }
                        onAdd(t) {
                            return this._map = t,
                            this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                            this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                            t.on("zoom", this._updateZoomButtons),
                            this._updateZoomButtons()),
                            this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                            this.options.visualizePitch && t.on("pitch", this._rotateCompassArrow),
                            t.on("rotate", this._rotateCompassArrow),
                            this._rotateCompassArrow(),
                            this._handler = new co(t,this._compass,this.options.visualizePitch)),
                            this._container
                        }
                        onRemove() {
                            const t = this._map;
                            t && (this._container.remove(),
                            this.options.showZoom && t.off("zoom", this._updateZoomButtons),
                            this.options.showCompass && (this.options.visualizePitch && t.off("pitch", this._rotateCompassArrow),
                            t.off("rotate", this._rotateCompassArrow),
                            this._handler && this._handler.off(),
                            this._handler = void 0),
                            this._map = void 0)
                        }
                        _createButton(t, e) {
                            const i = s("button", t, this._container);
                            return i.type = "button",
                            i.addEventListener("click", e),
                            i
                        }
                        _setButtonTitle(t, e) {
                            if (!this._map)
                                return;
                            const i = this._map._getUIString(`NavigationControl.${e}`);
                            t.setAttribute("aria-label", i),
                            t.firstElementChild && t.firstElementChild.setAttribute("title", i)
                        }
                    }
                    ,
                    GeolocateControl: class extends t.Evented {
                        constructor(e) {
                            super(),
                            this.options = t.extend({
                                geolocation: t.window.navigator.geolocation
                            }, ho, e),
                            t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this),
                            this._updateMarkerRotationThrottled = Kn(this._updateMarkerRotation, 20),
                            this._numberOfWatches = 0
                        }
                        onAdd(t) {
                            return this._map = t,
                            this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._checkGeolocationSupport(this._setupUI),
                            this._container
                        }
                        onRemove() {
                            void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID),
                            this._geolocationWatchID = void 0),
                            this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                            this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                            this._container.remove(),
                            this._map.off("zoom", this._onZoom),
                            this._map = void 0,
                            this._numberOfWatches = 0,
                            this._noTimeout = !1
                        }
                        _checkGeolocationSupport(e) {
                            const i = (t=!!this.options.geolocation) => {
                                this._supportsGeolocation = t,
                                e(t)
                            }
                            ;
                            void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({
                                name: "geolocation"
                            }).then((t => i("denied" !== t.state))).catch(( () => i())) : i()
                        }
                        _isOutOfMapMaxBounds(t) {
                            const e = this._map.getMaxBounds()
                              , i = t.coords;
                            return !!e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
                        }
                        _setErrorState() {
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._watchState = "ACTIVE_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                break;
                            case "ACTIVE_LOCK":
                                this._watchState = "ACTIVE_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                                break;
                            case "BACKGROUND":
                                this._watchState = "BACKGROUND_ERROR",
                                this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"),
                                this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting")
                            }
                        }
                        _onSuccess(e) {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(e))
                                    return this._setErrorState(),
                                    this.fire(new t.Event("outofmaxbounds",e)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = e,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background")
                                    }
                                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e),
                                this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e),
                                this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"),
                                this.fire(new t.Event("geolocate",e)),
                                this._finish()
                            }
                        }
                        _updateCamera(e) {
                            const i = new t.LngLat(e.coords.longitude,e.coords.latitude)
                              , n = e.coords.accuracy
                              , r = this._map.getBearing()
                              , o = t.extend({
                                bearing: r
                            }, this.options.fitBoundsOptions);
                            this._map.fitBounds(i.toBounds(n), o, {
                                geolocateSource: !0
                            })
                        }
                        _updateMarker(e) {
                            if (e) {
                                const i = new t.LngLat(e.coords.longitude,e.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                                this._accuracy = e.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        _updateCircleRadius() {
                            const e = this._map.transform
                              , i = t.mercatorZfromAltitude(1, e._center.lat) * e.worldSize
                              , n = Math.ceil(2 * this._accuracy * i);
                            this._circleElement.style.width = `${n}px`,
                            this._circleElement.style.height = `${n}px`
                        }
                        _onZoom() {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        _updateMarkerRotation() {
                            this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading),
                            this._dotElement.classList.add("mapboxgl-user-location-show-heading")) : (this._dotElement.classList.remove("mapboxgl-user-location-show-heading"),
                            this._userLocationDotMarker.setRotation(0))
                        }
                        _onError(e) {
                            if (this._map) {
                                if (this.options.trackUserLocation)
                                    if (1 === e.code) {
                                        this._watchState = "OFF",
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                        this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.disabled = !0;
                                        const t = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                        this._geolocateButton.setAttribute("aria-label", t),
                                        this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t),
                                        void 0 !== this._geolocationWatchID && this._clearWatch()
                                    } else {
                                        if (3 === e.code && this._noTimeout)
                                            return;
                                        this._setErrorState()
                                    }
                                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"),
                                this.fire(new t.Event("error",e)),
                                this._finish()
                            }
                        }
                        _finish() {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        _setupUI(e) {
                            if (void 0 !== this._map) {
                                if (this._container.addEventListener("contextmenu", (t => t.preventDefault())),
                                this._geolocateButton = s("button", "mapboxgl-ctrl-geolocate", this._container),
                                s("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                                this._geolocateButton.type = "button",
                                !1 === e) {
                                    t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const e = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.setAttribute("aria-label", e),
                                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e)
                                } else {
                                    const t = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.setAttribute("aria-label", t),
                                    this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = s("div", "mapboxgl-user-location"),
                                this._dotElement.appendChild(s("div", "mapboxgl-user-location-dot")),
                                this._dotElement.appendChild(s("div", "mapboxgl-user-location-heading")),
                                this._userLocationDotMarker = new eo({
                                    element: this._dotElement,
                                    rotationAlignment: "map",
                                    pitchAlignment: "map"
                                }),
                                this._circleElement = s("div", "mapboxgl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new eo({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", this.trigger.bind(this)),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", (e => {
                                    e.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e.originalEvent && "resize" === e.originalEvent.type || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                    this.fire(new t.Event("trackuserlocationend")))
                                }
                                ))
                            }
                        }
                        _onDeviceOrientation(t) {
                            this._userLocationDotMarker && (t.webkitCompassHeading ? this._heading = t.webkitCompassHeading : !0 === t.absolute && (this._heading = -1 * t.alpha),
                            this._updateMarkerRotationThrottled())
                        }
                        trigger() {
                            if (!this._setup)
                                return t.warnOnce("Geolocate control triggered before added to a map"),
                                !1;
                            if (this.options.trackUserLocation) {
                                switch (this._watchState) {
                                case "OFF":
                                    this._watchState = "WAITING_ACTIVE",
                                    this.fire(new t.Event("trackuserlocationstart"));
                                    break;
                                case "WAITING_ACTIVE":
                                case "ACTIVE_LOCK":
                                case "ACTIVE_ERROR":
                                case "BACKGROUND_ERROR":
                                    this._numberOfWatches--,
                                    this._noTimeout = !1,
                                    this._watchState = "OFF",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"),
                                    this.fire(new t.Event("trackuserlocationend"));
                                    break;
                                case "BACKGROUND":
                                    this._watchState = "ACTIVE_LOCK",
                                    this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"),
                                    this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                    this.fire(new t.Event("trackuserlocationstart"))
                                }
                                switch (this._watchState) {
                                case "WAITING_ACTIVE":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "ACTIVE_LOCK":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                                    break;
                                case "ACTIVE_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                                    break;
                                case "BACKGROUND":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                                    break;
                                case "BACKGROUND_ERROR":
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error")
                                }
                                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                                    this._clearWatch();
                                else if (void 0 === this._geolocationWatchID) {
                                    let t;
                                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"),
                                    this._geolocateButton.setAttribute("aria-pressed", "true"),
                                    this._numberOfWatches++,
                                    this._numberOfWatches > 1 ? (t = {
                                        maximumAge: 6e5,
                                        timeout: 0
                                    },
                                    this._noTimeout = !0) : (t = this.options.positionOptions,
                                    this._noTimeout = !1),
                                    this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, t),
                                    this.options.showUserHeading && this._addDeviceOrientationListener()
                                }
                            } else
                                this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                                this._timeoutId = setTimeout(this._finish, 1e4);
                            return !0
                        }
                        _addDeviceOrientationListener() {
                            const e = () => {
                                t.window.addEventListener("ondeviceorientationabsolute"in t.window ? "deviceorientationabsolute" : "deviceorientation", this._onDeviceOrientation)
                            }
                            ;
                            void 0 !== t.window.DeviceMotionEvent && "function" == typeof t.window.DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t => {
                                "granted" === t && e()
                            }
                            )).catch(n.error) : e()
                        }
                        _clearWatch() {
                            this.options.geolocation.clearWatch(this._geolocationWatchID),
                            t.window.removeEventListener("deviceorientation", this._onDeviceOrientation),
                            t.window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation),
                            this._geolocationWatchID = void 0,
                            this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"),
                            this._geolocateButton.setAttribute("aria-pressed", "false"),
                            this.options.showUserLocation && this._updateMarker(null)
                        }
                    }
                    ,
                    AttributionControl: Yr,
                    ScaleControl: class {
                        constructor(e) {
                            this.options = t.extend({}, uo, e),
                            this._isNumberFormatSupported = function() {
                                try {
                                    return new Intl.NumberFormat("en",{
                                        style: "unit",
                                        unitDisplay: "short",
                                        unit: "meter"
                                    }),
                                    !0
                                } catch (t) {
                                    return !1
                                }
                            }(),
                            t.bindAll(["_update", "_setScale", "setUnit"], this)
                        }
                        getDefaultPosition() {
                            return "bottom-left"
                        }
                        _update() {
                            const t = this.options.maxWidth || 100
                              , e = this._map
                              , i = e._containerHeight / 2
                              , n = e._containerWidth / 2 - t / 2
                              , r = e.unproject([n, i])
                              , o = e.unproject([n + t, i])
                              , s = r.distanceTo(o);
                            if ("imperial" === this.options.unit) {
                                const e = 3.2808 * s;
                                e > 5280 ? this._setScale(t, e / 5280, "mile") : this._setScale(t, e, "foot")
                            } else
                                "nautical" === this.options.unit ? this._setScale(t, s / 1852, "nautical-mile") : s >= 1e3 ? this._setScale(t, s / 1e3, "kilometer") : this._setScale(t, s, "meter")
                        }
                        _setScale(t, e, i) {
                            this._map._requestDomTask(( () => {
                                const n = function(t) {
                                    const e = Math.pow(10, `${Math.floor(t)}`.length - 1);
                                    let i = t / e;
                                    return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function(t) {
                                        const e = Math.pow(10, Math.ceil(-Math.log(t) / Math.LN10));
                                        return Math.round(t * e) / e
                                    }(i),
                                    e * i
                                }(e)
                                  , r = n / e;
                                this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i ? new Intl.NumberFormat(this._language,{
                                    style: "unit",
                                    unitDisplay: "short",
                                    unit: i
                                }).format(n) : `${n}&nbsp;${fo[i]}`,
                                this._container.style.width = t * r + "px"
                            }
                            ))
                        }
                        onAdd(t) {
                            return this._map = t,
                            this._language = t.getLanguage(),
                            this._container = s("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t.getContainer()),
                            this._container.dir = "auto",
                            this._map.on("move", this._update),
                            this._update(),
                            this._container
                        }
                        onRemove() {
                            this._container.remove(),
                            this._map.off("move", this._update),
                            this._map = void 0
                        }
                        _setLanguage(t) {
                            this._language = t,
                            this._update()
                        }
                        setUnit(t) {
                            this.options.unit = t,
                            this._update()
                        }
                    }
                    ,
                    FullscreenControl: class {
                        constructor(e) {
                            this._fullscreen = !1,
                            e && e.container && (e.container instanceof t.window.HTMLElement ? this._container = e.container : t.warnOnce("Full screen control 'container' must be a DOM element.")),
                            t.bindAll(["_onClickFullscreen", "_changeIcon"], this),
                            "onfullscreenchange"in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange"in t.window.document && (this._fullscreenchange = "webkitfullscreenchange")
                        }
                        onAdd(e) {
                            return this._map = e,
                            this._container || (this._container = this._map.getContainer()),
                            this._controlContainer = s("div", "mapboxgl-ctrl mapboxgl-ctrl-group"),
                            this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none",
                            t.warnOnce("This device does not support fullscreen mode.")),
                            this._controlContainer
                        }
                        onRemove() {
                            this._controlContainer.remove(),
                            this._map = null,
                            t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon)
                        }
                        _checkFullscreenSupport() {
                            return !(!t.window.document.fullscreenEnabled && !t.window.document.webkitFullscreenEnabled)
                        }
                        _setupUI() {
                            const e = this._fullscreenButton = s("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
                            s("span", "mapboxgl-ctrl-icon", e).setAttribute("aria-hidden", "true"),
                            e.type = "button",
                            this._updateTitle(),
                            this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                            t.window.document.addEventListener(this._fullscreenchange, this._changeIcon)
                        }
                        _updateTitle() {
                            const t = this._getTitle();
                            this._fullscreenButton.setAttribute("aria-label", t),
                            this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", t)
                        }
                        _getTitle() {
                            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                        }
                        _isFullscreen() {
                            return this._fullscreen
                        }
                        _changeIcon() {
                            (t.window.document.fullscreenElement || t.window.document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen,
                            this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"),
                            this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"),
                            this._updateTitle())
                        }
                        _onClickFullscreen() {
                            this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen()
                        }
                    }
                    ,
                    Popup: class extends t.Evented {
                        constructor(e) {
                            super(),
                            this.options = t.extend(Object.create(io), e),
                            t.bindAll(["_update", "_onClose", "remove", "_onMouseEvent"], this),
                            this._classList = new Set(e && e.className ? e.className.trim().split(/\s+/) : [])
                        }
                        addTo(e) {
                            return this._map && this.remove(),
                            this._map = e,
                            this.options.closeOnClick && e.on("preclick", this._onClose),
                            this.options.closeOnMove && e.on("move", this._onClose),
                            e.on("remove", this.remove),
                            this._update(),
                            e._addPopup(this),
                            this._focusFirstElement(),
                            this._trackPointer ? (e.on("mousemove", this._onMouseEvent),
                            e.on("mouseup", this._onMouseEvent),
                            e._canvasContainer.classList.add("mapboxgl-track-pointer")) : e.on("move", this._update),
                            this.fire(new t.Event("open")),
                            this
                        }
                        isOpen() {
                            return !!this._map
                        }
                        remove() {
                            this._content && this._content.remove(),
                            this._container && (this._container.remove(),
                            this._container = void 0);
                            const e = this._map;
                            return e && (e.off("move", this._update),
                            e.off("move", this._onClose),
                            e.off("preclick", this._onClose),
                            e.off("click", this._onClose),
                            e.off("remove", this.remove),
                            e.off("mousemove", this._onMouseEvent),
                            e.off("mouseup", this._onMouseEvent),
                            e.off("drag", this._onMouseEvent),
                            e._canvasContainer && e._canvasContainer.classList.remove("mapboxgl-track-pointer"),
                            e._removePopup(this),
                            this._map = void 0),
                            this.fire(new t.Event("close")),
                            this
                        }
                        getLngLat() {
                            return this._lngLat
                        }
                        setLngLat(e) {
                            this._lngLat = t.LngLat.convert(e),
                            this._pos = null,
                            this._trackPointer = !1,
                            this._update();
                            const i = this._map;
                            return i && (i.on("move", this._update),
                            i.off("mousemove", this._onMouseEvent),
                            i._canvasContainer.classList.remove("mapboxgl-track-pointer")),
                            this
                        }
                        trackPointer() {
                            this._trackPointer = !0,
                            this._pos = null,
                            this._update();
                            const t = this._map;
                            return t && (t.off("move", this._update),
                            t.on("mousemove", this._onMouseEvent),
                            t.on("drag", this._onMouseEvent),
                            t._canvasContainer.classList.add("mapboxgl-track-pointer")),
                            this
                        }
                        getElement() {
                            return this._container
                        }
                        setText(e) {
                            return this.setDOMContent(t.window.document.createTextNode(e))
                        }
                        setHTML(e) {
                            const i = t.window.document.createDocumentFragment()
                              , n = t.window.document.createElement("body");
                            let r;
                            for (n.innerHTML = e; r = n.firstChild,
                            r; )
                                i.appendChild(r);
                            return this.setDOMContent(i)
                        }
                        getMaxWidth() {
                            return this._container && this._container.style.maxWidth
                        }
                        setMaxWidth(t) {
                            return this.options.maxWidth = t,
                            this._update(),
                            this
                        }
                        setDOMContent(t) {
                            let e = this._content;
                            if (e)
                                for (; e.hasChildNodes(); )
                                    e.firstChild && e.removeChild(e.firstChild);
                            else
                                e = this._content = s("div", "mapboxgl-popup-content", this._container || void 0);
                            if (e.appendChild(t),
                            this.options.closeButton) {
                                const t = this._closeButton = s("button", "mapboxgl-popup-close-button", e);
                                t.type = "button",
                                t.setAttribute("aria-label", "Close popup"),
                                t.setAttribute("aria-hidden", "true"),
                                t.innerHTML = "&#215;",
                                t.addEventListener("click", this._onClose)
                            }
                            return this._update(),
                            this._focusFirstElement(),
                            this
                        }
                        addClassName(t) {
                            return this._classList.add(t),
                            this._updateClassList(),
                            this
                        }
                        removeClassName(t) {
                            return this._classList.delete(t),
                            this._updateClassList(),
                            this
                        }
                        setOffset(t) {
                            return this.options.offset = t,
                            this._update(),
                            this
                        }
                        toggleClassName(t) {
                            let e;
                            return this._classList.delete(t) ? e = !1 : (this._classList.add(t),
                            e = !0),
                            this._updateClassList(),
                            e
                        }
                        _onMouseEvent(t) {
                            this._update(t.point)
                        }
                        _getAnchor(t) {
                            if (this.options.anchor)
                                return this.options.anchor;
                            const e = this._map
                              , i = this._container
                              , n = this._pos;
                            if (!e || !i || !n)
                                return "bottom";
                            const r = i.offsetWidth
                              , o = i.offsetHeight
                              , s = n.x < r / 2
                              , a = n.x > e.transform.width - r / 2;
                            if (n.y + t < o)
                                return s ? "top-left" : a ? "top-right" : "top";
                            if (n.y > e.transform.height - o) {
                                if (s)
                                    return "bottom-left";
                                if (a)
                                    return "bottom-right"
                            }
                            return s ? "left" : a ? "right" : "bottom"
                        }
                        _updateClassList() {
                            const t = this._container;
                            if (!t)
                                return;
                            const e = [...this._classList];
                            e.push("mapboxgl-popup"),
                            this._anchor && e.push(`mapboxgl-popup-anchor-${this._anchor}`),
                            this._trackPointer && e.push("mapboxgl-popup-track-pointer"),
                            t.className = e.join(" ")
                        }
                        _update(e) {
                            const i = this._map
                              , n = this._content;
                            if (!i || !this._lngLat && !this._trackPointer || !n)
                                return;
                            let r = this._container;
                            if (r || (r = this._container = s("div", "mapboxgl-popup", i.getContainer()),
                            this._tip = s("div", "mapboxgl-popup-tip", r),
                            r.appendChild(n)),
                            this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth),
                            i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Qr(this._lngLat, this._pos, i.transform)),
                            !this._trackPointer || e) {
                                const t = this._pos = this._trackPointer && e ? e : i.project(this._lngLat)
                                  , n = ro(this.options.offset)
                                  , r = this._anchor = this._getAnchor(n.y)
                                  , o = ro(this.options.offset, r)
                                  , s = t.add(o).round();
                                i._requestDomTask(( () => {
                                    this._container && r && (this._container.style.transform = `${to[r]} translate(${s.x}px,${s.y}px)`)
                                }
                                ))
                            }
                            if (!this._marker && i._showingGlobe()) {
                                const e = t.isLngLatBehindGlobe(i.transform, this._lngLat) ? 0 : 1;
                                this._setOpacity(e)
                            }
                            this._updateClassList()
                        }
                        _focusFirstElement() {
                            if (!this.options.focusAfterOpen || !this._container)
                                return;
                            const t = this._container.querySelector(no);
                            t && t.focus()
                        }
                        _onClose() {
                            this.remove()
                        }
                        _setOpacity(t) {
                            this._container && (this._container.style.opacity = `${t}`),
                            this._content && (this._content.style.pointerEvents = t ? "auto" : "none")
                        }
                    }
                    ,
                    Marker: eo,
                    Style: Je,
                    LngLat: t.LngLat,
                    LngLatBounds: t.LngLatBounds,
                    Point: t.Point,
                    MercatorCoordinate: t.MercatorCoordinate,
                    FreeCameraOptions: Vn,
                    Evented: t.Evented,
                    config: t.config,
                    prewarm: function() {
                        jt().acquire(zt)
                    },
                    clearPrewarmedResources: function() {
                        const t = Nt;
                        t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(zt),
                        Nt = null) : n.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                    },
                    get accessToken() {
                        return t.config.ACCESS_TOKEN
                    },
                    set accessToken(e) {
                        t.config.ACCESS_TOKEN = e
                    },
                    get baseApiUrl() {
                        return t.config.API_URL
                    },
                    set baseApiUrl(e) {
                        t.config.API_URL = e
                    },
                    get workerCount() {
                        return Ft.workerCount
                    },
                    set workerCount(t) {
                        Ft.workerCount = t
                    },
                    get maxParallelImageRequests() {
                        return t.config.MAX_PARALLEL_IMAGE_REQUESTS
                    },
                    set maxParallelImageRequests(e) {
                        t.config.MAX_PARALLEL_IMAGE_REQUESTS = e
                    },
                    clearStorage(e) {
                        t.clearTileCache(e)
                    },
                    workerUrl: "",
                    workerClass: null,
                    setNow: t.exported.setNow,
                    restoreNow: t.exported.restoreNow
                };
                return po
            }
            )),
            i
        }()
    },
    82582: function(t) {
        t.exports = function() {
            "use strict";
            function t(t, n, r, o, s) {
                !function t(i, n, r, o, s) {
                    for (; o > r; ) {
                        if (o - r > 600) {
                            var a = o - r + 1
                              , l = n - r + 1
                              , c = Math.log(a)
                              , h = .5 * Math.exp(2 * c / 3)
                              , u = .5 * Math.sqrt(c * h * (a - h) / a) * (l - a / 2 < 0 ? -1 : 1);
                            t(i, n, Math.max(r, Math.floor(n - l * h / a + u)), Math.min(o, Math.floor(n + (a - l) * h / a + u)), s)
                        }
                        var d = i[n]
                          , f = r
                          , p = o;
                        for (e(i, r, n),
                        s(i[o], d) > 0 && e(i, r, o); f < p; ) {
                            for (e(i, f, p),
                            f++,
                            p--; s(i[f], d) < 0; )
                                f++;
                            for (; s(i[p], d) > 0; )
                                p--
                        }
                        0 === s(i[r], d) ? e(i, r, p) : e(i, ++p, o),
                        p <= n && (r = p + 1),
                        n <= p && (o = p - 1)
                    }
                }(t, n, r || 0, o || t.length - 1, s || i)
            }
            function e(t, e, i) {
                var n = t[e];
                t[e] = t[i],
                t[i] = n
            }
            function i(t, e) {
                return t < e ? -1 : t > e ? 1 : 0
            }
            var n = function(t) {
                void 0 === t && (t = 9),
                this._maxEntries = Math.max(4, t),
                this._minEntries = Math.max(2, Math.ceil(.4 * this._maxEntries)),
                this.clear()
            };
            function r(t, e, i) {
                if (!i)
                    return e.indexOf(t);
                for (var n = 0; n < e.length; n++)
                    if (i(t, e[n]))
                        return n;
                return -1
            }
            function o(t, e) {
                s(t, 0, t.children.length, e, t)
            }
            function s(t, e, i, n, r) {
                r || (r = p(null)),
                r.minX = 1 / 0,
                r.minY = 1 / 0,
                r.maxX = -1 / 0,
                r.maxY = -1 / 0;
                for (var o = e; o < i; o++) {
                    var s = t.children[o];
                    a(r, t.leaf ? n(s) : s)
                }
                return r
            }
            function a(t, e) {
                return t.minX = Math.min(t.minX, e.minX),
                t.minY = Math.min(t.minY, e.minY),
                t.maxX = Math.max(t.maxX, e.maxX),
                t.maxY = Math.max(t.maxY, e.maxY),
                t
            }
            function l(t, e) {
                return t.minX - e.minX
            }
            function c(t, e) {
                return t.minY - e.minY
            }
            function h(t) {
                return (t.maxX - t.minX) * (t.maxY - t.minY)
            }
            function u(t) {
                return t.maxX - t.minX + (t.maxY - t.minY)
            }
            function d(t, e) {
                return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY
            }
            function f(t, e) {
                return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY
            }
            function p(t) {
                return {
                    children: t,
                    height: 1,
                    leaf: !0,
                    minX: 1 / 0,
                    minY: 1 / 0,
                    maxX: -1 / 0,
                    maxY: -1 / 0
                }
            }
            function m(e, i, n, r, o) {
                for (var s = [i, n]; s.length; )
                    if (!((n = s.pop()) - (i = s.pop()) <= r)) {
                        var a = i + Math.ceil((n - i) / r / 2) * r;
                        t(e, a, i, n, o),
                        s.push(i, a, a, n)
                    }
            }
            return n.prototype.all = function() {
                return this._all(this.data, [])
            }
            ,
            n.prototype.search = function(t) {
                var e = this.data
                  , i = [];
                if (!f(t, e))
                    return i;
                for (var n = this.toBBox, r = []; e; ) {
                    for (var o = 0; o < e.children.length; o++) {
                        var s = e.children[o]
                          , a = e.leaf ? n(s) : s;
                        f(t, a) && (e.leaf ? i.push(s) : d(t, a) ? this._all(s, i) : r.push(s))
                    }
                    e = r.pop()
                }
                return i
            }
            ,
            n.prototype.collides = function(t) {
                var e = this.data;
                if (!f(t, e))
                    return !1;
                for (var i = []; e; ) {
                    for (var n = 0; n < e.children.length; n++) {
                        var r = e.children[n]
                          , o = e.leaf ? this.toBBox(r) : r;
                        if (f(t, o)) {
                            if (e.leaf || d(t, o))
                                return !0;
                            i.push(r)
                        }
                    }
                    e = i.pop()
                }
                return !1
            }
            ,
            n.prototype.load = function(t) {
                if (!t || !t.length)
                    return this;
                if (t.length < this._minEntries) {
                    for (var e = 0; e < t.length; e++)
                        this.insert(t[e]);
                    return this
                }
                var i = this._build(t.slice(), 0, t.length - 1, 0);
                if (this.data.children.length)
                    if (this.data.height === i.height)
                        this._splitRoot(this.data, i);
                    else {
                        if (this.data.height < i.height) {
                            var n = this.data;
                            this.data = i,
                            i = n
                        }
                        this._insert(i, this.data.height - i.height - 1, !0)
                    }
                else
                    this.data = i;
                return this
            }
            ,
            n.prototype.insert = function(t) {
                return t && this._insert(t, this.data.height - 1),
                this
            }
            ,
            n.prototype.clear = function() {
                return this.data = p([]),
                this
            }
            ,
            n.prototype.remove = function(t, e) {
                if (!t)
                    return this;
                for (var i, n, o, s = this.data, a = this.toBBox(t), l = [], c = []; s || l.length; ) {
                    if (s || (s = l.pop(),
                    n = l[l.length - 1],
                    i = c.pop(),
                    o = !0),
                    s.leaf) {
                        var h = r(t, s.children, e);
                        if (-1 !== h)
                            return s.children.splice(h, 1),
                            l.push(s),
                            this._condense(l),
                            this
                    }
                    o || s.leaf || !d(s, a) ? n ? (i++,
                    s = n.children[i],
                    o = !1) : s = null : (l.push(s),
                    c.push(i),
                    i = 0,
                    n = s,
                    s = s.children[0])
                }
                return this
            }
            ,
            n.prototype.toBBox = function(t) {
                return t
            }
            ,
            n.prototype.compareMinX = function(t, e) {
                return t.minX - e.minX
            }
            ,
            n.prototype.compareMinY = function(t, e) {
                return t.minY - e.minY
            }
            ,
            n.prototype.toJSON = function() {
                return this.data
            }
            ,
            n.prototype.fromJSON = function(t) {
                return this.data = t,
                this
            }
            ,
            n.prototype._all = function(t, e) {
                for (var i = []; t; )
                    t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children),
                    t = i.pop();
                return e
            }
            ,
            n.prototype._build = function(t, e, i, n) {
                var r, s = i - e + 1, a = this._maxEntries;
                if (s <= a)
                    return o(r = p(t.slice(e, i + 1)), this.toBBox),
                    r;
                n || (n = Math.ceil(Math.log(s) / Math.log(a)),
                a = Math.ceil(s / Math.pow(a, n - 1))),
                (r = p([])).leaf = !1,
                r.height = n;
                var l = Math.ceil(s / a)
                  , c = l * Math.ceil(Math.sqrt(a));
                m(t, e, i, c, this.compareMinX);
                for (var h = e; h <= i; h += c) {
                    var u = Math.min(h + c - 1, i);
                    m(t, h, u, l, this.compareMinY);
                    for (var d = h; d <= u; d += l) {
                        var f = Math.min(d + l - 1, u);
                        r.children.push(this._build(t, d, f, n - 1))
                    }
                }
                return o(r, this.toBBox),
                r
            }
            ,
            n.prototype._chooseSubtree = function(t, e, i, n) {
                for (; n.push(e),
                !e.leaf && n.length - 1 !== i; ) {
                    for (var r = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) {
                        var l = e.children[a]
                          , c = h(l)
                          , u = (d = t,
                        f = l,
                        (Math.max(f.maxX, d.maxX) - Math.min(f.minX, d.minX)) * (Math.max(f.maxY, d.maxY) - Math.min(f.minY, d.minY)) - c);
                        u < o ? (o = u,
                        r = c < r ? c : r,
                        s = l) : u === o && c < r && (r = c,
                        s = l)
                    }
                    e = s || e.children[0]
                }
                var d, f;
                return e
            }
            ,
            n.prototype._insert = function(t, e, i) {
                var n = i ? t : this.toBBox(t)
                  , r = []
                  , o = this._chooseSubtree(n, this.data, e, r);
                for (o.children.push(t),
                a(o, n); e >= 0 && r[e].children.length > this._maxEntries; )
                    this._split(r, e),
                    e--;
                this._adjustParentBBoxes(n, r, e)
            }
            ,
            n.prototype._split = function(t, e) {
                var i = t[e]
                  , n = i.children.length
                  , r = this._minEntries;
                this._chooseSplitAxis(i, r, n);
                var s = this._chooseSplitIndex(i, r, n)
                  , a = p(i.children.splice(s, i.children.length - s));
                a.height = i.height,
                a.leaf = i.leaf,
                o(i, this.toBBox),
                o(a, this.toBBox),
                e ? t[e - 1].children.push(a) : this._splitRoot(i, a)
            }
            ,
            n.prototype._splitRoot = function(t, e) {
                this.data = p([t, e]),
                this.data.height = t.height + 1,
                this.data.leaf = !1,
                o(this.data, this.toBBox)
            }
            ,
            n.prototype._chooseSplitIndex = function(t, e, i) {
                for (var n, r, o, a, l, c, u, d = 1 / 0, f = 1 / 0, p = e; p <= i - e; p++) {
                    var m = s(t, 0, p, this.toBBox)
                      , g = s(t, p, i, this.toBBox)
                      , _ = (r = m,
                    o = g,
                    a = void 0,
                    l = void 0,
                    c = void 0,
                    u = void 0,
                    a = Math.max(r.minX, o.minX),
                    l = Math.max(r.minY, o.minY),
                    c = Math.min(r.maxX, o.maxX),
                    u = Math.min(r.maxY, o.maxY),
                    Math.max(0, c - a) * Math.max(0, u - l))
                      , y = h(m) + h(g);
                    _ < d ? (d = _,
                    n = p,
                    f = y < f ? y : f) : _ === d && y < f && (f = y,
                    n = p)
                }
                return n || i - e
            }
            ,
            n.prototype._chooseSplitAxis = function(t, e, i) {
                var n = t.leaf ? this.compareMinX : l
                  , r = t.leaf ? this.compareMinY : c;
                this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, r) && t.children.sort(n)
            }
            ,
            n.prototype._allDistMargin = function(t, e, i, n) {
                t.children.sort(n);
                for (var r = this.toBBox, o = s(t, 0, e, r), l = s(t, i - e, i, r), c = u(o) + u(l), h = e; h < i - e; h++) {
                    var d = t.children[h];
                    a(o, t.leaf ? r(d) : d),
                    c += u(o)
                }
                for (var f = i - e - 1; f >= e; f--) {
                    var p = t.children[f];
                    a(l, t.leaf ? r(p) : p),
                    c += u(l)
                }
                return c
            }
            ,
            n.prototype._adjustParentBBoxes = function(t, e, i) {
                for (var n = i; n >= 0; n--)
                    a(e[n], t)
            }
            ,
            n.prototype._condense = function(t) {
                for (var e = t.length - 1, i = void 0; e >= 0; e--)
                    0 === t[e].children.length ? e > 0 ? (i = t[e - 1].children).splice(i.indexOf(t[e]), 1) : this.clear() : o(t[e], this.toBBox)
            }
            ,
            n
        }()
    },
    91033: function(t, e, i) {
        "use strict";
        i.r(e);
        var n = function() {
            if ("undefined" != typeof Map)
                return Map;
            function t(t, e) {
                var i = -1;
                return t.some((function(t, n) {
                    return t[0] === e && (i = n,
                    !0)
                }
                )),
                i
            }
            return function() {
                function e() {
                    this.__entries__ = []
                }
                return Object.defineProperty(e.prototype, "size", {
                    get: function() {
                        return this.__entries__.length
                    },
                    enumerable: !0,
                    configurable: !0
                }),
                e.prototype.get = function(e) {
                    var i = t(this.__entries__, e)
                      , n = this.__entries__[i];
                    return n && n[1]
                }
                ,
                e.prototype.set = function(e, i) {
                    var n = t(this.__entries__, e);
                    ~n ? this.__entries__[n][1] = i : this.__entries__.push([e, i])
                }
                ,
                e.prototype.delete = function(e) {
                    var i = this.__entries__
                      , n = t(i, e);
                    ~n && i.splice(n, 1)
                }
                ,
                e.prototype.has = function(e) {
                    return !!~t(this.__entries__, e)
                }
                ,
                e.prototype.clear = function() {
                    this.__entries__.splice(0)
                }
                ,
                e.prototype.forEach = function(t, e) {
                    void 0 === e && (e = null);
                    for (var i = 0, n = this.__entries__; i < n.length; i++) {
                        var r = n[i];
                        t.call(e, r[1], r[0])
                    }
                }
                ,
                e
            }()
        }()
          , r = "undefined" != typeof window && "undefined" != typeof document && window.document === document
          , o = void 0 !== i.g && i.g.Math === Math ? i.g : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")()
          , s = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(o) : function(t) {
            return setTimeout((function() {
                return t(Date.now())
            }
            ), 1e3 / 60)
        }
        ;
        var a = ["top", "right", "bottom", "left", "width", "height", "size", "weight"]
          , l = "undefined" != typeof MutationObserver
          , c = function() {
            function t() {
                this.connected_ = !1,
                this.mutationEventsAdded_ = !1,
                this.mutationsObserver_ = null,
                this.observers_ = [],
                this.onTransitionEnd_ = this.onTransitionEnd_.bind(this),
                this.refresh = function(t, e) {
                    var i = !1
                      , n = !1
                      , r = 0;
                    function o() {
                        i && (i = !1,
                        t()),
                        n && l()
                    }
                    function a() {
                        s(o)
                    }
                    function l() {
                        var t = Date.now();
                        if (i) {
                            if (t - r < 2)
                                return;
                            n = !0
                        } else
                            i = !0,
                            n = !1,
                            setTimeout(a, e);
                        r = t
                    }
                    return l
                }(this.refresh.bind(this), 20)
            }
            return t.prototype.addObserver = function(t) {
                ~this.observers_.indexOf(t) || this.observers_.push(t),
                this.connected_ || this.connect_()
            }
            ,
            t.prototype.removeObserver = function(t) {
                var e = this.observers_
                  , i = e.indexOf(t);
                ~i && e.splice(i, 1),
                !e.length && this.connected_ && this.disconnect_()
            }
            ,
            t.prototype.refresh = function() {
                this.updateObservers_() && this.refresh()
            }
            ,
            t.prototype.updateObservers_ = function() {
                var t = this.observers_.filter((function(t) {
                    return t.gatherActive(),
                    t.hasActive()
                }
                ));
                return t.forEach((function(t) {
                    return t.broadcastActive()
                }
                )),
                t.length > 0
            }
            ,
            t.prototype.connect_ = function() {
                r && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_),
                window.addEventListener("resize", this.refresh),
                l ? (this.mutationsObserver_ = new MutationObserver(this.refresh),
                this.mutationsObserver_.observe(document, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                })) : (document.addEventListener("DOMSubtreeModified", this.refresh),
                this.mutationEventsAdded_ = !0),
                this.connected_ = !0)
            }
            ,
            t.prototype.disconnect_ = function() {
                r && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_),
                window.removeEventListener("resize", this.refresh),
                this.mutationsObserver_ && this.mutationsObserver_.disconnect(),
                this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh),
                this.mutationsObserver_ = null,
                this.mutationEventsAdded_ = !1,
                this.connected_ = !1)
            }
            ,
            t.prototype.onTransitionEnd_ = function(t) {
                var e = t.propertyName
                  , i = void 0 === e ? "" : e;
                a.some((function(t) {
                    return !!~i.indexOf(t)
                }
                )) && this.refresh()
            }
            ,
            t.getInstance = function() {
                return this.instance_ || (this.instance_ = new t),
                this.instance_
            }
            ,
            t.instance_ = null,
            t
        }()
          , h = function(t, e) {
            for (var i = 0, n = Object.keys(e); i < n.length; i++) {
                var r = n[i];
                Object.defineProperty(t, r, {
                    value: e[r],
                    enumerable: !1,
                    writable: !1,
                    configurable: !0
                })
            }
            return t
        }
          , u = function(t) {
            return t && t.ownerDocument && t.ownerDocument.defaultView || o
        }
          , d = y(0, 0, 0, 0);
        function f(t) {
            return parseFloat(t) || 0
        }
        function p(t) {
            for (var e = [], i = 1; i < arguments.length; i++)
                e[i - 1] = arguments[i];
            return e.reduce((function(e, i) {
                return e + f(t["border-" + i + "-width"])
            }
            ), 0)
        }
        function m(t) {
            var e = t.clientWidth
              , i = t.clientHeight;
            if (!e && !i)
                return d;
            var n = u(t).getComputedStyle(t)
              , r = function(t) {
                for (var e = {}, i = 0, n = ["top", "right", "bottom", "left"]; i < n.length; i++) {
                    var r = n[i]
                      , o = t["padding-" + r];
                    e[r] = f(o)
                }
                return e
            }(n)
              , o = r.left + r.right
              , s = r.top + r.bottom
              , a = f(n.width)
              , l = f(n.height);
            if ("border-box" === n.boxSizing && (Math.round(a + o) !== e && (a -= p(n, "left", "right") + o),
            Math.round(l + s) !== i && (l -= p(n, "top", "bottom") + s)),
            !function(t) {
                return t === u(t).document.documentElement
            }(t)) {
                var c = Math.round(a + o) - e
                  , h = Math.round(l + s) - i;
                1 !== Math.abs(c) && (a -= c),
                1 !== Math.abs(h) && (l -= h)
            }
            return y(r.left, r.top, a, l)
        }
        var g = "undefined" != typeof SVGGraphicsElement ? function(t) {
            return t instanceof u(t).SVGGraphicsElement
        }
        : function(t) {
            return t instanceof u(t).SVGElement && "function" == typeof t.getBBox
        }
        ;
        function _(t) {
            return r ? g(t) ? function(t) {
                var e = t.getBBox();
                return y(0, 0, e.width, e.height)
            }(t) : m(t) : d
        }
        function y(t, e, i, n) {
            return {
                x: t,
                y: e,
                width: i,
                height: n
            }
        }
        var v = function() {
            function t(t) {
                this.broadcastWidth = 0,
                this.broadcastHeight = 0,
                this.contentRect_ = y(0, 0, 0, 0),
                this.target = t
            }
            return t.prototype.isActive = function() {
                var t = _(this.target);
                return this.contentRect_ = t,
                t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
            }
            ,
            t.prototype.broadcastRect = function() {
                var t = this.contentRect_;
                return this.broadcastWidth = t.width,
                this.broadcastHeight = t.height,
                t
            }
            ,
            t
        }()
          , x = function(t, e) {
            var i, n, r, o, s, a, l, c = (n = (i = e).x,
            r = i.y,
            o = i.width,
            s = i.height,
            a = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object,
            l = Object.create(a.prototype),
            h(l, {
                x: n,
                y: r,
                width: o,
                height: s,
                top: r,
                right: n + o,
                bottom: s + r,
                left: n
            }),
            l);
            h(this, {
                target: t,
                contentRect: c
            })
        }
          , b = function() {
            function t(t, e, i) {
                if (this.activeObservations_ = [],
                this.observations_ = new n,
                "function" != typeof t)
                    throw new TypeError("The callback provided as parameter 1 is not a function.");
                this.callback_ = t,
                this.controller_ = e,
                this.callbackCtx_ = i
            }
            return t.prototype.observe = function(t) {
                if (!arguments.length)
                    throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(t instanceof u(t).Element))
                        throw new TypeError('parameter 1 is not of type "Element".');
                    var e = this.observations_;
                    e.has(t) || (e.set(t, new v(t)),
                    this.controller_.addObserver(this),
                    this.controller_.refresh())
                }
            }
            ,
            t.prototype.unobserve = function(t) {
                if (!arguments.length)
                    throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(t instanceof u(t).Element))
                        throw new TypeError('parameter 1 is not of type "Element".');
                    var e = this.observations_;
                    e.has(t) && (e.delete(t),
                    e.size || this.controller_.removeObserver(this))
                }
            }
            ,
            t.prototype.disconnect = function() {
                this.clearActive(),
                this.observations_.clear(),
                this.controller_.removeObserver(this)
            }
            ,
            t.prototype.gatherActive = function() {
                var t = this;
                this.clearActive(),
                this.observations_.forEach((function(e) {
                    e.isActive() && t.activeObservations_.push(e)
                }
                ))
            }
            ,
            t.prototype.broadcastActive = function() {
                if (this.hasActive()) {
                    var t = this.callbackCtx_
                      , e = this.activeObservations_.map((function(t) {
                        return new x(t.target,t.broadcastRect())
                    }
                    ));
                    this.callback_.call(t, e, t),
                    this.clearActive()
                }
            }
            ,
            t.prototype.clearActive = function() {
                this.activeObservations_.splice(0)
            }
            ,
            t.prototype.hasActive = function() {
                return this.activeObservations_.length > 0
            }
            ,
            t
        }()
          , w = "undefined" != typeof WeakMap ? new WeakMap : new n
          , E = function t(e) {
            if (!(this instanceof t))
                throw new TypeError("Cannot call a class as a function.");
            if (!arguments.length)
                throw new TypeError("1 argument required, but only 0 present.");
            var i = c.getInstance()
              , n = new b(e,i,this);
            w.set(this, n)
        };
        ["observe", "unobserve", "disconnect"].forEach((function(t) {
            E.prototype[t] = function() {
                var e;
                return (e = w.get(this))[t].apply(e, arguments)
            }
        }
        ));
        var T = void 0 !== o.ResizeObserver ? o.ResizeObserver : E;
        e.default = T
    },
    94203: function(t, e, i) {
        "use strict";
        function n(t) {
            return "object" == typeof t && null != t && 1 === t.nodeType
        }
        function r(t, e) {
            return (!e || "hidden" !== t) && "visible" !== t && "clip" !== t
        }
        function o(t, e) {
            if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
                var i = getComputedStyle(t, null);
                return r(i.overflowY, e) || r(i.overflowX, e) || function(t) {
                    var e = function(t) {
                        if (!t.ownerDocument || !t.ownerDocument.defaultView)
                            return null;
                        try {
                            return t.ownerDocument.defaultView.frameElement
                        } catch (t) {
                            return null
                        }
                    }(t);
                    return !!e && (e.clientHeight < t.scrollHeight || e.clientWidth < t.scrollWidth)
                }(t)
            }
            return !1
        }
        function s(t, e, i, n, r, o, s, a) {
            return o < t && s > e || o > t && s < e ? 0 : o <= t && a <= i || s >= e && a >= i ? o - t - n : s > e && a < i || o < t && a > i ? s - e + r : 0
        }
        i.d(e, {
            Z: function() {
                return c
            }
        });
        var a = function(t, e) {
            var i = window
              , r = e.scrollMode
              , a = e.block
              , l = e.inline
              , c = e.boundary
              , h = e.skipOverflowHiddenElements
              , u = "function" == typeof c ? c : function(t) {
                return t !== c
            }
            ;
            if (!n(t))
                throw new TypeError("Invalid target");
            for (var d, f, p = document.scrollingElement || document.documentElement, m = [], g = t; n(g) && u(g); ) {
                if ((g = null == (f = (d = g).parentElement) ? d.getRootNode().host || null : f) === p) {
                    m.push(g);
                    break
                }
                null != g && g === document.body && o(g) && !o(document.documentElement) || null != g && o(g, h) && m.push(g)
            }
            for (var _ = i.visualViewport ? i.visualViewport.width : innerWidth, y = i.visualViewport ? i.visualViewport.height : innerHeight, v = window.scrollX || pageXOffset, x = window.scrollY || pageYOffset, b = t.getBoundingClientRect(), w = b.height, E = b.width, T = b.top, S = b.right, C = b.bottom, A = b.left, I = "start" === a || "nearest" === a ? T : "end" === a ? C : T + w / 2, M = "center" === l ? A + E / 2 : "end" === l ? S : A, P = [], k = 0; k < m.length; k++) {
                var O = m[k]
                  , R = O.getBoundingClientRect()
                  , D = R.height
                  , L = R.width
                  , B = R.top
                  , z = R.right
                  , F = R.bottom
                  , N = R.left;
                if ("if-needed" === r && T >= 0 && A >= 0 && C <= y && S <= _ && T >= B && C <= F && A >= N && S <= z)
                    return P;
                var j = getComputedStyle(O)
                  , U = parseInt(j.borderLeftWidth, 10)
                  , V = parseInt(j.borderTopWidth, 10)
                  , G = parseInt(j.borderRightWidth, 10)
                  , Z = parseInt(j.borderBottomWidth, 10)
                  , q = 0
                  , W = 0
                  , H = "offsetWidth"in O ? O.offsetWidth - O.clientWidth - U - G : 0
                  , $ = "offsetHeight"in O ? O.offsetHeight - O.clientHeight - V - Z : 0
                  , X = "offsetWidth"in O ? 0 === O.offsetWidth ? 0 : L / O.offsetWidth : 0
                  , Y = "offsetHeight"in O ? 0 === O.offsetHeight ? 0 : D / O.offsetHeight : 0;
                if (p === O)
                    q = "start" === a ? I : "end" === a ? I - y : "nearest" === a ? s(x, x + y, y, V, Z, x + I, x + I + w, w) : I - y / 2,
                    W = "start" === l ? M : "center" === l ? M - _ / 2 : "end" === l ? M - _ : s(v, v + _, _, U, G, v + M, v + M + E, E),
                    q = Math.max(0, q + x),
                    W = Math.max(0, W + v);
                else {
                    q = "start" === a ? I - B - V : "end" === a ? I - F + Z + $ : "nearest" === a ? s(B, F, D, V, Z + $, I, I + w, w) : I - (B + D / 2) + $ / 2,
                    W = "start" === l ? M - N - U : "center" === l ? M - (N + L / 2) + H / 2 : "end" === l ? M - z + G + H : s(N, z, L, U, G + H, M, M + E, E);
                    var K = O.scrollLeft
                      , J = O.scrollTop;
                    I += J - (q = Math.max(0, Math.min(J + q / Y, O.scrollHeight - D / Y + $))),
                    M += K - (W = Math.max(0, Math.min(K + W / X, O.scrollWidth - L / X + H)))
                }
                P.push({
                    el: O,
                    top: q,
                    left: W
                })
            }
            return P
        };
        function l(t) {
            return t === Object(t) && 0 !== Object.keys(t).length
        }
        var c = function(t, e) {
            var i = t.isConnected || t.ownerDocument.documentElement.contains(t);
            if (l(e) && "function" == typeof e.behavior)
                return e.behavior(i ? a(t, e) : []);
            if (i) {
                var n = function(t) {
                    return !1 === t ? {
                        block: "end",
                        inline: "nearest"
                    } : l(t) ? t : {
                        block: "start",
                        inline: "nearest"
                    }
                }(e);
                return function(t, e) {
                    void 0 === e && (e = "auto");
                    var i = "scrollBehavior"in document.body.style;
                    t.forEach((function(t) {
                        var n = t.el
                          , r = t.top
                          , o = t.left;
                        n.scroll && i ? n.scroll({
                            top: r,
                            left: o,
                            behavior: e
                        }) : (n.scrollTop = r,
                        n.scrollLeft = o)
                    }
                    ))
                }(a(t, n), n.behavior)
            }
        }
    },
    87854: function(t, e, i) {
        t.exports = function() {
            "use strict";
            var t = function(t) {
                var e = t.id
                  , i = t.viewBox
                  , n = t.content;
                this.id = e,
                this.viewBox = i,
                this.content = n
            };
            t.prototype.stringify = function() {
                return this.content
            }
            ,
            t.prototype.toString = function() {
                return this.stringify()
            }
            ,
            t.prototype.destroy = function() {
                var t = this;
                ["id", "viewBox", "content"].forEach((function(e) {
                    return delete t[e]
                }
                ))
            }
            ;
            var e = function(t) {
                var e = !!document.importNode
                  , i = (new DOMParser).parseFromString(t, "image/svg+xml").documentElement;
                return e ? document.importNode(i, !0) : i
            };
            function n(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports),
                e.exports
            }
            "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self && self;
            var r = n((function(t, e) {
                !function(e, i) {
                    t.exports = i()
                }(0, (function() {
                    function t(t) {
                        return t && "object" == typeof t && "[object RegExp]" !== Object.prototype.toString.call(t) && "[object Date]" !== Object.prototype.toString.call(t)
                    }
                    function e(t) {
                        return Array.isArray(t) ? [] : {}
                    }
                    function i(i, n) {
                        return n && !0 === n.clone && t(i) ? o(e(i), i, n) : i
                    }
                    function n(e, n, r) {
                        var s = e.slice();
                        return n.forEach((function(n, a) {
                            void 0 === s[a] ? s[a] = i(n, r) : t(n) ? s[a] = o(e[a], n, r) : -1 === e.indexOf(n) && s.push(i(n, r))
                        }
                        )),
                        s
                    }
                    function r(e, n, r) {
                        var s = {};
                        return t(e) && Object.keys(e).forEach((function(t) {
                            s[t] = i(e[t], r)
                        }
                        )),
                        Object.keys(n).forEach((function(a) {
                            t(n[a]) && e[a] ? s[a] = o(e[a], n[a], r) : s[a] = i(n[a], r)
                        }
                        )),
                        s
                    }
                    function o(t, e, o) {
                        var s = Array.isArray(e)
                          , a = (o || {
                            arrayMerge: n
                        }).arrayMerge || n;
                        return s ? Array.isArray(t) ? a(t, e, o) : i(e, o) : r(t, e, o)
                    }
                    return o.all = function(t, e) {
                        if (!Array.isArray(t) || t.length < 2)
                            throw new Error("first argument should be an array with at least two elements");
                        return t.reduce((function(t, i) {
                            return o(t, i, e)
                        }
                        ))
                    }
                    ,
                    o
                }
                ))
            }
            ))
              , o = n((function(t, e) {
                var i = {
                    svg: {
                        name: "xmlns",
                        uri: "http://www.w3.org/2000/svg"
                    },
                    xlink: {
                        name: "xmlns:xlink",
                        uri: "http://www.w3.org/1999/xlink"
                    }
                };
                e.default = i,
                t.exports = e.default
            }
            ))
              , s = function(t) {
                return Object.keys(t).map((function(e) {
                    return e + '="' + t[e].toString().replace(/"/g, "&quot;") + '"'
                }
                )).join(" ")
            }
              , a = o.svg
              , l = o.xlink
              , c = {};
            c[a.name] = a.uri,
            c[l.name] = l.uri;
            var h = function(t, e) {
                void 0 === t && (t = "");
                var i = r(c, e || {});
                return "<svg " + s(i) + ">" + t + "</svg>"
            }
              , u = function(t) {
                function i() {
                    t.apply(this, arguments)
                }
                t && (i.__proto__ = t),
                i.prototype = Object.create(t && t.prototype),
                i.prototype.constructor = i;
                var n = {
                    isMounted: {}
                };
                return n.isMounted.get = function() {
                    return !!this.node
                }
                ,
                i.createFromExistingNode = function(t) {
                    return new i({
                        id: t.getAttribute("id"),
                        viewBox: t.getAttribute("viewBox"),
                        content: t.outerHTML
                    })
                }
                ,
                i.prototype.destroy = function() {
                    this.isMounted && this.unmount(),
                    t.prototype.destroy.call(this)
                }
                ,
                i.prototype.mount = function(t) {
                    if (this.isMounted)
                        return this.node;
                    var e = "string" == typeof t ? document.querySelector(t) : t
                      , i = this.render();
                    return this.node = i,
                    e.appendChild(i),
                    i
                }
                ,
                i.prototype.render = function() {
                    var t = this.stringify();
                    return e(h(t)).childNodes[0]
                }
                ,
                i.prototype.unmount = function() {
                    this.node.parentNode.removeChild(this.node)
                }
                ,
                Object.defineProperties(i.prototype, n),
                i
            }(t);
            return u
        }()
    },
    95348: function(t, e, i) {
        t.exports = function() {
            "use strict";
            function t(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports),
                e.exports
            }
            "undefined" != typeof window ? window : void 0 !== i.g ? i.g : "undefined" != typeof self && self;
            var e = t((function(t, e) {
                !function(e, i) {
                    t.exports = i()
                }(0, (function() {
                    function t(t) {
                        return t && "object" == typeof t && "[object RegExp]" !== Object.prototype.toString.call(t) && "[object Date]" !== Object.prototype.toString.call(t)
                    }
                    function e(t) {
                        return Array.isArray(t) ? [] : {}
                    }
                    function i(i, n) {
                        return n && !0 === n.clone && t(i) ? o(e(i), i, n) : i
                    }
                    function n(e, n, r) {
                        var s = e.slice();
                        return n.forEach((function(n, a) {
                            void 0 === s[a] ? s[a] = i(n, r) : t(n) ? s[a] = o(e[a], n, r) : -1 === e.indexOf(n) && s.push(i(n, r))
                        }
                        )),
                        s
                    }
                    function r(e, n, r) {
                        var s = {};
                        return t(e) && Object.keys(e).forEach((function(t) {
                            s[t] = i(e[t], r)
                        }
                        )),
                        Object.keys(n).forEach((function(a) {
                            t(n[a]) && e[a] ? s[a] = o(e[a], n[a], r) : s[a] = i(n[a], r)
                        }
                        )),
                        s
                    }
                    function o(t, e, o) {
                        var s = Array.isArray(e)
                          , a = (o || {
                            arrayMerge: n
                        }).arrayMerge || n;
                        return s ? Array.isArray(t) ? a(t, e, o) : i(e, o) : r(t, e, o)
                    }
                    return o.all = function(t, e) {
                        if (!Array.isArray(t) || t.length < 2)
                            throw new Error("first argument should be an array with at least two elements");
                        return t.reduce((function(t, i) {
                            return o(t, i, e)
                        }
                        ))
                    }
                    ,
                    o
                }
                ))
            }
            ));
            function n(t) {
                return t = t || Object.create(null),
                {
                    on: function(e, i) {
                        (t[e] || (t[e] = [])).push(i)
                    },
                    off: function(e, i) {
                        t[e] && t[e].splice(t[e].indexOf(i) >>> 0, 1)
                    },
                    emit: function(e, i) {
                        (t[e] || []).map((function(t) {
                            t(i)
                        }
                        )),
                        (t["*"] || []).map((function(t) {
                            t(e, i)
                        }
                        ))
                    }
                }
            }
            var r = t((function(t, e) {
                var i = {
                    svg: {
                        name: "xmlns",
                        uri: "http://www.w3.org/2000/svg"
                    },
                    xlink: {
                        name: "xmlns:xlink",
                        uri: "http://www.w3.org/1999/xlink"
                    }
                };
                e.default = i,
                t.exports = e.default
            }
            ))
              , o = function(t) {
                return Object.keys(t).map((function(e) {
                    return e + '="' + t[e].toString().replace(/"/g, "&quot;") + '"'
                }
                )).join(" ")
            }
              , s = r.svg
              , a = r.xlink
              , l = {};
            l[s.name] = s.uri,
            l[a.name] = a.uri;
            var c, h = function(t, i) {
                void 0 === t && (t = "");
                var n = e(l, i || {});
                return "<svg " + o(n) + ">" + t + "</svg>"
            }, u = r.svg, d = r.xlink, f = {
                attrs: (c = {
                    style: ["position: absolute", "width: 0", "height: 0"].join("; "),
                    "aria-hidden": "true"
                },
                c[u.name] = u.uri,
                c[d.name] = d.uri,
                c)
            }, p = function(t) {
                this.config = e(f, t || {}),
                this.symbols = []
            };
            p.prototype.add = function(t) {
                var e = this.symbols
                  , i = this.find(t.id);
                return i ? (e[e.indexOf(i)] = t,
                !1) : (e.push(t),
                !0)
            }
            ,
            p.prototype.remove = function(t) {
                var e = this.symbols
                  , i = this.find(t);
                return !!i && (e.splice(e.indexOf(i), 1),
                i.destroy(),
                !0)
            }
            ,
            p.prototype.find = function(t) {
                return this.symbols.filter((function(e) {
                    return e.id === t
                }
                ))[0] || null
            }
            ,
            p.prototype.has = function(t) {
                return null !== this.find(t)
            }
            ,
            p.prototype.stringify = function() {
                var t = this.config.attrs
                  , e = this.symbols.map((function(t) {
                    return t.stringify()
                }
                )).join("");
                return h(e, t)
            }
            ,
            p.prototype.toString = function() {
                return this.stringify()
            }
            ,
            p.prototype.destroy = function() {
                this.symbols.forEach((function(t) {
                    return t.destroy()
                }
                ))
            }
            ;
            var m = function(t) {
                var e = t.id
                  , i = t.viewBox
                  , n = t.content;
                this.id = e,
                this.viewBox = i,
                this.content = n
            };
            m.prototype.stringify = function() {
                return this.content
            }
            ,
            m.prototype.toString = function() {
                return this.stringify()
            }
            ,
            m.prototype.destroy = function() {
                var t = this;
                ["id", "viewBox", "content"].forEach((function(e) {
                    return delete t[e]
                }
                ))
            }
            ;
            var g = function(t) {
                var e = !!document.importNode
                  , i = (new DOMParser).parseFromString(t, "image/svg+xml").documentElement;
                return e ? document.importNode(i, !0) : i
            }
              , _ = function(t) {
                function e() {
                    t.apply(this, arguments)
                }
                t && (e.__proto__ = t),
                e.prototype = Object.create(t && t.prototype),
                e.prototype.constructor = e;
                var i = {
                    isMounted: {}
                };
                return i.isMounted.get = function() {
                    return !!this.node
                }
                ,
                e.createFromExistingNode = function(t) {
                    return new e({
                        id: t.getAttribute("id"),
                        viewBox: t.getAttribute("viewBox"),
                        content: t.outerHTML
                    })
                }
                ,
                e.prototype.destroy = function() {
                    this.isMounted && this.unmount(),
                    t.prototype.destroy.call(this)
                }
                ,
                e.prototype.mount = function(t) {
                    if (this.isMounted)
                        return this.node;
                    var e = "string" == typeof t ? document.querySelector(t) : t
                      , i = this.render();
                    return this.node = i,
                    e.appendChild(i),
                    i
                }
                ,
                e.prototype.render = function() {
                    var t = this.stringify();
                    return g(h(t)).childNodes[0]
                }
                ,
                e.prototype.unmount = function() {
                    this.node.parentNode.removeChild(this.node)
                }
                ,
                Object.defineProperties(e.prototype, i),
                e
            }(m)
              , y = {
                autoConfigure: !0,
                mountTo: "body",
                syncUrlsWithBaseTag: !1,
                listenLocationChangeEvent: !0,
                locationChangeEvent: "locationChange",
                locationChangeAngularEmitter: !1,
                usagesToUpdate: "use[*|href]",
                moveGradientsOutsideSymbol: !1
            }
              , v = function(t) {
                return Array.prototype.slice.call(t, 0)
            }
              , x = {
                isChrome: function() {
                    return /chrome/i.test(navigator.userAgent)
                },
                isFirefox: function() {
                    return /firefox/i.test(navigator.userAgent)
                },
                isIE: function() {
                    return /msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent)
                },
                isEdge: function() {
                    return /edge/i.test(navigator.userAgent)
                }
            }
              , b = function(t, e) {
                var i = document.createEvent("CustomEvent");
                i.initCustomEvent(t, !1, !1, e),
                window.dispatchEvent(i)
            }
              , w = function(t) {
                var e = [];
                return v(t.querySelectorAll("style")).forEach((function(t) {
                    t.textContent += "",
                    e.push(t)
                }
                )),
                e
            }
              , E = function(t) {
                return (t || window.location.href).split("#")[0]
            }
              , T = function(t) {
                angular.module("ng").run(["$rootScope", function(e) {
                    e.$on("$locationChangeSuccess", (function(e, i, n) {
                        b(t, {
                            oldUrl: n,
                            newUrl: i
                        })
                    }
                    ))
                }
                ])
            }
              , S = "linearGradient, radialGradient, pattern, mask, clipPath"
              , C = function(t, e) {
                return void 0 === e && (e = S),
                v(t.querySelectorAll("symbol")).forEach((function(t) {
                    v(t.querySelectorAll(e)).forEach((function(e) {
                        t.parentNode.insertBefore(e, t)
                    }
                    ))
                }
                )),
                t
            };
            function A(t, e) {
                return v(t).reduce((function(t, i) {
                    if (!i.attributes)
                        return t;
                    var n = v(i.attributes)
                      , r = e ? n.filter(e) : n;
                    return t.concat(r)
                }
                ), [])
            }
            var I = r.xlink.uri
              , M = "xlink:href"
              , P = /[{}|\\\^\[\]`"<>]/g;
            function k(t) {
                return t.replace(P, (function(t) {
                    return "%" + t[0].charCodeAt(0).toString(16).toUpperCase()
                }
                ))
            }
            function O(t) {
                return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
            }
            function R(t, e, i) {
                return v(t).forEach((function(t) {
                    var n = t.getAttribute(M);
                    if (n && 0 === n.indexOf(e)) {
                        var r = n.replace(e, i);
                        t.setAttributeNS(I, M, r)
                    }
                }
                )),
                t
            }
            var D, L = ["clipPath", "colorProfile", "src", "cursor", "fill", "filter", "marker", "markerStart", "markerMid", "markerEnd", "mask", "stroke", "style"], B = L.map((function(t) {
                return "[" + t + "]"
            }
            )).join(","), z = function(t, e, i, n) {
                var r = k(i)
                  , o = k(n);
                A(t.querySelectorAll(B), (function(t) {
                    var e = t.localName
                      , i = t.value;
                    return -1 !== L.indexOf(e) && -1 !== i.indexOf("url(" + r)
                }
                )).forEach((function(t) {
                    return t.value = t.value.replace(new RegExp(O(r),"g"), o)
                }
                )),
                R(e, r, o)
            }, F = {
                MOUNT: "mount",
                SYMBOL_MOUNT: "symbol_mount"
            }, N = function(t) {
                function i(i) {
                    var r = this;
                    void 0 === i && (i = {}),
                    t.call(this, e(y, i));
                    var o = n();
                    this._emitter = o,
                    this.node = null;
                    var s = this.config;
                    if (s.autoConfigure && this._autoConfigure(i),
                    s.syncUrlsWithBaseTag) {
                        var a = document.getElementsByTagName("base")[0].getAttribute("href");
                        o.on(F.MOUNT, (function() {
                            return r.updateUrls("#", a)
                        }
                        ))
                    }
                    var l = this._handleLocationChange.bind(this);
                    this._handleLocationChange = l,
                    s.listenLocationChangeEvent && window.addEventListener(s.locationChangeEvent, l),
                    s.locationChangeAngularEmitter && T(s.locationChangeEvent),
                    o.on(F.MOUNT, (function(t) {
                        s.moveGradientsOutsideSymbol && C(t)
                    }
                    )),
                    o.on(F.SYMBOL_MOUNT, (function(t) {
                        s.moveGradientsOutsideSymbol && C(t.parentNode),
                        (x.isIE() || x.isEdge()) && w(t)
                    }
                    ))
                }
                t && (i.__proto__ = t),
                i.prototype = Object.create(t && t.prototype),
                i.prototype.constructor = i;
                var r = {
                    isMounted: {}
                };
                return r.isMounted.get = function() {
                    return !!this.node
                }
                ,
                i.prototype._autoConfigure = function(t) {
                    var e = this.config;
                    void 0 === t.syncUrlsWithBaseTag && (e.syncUrlsWithBaseTag = void 0 !== document.getElementsByTagName("base")[0]),
                    void 0 === t.locationChangeAngularEmitter && (e.locationChangeAngularEmitter = void 0 !== window.angular),
                    void 0 === t.moveGradientsOutsideSymbol && (e.moveGradientsOutsideSymbol = x.isFirefox())
                }
                ,
                i.prototype._handleLocationChange = function(t) {
                    var e = t.detail
                      , i = e.oldUrl
                      , n = e.newUrl;
                    this.updateUrls(i, n)
                }
                ,
                i.prototype.add = function(e) {
                    var i = this
                      , n = t.prototype.add.call(this, e);
                    return this.isMounted && n && (e.mount(i.node),
                    this._emitter.emit(F.SYMBOL_MOUNT, e.node)),
                    n
                }
                ,
                i.prototype.attach = function(t) {
                    var e = this
                      , i = this;
                    if (i.isMounted)
                        return i.node;
                    var n = "string" == typeof t ? document.querySelector(t) : t;
                    return i.node = n,
                    this.symbols.forEach((function(t) {
                        t.mount(i.node),
                        e._emitter.emit(F.SYMBOL_MOUNT, t.node)
                    }
                    )),
                    v(n.querySelectorAll("symbol")).forEach((function(t) {
                        var e = _.createFromExistingNode(t);
                        e.node = t,
                        i.add(e)
                    }
                    )),
                    this._emitter.emit(F.MOUNT, n),
                    n
                }
                ,
                i.prototype.destroy = function() {
                    var t = this
                      , e = t.config
                      , i = t.symbols
                      , n = t._emitter;
                    i.forEach((function(t) {
                        return t.destroy()
                    }
                    )),
                    n.off("*"),
                    window.removeEventListener(e.locationChangeEvent, this._handleLocationChange),
                    this.isMounted && this.unmount()
                }
                ,
                i.prototype.mount = function(t, e) {
                    void 0 === t && (t = this.config.mountTo),
                    void 0 === e && (e = !1);
                    var i = this;
                    if (i.isMounted)
                        return i.node;
                    var n = "string" == typeof t ? document.querySelector(t) : t
                      , r = i.render();
                    return this.node = r,
                    e && n.childNodes[0] ? n.insertBefore(r, n.childNodes[0]) : n.appendChild(r),
                    this._emitter.emit(F.MOUNT, r),
                    r
                }
                ,
                i.prototype.render = function() {
                    return g(this.stringify())
                }
                ,
                i.prototype.unmount = function() {
                    this.node.parentNode.removeChild(this.node)
                }
                ,
                i.prototype.updateUrls = function(t, e) {
                    if (!this.isMounted)
                        return !1;
                    var i = document.querySelectorAll(this.config.usagesToUpdate);
                    return z(this.node, i, E(t) + "#", E(e) + "#"),
                    !0
                }
                ,
                Object.defineProperties(i.prototype, r),
                i
            }(p), j = t((function(t) {
                var e;
                e = function() {
                    var t, e = [], i = document, n = i.documentElement.doScroll, r = "DOMContentLoaded", o = (n ? /^loaded|^c/ : /^loaded|^i|^c/).test(i.readyState);
                    return o || i.addEventListener(r, t = function() {
                        for (i.removeEventListener(r, t),
                        o = 1; t = e.shift(); )
                            t()
                    }
                    ),
                    function(t) {
                        o ? setTimeout(t, 0) : e.push(t)
                    }
                }
                ,
                t.exports = e()
            }
            )), U = "__SVG_SPRITE_NODE__", V = "__SVG_SPRITE__";
            window[V] ? D = window[V] : (D = new N({
                attrs: {
                    id: U,
                    "aria-hidden": "true"
                }
            }),
            window[V] = D);
            var G = function() {
                var t = document.getElementById(U);
                t ? D.attach(t) : D.mount(document.body, !0)
            };
            return document.body ? G() : j(G),
            D
        }()
    },
    83744: function(t, e) {
        "use strict";
        e.Z = (t, e) => {
            const i = t.__vccOpts || t;
            for (const [t,n] of e)
                i[t] = n;
            return i
        }
    },
    48935: function(t, e, i) {
        "use strict";
        function n(t, e) {
            for (var i = 0; i < e.length; i++) {
                var n = e[i];
                n.enumerable = n.enumerable || !1,
                n.configurable = !0,
                "value"in n && (n.writable = !0),
                Object.defineProperty(t, n.key, n)
            }
        }
        function r(t, e, i) {
            return e && n(t.prototype, e),
            i && n(t, i),
            t
        }
        function o() {
            return (o = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var n in i)
                        Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n])
                }
                return t
            }
            ).apply(this, arguments)
        }
        function s(t, e) {
            t.prototype = Object.create(e.prototype),
            t.prototype.constructor = t,
            t.__proto__ = e
        }
        function a(t, e) {
            if (null == t)
                return {};
            var i, n, r = {}, o = Object.keys(t);
            for (n = 0; n < o.length; n++)
                e.indexOf(i = o[n]) >= 0 || (r[i] = t[i]);
            return r
        }
        function l(t) {
            return 1 == (null != (e = t) && "object" == typeof e && !1 === Array.isArray(e)) && "[object Object]" === Object.prototype.toString.call(t);
            var e
        }
        i.r(e),
        i.d(e, {
            any: function() {
                return I
            },
            array: function() {
                return R
            },
            arrayOf: function() {
                return j
            },
            bool: function() {
                return P
            },
            createTypes: function() {
                return q
            },
            custom: function() {
                return z
            },
            fromType: function() {
                return C
            },
            func: function() {
                return M
            },
            instanceOf: function() {
                return U
            },
            integer: function() {
                return L
            },
            number: function() {
                return O
            },
            object: function() {
                return D
            },
            objectOf: function() {
                return V
            },
            oneOf: function() {
                return F
            },
            oneOfType: function() {
                return N
            },
            shape: function() {
                return G
            },
            string: function() {
                return k
            },
            symbol: function() {
                return B
            },
            toType: function() {
                return T
            },
            toValidableType: function() {
                return S
            },
            validateType: function() {
                return E
            }
        });
        var c = Object.prototype
          , h = c.toString
          , u = c.hasOwnProperty
          , d = /^\s*function (\w+)/;
        function f(t) {
            var e, i = null !== (e = null == t ? void 0 : t.type) && void 0 !== e ? e : t;
            if (i) {
                var n = i.toString().match(d);
                return n ? n[1] : ""
            }
            return ""
        }
        var p = function(t) {
            var e, i;
            return !1 !== l(t) && "function" == typeof (e = t.constructor) && !1 !== l(i = e.prototype) && !1 !== i.hasOwnProperty("isPrototypeOf")
        }
          , m = function(t) {
            return t
        }
          , g = function(t, e) {
            return u.call(t, e)
        }
          , _ = Number.isInteger || function(t) {
            return "number" == typeof t && isFinite(t) && Math.floor(t) === t
        }
          , y = Array.isArray || function(t) {
            return "[object Array]" === h.call(t)
        }
          , v = function(t) {
            return "[object Function]" === h.call(t)
        }
          , x = function(t) {
            return p(t) && g(t, "_vueTypes_name")
        }
          , b = function(t) {
            return p(t) && (g(t, "type") || ["_vueTypes_name", "validator", "default", "required"].some((function(e) {
                return g(t, e)
            }
            )))
        };
        function w(t, e) {
            return Object.defineProperty(t.bind(e), "__original", {
                value: t
            })
        }
        function E(t, e, i) {
            var n;
            void 0 === i && (i = !1);
            var r = !0
              , o = "";
            n = p(t) ? t : {
                type: t
            };
            var s = x(n) ? n._vueTypes_name + " - " : "";
            if (b(n) && null !== n.type) {
                if (void 0 === n.type || !0 === n.type)
                    return r;
                if (!n.required && void 0 === e)
                    return r;
                y(n.type) ? (r = n.type.some((function(t) {
                    return !0 === E(t, e, !0)
                }
                )),
                o = n.type.map((function(t) {
                    return f(t)
                }
                )).join(" or ")) : r = "Array" === (o = f(n)) ? y(e) : "Object" === o ? p(e) : "String" === o || "Number" === o || "Boolean" === o || "Function" === o ? function(t) {
                    if (null == t)
                        return "";
                    var e = t.constructor.toString().match(d);
                    return e ? e[1] : ""
                }(e) === o : e instanceof n.type
            }
            if (!r) {
                var a = s + 'value "' + e + '" should be of type "' + o + '"';
                return !1 === i ? (m(a),
                !1) : a
            }
            if (g(n, "validator") && v(n.validator)) {
                var l = m
                  , c = [];
                if (m = function(t) {
                    c.push(t)
                }
                ,
                r = n.validator(e),
                m = l,
                !r) {
                    var h = (c.length > 1 ? "* " : "") + c.join("\n* ");
                    return c.length = 0,
                    !1 === i ? (m(h),
                    r) : h
                }
            }
            return r
        }
        function T(t, e) {
            var i = Object.defineProperties(e, {
                _vueTypes_name: {
                    value: t,
                    writable: !0
                },
                isRequired: {
                    get: function() {
                        return this.required = !0,
                        this
                    }
                },
                def: {
                    value: function(t) {
                        return void 0 !== t || this.default ? v(t) || !0 === E(this, t, !0) ? (this.default = y(t) ? function() {
                            return [].concat(t)
                        }
                        : p(t) ? function() {
                            return Object.assign({}, t)
                        }
                        : t,
                        this) : (m(this._vueTypes_name + ' - invalid default value: "' + t + '"'),
                        this) : this
                    }
                }
            })
              , n = i.validator;
            return v(n) && (i.validator = w(n, i)),
            i
        }
        function S(t, e) {
            var i = T(t, e);
            return Object.defineProperty(i, "validate", {
                value: function(t) {
                    return v(this.validator) && m(this._vueTypes_name + " - calling .validate() will overwrite the current custom validator function. Validator info:\n" + JSON.stringify(this)),
                    this.validator = w(t, this),
                    this
                }
            })
        }
        function C(t, e, i) {
            var n, r, o = (n = e,
            r = {},
            Object.getOwnPropertyNames(n).forEach((function(t) {
                r[t] = Object.getOwnPropertyDescriptor(n, t)
            }
            )),
            Object.defineProperties({}, r));
            if (o._vueTypes_name = t,
            !p(i))
                return o;
            var s, l, c = i.validator, h = a(i, ["validator"]);
            if (v(c)) {
                var u = o.validator;
                u && (u = null !== (l = (s = u).__original) && void 0 !== l ? l : s),
                o.validator = w(u ? function(t) {
                    return u.call(this, t) && c.call(this, t)
                }
                : c, o)
            }
            return Object.assign(o, h)
        }
        function A(t) {
            return t.replace(/^(?!\s*$)/gm, "  ")
        }
        var I = function() {
            return S("any", {})
        }
          , M = function() {
            return S("function", {
                type: Function
            })
        }
          , P = function() {
            return S("boolean", {
                type: Boolean
            })
        }
          , k = function() {
            return S("string", {
                type: String
            })
        }
          , O = function() {
            return S("number", {
                type: Number
            })
        }
          , R = function() {
            return S("array", {
                type: Array
            })
        }
          , D = function() {
            return S("object", {
                type: Object
            })
        }
          , L = function() {
            return T("integer", {
                type: Number,
                validator: function(t) {
                    return _(t)
                }
            })
        }
          , B = function() {
            return T("symbol", {
                validator: function(t) {
                    return "symbol" == typeof t
                }
            })
        };
        function z(t, e) {
            if (void 0 === e && (e = "custom validation failed"),
            "function" != typeof t)
                throw new TypeError("[VueTypes error]: You must provide a function as argument");
            return T(t.name || "<<anonymous function>>", {
                validator: function(i) {
                    var n = t(i);
                    return n || m(this._vueTypes_name + " - " + e),
                    n
                }
            })
        }
        function F(t) {
            if (!y(t))
                throw new TypeError("[VueTypes error]: You must provide an array as argument.");
            var e = 'oneOf - value should be one of "' + t.join('", "') + '".'
              , i = t.reduce((function(t, e) {
                if (null != e) {
                    var i = e.constructor;
                    -1 === t.indexOf(i) && t.push(i)
                }
                return t
            }
            ), []);
            return T("oneOf", {
                type: i.length > 0 ? i : void 0,
                validator: function(i) {
                    var n = -1 !== t.indexOf(i);
                    return n || m(e),
                    n
                }
            })
        }
        function N(t) {
            if (!y(t))
                throw new TypeError("[VueTypes error]: You must provide an array as argument");
            for (var e = !1, i = [], n = 0; n < t.length; n += 1) {
                var r = t[n];
                if (b(r)) {
                    if (x(r) && "oneOf" === r._vueTypes_name) {
                        i = i.concat(r.type);
                        continue
                    }
                    if (v(r.validator) && (e = !0),
                    !0 !== r.type && r.type) {
                        i = i.concat(r.type);
                        continue
                    }
                }
                i.push(r)
            }
            return i = i.filter((function(t, e) {
                return i.indexOf(t) === e
            }
            )),
            T("oneOfType", e ? {
                type: i,
                validator: function(e) {
                    var i = []
                      , n = t.some((function(t) {
                        var n = E(x(t) && "oneOf" === t._vueTypes_name ? t.type || null : t, e, !0);
                        return "string" == typeof n && i.push(n),
                        !0 === n
                    }
                    ));
                    return n || m("oneOfType - provided value does not match any of the " + i.length + " passed-in validators:\n" + A(i.join("\n"))),
                    n
                }
            } : {
                type: i
            })
        }
        function j(t) {
            return T("arrayOf", {
                type: Array,
                validator: function(e) {
                    var i, n = e.every((function(e) {
                        return !0 === (i = E(t, e, !0))
                    }
                    ));
                    return n || m("arrayOf - value validation error:\n" + A(i)),
                    n
                }
            })
        }
        function U(t) {
            return T("instanceOf", {
                type: t
            })
        }
        function V(t) {
            return T("objectOf", {
                type: Object,
                validator: function(e) {
                    var i, n = Object.keys(e).every((function(n) {
                        return !0 === (i = E(t, e[n], !0))
                    }
                    ));
                    return n || m("objectOf - value validation error:\n" + A(i)),
                    n
                }
            })
        }
        function G(t) {
            var e = Object.keys(t)
              , i = e.filter((function(e) {
                var i;
                return !!(null === (i = t[e]) || void 0 === i ? void 0 : i.required)
            }
            ))
              , n = T("shape", {
                type: Object,
                validator: function(n) {
                    var r = this;
                    if (!p(n))
                        return !1;
                    var o = Object.keys(n);
                    if (i.length > 0 && i.some((function(t) {
                        return -1 === o.indexOf(t)
                    }
                    ))) {
                        var s = i.filter((function(t) {
                            return -1 === o.indexOf(t)
                        }
                        ));
                        return m(1 === s.length ? 'shape - required property "' + s[0] + '" is not defined.' : 'shape - required properties "' + s.join('", "') + '" are not defined.'),
                        !1
                    }
                    return o.every((function(i) {
                        if (-1 === e.indexOf(i))
                            return !0 === r._vueTypes_isLoose || (m('shape - shape definition does not include a "' + i + '" property. Allowed keys: "' + e.join('", "') + '".'),
                            !1);
                        var o = E(t[i], n[i], !0);
                        return "string" == typeof o && m('shape - "' + i + '" property validation error:\n ' + A(o)),
                        !0 === o
                    }
                    ))
                }
            });
            return Object.defineProperty(n, "_vueTypes_isLoose", {
                writable: !0,
                value: !1
            }),
            Object.defineProperty(n, "loose", {
                get: function() {
                    return this._vueTypes_isLoose = !0,
                    this
                }
            }),
            n
        }
        var Z = function() {
            function t() {}
            return t.extend = function(t) {
                var e = this;
                if (y(t))
                    return t.forEach((function(t) {
                        return e.extend(t)
                    }
                    )),
                    this;
                var i = t.name
                  , n = t.validate
                  , r = void 0 !== n && n
                  , o = t.getter
                  , s = void 0 !== o && o
                  , l = a(t, ["name", "validate", "getter"]);
                if (g(this, i))
                    throw new TypeError('[VueTypes error]: Type "' + i + '" already defined');
                var c, h = l.type;
                return x(h) ? (delete l.type,
                Object.defineProperty(this, i, s ? {
                    get: function() {
                        return C(i, h, l)
                    }
                } : {
                    value: function() {
                        var t, e = C(i, h, l);
                        return e.validator && (e.validator = (t = e.validator).bind.apply(t, [e].concat([].slice.call(arguments)))),
                        e
                    }
                })) : (c = s ? {
                    get: function() {
                        var t = Object.assign({}, l);
                        return r ? S(i, t) : T(i, t)
                    },
                    enumerable: !0
                } : {
                    value: function() {
                        var t, e, n = Object.assign({}, l);
                        return t = r ? S(i, n) : T(i, n),
                        n.validator && (t.validator = (e = n.validator).bind.apply(e, [t].concat([].slice.call(arguments)))),
                        t
                    },
                    enumerable: !0
                },
                Object.defineProperty(this, i, c))
            }
            ,
            r(t, null, [{
                key: "any",
                get: function() {
                    return I()
                }
            }, {
                key: "func",
                get: function() {
                    return M().def(this.defaults.func)
                }
            }, {
                key: "bool",
                get: function() {
                    return P().def(this.defaults.bool)
                }
            }, {
                key: "string",
                get: function() {
                    return k().def(this.defaults.string)
                }
            }, {
                key: "number",
                get: function() {
                    return O().def(this.defaults.number)
                }
            }, {
                key: "array",
                get: function() {
                    return R().def(this.defaults.array)
                }
            }, {
                key: "object",
                get: function() {
                    return D().def(this.defaults.object)
                }
            }, {
                key: "integer",
                get: function() {
                    return L().def(this.defaults.integer)
                }
            }, {
                key: "symbol",
                get: function() {
                    return B()
                }
            }]),
            t
        }();
        function q(t) {
            var e;
            return void 0 === t && (t = {
                func: function() {},
                bool: !0,
                string: "",
                number: 0,
                array: function() {
                    return []
                },
                object: function() {
                    return {}
                },
                integer: 0
            }),
            (e = function(e) {
                function i() {
                    return e.apply(this, arguments) || this
                }
                return s(i, e),
                r(i, null, [{
                    key: "sensibleDefaults",
                    get: function() {
                        return o({}, this.defaults)
                    },
                    set: function(e) {
                        this.defaults = !1 !== e ? o({}, !0 !== e ? e : t) : {}
                    }
                }]),
                i
            }(Z)).defaults = o({}, t),
            e
        }
        Z.defaults = {},
        Z.custom = z,
        Z.oneOf = F,
        Z.instanceOf = U,
        Z.oneOfType = N,
        Z.arrayOf = j,
        Z.objectOf = V,
        Z.shape = G,
        Z.utils = {
            validate: function(t, e) {
                return !0 === E(e, t, !0)
            },
            toType: function(t, e, i) {
                return void 0 === i && (i = !1),
                i ? S(t, e) : T(t, e)
            }
        };
        var W = function(t) {
            function e() {
                return t.apply(this, arguments) || this
            }
            return s(e, t),
            e
        }(q());
        e.default = W
    },
    47529: function(t) {
        t.exports = function() {
            for (var t = {}, i = 0; i < arguments.length; i++) {
                var n = arguments[i];
                for (var r in n)
                    e.call(n, r) && (t[r] = n[r])
            }
            return t
        }
        ;
        var e = Object.prototype.hasOwnProperty
    },
    53898: function(t, e, i) {
        i(57658);
        var n = i(54614).default;
        function r() {
            "use strict";
            t.exports = r = function() {
                return i
            }
            ,
            t.exports.__esModule = !0,
            t.exports.default = t.exports;
            var e, i = {}, o = Object.prototype, s = o.hasOwnProperty, a = Object.defineProperty || function(t, e, i) {
                t[e] = i.value
            }
            , l = "function" == typeof Symbol ? Symbol : {}, c = l.iterator || "@@iterator", h = l.asyncIterator || "@@asyncIterator", u = l.toStringTag || "@@toStringTag";
            function d(t, e, i) {
                return Object.defineProperty(t, e, {
                    value: i,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }),
                t[e]
            }
            try {
                d({}, "")
            } catch (e) {
                d = function(t, e, i) {
                    return t[e] = i
                }
            }
            function f(t, e, i, n) {
                var r = e && e.prototype instanceof x ? e : x
                  , o = Object.create(r.prototype)
                  , s = new R(n || []);
                return a(o, "_invoke", {
                    value: M(t, i, s)
                }),
                o
            }
            function p(t, e, i) {
                try {
                    return {
                        type: "normal",
                        arg: t.call(e, i)
                    }
                } catch (t) {
                    return {
                        type: "throw",
                        arg: t
                    }
                }
            }
            i.wrap = f;
            var m = "suspendedStart"
              , g = "suspendedYield"
              , _ = "executing"
              , y = "completed"
              , v = {};
            function x() {}
            function b() {}
            function w() {}
            var E = {};
            d(E, c, (function() {
                return this
            }
            ));
            var T = Object.getPrototypeOf
              , S = T && T(T(D([])));
            S && S !== o && s.call(S, c) && (E = S);
            var C = w.prototype = x.prototype = Object.create(E);
            function A(t) {
                ["next", "throw", "return"].forEach((function(e) {
                    d(t, e, (function(t) {
                        return this._invoke(e, t)
                    }
                    ))
                }
                ))
            }
            function I(t, e) {
                function i(r, o, a, l) {
                    var c = p(t[r], t, o);
                    if ("throw" !== c.type) {
                        var h = c.arg
                          , u = h.value;
                        return u && "object" == n(u) && s.call(u, "__await") ? e.resolve(u.__await).then((function(t) {
                            i("next", t, a, l)
                        }
                        ), (function(t) {
                            i("throw", t, a, l)
                        }
                        )) : e.resolve(u).then((function(t) {
                            h.value = t,
                            a(h)
                        }
                        ), (function(t) {
                            return i("throw", t, a, l)
                        }
                        ))
                    }
                    l(c.arg)
                }
                var r;
                a(this, "_invoke", {
                    value: function(t, n) {
                        function o() {
                            return new e((function(e, r) {
                                i(t, n, e, r)
                            }
                            ))
                        }
                        return r = r ? r.then(o, o) : o()
                    }
                })
            }
            function M(t, i, n) {
                var r = m;
                return function(o, s) {
                    if (r === _)
                        throw Error("Generator is already running");
                    if (r === y) {
                        if ("throw" === o)
                            throw s;
                        return {
                            value: e,
                            done: !0
                        }
                    }
                    for (n.method = o,
                    n.arg = s; ; ) {
                        var a = n.delegate;
                        if (a) {
                            var l = P(a, n);
                            if (l) {
                                if (l === v)
                                    continue;
                                return l
                            }
                        }
                        if ("next" === n.method)
                            n.sent = n._sent = n.arg;
                        else if ("throw" === n.method) {
                            if (r === m)
                                throw r = y,
                                n.arg;
                            n.dispatchException(n.arg)
                        } else
                            "return" === n.method && n.abrupt("return", n.arg);
                        r = _;
                        var c = p(t, i, n);
                        if ("normal" === c.type) {
                            if (r = n.done ? y : g,
                            c.arg === v)
                                continue;
                            return {
                                value: c.arg,
                                done: n.done
                            }
                        }
                        "throw" === c.type && (r = y,
                        n.method = "throw",
                        n.arg = c.arg)
                    }
                }
            }
            function P(t, i) {
                var n = i.method
                  , r = t.iterator[n];
                if (r === e)
                    return i.delegate = null,
                    "throw" === n && t.iterator.return && (i.method = "return",
                    i.arg = e,
                    P(t, i),
                    "throw" === i.method) || "return" !== n && (i.method = "throw",
                    i.arg = new TypeError("The iterator does not provide a '" + n + "' method")),
                    v;
                var o = p(r, t.iterator, i.arg);
                if ("throw" === o.type)
                    return i.method = "throw",
                    i.arg = o.arg,
                    i.delegate = null,
                    v;
                var s = o.arg;
                return s ? s.done ? (i[t.resultName] = s.value,
                i.next = t.nextLoc,
                "return" !== i.method && (i.method = "next",
                i.arg = e),
                i.delegate = null,
                v) : s : (i.method = "throw",
                i.arg = new TypeError("iterator result is not an object"),
                i.delegate = null,
                v)
            }
            function k(t) {
                var e = {
                    tryLoc: t[0]
                };
                1 in t && (e.catchLoc = t[1]),
                2 in t && (e.finallyLoc = t[2],
                e.afterLoc = t[3]),
                this.tryEntries.push(e)
            }
            function O(t) {
                var e = t.completion || {};
                e.type = "normal",
                delete e.arg,
                t.completion = e
            }
            function R(t) {
                this.tryEntries = [{
                    tryLoc: "root"
                }],
                t.forEach(k, this),
                this.reset(!0)
            }
            function D(t) {
                if (t || "" === t) {
                    var i = t[c];
                    if (i)
                        return i.call(t);
                    if ("function" == typeof t.next)
                        return t;
                    if (!isNaN(t.length)) {
                        var r = -1
                          , o = function i() {
                            for (; ++r < t.length; )
                                if (s.call(t, r))
                                    return i.value = t[r],
                                    i.done = !1,
                                    i;
                            return i.value = e,
                            i.done = !0,
                            i
                        };
                        return o.next = o
                    }
                }
                throw new TypeError(n(t) + " is not iterable")
            }
            return b.prototype = w,
            a(C, "constructor", {
                value: w,
                configurable: !0
            }),
            a(w, "constructor", {
                value: b,
                configurable: !0
            }),
            b.displayName = d(w, u, "GeneratorFunction"),
            i.isGeneratorFunction = function(t) {
                var e = "function" == typeof t && t.constructor;
                return !!e && (e === b || "GeneratorFunction" === (e.displayName || e.name))
            }
            ,
            i.mark = function(t) {
                return Object.setPrototypeOf ? Object.setPrototypeOf(t, w) : (t.__proto__ = w,
                d(t, u, "GeneratorFunction")),
                t.prototype = Object.create(C),
                t
            }
            ,
            i.awrap = function(t) {
                return {
                    __await: t
                }
            }
            ,
            A(I.prototype),
            d(I.prototype, h, (function() {
                return this
            }
            )),
            i.AsyncIterator = I,
            i.async = function(t, e, n, r, o) {
                void 0 === o && (o = Promise);
                var s = new I(f(t, e, n, r),o);
                return i.isGeneratorFunction(e) ? s : s.next().then((function(t) {
                    return t.done ? t.value : s.next()
                }
                ))
            }
            ,
            A(C),
            d(C, u, "Generator"),
            d(C, c, (function() {
                return this
            }
            )),
            d(C, "toString", (function() {
                return "[object Generator]"
            }
            )),
            i.keys = function(t) {
                var e = Object(t)
                  , i = [];
                for (var n in e)
                    i.push(n);
                return i.reverse(),
                function t() {
                    for (; i.length; ) {
                        var n = i.pop();
                        if (n in e)
                            return t.value = n,
                            t.done = !1,
                            t
                    }
                    return t.done = !0,
                    t
                }
            }
            ,
            i.values = D,
            R.prototype = {
                constructor: R,
                reset: function(t) {
                    if (this.prev = 0,
                    this.next = 0,
                    this.sent = this._sent = e,
                    this.done = !1,
                    this.delegate = null,
                    this.method = "next",
                    this.arg = e,
                    this.tryEntries.forEach(O),
                    !t)
                        for (var i in this)
                            "t" === i.charAt(0) && s.call(this, i) && !isNaN(+i.slice(1)) && (this[i] = e)
                },
                stop: function() {
                    this.done = !0;
                    var t = this.tryEntries[0].completion;
                    if ("throw" === t.type)
                        throw t.arg;
                    return this.rval
                },
                dispatchException: function(t) {
                    if (this.done)
                        throw t;
                    var i = this;
                    function n(n, r) {
                        return a.type = "throw",
                        a.arg = t,
                        i.next = n,
                        r && (i.method = "next",
                        i.arg = e),
                        !!r
                    }
                    for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                        var o = this.tryEntries[r]
                          , a = o.completion;
                        if ("root" === o.tryLoc)
                            return n("end");
                        if (o.tryLoc <= this.prev) {
                            var l = s.call(o, "catchLoc")
                              , c = s.call(o, "finallyLoc");
                            if (l && c) {
                                if (this.prev < o.catchLoc)
                                    return n(o.catchLoc, !0);
                                if (this.prev < o.finallyLoc)
                                    return n(o.finallyLoc)
                            } else if (l) {
                                if (this.prev < o.catchLoc)
                                    return n(o.catchLoc, !0)
                            } else {
                                if (!c)
                                    throw Error("try statement without catch or finally");
                                if (this.prev < o.finallyLoc)
                                    return n(o.finallyLoc)
                            }
                        }
                    }
                },
                abrupt: function(t, e) {
                    for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                        var n = this.tryEntries[i];
                        if (n.tryLoc <= this.prev && s.call(n, "finallyLoc") && this.prev < n.finallyLoc) {
                            var r = n;
                            break
                        }
                    }
                    r && ("break" === t || "continue" === t) && r.tryLoc <= e && e <= r.finallyLoc && (r = null);
                    var o = r ? r.completion : {};
                    return o.type = t,
                    o.arg = e,
                    r ? (this.method = "next",
                    this.next = r.finallyLoc,
                    v) : this.complete(o)
                },
                complete: function(t, e) {
                    if ("throw" === t.type)
                        throw t.arg;
                    return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg,
                    this.method = "return",
                    this.next = "end") : "normal" === t.type && e && (this.next = e),
                    v
                },
                finish: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var i = this.tryEntries[e];
                        if (i.finallyLoc === t)
                            return this.complete(i.completion, i.afterLoc),
                            O(i),
                            v
                    }
                },
                catch: function(t) {
                    for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                        var i = this.tryEntries[e];
                        if (i.tryLoc === t) {
                            var n = i.completion;
                            if ("throw" === n.type) {
                                var r = n.arg;
                                O(i)
                            }
                            return r
                        }
                    }
                    throw Error("illegal catch attempt")
                },
                delegateYield: function(t, i, n) {
                    return this.delegate = {
                        iterator: D(t),
                        resultName: i,
                        nextLoc: n
                    },
                    "next" === this.method && (this.arg = e),
                    v
                }
            },
            i
        }
        t.exports = r,
        t.exports.__esModule = !0,
        t.exports.default = t.exports
    },
    54614: function(t) {
        function e(i) {
            return t.exports = e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            }
            : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }
            ,
            t.exports.__esModule = !0,
            t.exports.default = t.exports,
            e(i)
        }
        t.exports = e,
        t.exports.__esModule = !0,
        t.exports.default = t.exports
    },
    78305: function(t, e, i) {
        var n = i(53898)();
        t.exports = n;
        try {
            regeneratorRuntime = n
        } catch (t) {
            "object" == typeof globalThis ? globalThis.regeneratorRuntime = n : Function("r", "regeneratorRuntime = r")(n)
        }
    },
    1633: function(t, e, i) {
        "use strict";
        i.d(e, {
            GM: function() {
                return a
            },
            Gr: function() {
                return o
            },
            Xr: function() {
                return s
            },
            cK: function() {
                return n
            },
            nm: function() {
                return l
            },
            tY: function() {
                return r
            }
        });
        const n = 1e4;
        var r, o, s, a, l;
        !function(t) {
            t.HTTP = "http",
            t.M3U8 = "m3u8",
            t.WS = "ws"
        }(r || (r = {})),
        function(t) {
            t.Notification = "notification",
            t.Response = "response"
        }(o || (o = {})),
        function(t) {
            t.Complete = "loader:complete",
            t.Close = "loader:close",
            t.Connect = "loader:connect",
            t.Data = "loader:data",
            t.Error = "loader:error",
            t.Headers = "loader:header"
        }(s || (s = {})),
        function(t) {
            t[t.Idle = 0] = "Idle",
            t[t.Connecting = 1] = "Connecting",
            t[t.Connected = 2] = "Connected",
            t[t.Buffering = 3] = "Buffering",
            t[t.Error = 4] = "Error",
            t[t.Complete = 5] = "Complete"
        }(a || (a = {})),
        function(t) {
            t.OK = "OK",
            t.ABORT_ERROR = "Loader Abort",
            t.EXCEPTION = "Exception",
            t.HTTP_STATUS_CODE_INVALID = "HttpStatusCodeInvalid",
            t.CONNECTING_TIMEOUT = "ConnectingTimeout",
            t.EARLY_EOF = "EarlyEof",
            t.UNRECOVERABLE_EARLY_EOF = "UnrecoverableEarlyEof"
        }(l || (l = {}))
    },
    19131: function(t, e, i) {
        "use strict";
        i.d(e, {
            CO: function() {
                return o
            },
            DD: function() {
                return r
            },
            EW: function() {
                return s
            },
            fj: function() {
                return n
            },
            kK: function() {
                return a
            }
        });
        const n = {
            HOST: "Host",
            USER_AGENT: "User-Agent",
            KEEP_RELAY: "Keep-Relay",
            COOKIE: "Cookie",
            XTOKEN: "X-token",
            CLIENT_IP: "X-Forwarded-For",
            CONTENT_LENGTH: "Content-Length",
            CONTENT_TYPE: "Content-Type",
            BOUNDARY: "boundary",
            CACHE_CONTROL: "Cache-Control",
            CONNECTION: "Connection",
            ACCEPT: "Accept",
            X_CLIENT_ID: "X-Client-Id",
            X_TIMELEFT: "X-Timeleft",
            X_TIMESTAMP: "X-Timestamp",
            X_ENCRYPT_TYPE: "X-Encrypt-Type",
            X_FRAME_TYPE: "X-Frame-Type",
            X_DATA_SEQUENCE: "X-Data-Sequence",
            X_AUDIO: "X-Audio",
            X_ManualRecording: "X-ManualRecording",
            SERVICE: "service",
            DEVICE_ID: "deviceid",
            TYPE: "type",
            RESOLUTION: "resolution",
            URL: "url",
            DATE: "Date",
            PTZ: "PTZ",
            WWW_AUTHENTICATE: "WWW-Authenticate",
            AUTHORIZATION: "Authorization",
            X_CLEENT_MODEL: "X-Client-Model",
            X_CLIENT_UUID: "X-Client-UUID"
        };
        var r;
        !function(t) {
            t.VIDEO = "video",
            t.AUDIO = "audio",
            t.MIXED = "mixed",
            t.DOUBLE_LINES = "double-lines"
        }(r || (r = {}));
        r.VIDEO,
        r.AUDIO,
        r.MIXED,
        r.DOUBLE_LINES;
        var o, s;
        !function(t) {
            t.AUDIO = "audio",
            t.VIDEO = "video"
        }(o || (o = {})),
        function(t) {
            t.DATA_BOUNDARY = "--data-boundary--",
            t.VIDEO_BOUNDARY = "--video-boundary--",
            t.AUDIO_BOUNDARY = "--audio-boundary--",
            t.MP2T_BOUNDARY = "----device-stream-boundary--"
        }(s || (s = {}));
        const a = [n.CONTENT_LENGTH, n.CONTENT_TYPE];
        n.X_TIMESTAMP
    },
    86490: function(t, e, i) {
        "use strict";
        var n, r;
        i.d(e, {
            K7: function() {
                return s
            },
            Qp: function() {
                return r
            },
            U3: function() {
                return p
            },
            mF: function() {
                return n
            },
            mb: function() {
                return f
            },
            mf: function() {
                return c
            },
            q7: function() {
                return u
            },
            uH: function() {
                return a
            },
            uK: function() {
                return h
            },
            vm: function() {
                return o
            },
            wo: function() {
                return d
            },
            zp: function() {
                return l
            }
        }),
        function(t) {
            t.OK = "OK",
            t.FORMAT_ERR = "FormatError",
            t.MISSING_REQUIRED_HEADER = "MissingRequiredHeader",
            t.FORMAT_UNSUPPORTED = "FormatUnsupported",
            t.CODEC_UNSUPPORTED = "CodecUnsupported",
            t.ENCRYPT_DATA = "EncryptData",
            t.UNKNOWN_ERR = "UnknownError",
            t.UNKNOWN_MEDIA_SAMPLE_TYPE = "UnknownMediaSampleType"
        }(n || (n = {})),
        function(t) {
            t[t.IDR = 0] = "IDR",
            t[t.P = 1] = "P"
        }(r || (r = {}));
        const o = {
            START: "start",
            BOUNDARY: "boundary",
            HEADER: "header",
            CONTENT: "content",
            PRE_EPILOGUE: "pre-epilogue",
            END: "end"
        };
        var s, a, l;
        !function(t) {
            t.SEQUENCE_RECEIVED = "transformer:sequence-received",
            t.JSON_RECEIVED = "transformer:json-received",
            t.STREAM_SEQ_CHANGED = "transformer:stream-seq-changed",
            t.AUDIO_SAMPLE = "transformer:audio-sample",
            t.VIDEO_SAMPLE = "transformer:video-sample",
            t.FIRST_SEGMENT = "transformer:first-segment",
            t.MSE_INIT_SEGMENT = "transformer:mse-init-segment",
            t.RECORDER_PROGRESS = "transformer:recorder-progress",
            t.SEEK_FINISHED = "transformer:seek-finished",
            t.DATA_FINISHED = "transformer:data-finished",
            t.VIDEO_CODE = "transformer:video-code",
            t.PLAYER_TYPE = "transformer:player-type",
            t.SWITCH_STREAM = "transformer:switching-stream",
            t.SWITCH_STREAM_FINISH = "transformer:switch-stream-finish"
        }(s || (s = {})),
        function(t) {
            t.BT601 = "bt601",
            t.BT709 = "BT709"
        }(a || (a = {})),
        function(t) {
            t[t.RESERVED0 = 0] = "RESERVED0",
            t[t.BT709 = 1] = "BT709",
            t[t.BT470M = 4] = "BT470M",
            t[t.BT470BG = 5] = "BT470BG",
            t[t.SMPTE170M = 6] = "SMPTE170M",
            t[t.SMPTE240M = 7] = "SMPTE240M"
        }(l || (l = {}));
        const c = new Map([[l.BT709, "bt709"], [l.BT470BG, "bt470bg"], [l.SMPTE170M, "smpte170m"]]);
        var h;
        !function(t) {
            t[t.RESERVED0 = 0] = "RESERVED0",
            t[t.BT709 = 1] = "BT709",
            t[t.GAMMA22 = 4] = "GAMMA22",
            t[t.GAMMA28 = 5] = "GAMMA28",
            t[t.SMPTE170M = 6] = "SMPTE170M",
            t[t.SMPTE240M = 7] = "SMPTE240M"
        }(h || (h = {}));
        const u = new Map([[h.BT709, "bt709"], [h.SMPTE170M, "smpte170m"]]);
        var d;
        !function(t) {
            t[t.RGB = 0] = "RGB",
            t[t.BT709 = 1] = "BT709",
            t[t.BT470BG = 5] = "BT470BG",
            t[t.SMPTE170M = 6] = "SMPTE170M",
            t[t.SMPTE240M = 7] = "SMPTE240M"
        }(d || (d = {}));
        const f = new Map([[d.RGB, "rgb"], [d.BT709, "bt709"], [d.BT470BG, "bt470bg"], [d.SMPTE170M, "smpte170m"]])
          , p = new Map([[a.BT601, {
            primaries: "smpte170m",
            transfer: "smpte170m",
            matrix: "smpte170m",
            fullRange: !0
        }], [a.BT709, {
            primaries: "bt709",
            transfer: "bt709",
            matrix: "bt709",
            fullRange: !0
        }]])
    },
    21021: function(t, e, i) {
        "use strict";
        i.d(e, {
            PK: function() {
                return mt
            },
            Xr: function() {
                return M.Xr
            },
            tY: function() {
                return M.tY
            },
            t3: function() {
                return m
            },
            Bc: function() {
                return g
            },
            K7: function() {
                return B.K7
            },
            Lt: function() {
                return d
            }
        });
        var n = i(26700);
        class r {
            static supportMseAvcPlayback() {
                return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"')
            }
            static supportMseHevcPlayback() {
                return window.MediaSource && window.MediaSource.isTypeSupported('video/mp4; codecs="hvc1.1.6.L93.B0"')
            }
            static supportNativeMediaPlayback(t) {
                void 0 === r.videoElement && (r.videoElement = window.document.createElement("video"));
                const e = r.videoElement.canPlayType(t);
                return "probably" === e || "maybe" === e
            }
            static getFeatureList() {
                const t = {
                    mseAvcPlayback: !1,
                    mseHevcPlayback: !1,
                    networkStreamIO: !1,
                    networkLoaderName: "",
                    nativeMP4H264Playback: !1,
                    nativeWebmVP8Playback: !1,
                    nativeWebmVP9Playback: !1
                };
                return t.mseAvcPlayback = r.supportMseAvcPlayback(),
                t.mseHevcPlayback = r.supportMseAvcPlayback(),
                t.nativeMP4H264Playback = r.supportNativeMediaPlayback('video/mp4; codecs="avc1.42001E, mp4a.40.2"'),
                t.nativeWebmVP8Playback = r.supportNativeMediaPlayback('video/webm; codecs="vp8.0, vorbis"'),
                t.nativeWebmVP9Playback = r.supportNativeMediaPlayback('video/webm; codecs="vp9"'),
                t
            }
        }
        var o = r;
        var s = class {
            constructor(t, e) {
                this.options = {
                    isAntialias: !1
                },
                this.gl = t,
                this.options = Object.assign(this.options, e),
                this.texture = t.createTexture();
                const i = this.options.isAntialias ? t.LINEAR_MIPMAP_LINEAR : t.LINEAR;
                t.bindTexture(t.TEXTURE_2D, this.texture),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, i),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE)
            }
            bind(t, e, i) {
                const n = this.gl;
                n.activeTexture([n.TEXTURE0, n.TEXTURE1, n.TEXTURE2][t]),
                n.bindTexture(n.TEXTURE_2D, this.texture),
                n.uniform1i(n.getUniformLocation(e, i), t)
            }
            fill(t, e, i) {
                const n = this.gl;
                n.bindTexture(n.TEXTURE_2D, this.texture),
                n.texImage2D(n.TEXTURE_2D, 0, n.LUMINANCE, t, e, 0, n.LUMINANCE, n.UNSIGNED_BYTE, i),
                this.options.isAntialias && n.generateMipmap(n.TEXTURE_2D)
            }
        }
        ;
        class a extends n.KG {
            constructor(t) {
                super(t),
                this.id = t.id
            }
            get playerEmitter() {
                const t = this.id;
                return a.emitter[t] || (a.emitter[t] = this.emitter),
                a.emitter[t]
            }
            destroy() {
                delete a.emitter[this.id]
            }
            static clear() {
                a.emitter = {}
            }
        }
        a.emitter = {};
        class l extends a {
            constructor(t) {
                super(t.baseConfig),
                this.isZoom = !1,
                this.lastFrameSequence = -1,
                this.isStuck = !1,
                this.stuckTimer = null
            }
            set zoomStatus(t) {}
            get zoomStatus() {
                return this.isZoom
            }
            destroy() {
                super.destroy()
            }
            fullscreen() {
                const t = this.mediaElement.parentElement;
                t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.msRequestFullscreen ? t.msRequestFullscreen() : this.logger.error("This browser doesn't supporter fullscreen")
            }
            exitFullscreen() {
                const t = document;
                t.exitFullscreen ? t.exitFullscreen() : t.webkitExitFullscreen ? t.webkitExitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.msExitFullscreen ? t.msExitFullscreen() : this.logger.error("Exit fullscreen doesn't work")
            }
            updateZoomState() {
                this.isZoom && (this.mediaElement.style.cursor = "zoom-in",
                this.resetZoom())
            }
        }
        const c = {
            objectFit: "contain",
            mode: "live",
            mediaType: "",
            enableWorker: !0,
            enableStashBuffer: !1,
            stashInitialSize: 262144,
            forceCompatibility4_2: !1,
            isTransportStream: !0,
            isLive: !0,
            lazyLoad: !1,
            lazyLoadMaxDuration: 180,
            lazyLoadRecoverDuration: 30,
            deferLoadAfterSourceOpen: !0,
            autoCleanupSourceBuffer: !0,
            autoCleanupMaxBackwardDuration: 120,
            autoCleanupMinBackwardDuration: 60,
            statisticsInfoReportInterval: 600,
            timeLeftHint: 10,
            maxLatency: 3.2,
            latencyFactor: 1,
            dlinesAdditionalDelay: 3.5,
            delayCheckTime: .5,
            liveBufferLatencyChasing: !0,
            liveBufferLatencyMaxLatency: 1.5,
            liveBufferLatencyMinRemain: .5,
            needStashBuffer: !1,
            accurateSeek: !0,
            seekType: "range",
            seekParamStart: "bstart",
            seekParamEnd: "bend",
            rangeLoadZeroStart: !1,
            customSeekHandler: void 0,
            reuseRedirectedURL: !1,
            timescale: 1,
            fixedPointNum: 0,
            scaleOptions: {
                scaleStep: 1.05,
                scaleTimes: 15,
                maxScale: 5
            },
            defaultPlaybackRate: 1,
            changePtsRates: [2, 4, 8, 16],
            stuckTriggerTime: 3,
            supportWebcodecs: !1,
            screenshot: !0,
            isConvertPicture: !1,
            renderResolution: {
                width: 0,
                height: 0
            },
            isAntialias: !0,
            onlyScreenShot: !1,
            webcodecDelayAcceptDuration: 100,
            maxWebcodecDelayDuration: 1e3,
            imageQualityImprovementExtend: 1
        };
        function h() {
            return Object.assign({}, c)
        }
        const u = new Map([["live", {
            liveBufferLatencyChasing: !0,
            needStashBuffer: !1
        }], ["playback", {
            liveBufferLatencyChasing: !1,
            needStashBuffer: !0
        }]]);
        var d, f, p, m, g, _ = i(80309);
        !function(t) {
            t.AUTO = "auto",
            t.WEBGL = "webgl",
            t.MSE = "mse"
        }(d || (d = {})),
        function(t) {
            t.UN_INIT = "uninitialized",
            t.INIT = "init",
            t.PRE_CONNECTED = "pre-connected",
            t.PLAY = "play",
            t.PLAY_ERROR = "play-error",
            t.DESTROY = "destroy"
        }(f || (f = {})),
        function(t) {
            t.AUTO = "auto",
            t.G711A = "pcma",
            t.MP3 = "mp3"
        }(p || (p = {})),
        function(t) {
            t.ERROR = "mse-error",
            t.SOURCE_OPEN = "source-open",
            t.UPDATE_END = "update-end",
            t.BUFFER_FULL = "buffer-full"
        }(m || (m = {})),
        function(t) {
            t.UPDATE_STATUS = "player:update-status",
            t.UPDATE_TIMESTAMP = "player:update-timestamp",
            t.CHANGE_PLAYBACK_RATE = "player:change-playback-rate",
            t.PLAY_FINISHED = "player:play-finished",
            t.CAN_PLAY = "player:can-play",
            t.PLAYER_SIZE = "player:change-player-size",
            t.SCALE_CHANGE = "player:scale-change",
            t.STALLED = "player:stalled",
            t.STALLED_RESUME = "player:stalled-resume"
        }(g || (g = {}));
        var y = i(25108);
        const v = {
            scale: 1,
            Tx: 0,
            Ty: 0,
            pointX: 0,
            pointY: 0,
            realScaleX: 1,
            realScaleY: 1,
            realScaleXList: [],
            realScaleYList: [],
            pointXList: [],
            pointYList: [],
            DxList: [],
            DyList: []
        };
        class x extends l {
            constructor(t, e) {
                super(e),
                this.screenshotGL = null,
                this.lastFrame = null,
                this.program = null,
                this.yTexture = null,
                this.uTexture = null,
                this.vTexture = null,
                this.zoomStats = Object.assign({}, v),
                this.size = {
                    renderWidth: 0,
                    renderHeight: 0,
                    styleWidth: 0,
                    styleHeight: 0
                },
                this.timestamp = 0,
                this.initPos = {
                    x: 0,
                    y: 0,
                    Tx: 0,
                    Ty: 0,
                    Mx: 0,
                    My: 0
                },
                this.canPlay = !1,
                this.paused = !1,
                this.frameQueue = [],
                this.syncFrameTime = {
                    startTime: -1,
                    startPTS: -1,
                    lastPTS: -1
                },
                this.syncTimer = null,
                this.resizeTimer = null,
                this.resizeBeforeRender = !1,
                this.isRendering = !1,
                this.zoomClickEvent = t => {
                    this.zoomUp(t)
                }
                ,
                this.zoomWheelEvent = t => {
                    t.preventDefault(),
                    t.deltaY < 0 ? this.zoomUp(t) : this.zoomDown()
                }
                ,
                this.onDragStart = t => {
                    this.initPos.x = t.offsetX,
                    this.initPos.y = t.offsetY,
                    t.dataTransfer && (t.dataTransfer.setDragImage(new Image, 0, 0),
                    t.dataTransfer.effectAllowed = "move")
                }
                ,
                this.onDragOver = t => {
                    this.handleDrag(t)
                }
                ,
                this.handleDrag = t => {
                    var e, i, n, r;
                    t.preventDefault();
                    const o = this.zoomStats.scale;
                    if (!t.offsetX || !t.offsetY)
                        return;
                    const s = t.offsetX - this.initPos.x
                      , a = t.offsetY - this.initPos.y
                      , l = s / this.mediaElement.width * o
                      , c = a / this.mediaElement.height * o
                      , h = this.initPos.Tx + l
                      , u = this.initPos.Ty - c
                      , {x: d, y: f} = this.moveTo(h, u);
                    if (this.initPos.Mx = d,
                    this.initPos.My = f,
                    this.config.supportWebcodecs && this.program) {
                        const t = null === (e = this.glWebcodecs) || void 0 === e ? void 0 : e.getUniformLocation(this.program, "scale")
                          , o = [this.zoomStats.scale, this.zoomStats.scale];
                        t && (null === (i = this.glWebcodecs) || void 0 === i || i.uniform2fv(t, o));
                        const s = null === (n = this.glWebcodecs) || void 0 === n ? void 0 : n.getUniformLocation(this.program, "translate")
                          , a = [d, f];
                        s && (null === (r = this.glWebcodecs) || void 0 === r || r.uniform2fv(s, a))
                    }
                }
                ,
                this.onDragEnd = () => {
                    this.initPos.Tx = this.initPos.Mx,
                    this.initPos.Ty = this.initPos.My,
                    this.initPos.Mx = 0,
                    this.initPos.My = 0
                }
                ,
                this.container = t,
                this.config = Object.assign(h(), e),
                this.ratio = this.config.objectFit;
                const i = this.createCanvas();
                this.canvas = i;
                const n = new ResizeObserver(( () => {
                    this.resizeVideo()
                }
                ));
                this.resizeObserver = n,
                n.observe(t),
                this.mediaElement = i,
                window.addEventListener("resize", this.resizeVideo.bind(this)),
                this.gl = this.mediaElement.getContext("webgl2") || this.mediaElement.getContext("experimental-webgl2"),
                this.gl ? x.supportWebGL2 = !0 : (this.gl = i.getContext("webgl") || i.getContext("experimental-webgl"),
                this.config.isAntialias = !1),
                this.glWebcodecs = null,
                e.supportWebcodecs ? this.initWebcodecsCanvas() : this.init() || this.logger.error("WebGL not supported.")
            }
            init() {
                if (!this.gl)
                    return !1;
                const t = this.gl;
                t.pixelStorei(t.UNPACK_ALIGNMENT, 1);
                const e = t.createProgram()
                  , i = ["attribute highp vec4 aVertexPosition;", "uniform mat4 u_xformMatrix;", "attribute vec2 aTextureCoord;", "varying highp vec2 vTextureCoord;", "void main(void) {", "    gl_Position = u_xformMatrix * aVertexPosition;", "    vTextureCoord = aTextureCoord;", "}"].join("\n")
                  , n = t.createShader(t.VERTEX_SHADER);
                if (!e || !n)
                    return !1;
                t.shaderSource(n, i),
                t.compileShader(n);
                const r = ["precision highp float;", "varying lowp vec2 vTextureCoord;", "uniform sampler2D YTexture;", "uniform sampler2D UTexture;", "uniform sampler2D VTexture;", "const mat4 YUV2RGB = mat4", "(", " 1, 0, 1.402, -0.701,", " 1, -0.344, -0.714, 0.529,", " 1, 1.772, 0, -0.886,", " 0, 0, 0, 1", ");", "void main(void) {", "    gl_FragColor = vec4( texture2D(YTexture, vTextureCoord).x, texture2D(UTexture, vTextureCoord).x, texture2D(VTexture, vTextureCoord).x, 1) * YUV2RGB;", "}"].join("\n")
                  , o = t.createShader(t.FRAGMENT_SHADER);
                if (!o)
                    return !1;
                t.shaderSource(o, r),
                t.compileShader(o),
                t.attachShader(e, n),
                t.attachShader(e, o),
                t.linkProgram(e),
                t.useProgram(e),
                t.getProgramParameter(e, t.LINK_STATUS) || this.logger.error("Shader link failed.");
                const a = t.getAttribLocation(e, "aVertexPosition");
                t.enableVertexAttribArray(a);
                const l = t.getAttribLocation(e, "aTextureCoord");
                t.enableVertexAttribArray(l);
                const c = t.createBuffer();
                t.bindBuffer(t.ARRAY_BUFFER, c),
                t.bufferData(t.ARRAY_BUFFER, new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]), t.STATIC_DRAW),
                t.vertexAttribPointer(a, 3, t.FLOAT, !1, 0, 0);
                const h = t.createBuffer();
                return t.bindBuffer(t.ARRAY_BUFFER, h),
                t.bufferData(t.ARRAY_BUFFER, new Float32Array([1, 0, 0, 0, 1, 1, 0, 1]), t.STATIC_DRAW),
                t.vertexAttribPointer(l, 2, t.FLOAT, !1, 0, 0),
                this.program = e,
                this.yTexture = new s(t,{
                    isAntialias: this.config.isAntialias
                }),
                this.uTexture = new s(t,{
                    isAntialias: this.config.isAntialias
                }),
                this.vTexture = new s(t,{
                    isAntialias: this.config.isAntialias
                }),
                this.yTexture.bind(0, e, "YTexture"),
                this.uTexture.bind(1, e, "UTexture"),
                this.vTexture.bind(2, e, "VTexture"),
                this.resetZoom(),
                !0
            }
            initWebcodecsCanvas() {
                const t = this.mediaElement;
                if (this.glWebcodecs = t.getContext("webgl2") || t.getContext("experimental-webgl2"),
                this.glWebcodecs ? x.supportWebGL2 = !0 : (this.glWebcodecs = t.getContext("webgl") || t.getContext("experimental-webgl"),
                this.config.isAntialias = !1),
                !this.glWebcodecs)
                    return;
                const e = this.glWebcodecs
                  , i = e.createShader(e.FRAGMENT_SHADER);
                if (!i)
                    return;
                if (e.shaderSource(i, "\n    varying highp vec2 uv;\n\n    uniform sampler2D texture;\n\n    void main(void) {\n      gl_FragColor = texture2D(texture, uv);\n    }\n  "),
                e.compileShader(i),
                !e.getShaderParameter(i, e.COMPILE_STATUS))
                    return y.error("An error occurred compiling the shaders: " + e.getShaderInfoLog(i)),
                    void e.deleteShader(i);
                const n = e.createShader(e.VERTEX_SHADER);
                if (!n)
                    return;
                e.shaderSource(n, "\n    attribute vec2 xy;\n\n    uniform vec2 scale;\n    uniform vec2 translate;\n\n    varying highp vec2 uv;\n\n    void main(void) {\n    vec2 scaledPosition = xy * scale+ translate;\n\n      gl_Position = vec4(scaledPosition, 0.0, 1.0);\n      // Map vertex coordinates (-1 to +1) to UV coordinates (0 to 1).\n      // UV coordinates are Y-flipped relative to vertex coordinates.\n      uv = vec2((1.0 + xy.x) / 2.0, (1.0 - xy.y) / 2.0);\n      }\n  "),
                e.compileShader(n);
                const r = e.createProgram();
                if (this.program = r,
                !r)
                    return;
                if (e.attachShader(r, n),
                e.attachShader(r, i),
                e.linkProgram(r),
                !e.getProgramParameter(r, e.LINK_STATUS))
                    return y.error("Unable to initialize the shader program: " + e.getProgramInfoLog(r)),
                    void e.deleteProgram(r);
                e.useProgram(r);
                const o = e.createBuffer();
                e.bindBuffer(e.ARRAY_BUFFER, o),
                e.bufferData(e.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), e.STATIC_DRAW);
                const s = e.getAttribLocation(r, "xy");
                e.vertexAttribPointer(s, 2, e.FLOAT, !1, 0, 0),
                e.enableVertexAttribArray(s);
                const a = e.getUniformLocation(r, "scale");
                e.uniform2fv(a, [1, 1]);
                const l = e.getUniformLocation(r, "translate");
                e.uniform2fv(l, [0, 0]);
                const c = e.createTexture()
                  , h = this.config.isAntialias ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR;
                e.bindTexture(e.TEXTURE_2D, c),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, h),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)
            }
            drawVideoFrame(t) {
                const e = this.glWebcodecs;
                if (!e)
                    return "";
                const {displayWidth: i, displayHeight: n} = t;
                e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
                if (((i !== this.size.renderWidth || n !== this.size.renderHeight) && "contain" === this.ratio || this.resizeBeforeRender) && (this.resizeCanvas(this.mediaElement, {
                    width: i,
                    height: n
                }),
                this.resizeBeforeRender = !1),
                this.config.isAntialias && e.generateMipmap(e.TEXTURE_2D),
                e.viewport(0, 0, e.drawingBufferWidth, e.drawingBufferHeight),
                e.clearColor(0, 0, 0, 0),
                e.clear(e.COLOR_BUFFER_BIT),
                this.isRendering = !0,
                e.drawArrays(e.TRIANGLE_FAN, 0, 4),
                this.lastFrame && this.lastFrame instanceof VideoFrame && !this.paused) {
                    this.lastFrame.close()
                }
                this.lastFrame = t,
                this.triggerCanPlay()
            }
            initScreenshot() {
                const t = document.createElement("canvas");
                this.screenshotGL = new x(t,Object.assign(Object.assign({}, this.config), {
                    screenshot: !1
                })),
                this.lastFrame = null
            }
            destroy() {
                var t;
                this.syncTimer && clearTimeout(this.syncTimer),
                window.removeEventListener("resize", this.resizeVideo.bind(this)),
                this.clear(),
                this.resizeObserver.disconnect(),
                this.canvas && (null === (t = this.container) || void 0 === t ? void 0 : t.contains(this.canvas)) && this.container.removeChild(this.canvas)
            }
            disConnectKeepLastFrame() {
                this.isRendering = !1
            }
            createCanvas() {
                if (!this.container)
                    throw this.logger.getLog("Container not exists.");
                const {width: t, height: e} = this.config
                  , {clientWidth: i, clientHeight: n} = this.container
                  , r = document.createElement("canvas");
                return r.oncontextmenu = function(t) {
                    t.preventDefault()
                }
                ,
                this.resizeCanvas(r, {
                    width: t || i,
                    height: e || n
                }),
                this.container.innerHTML = "",
                this.container.appendChild(r),
                r
            }
            resizeCanvas(t, {width: e, height: i}) {
                this.resizeTimer && clearInterval(this.resizeTimer);
                let n = ["width: 100%;", "height: 100%;"]
                  , r = 1;
                window.devicePixelRatio && window.devicePixelRatio > 1 && (r = window.devicePixelRatio);
                const o = e
                  , s = i;
                switch (this.ratio) {
                case "4/3":
                    {
                        const {width: e, height: i} = (0,
                        _.Mb)(this.container, 4 / 3);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: e,
                            height: i
                        }),
                        n = [`width: ${e}px;`, `height: ${i}px;`],
                        t.width = e * r,
                        t.height = i * r
                    }
                    break;
                case "16/9":
                    {
                        const {width: e, height: i} = (0,
                        _.Mb)(this.container, 16 / 9);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: e,
                            height: i
                        }),
                        n = [`width: ${e}px;`, `height: ${i}px;`],
                        t.width = e * r,
                        t.height = i * r
                    }
                    break;
                case "contain":
                    {
                        const {width: o, height: s} = (0,
                        _.Mb)(this.container, e / i);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: o,
                            height: s
                        }),
                        n = [`width: ${o}px;`, `height: ${s}px;`];
                        const a = o * r * this.config.imageQualityImprovementExtend
                          , l = s * r * this.config.imageQualityImprovementExtend;
                        t.width = a > e ? e : a,
                        t.height = l > i ? i : l
                    }
                    break;
                case "fill":
                    n = ["width: 100%;", "height: 100%;"],
                    t.width = this.container.offsetWidth * window.devicePixelRatio,
                    t.height = this.container.offsetHeight * window.devicePixelRatio,
                    this.playerEmitter.emit(g.PLAYER_SIZE, {
                        width: this.container.offsetWidth,
                        height: this.container.offsetHeight
                    })
                }
                this.size.styleWidth = o,
                this.size.styleHeight = s,
                t.setAttribute("style", n.join("")),
                this.size.renderWidth = e,
                this.size.renderHeight = i,
                this.lastFrame && this.paused && (this.config.supportWebcodecs ? this.drawVideoFrame(this.lastFrame) : this.renderFrame(this.lastFrame)),
                this.logger.log(`Resize canvas: ${e}*${i}`)
            }
            set zoomStatus(t) {
                this.isZoom = t,
                this.isZoom ? this.triggerZoomEvents() : this.detachZoomEvents()
            }
            triggerZoomEvents() {
                this.mediaElement.style.cursor = "zoom-in",
                this.mediaElement.addEventListener("click", this.zoomClickEvent),
                this.mediaElement.addEventListener("wheel", this.zoomWheelEvent),
                this.mediaElement.addEventListener("dragstart", this.onDragStart),
                this.mediaElement.addEventListener("dragover", this.onDragOver),
                this.mediaElement.addEventListener("dragend", this.onDragEnd)
            }
            detachZoomEvents() {
                this.mediaElement.style.cursor = "default",
                this.mediaElement.removeEventListener("click", this.zoomClickEvent),
                this.mediaElement.removeEventListener("wheel", this.zoomWheelEvent),
                this.mediaElement.removeEventListener("dragstart", this.onDragStart),
                this.mediaElement.removeEventListener("dragover", this.onDragOver),
                this.mediaElement.removeEventListener("dragend", this.onDragEnd)
            }
            resizeVideo() {
                this.paused ? this.resizeCanvas(this.mediaElement, {
                    width: this.size.renderWidth,
                    height: this.size.renderHeight
                }) : (this.resizeBeforeRender = !0,
                this.isRendering = !1,
                this.resizeTimer && clearInterval(this.resizeTimer),
                this.resizeTimer = setInterval(( () => {
                    this.isRendering || this.resizeCanvas(this.mediaElement, {
                        width: this.size.renderWidth,
                        height: this.size.renderHeight
                    })
                }
                ), 30))
            }
            changeRatio(t) {
                this.ratio = t,
                this.resizeVideo(),
                this.updateZoomState()
            }
            appendInitSegment() {}
            appendMediaSegment(t) {
                var e;
                if (this.paused) {
                    if (this.config.supportWebcodecs) {
                        t.data.close()
                    }
                } else
                    this.isStuck && (null === (e = this.playerEmitter) || void 0 === e || e.emit(g.STALLED_RESUME),
                    this.isStuck = !1),
                    this.canPlay && (this.stuckTimer && clearTimeout(this.stuckTimer),
                    this.stuckTimer = setTimeout(( () => {
                        var t;
                        this.paused || (null === (t = this.playerEmitter) || void 0 === t || t.emit(g.STALLED),
                        this.isStuck = !0)
                    }
                    ), 1e3 * this.config.stuckTriggerTime)),
                    this.syncVideoFrame(t)
            }
            syncVideoFrame(t) {
                this.frameQueue.push(t),
                -1 === this.syncFrameTime.startPTS ? this.renderNextFrame() : 1 === this.frameQueue.length && this.sync()
            }
            sync() {
                if (!this.frameQueue.length || this.syncTimer)
                    return;
                const t = performance.now() - this.syncFrameTime.startTime - this.config.webcodecDelayAcceptDuration
                  , e = 1e3 * (this.frameQueue[0].pts - this.syncFrameTime.startPTS) / 9e4;
                let i = e - t;
                e < 0 && (this.syncFrameTime.startPTS = this.frameQueue[0].pts,
                this.syncFrameTime.startTime = performance.now()),
                i > this.config.maxWebcodecDelayDuration && (this.syncFrameTime.startPTS = this.frameQueue[0].pts,
                this.syncFrameTime.startTime = performance.now(),
                i = 0),
                i > 0 ? this.syncTimer = setTimeout(( () => {
                    this.syncTimer = null,
                    this.renderNextFrame()
                }
                ), i) : this.renderNextFrame()
            }
            renderNextFrame() {
                const t = this.frameQueue.shift();
                if (t) {
                    if (-1 === this.syncFrameTime.startPTS) {
                        const {pts: e} = t;
                        this.syncFrameTime.startPTS = e,
                        this.syncFrameTime.startTime = performance.now()
                    }
                    this.config.supportWebcodecs ? this.drawVideoFrame(t.data) : this.renderFrame(t.data)
                }
                this.sync()
            }
            moveTo(t, e) {
                const i = this.zoomStats;
                return this.isExceedBorder(t, e),
                this.setTransformMatrix(i.scale, i.scale, i.Tx, i.Ty),
                {
                    x: i.Tx,
                    y: i.Ty
                }
            }
            isExceedBorder(t, e) {
                const i = this.zoomStats
                  , n = i.scale - 1;
                t > n ? t = n : t < -n && (t = -n),
                e > n ? e = n : e < -n && (e = -n),
                i.Tx = t,
                i.Ty = e
            }
            renderFrame(t) {
                var e, i, n;
                if (!this.gl)
                    return void this.logger.error("Render frame failed due to WebGL not supported.");
                const {data: r, width: o, height: s, uOffset: a, vOffset: l, timestamp: c, seq: h} = t;
                ((o !== this.size.renderWidth || s !== this.size.renderHeight) && "contain" === this.ratio || this.resizeBeforeRender) && (this.resizeCanvas(this.mediaElement, {
                    width: o,
                    height: s
                }),
                this.resizeBeforeRender = !1),
                this.timestamp !== c && (this.playerEmitter.emit(g.UPDATE_TIMESTAMP, c),
                this.timestamp = c);
                const u = this.gl
                  , d = new Uint8Array(r);
                u.viewport(0, 0, u.drawingBufferWidth, u.drawingBufferHeight),
                u.clearColor(0, 0, 0, 0),
                u.clear(u.COLOR_BUFFER_BIT),
                null === (e = this.yTexture) || void 0 === e || e.fill(o, s, d.subarray(0, a)),
                null === (i = this.uTexture) || void 0 === i || i.fill(o >> 1, s >> 1, d.subarray(a, a + l)),
                null === (n = this.vTexture) || void 0 === n || n.fill(o >> 1, s >> 1, d.subarray(a + l, d.length)),
                this.isRendering = !0,
                u.drawArrays(u.TRIANGLE_STRIP, 0, 4),
                this.lastFrameSequence > 0 && this.lastFrameSequence - h <= 3 && this.playerEmitter.emit(g.PLAY_FINISHED),
                this.lastFrame = Object.assign({}, t),
                this.triggerCanPlay()
            }
            triggerCanPlay() {
                this.canPlay || this.canPlay || this.config.onlyScreenShot || (this.canPlay = !0,
                this.playerEmitter.emit(g.CAN_PLAY))
            }
            zoomUp(t) {
                var e, i, n;
                if (this.mediaElement.draggable || (this.mediaElement.draggable = !0),
                !t)
                    return;
                const r = this.zoomStats
                  , o = t.target
                  , s = o.getBoundingClientRect()
                  , a = (t.clientX - s.left - o.width / 2) / (o.width / 2)
                  , l = (o.height / 2 - (t.clientY - s.top)) / (o.height / 2);
                if (r.scale = Math.min(r.scale * this.config.scaleOptions.scaleStep, this.config.scaleOptions.maxScale),
                this.playerEmitter.emit(g.SCALE_CHANGE, this.zoomStats.scale),
                r.scale > this.config.scaleOptions.maxScale)
                    return;
                a * r.pointX < 0 && (r.realScaleX = 1),
                l * r.pointY < 0 && (r.realScaleY = 1),
                r.realScaleXList.push(r.realScaleX),
                r.realScaleYList.push(r.realScaleY),
                r.realScaleX *= this.config.scaleOptions.scaleStep,
                r.realScaleY *= this.config.scaleOptions.scaleStep;
                const c = r.scale
                  , h = r.scale
                  , u = a * (this.config.scaleOptions.scaleStep - 1) * r.realScaleX / this.config.scaleOptions.scaleStep
                  , d = l * (this.config.scaleOptions.scaleStep - 1) * r.realScaleY / this.config.scaleOptions.scaleStep
                  , f = r.Tx - u
                  , p = r.Ty - d;
                if (this.initPos.Tx = f,
                this.initPos.Ty = p,
                this.isExceedBorder(f, p),
                this.setTransformMatrix(c, h, this.zoomStats.Tx, this.zoomStats.Ty),
                this.config.supportWebcodecs && this.program && this.glWebcodecs) {
                    const t = this.glWebcodecs.getUniformLocation(this.program, "scale")
                      , r = [c, h];
                    t && (null === (e = this.glWebcodecs) || void 0 === e || e.uniform2fv(t, r));
                    const o = null === (i = this.glWebcodecs) || void 0 === i ? void 0 : i.getUniformLocation(this.program, "translate")
                      , s = [this.zoomStats.Tx, this.zoomStats.Ty];
                    o && (null === (n = this.glWebcodecs) || void 0 === n || n.uniform2fv(o, s))
                }
                r.pointX = a,
                r.pointY = l,
                r.Tx = f,
                r.Ty = p,
                r.pointXList.push(r.pointX),
                r.pointYList.push(r.pointY),
                r.DxList.push(u),
                r.DyList.push(d)
            }
            zoomValue(t) {
                var e, i, n;
                const r = this.zoomStats;
                if (r.scale = Math.min(t, this.config.scaleOptions.maxScale),
                this.playerEmitter.emit(g.SCALE_CHANGE, this.zoomStats.scale),
                r.scale > this.config.scaleOptions.maxScale)
                    return;
                const o = r.scale
                  , s = r.scale
                  , a = r.Tx
                  , l = r.Ty;
                if (this.isExceedBorder(a, l),
                this.setTransformMatrix(o, s, r.Tx, r.Ty),
                this.config.supportWebcodecs && this.program && this.glWebcodecs) {
                    const t = this.glWebcodecs.getUniformLocation(this.program, "scale")
                      , r = [o, s];
                    t && (null === (e = this.glWebcodecs) || void 0 === e || e.uniform2fv(t, r));
                    const a = null === (i = this.glWebcodecs) || void 0 === i ? void 0 : i.getUniformLocation(this.program, "translate")
                      , l = [this.zoomStats.Tx, this.zoomStats.Ty];
                    a && (null === (n = this.glWebcodecs) || void 0 === n || n.uniform2fv(a, l))
                }
            }
            zoomDown() {
                var t, e, i;
                const {DxList: n, DyList: r, pointXList: o, pointYList: s, realScaleXList: a, realScaleYList: l} = this.zoomStats;
                if (this.zoomStats.scale /= this.config.scaleOptions.scaleStep,
                this.zoomStats.scale <= 1)
                    return void this.resetZoom();
                this.playerEmitter.emit(g.SCALE_CHANGE, this.zoomStats.scale);
                const c = n.pop()
                  , h = r.pop()
                  , u = this.zoomStats.scale
                  , d = this.zoomStats.scale
                  , f = this.zoomStats.Tx + (c || 0)
                  , p = this.zoomStats.Ty + (h || 0);
                if (this.isExceedBorder(f, p),
                this.config.supportWebcodecs && this.program && this.glWebcodecs) {
                    const n = this.glWebcodecs.getUniformLocation(this.program, "scale")
                      , r = [u, d];
                    n && (null === (t = this.glWebcodecs) || void 0 === t || t.uniform2fv(n, r));
                    const o = null === (e = this.glWebcodecs) || void 0 === e ? void 0 : e.getUniformLocation(this.program, "translate")
                      , s = [this.zoomStats.Tx, this.zoomStats.Ty];
                    o && (null === (i = this.glWebcodecs) || void 0 === i || i.uniform2fv(o, s))
                }
                this.setTransformMatrix(u, d, this.zoomStats.Tx, this.zoomStats.Ty),
                this.zoomStats.pointX = o.pop() || 0,
                this.zoomStats.pointY = s.pop() || 0,
                this.zoomStats.realScaleX = a.pop() || 0,
                this.zoomStats.realScaleY = l.pop() || 0,
                this.zoomStats.Tx = f,
                this.zoomStats.Ty = p
            }
            resetZoom() {
                Object.assign(this.zoomStats, v),
                this.playerEmitter.emit(g.SCALE_CHANGE, this.zoomStats.scale),
                this.setTransformMatrix(this.zoomStats.realScaleX, this.zoomStats.realScaleY, this.zoomStats.Tx, this.zoomStats.Ty)
            }
            handleWebcodecsScreenshot(t="screenshot") {
                if (!(this.lastFrame instanceof VideoFrame))
                    return;
                const e = document.createElement("canvas")
                  , i = e.getContext("2d")
                  , {displayWidth: n, displayHeight: r} = this.lastFrame;
                e.width = n,
                e.height = r,
                null == i || i.drawImage(this.lastFrame, 0, 0, n, r);
                const o = document.createElement("a");
                o.download = (0,
                _.QZ)(t, ".png"),
                o.href = e.toDataURL(),
                o.click(),
                o.remove(),
                this.lastFrame.close()
            }
            handleScreenshot(t="screenshot") {
                this.lastFrame = this.lastFrame;
                const {width: e, height: i} = this.lastFrame
                  , n = document.createElement("div")
                  , r = new x(n,{
                    width: e,
                    height: i,
                    onlyScreenShot: !0,
                    baseConfig: this.config.baseConfig
                });
                r.mediaElement.width = e,
                r.mediaElement.height = i,
                r.renderFrame(this.lastFrame);
                const o = document.createElement("a");
                o.download = (0,
                _.QZ)(t, ".png"),
                o.href = r.mediaElement.toDataURL(),
                o.click(),
                o.remove(),
                r.destroy(),
                n.remove()
            }
            screenshot(t="screenshot") {
                this.lastFrame && (this.config.supportWebcodecs ? this.handleWebcodecsScreenshot(t) : this.handleScreenshot(t))
            }
            captureImage() {
                return this.config.supportWebcodecs ? this.webcodecCaptureImg() : this.webGLCaptureImg()
            }
            webcodecCaptureImg() {
                const t = {
                    base64URL: "",
                    success: !1
                };
                if (!(this.lastFrame instanceof VideoFrame))
                    return t;
                const e = document.createElement("canvas")
                  , i = e.getContext("2d")
                  , {displayWidth: n, displayHeight: r} = this.lastFrame;
                return e.width = n,
                e.height = r,
                null == i || i.drawImage(this.lastFrame, 0, 0, n, r),
                t.base64URL = e.toDataURL(),
                t.success = !0,
                t
            }
            webGLCaptureImg() {
                const t = {
                    base64URL: "",
                    success: !1
                };
                if (!this.lastFrame)
                    return t;
                const {width: e, height: i} = this.lastFrame
                  , n = document.createElement("div")
                  , r = new x(n,{
                    width: e,
                    height: i,
                    onlyScreenShot: !0,
                    baseConfig: this.config.baseConfig
                });
                return r.mediaElement.width = e,
                r.mediaElement.height = i,
                r.renderFrame(this.lastFrame),
                t.success = !0,
                t.base64URL = r.mediaElement.toDataURL(),
                r.destroy(),
                n.remove(),
                t
            }
            setTransformMatrix(t, e, i, n) {
                if (!this.program || !this.gl)
                    return;
                const r = this.gl
                  , o = new Float32Array([t, 0, 0, 0, 0, e, 0, 0, 0, 0, 1, 0, i, n, 0, 1])
                  , s = r.getUniformLocation(this.program, "u_xformMatrix");
                r.uniformMatrix4fv(s, !1, o)
            }
            clear() {
                var t;
                if (!this.gl)
                    return;
                const e = this.gl;
                e.clearColor(0, 0, 0, 0),
                e.clear(e.COLOR_BUFFER_BIT),
                null === (t = e.getExtension("WEBGL_lose_context")) || void 0 === t || t.loseContext()
            }
            seek() {}
            pause() {
                this.paused = !0
            }
            resume() {
                this.paused = !1
            }
            changePlayBackRate() {
                this.logger.warn("webGLPlayer doesn't support double speed playback")
            }
            onVideoSegment(t) {
                this.videoSegmentHook = t
            }
        }
        x.supportWebGL2 = !1;
        var b = x;
        const w = {
            version: {
                major: 0,
                minor: 0,
                build: 0,
                string: ""
            }
        };
        !function() {
            const t = self.navigator.userAgent.toLowerCase()
              , e = /(edge)\/([\w.]+)/.exec(t) || /(opr)[/]([\w.]+)/.exec(t) || /(chrome)[ /]([\w.]+)/.exec(t) || /(iemobile)[/]([\w.]+)/.exec(t) || /(version)(applewebkit)[ /]([\w.]+).*(safari)[ /]([\w.]+)/.exec(t) || /(webkit)[ /]([\w.]+).*(version)[ /]([\w.]+).*(safari)[ /]([\w.]+)/.exec(t) || /(webkit)[ /]([\w.]+)/.exec(t) || /(opera)(?:.*version|)[ /]([\w.]+)/.exec(t) || /(msie) ([\w.]+)/.exec(t) || t.indexOf("trident") >= 0 && /(rv)[: ]([\w.]+)/.exec(t) || t.indexOf("compatible") < 0 && /(firefox)[ /]([\w.]+)/.exec(t) || []
              , i = /(ipad)/.exec(t) || /(ipod)/.exec(t) || /(windows phone)/.exec(t) || /(iphone)/.exec(t) || /(kindle)/.exec(t) || /(android)/.exec(t) || /(windows)/.exec(t) || /(mac)/.exec(t) || /(linux)/.exec(t) || /(cros)/.exec(t) || []
              , n = {
                browser: e[5] || e[3] || e[1] || "",
                version: e[2] || e[4] || "0",
                majorVersion: e[4] || e[2] || "0",
                platform: i[0] || ""
            }
              , r = {};
            if (n.browser) {
                r[n.browser] = !0;
                const t = n.majorVersion.split(".");
                r.version = {
                    major: parseInt(n.majorVersion, 10),
                    minor: 0,
                    build: 0,
                    string: n.version
                },
                t.length > 1 && (r.version.minor = parseInt(t[1], 10)),
                t.length > 2 && (r.version.build = parseInt(t[2], 10))
            }
            n.platform && (r[n.platform] = !0),
            (r.chrome || r.opr || r.safari) && (r.webkit = !0),
            (r.rv || r.iemobile) && (r.msie = !0),
            r.opr && (r.opera = !0),
            r.safari && r.android && (r.android = !0),
            r.name = n.browser,
            r.platform = n.platform,
            Object.assign(w, r)
        }();
        var E = w
          , T = i(19131);
        class S {
            constructor(t) {
                this._message = t
            }
            get name() {
                return "RuntimeException"
            }
            get message() {
                return this._message
            }
            toString() {
                return this.name + ": " + this.message
            }
        }
        class C extends S {
            constructor(t) {
                super(t)
            }
            get name() {
                return "IllegalStateException"
            }
        }
        var A = class extends a {
            constructor(t) {
                super(t.baseConfig),
                this.onSourceOpen = () => {
                    var t;
                    if (this.logger.log("MediaSource onSourceOpen"),
                    null === (t = this.mediaSource) || void 0 === t || t.removeEventListener("sourceopen", this.onSourceOpen),
                    this.mediaSource && (this.mediaSource.duration = Number.POSITIVE_INFINITY),
                    this.pendingSourceBufferInit.length > 0) {
                        const t = this.pendingSourceBufferInit;
                        for (; t.length; ) {
                            const e = t.shift();
                            e && this.appendInitSegment(e, !0)
                        }
                    }
                    this.hasPendingSegments() && this.doAppendSegments(),
                    this.playerEmitter.emit(m.SOURCE_OPEN)
                }
                ,
                this.onSourceEnded = () => {
                    this.logger.log("MediaSource onSourceEnded")
                }
                ,
                this.onSourceClose = () => {
                    this.logger.log("MediaSource onSourceClose"),
                    this.mediaSource && (this.mediaSource.removeEventListener("sourceopen", this.onSourceOpen),
                    this.mediaSource.removeEventListener("sourceended", this.onSourceEnded),
                    this.mediaSource.removeEventListener("sourceclose", this.onSourceClose))
                }
                ,
                this.onSourceBufferUpdateEnd = () => {
                    this.hasPendingRemoveRanges() ? this.doRemoveRanges() : this.hasPendingSegments() ? this.doAppendSegments() : this.hasPendingEos && this.endOfStream(),
                    this.playerEmitter.emit(m.UPDATE_END)
                }
                ,
                this.onSourceBufferError = t => {
                    this.logger.error("SourceBuffer Error: " + JSON.stringify(t))
                }
                ,
                this.config = t,
                this.duration = 0,
                this.lastMediaTime = 0,
                this.lastCheckTime = 0,
                this.config.mediaType === T.DD.DOUBLE_LINES && (this.config.maxLatency += this.config.dlinesAdditionalDelay),
                this.mediaSource = null,
                this.mediaSourceObjectURL = "",
                this.mediaElement = null,
                this.isBufferFull = !1,
                this.hasPendingEos = !1,
                this.mimeChanged = !1,
                this.pendingSourceBufferInit = [],
                this.mimeTypes = {
                    video: null,
                    audio: null
                },
                this.sourceBuffers = {
                    video: null,
                    audio: null
                },
                this.lastInitSegments = {
                    video: null,
                    audio: null
                },
                this.pendingSegments = {
                    video: [],
                    audio: []
                },
                this.pendingRemoveRanges = {
                    video: [],
                    audio: []
                }
            }
            destroy() {
                (this.mediaElement || this.mediaSource) && this.detachMediaElement()
            }
            attachMediaElement(t) {
                if (this.mediaSource)
                    throw new C("MediaSource has been attached to an HTMLMediaElement!");
                const e = this.mediaSource = new window.MediaSource;
                e.addEventListener("sourceopen", this.onSourceOpen),
                e.addEventListener("sourceended", this.onSourceEnded),
                e.addEventListener("sourceclose", this.onSourceClose),
                this.mediaElement = t,
                this.mediaSourceObjectURL = window.URL.createObjectURL(this.mediaSource),
                t.src = this.mediaSourceObjectURL
            }
            detachMediaElement() {
                if (this.mediaSource) {
                    const t = this.mediaSource;
                    for (const e in this.sourceBuffers) {
                        const i = e
                          , n = this.pendingSegments[i];
                        n.splice(0, n.length),
                        this.pendingSegments[i] = [],
                        this.pendingRemoveRanges[i] = [],
                        this.lastInitSegments[i] = null;
                        const r = this.sourceBuffers[i];
                        r && ("closed" !== t.readyState && (t.removeSourceBuffer(r),
                        r.removeEventListener("error", this.onSourceBufferError),
                        r.removeEventListener("updateend", this.onSourceBufferUpdateEnd)),
                        this.mimeTypes[i] = null,
                        this.sourceBuffers[i] = null)
                    }
                    if ("open" === t.readyState)
                        try {
                            t.endOfStream()
                        } catch (t) {
                            const e = t;
                            this.logger.error(e.message)
                        }
                    t.removeEventListener("sourceopen", this.onSourceOpen),
                    t.removeEventListener("sourceended", this.onSourceEnded),
                    t.removeEventListener("sourceclose", this.onSourceClose),
                    this.pendingSourceBufferInit = [],
                    this.isBufferFull = !1,
                    this.mediaSource = null
                }
                this.mediaElement && (this.mediaElement.src = "",
                this.mediaElement.removeAttribute("src"),
                this.mediaElement = null),
                this.mediaSourceObjectURL && (window.URL.revokeObjectURL(this.mediaSourceObjectURL),
                this.mediaSourceObjectURL = "")
            }
            appendInitSegment(t, e) {
                var i;
                const n = t.type;
                if (!this.mediaSource || "open" !== this.mediaSource.readyState)
                    return this.pendingSourceBufferInit.push(t),
                    void this.pendingSegments[n].push(t);
                const r = `${t.container};codecs=${t.codec}`;
                let o = !1;
                if (this.logger.log("Received Initialization Segment, mimeType: " + r),
                this.lastInitSegments[n] = t,
                r !== this.mimeTypes[n]) {
                    if (this.mimeTypes[n])
                        this.logger.log(`Notice: ${n} mimeType changed, origin: ${this.mimeTypes[n]}, target: ${r}`),
                        this.mimeChanged = !0;
                    else {
                        o = !0;
                        try {
                            const t = this.sourceBuffers[n] = this.mediaSource.addSourceBuffer(r);
                            t.addEventListener("error", this.onSourceBufferError),
                            t.addEventListener("updateend", this.onSourceBufferUpdateEnd)
                        } catch (t) {
                            const e = t;
                            return this.logger.error(e.message),
                            void this.playerEmitter.emit(m.ERROR, {
                                code: e.code,
                                msg: e.message
                            })
                        }
                    }
                    this.mimeTypes[n] = r
                }
                e || this.pendingSegments[n].push(t),
                o || this.sourceBuffers[n] && !(null === (i = this.sourceBuffers[n]) || void 0 === i ? void 0 : i.updating) && this.doAppendSegments()
            }
            appendMediaSegment(t) {
                const e = t
                  , i = e.type;
                this.pendingSegments[i].push(e),
                this.config.autoCleanupSourceBuffer && this.needCleanupSourceBuffer() && this.doCleanupSourceBuffer();
                const n = this.sourceBuffers[i];
                !n || n.updating || this.hasPendingRemoveRanges() || this.doAppendSegments()
            }
            seek() {
                var t, e;
                for (const i in this.sourceBuffers) {
                    const n = i;
                    if (!this.sourceBuffers[n])
                        continue;
                    const r = this.sourceBuffers[n];
                    if (!r)
                        continue;
                    if ("open" === (null === (t = this.mediaSource) || void 0 === t ? void 0 : t.readyState))
                        try {
                            null == r || r.abort()
                        } catch (t) {
                            const e = t;
                            this.logger.error(e.message)
                        }
                    const o = this.pendingSegments[n];
                    if (o.splice(0, o.length),
                    "closed" !== (null === (e = this.mediaSource) || void 0 === e ? void 0 : e.readyState)) {
                        for (let t = 0; t < r.buffered.length; t++) {
                            const e = r.buffered.start(t)
                              , i = r.buffered.end(t);
                            this.pendingRemoveRanges[n].push({
                                start: e,
                                end: i
                            })
                        }
                        if (r.updating || this.doRemoveRanges(),
                        E.safari) {
                            const t = this.lastInitSegments[n];
                            t && (this.pendingSegments[n].push(t),
                            r.updating || this.doAppendSegments())
                        }
                    }
                }
            }
            endOfStream() {
                const t = this.mediaSource
                  , e = this.sourceBuffers;
                t && "open" === t.readyState ? e.video && e.video.updating || e.audio && e.audio.updating ? this.hasPendingEos = !0 : (this.hasPendingEos = !1,
                t.endOfStream()) : t && "closed" === t.readyState && this.hasPendingSegments() && (this.hasPendingEos = !0)
            }
            doRemoveRanges() {
                for (const t in this.pendingRemoveRanges) {
                    const e = t
                      , i = this.sourceBuffers[e];
                    if (!i || i.updating)
                        continue;
                    const n = this.pendingRemoveRanges[e];
                    for (; n.length && !i.updating; ) {
                        const t = n.shift();
                        t && i.remove(t.start, t.end),
                        t && this.logger.log(`doCleanupSourceBuffer from:${t.start},to:${t.end}`)
                    }
                }
            }
            doAppendSegments() {
                const t = this.pendingSegments
                  , e = this.sourceBuffers;
                if (this.mediaElement)
                    for (const i in t) {
                        const n = i;
                        if (!(e.video && e.video.updating || e.audio && e.audio.updating) && t[n].length > 0) {
                            const i = e[n]
                              , r = t[n].shift();
                            if (!r || !i)
                                continue;
                            if (r.codec && this.mimeChanged && this.mimeTypes[n] && i.changeType(this.mimeTypes[n]),
                            !r.data || 0 === r.data.byteLength) {
                                this.logger.log("skip empty segment");
                                continue
                            }
                            try {
                                i.appendBuffer(r.data),
                                this.isBufferFull = !1,
                                "video" === n && void 0 !== r.duration && (this.duration = this.duration + r.duration)
                            } catch (e) {
                                t[n].unshift(r);
                                const i = e;
                                22 === (null == i ? void 0 : i.code) ? (this.isBufferFull || this.playerEmitter.emit(m.BUFFER_FULL),
                                this.isBufferFull = !0) : (this.logger.error(i.message),
                                this.playerEmitter.emit(m.ERROR, {
                                    code: i.code,
                                    msg: i.message
                                }))
                            }
                        }
                    }
                else
                    this.logger.error("mediaElement not exists.")
            }
            needCleanupSourceBuffer() {
                var t;
                if (!this.config.autoCleanupSourceBuffer)
                    return !1;
                if (this.mediaElement && this.sourceBuffers) {
                    const e = null === (t = this.mediaElement) || void 0 === t ? void 0 : t.currentTime
                      , i = this.mediaElement.paused;
                    for (const t in this.sourceBuffers) {
                        const n = this.sourceBuffers[t];
                        if (n) {
                            const t = n.buffered;
                            if (t.length >= 1) {
                                if (e - t.start(0) >= this.config.autoCleanupMaxBackwardDuration)
                                    return !0;
                                if (i && !this.config.needStashBuffer) {
                                    if (t.end(0) - t.start(0) >= this.config.autoCleanupMaxBackwardDuration)
                                        return !0
                                }
                            }
                        }
                    }
                }
                return !1
            }
            doCleanupSourceBuffer() {
                if (this.mediaElement) {
                    const t = this.mediaElement.currentTime
                      , e = this.mediaElement.paused;
                    for (const i in this.sourceBuffers) {
                        const n = this.sourceBuffers[i];
                        if (n) {
                            const r = n.buffered;
                            let o = !1;
                            for (let n = 0; n < r.length; n++) {
                                const s = r.start(n)
                                  , a = r.end(n);
                                if (e && !this.config.needStashBuffer) {
                                    if (r.end(n) - r.start(n) >= this.config.autoCleanupMaxBackwardDuration) {
                                        o = !0;
                                        const t = a - this.config.autoCleanupMinBackwardDuration;
                                        this.pendingRemoveRanges[i].push({
                                            start: s,
                                            end: t
                                        })
                                    }
                                } else if (s <= t && t < a + 3 && t - s >= this.config.autoCleanupMaxBackwardDuration) {
                                    o = !0;
                                    const e = t - this.config.autoCleanupMinBackwardDuration;
                                    this.pendingRemoveRanges[i].push({
                                        start: s,
                                        end: e
                                    })
                                }
                            }
                            o && !n.updating && this.doRemoveRanges()
                        }
                    }
                }
            }
            hasPendingSegments() {
                const t = this.pendingSegments;
                return t.video.length > 0 || t.audio.length > 0
            }
            hasPendingRemoveRanges() {
                const t = this.pendingRemoveRanges;
                return t.video.length > 0 || t.audio.length > 0
            }
        }
        ;
        class I extends l {
            constructor(t, e) {
                super(e),
                this.videoFrameMap = new Map,
                this.minLiveBuffer = 0,
                this.scale = 1,
                this.initPoint = {
                    x: 0,
                    y: 0
                },
                this.movePoint = {
                    x: 0,
                    y: 0
                },
                this.isMove = !1,
                this.isDrag = !1,
                this.enableFrameCallback = !E.safari && "requestVideoFrameCallback"in HTMLVideoElement.prototype,
                this.codeResolution = {
                    width: 0,
                    height: 0
                },
                this.zoomClickEvent = t => {
                    this.zoomUp(t)
                }
                ,
                this.zoomWheelEvent = t => {
                    t.preventDefault(),
                    t.deltaY < 0 ? this.zoomUp(t) : this.zoomDown()
                }
                ,
                this.onMSEUpdateEnd = () => {
                    if (!this.mediaElement)
                        return void this.logger.error("MediaElement not exists");
                    this.isStuck && (this.playerEmitter.emit(g.STALLED_RESUME),
                    this.isStuck = !1);
                    const t = this.mediaElement.buffered
                      , e = this.mediaElement.currentTime;
                    if (this.config.liveBufferLatencyChasing && t.length > 0 && !this.mediaElement.paused) {
                        const i = t.end(t.length - 1);
                        if (i > this.config.liveBufferLatencyMaxLatency + this.minLiveBuffer && i - e > this.config.liveBufferLatencyMaxLatency + this.minLiveBuffer) {
                            const t = i - (this.config.liveBufferLatencyMinRemain + this.minLiveBuffer);
                            this.currentTime = t
                        }
                    }
                    if (!this.config.lazyLoad)
                        return;
                    let i = 0;
                    for (let n = 0; n < t.length; n++) {
                        const r = t.start(n)
                          , o = t.end(n);
                        if (r <= e && e < o) {
                            i = o;
                            break
                        }
                    }
                    i >= e + this.config.lazyLoadMaxDuration && -1 === this.progressChecker && (this.logger.log("Maximum buffering duration exceeded, suspend transmuxing task"),
                    this.suspendTransmuxer())
                }
                ,
                this.onMSEBufferFull = () => {
                    this.logger.log("MSE SourceBuffer is full, suspend transmuxing task")
                }
                ,
                this.checkAndApplyUnbufferedSeekPoint = () => {
                    var t;
                    if (this.mediaElement) {
                        if (this.seekPointRecord)
                            if (this.seekPointRecord.recordTime <= Date.now() - 100) {
                                const e = this.mediaElement.currentTime;
                                this.seekPointRecord = null,
                                this.isTimePointBuffered(e) || (-1 !== this.progressChecker && (window.clearTimeout(this.progressChecker),
                                this.progressChecker = -1),
                                null === (t = this.mseController) || void 0 === t || t.seek(),
                                this.config.accurateSeek && (this.requestSetTime = !0,
                                this.mediaElement.currentTime = e))
                            } else
                                window.setTimeout(this.checkAndApplyUnbufferedSeekPoint.bind(this), 50)
                    } else
                        this.logger.error("MediaElement not exists")
                }
                ,
                this.onvLoadedMetadata = () => {
                    this.mediaElement ? -1 != this.pendingSeekTime && (this.mediaElement.currentTime = this.pendingSeekTime,
                    this.pendingSeekTime = -1) : this.logger.error("MediaElement not exists")
                }
                ,
                this.onvSeeking = () => {
                    if (!this.mediaElement)
                        return void this.logger.error("MediaElement not exists");
                    const t = this.mediaElement.currentTime
                      , e = this.mediaElement.buffered;
                    if (this.requestSetTime)
                        this.requestSetTime = !1;
                    else {
                        if (t < 1 && e.length > 0) {
                            const i = e.start(0);
                            if (i < 1 && t < i || E.safari)
                                return this.requestSetTime = !0,
                                void (this.mediaElement.currentTime = E.safari ? .1 : i)
                        }
                        this.seekPointRecord = {
                            seekPoint: t,
                            recordTime: Date.now()
                        }
                    }
                }
                ,
                this.onvCanPlay = () => {
                    var t;
                    if (!this.mediaElement)
                        return void this.logger.error("MediaElement not exists");
                    this.mediaElement.play();
                    const e = this.mediaElement;
                    null === (t = e.captureStream) || void 0 === t || t.call(e),
                    this.receivedCanPlay = !0,
                    this.playerEmitter.emit(g.CAN_PLAY);
                    const i = this.mediaElement.buffered;
                    i.length && (this.minLiveBuffer = i.end(i.length - 1),
                    this.initPlayRate(),
                    this.mediaElement.removeEventListener("canplay", this.onvCanPlay))
                }
                ,
                this.onvStalled = () => {
                    this.checkAndResumeStuckPlayback(!0)
                }
                ,
                this.onvProgress = () => {
                    this.checkAndResumeStuckPlayback(!1)
                }
                ,
                this.onvWaiting = () => {
                    if (this.mediaElement.buffered.length) {
                        if (this.isStuck)
                            return;
                        this.isStuck = !0,
                        this.stuckTimer && clearTimeout(this.stuckTimer),
                        this.stuckTimer = setTimeout(( () => {
                            this.isStuck && this.playerEmitter.emit(g.STALLED)
                        }
                        ), 1e3 * this.config.stuckTriggerTime)
                    }
                }
                ,
                this.videoFrameCallback = (t, e) => {
                    let {mediaTime: i} = e;
                    const {width: n, height: r} = e;
                    if (this.codeResolution.width !== n || this.codeResolution.height !== r) {
                        this.codeResolution.width = n,
                        this.codeResolution.height = r;
                        const t = (0,
                        _.Mb)(this.container, this.codeResolution.width / this.codeResolution.height);
                        "contain" === this.ratio && this.playerEmitter.emit(g.PLAYER_SIZE, t)
                    }
                    i *= 1e3,
                    i = +i.toFixed();
                    const o = this.videoFrameMap.get(i);
                    if (o) {
                        const {timestamp: t, seq: e} = o;
                        this.lastFrameSequence > 0 && this.lastFrameSequence - e <= 3 && this.playerEmitter.emit(g.PLAY_FINISHED),
                        this.timestamp !== t && (this.timestamp = t,
                        this.playerEmitter.emit(g.UPDATE_TIMESTAMP, t))
                    } else
                        this.videoFrameMap.clear();
                    [...this.videoFrameMap.keys()].forEach((t => {
                        (t < i || !i) && this.videoFrameMap.delete(t)
                    }
                    )),
                    this.videoFrameMap.delete(i),
                    this.mediaElement.requestVideoFrameCallback(this.videoFrameCallback)
                }
                ,
                this.onvTimeupdate = () => {
                    if (!this.mediaElement)
                        return void this.logger.error("MediaElement not exists");
                    const t = this.mediaElement.buffered
                      , e = this.mediaElement.currentTime
                      , i = t.end(t.length - 1);
                    i - e > 2 && !this.isOverflow ? (this.isOverflow = !0,
                    this.playerEmitter.emit(g.UPDATE_STATUS, {
                        isOverflow: this.isOverflow
                    })) : i - e <= 2 && this.isOverflow && (this.isOverflow = !1,
                    this.playerEmitter.emit(g.UPDATE_STATUS, {
                        isOverflow: this.isOverflow
                    }));
                    const n = Math.round(this.mediaElement.currentTime);
                    n >= Math.ceil(this.needCorrectDts / 1e3) && this.needCorrectDts && (this.totalReduce += this.lastReduce,
                    this.needCorrectDts = 0);
                    const r = this.timeBase + n + this.totalReduce;
                    this.timestamp !== r && this.timeBase && (this.playerEmitter.emit(g.UPDATE_TIMESTAMP, r),
                    this.timestamp = r)
                }
                ,
                this.onMouseDown = t => {
                    const e = this.mediaElement;
                    this.isMove = !0,
                    this.isDrag = !1;
                    const {offsetX: i, offsetY: n} = t;
                    this.initPoint.x = i,
                    this.initPoint.y = n,
                    null == e || e.addEventListener("mousemove", this.onMouseMove)
                }
                ,
                this.onMouseMove = t => {
                    const e = this.mediaElement;
                    if (this.isMove && e) {
                        const {offsetX: i, offsetY: n} = t;
                        this.initPoint.x === i && this.initPoint.y === n || (this.movePoint.x += i - this.initPoint.x,
                        this.movePoint.y += n - this.initPoint.y,
                        this.isDrag = !0,
                        this.judgeBoundary(),
                        e.style.transform = `translate(${this.movePoint.x}px, ${this.movePoint.y}px) scale(${this.scale})`)
                    }
                }
                ,
                this.onMouseUp = () => {
                    const t = this.mediaElement;
                    this.isMove = !1,
                    null == t || t.removeEventListener("mousemove", this.onMouseMove)
                }
                ,
                this.container = t,
                this.config = Object.assign(h(), e),
                Object.assign(this.config, u.get(this.config.mode)),
                this.pendingSeekTime = -1,
                this.requestSetTime = !1,
                this.seekPointRecord = null,
                this.progressChecker = -1,
                this.mseController = null,
                this.mseSourceOpened = !1,
                this.receivedCanPlay = !1;
                const i = E.chrome && (E.version.major < 50 || 50 === E.version.major && E.version.build < 2661);
                this.alwaysSeekKeyframe = !!(i || E.edge || E.msie),
                this.alwaysSeekKeyframe && (this.config.accurateSeek = !1),
                this.timeBase = 0,
                this.timestamp = 0,
                this.lastTimestamp = 0,
                this.totalReduce = 0,
                this.lastReduce = 0,
                this.needCorrectDts = 0,
                this.lastMediaSegment = null,
                this.isOverflow = !1,
                this.ratio = this.config.objectFit,
                this.mediaElement = this.init()
            }
            init() {
                if (!this.container)
                    throw this.logger.getLog("Container not exists.");
                const t = document.createElement("video")
                  , e = [`object-fit: ${this.config.objectFit};`, "width: 100%;", "height: 100%;"];
                return t.oncontextmenu = function(t) {
                    t.preventDefault()
                }
                ,
                t.autoplay = !0,
                t.volume = 0,
                t.setAttribute("style", e.join("")),
                this.container.innerHTML = "",
                this.container.appendChild(t),
                this.attachMediaElement(t),
                window.addEventListener("resize", this.resizeVideo.bind(this)),
                t
            }
            resizeVideo() {
                this.changeRatio(this.ratio)
            }
            clear() {}
            destroy() {
                -1 !== this.progressChecker && (window.clearInterval(this.progressChecker),
                this.progressChecker = -1),
                this.mediaElement && this.detachMediaElement(),
                window.removeEventListener("resize", this.resizeVideo.bind(this))
            }
            attachMediaElement(t) {
                if (t.addEventListener("loadedmetadata", this.onvLoadedMetadata),
                t.addEventListener("seeking", this.onvSeeking),
                t.addEventListener("canplay", this.onvCanPlay),
                t.addEventListener("stalled", this.onvStalled),
                t.addEventListener("progress", this.onvProgress),
                t.addEventListener("waiting", this.onvWaiting),
                this.enableFrameCallback ? t.requestVideoFrameCallback(this.videoFrameCallback) : t.addEventListener("timeupdate", this.onvTimeupdate),
                this.mseController = new A(this.config),
                this.playerEmitter.on(m.UPDATE_END, this.onMSEUpdateEnd),
                this.playerEmitter.on(m.BUFFER_FULL, this.onMSEBufferFull),
                this.playerEmitter.on(m.SOURCE_OPEN, ( () => {
                    this.mseSourceOpened = !0
                }
                )),
                this.mseController.attachMediaElement(t),
                -1 != this.pendingSeekTime)
                    try {
                        t.currentTime = this.pendingSeekTime,
                        this.pendingSeekTime = -1
                    } catch (t) {}
            }
            detachMediaElement() {
                var t;
                this.mediaElement && (this.mediaElement.removeEventListener("loadedmetadata", this.onvLoadedMetadata),
                this.mediaElement.removeEventListener("seeking", this.onvSeeking),
                this.mediaElement.removeEventListener("canplay", this.onvCanPlay),
                this.mediaElement.removeEventListener("stalled", this.onvStalled),
                this.mediaElement.removeEventListener("progress", this.onvProgress),
                this.mediaElement.removeEventListener("timeupdate", this.onvTimeupdate),
                this.mediaElement.removeEventListener("mousedown", this.onMouseDown),
                this.mediaElement.removeEventListener("mouseup", this.onMouseUp)),
                null === (t = this.container) || void 0 === t || t.removeChild(this.mediaElement),
                this.mseController && (this.mseController.detachMediaElement(),
                this.mseController.destroy(),
                this.mseController = null)
            }
            disConnectKeepLastFrame() {
                this.pause()
            }
            appendInitSegment(t) {
                var e, i;
                null === (i = null === (e = this.mseController) || void 0 === e ? void 0 : e.appendInitSegment) || void 0 === i || i.call(e, t)
            }
            appendMediaSegment(t) {
                var e, i;
                const {timestamp: n, dts: r, width: o, height: s} = t;
                if (this.enableFrameCallback && this.videoFrameMap.set(r, t),
                !this.codeResolution.width || !this.codeResolution.height) {
                    this.codeResolution.width = null != o ? o : 0,
                    this.codeResolution.height = null != s ? s : 0;
                    const t = (0,
                    _.Mb)(this.container, this.codeResolution.width / this.codeResolution.height);
                    this.playerEmitter.emit(g.PLAYER_SIZE, t)
                }
                if (!this.lastTimestamp) {
                    if (r > 12e3)
                        return;
                    this.lastTimestamp = n
                }
                const a = n - this.lastTimestamp;
                if (a > 1 && this.lastMediaSegment && (this.lastReduce = a,
                this.needCorrectDts = this.lastMediaSegment.dts),
                this.lastTimestamp = n,
                this.lastMediaSegment = t,
                !this.timeBase) {
                    if (r > 12e3)
                        return;
                    this.timeBase = n,
                    this.timestamp = n,
                    this.playerEmitter.emit(g.UPDATE_TIMESTAMP, n)
                }
                null === (i = null === (e = this.mseController) || void 0 === e ? void 0 : e.appendMediaSegment) || void 0 === i || i.call(e, t)
            }
            screenshot(t="screenshot") {
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const e = document.createElement("canvas");
                e.width = this.mediaElement.videoWidth,
                e.height = this.mediaElement.videoHeight;
                const i = e.getContext("2d");
                null == i || i.drawImage(this.mediaElement, 0, 0, e.width, e.height);
                const n = document.createElement("a");
                n.download = (0,
                _.QZ)(t, ".png"),
                n.href = e.toDataURL(),
                n.click(),
                n.remove()
            }
            captureImage() {
                const t = {
                    base64URL: "",
                    success: !1
                };
                if (!this.receivedCanPlay)
                    return this.logger.error("MediaElement not exists"),
                    t;
                const e = document.createElement("canvas");
                e.width = this.mediaElement.videoWidth,
                e.height = this.mediaElement.videoHeight;
                const i = e.getContext("2d");
                return null == i || i.drawImage(this.mediaElement, 0, 0, e.width, e.height),
                t.success = !0,
                t.base64URL = e.toDataURL(),
                t
            }
            changeTimeBase() {
                this.seek()
            }
            unload() {
                this.mediaElement && this.mediaElement.pause(),
                this.mseController && this.mseController.seek()
            }
            play() {
                var t;
                return null === (t = this.mediaElement) || void 0 === t ? void 0 : t.play()
            }
            pause() {
                var t;
                null === (t = this.mediaElement) || void 0 === t || t.pause()
            }
            resume() {
                this.play()
            }
            seek() {
                var t;
                this.pause(),
                this.videoFrameMap.clear(),
                this.timeBase = 0,
                this.lastTimestamp = 0,
                this.totalReduce = 0,
                null === (t = this.mseController) || void 0 === t || t.seek(),
                this.playerEmitter.emit(g.UPDATE_STATUS, {
                    isOverflow: !1
                });
                const e = setInterval(( () => {
                    this.mediaElement ? this.mediaElement.buffered.length && (this.play(),
                    this.mediaElement.currentTime = this.mediaElement.buffered.start(0),
                    clearInterval(e)) : this.logger.error("MediaElement not exists")
                }
                ), 50)
            }
            get buffered() {
                var t;
                return (null === (t = this.mediaElement) || void 0 === t ? void 0 : t.buffered) || [0, 0]
            }
            get duration() {
                var t;
                return (null === (t = this.mediaElement) || void 0 === t ? void 0 : t.duration) || 0
            }
            get volume() {
                var t;
                return (null === (t = this.mediaElement) || void 0 === t ? void 0 : t.volume) || 0
            }
            set volume(t) {
                this.mediaElement && (this.mediaElement.volume = t)
            }
            get muted() {
                var t;
                return !!(null === (t = this.mediaElement) || void 0 === t ? void 0 : t.muted)
            }
            set muted(t) {
                this.mediaElement && (this.mediaElement.muted = t)
            }
            set zoomStatus(t) {
                this.isZoom = t,
                this.isZoom ? this.triggerZoomEvents() : this.detachZoomEvents()
            }
            get currentTime() {
                return this.mediaElement ? this.mediaElement.currentTime : 0
            }
            set currentTime(t) {
                this.mediaElement ? this.internalSeek(t) : this.pendingSeekTime = t
            }
            get tagName() {
                return "video"
            }
            triggerZoomEvents() {
                this.mediaElement.style.cursor = "zoom-in",
                this.mediaElement.addEventListener("click", this.zoomClickEvent),
                this.mediaElement.addEventListener("wheel", this.zoomWheelEvent),
                this.mediaElement.addEventListener("mousedown", this.onMouseDown),
                document.addEventListener("mouseup", this.onMouseUp)
            }
            detachZoomEvents() {
                this.mediaElement.style.cursor = "default",
                this.mediaElement.removeEventListener("click", this.zoomClickEvent),
                this.mediaElement.removeEventListener("wheel", this.zoomWheelEvent),
                this.mediaElement.removeEventListener("mousedown", this.onMouseDown),
                document.removeEventListener("mouseup", this.onMouseUp)
            }
            initPlayRate() {
                const t = this.config.changePtsRates
                  , e = this.config.defaultPlaybackRate;
                1 !== e && (t.includes(e) ? this.playerEmitter.emit(g.CHANGE_PLAYBACK_RATE, {
                    isChangePts: !0,
                    playbackRate: e
                }) : this.mediaElement.playbackRate = e)
            }
            suspendTransmuxer() {}
            checkProgressAndResume() {
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const t = this.mediaElement.currentTime
                  , e = this.mediaElement.buffered;
                let i = !1;
                for (let n = 0; n < e.length; n++) {
                    const r = e.start(n)
                      , o = e.end(n);
                    if (t >= r && t < o) {
                        t >= o - this.config.lazyLoadRecoverDuration && (i = !0);
                        break
                    }
                }
                i && (window.clearInterval(this.progressChecker),
                this.progressChecker = -1,
                i && this.logger.log("Continue loading from paused position"))
            }
            isTimePointBuffered(t) {
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const e = this.mediaElement.buffered;
                for (let i = 0; i < e.length; i++) {
                    const n = e.start(i)
                      , r = e.end(i);
                    if (t >= n && t < r)
                        return !0
                }
                return !1
            }
            internalSeek(t) {
                var e;
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const i = this.isTimePointBuffered(t);
                let n = !1
                  , r = 0;
                if (t < 1 && this.mediaElement.buffered.length > 0) {
                    const e = this.mediaElement.buffered.start(0);
                    (e < 1 && t < e || E.safari) && (n = !0,
                    r = E.safari ? .1 : e)
                }
                n ? (this.requestSetTime = !0,
                this.mediaElement.currentTime = r) : i ? (this.alwaysSeekKeyframe || (this.requestSetTime = !0,
                this.mediaElement.currentTime = t),
                -1 !== this.progressChecker && this.checkProgressAndResume()) : (-1 !== this.progressChecker && (window.clearInterval(this.progressChecker),
                this.progressChecker = -1),
                null === (e = this.mseController) || void 0 === e || e.seek(),
                this.config.accurateSeek)
            }
            checkAndResumeStuckPlayback(t) {
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const e = this.mediaElement;
                if (t || !this.receivedCanPlay || e.readyState < 2) {
                    const t = e.buffered;
                    t.length > 0 && e.currentTime < t.start(0) && (this.logger.warn(`Playback seems stuck at ${e.currentTime}, seek to ${t.start(0)}`),
                    this.requestSetTime = !0,
                    this.mediaElement.currentTime = t.start(0),
                    this.mediaElement.removeEventListener("progress", this.onvProgress))
                } else
                    this.mediaElement.removeEventListener("progress", this.onvProgress)
            }
            judgeBoundary() {
                var t, e, i, n, r, o;
                const s = this.mediaElement
                  , a = +(null !== (i = null === (e = null === (t = s.style.transformOrigin.split(" ")) || void 0 === t ? void 0 : t[0]) || void 0 === e ? void 0 : e.replace("px", "")) && void 0 !== i ? i : 0)
                  , l = +(null !== (o = null === (r = null === (n = s.style.transformOrigin.split(" ")) || void 0 === n ? void 0 : n[1]) || void 0 === r ? void 0 : r.replace("px", "")) && void 0 !== o ? o : 0)
                  , c = a ? a * (this.scale - 1) : (s.offsetWidth * this.scale - s.offsetWidth - a) / 2
                  , h = (s.offsetWidth - a) * (this.scale - 1)
                  , u = l ? l * (this.scale - 1) : (s.offsetHeight * this.scale - s.offsetHeight - l) / 2
                  , d = l ? (s.offsetHeight - l) * (this.scale - 1) : (s.offsetHeight * this.scale - s.offsetHeight - l) / 2;
                this.movePoint.x > c && (this.movePoint.x = c),
                this.movePoint.x < -h && (this.movePoint.x = -h),
                this.movePoint.y > u && (this.movePoint.y = u),
                this.movePoint.y < -d && (this.movePoint.y = -d)
            }
            changeRatio(t) {
                let e = [];
                switch (this.ratio = t,
                t) {
                case "4/3":
                    {
                        const {width: t, height: i} = (0,
                        _.Mb)(this.container, 4 / 3);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: t,
                            height: i
                        }),
                        e = ["object-fit: fill;", `width: ${t}px;`, `height: ${i}px;`]
                    }
                    break;
                case "16/9":
                    {
                        const {width: t, height: i} = (0,
                        _.Mb)(this.container, 16 / 9);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: t,
                            height: i
                        }),
                        e = ["object-fit: fill;", `width: ${t}px;`, `height: ${i}px;`]
                    }
                    break;
                case "contain":
                    {
                        const {width: t, height: i} = (0,
                        _.Mb)(this.container, this.codeResolution.width / this.codeResolution.height);
                        this.playerEmitter.emit(g.PLAYER_SIZE, {
                            width: t,
                            height: i
                        }),
                        e = ["object-fit: contain;", "width: 100%;", "height: 100%;"]
                    }
                    break;
                case "fill":
                    this.playerEmitter.emit(g.PLAYER_SIZE, {
                        width: this.container.offsetWidth,
                        height: this.container.offsetHeight
                    }),
                    e = ["object-fit: fill;", "width: 100%;", "height: 100%;"]
                }
                this.mediaElement.setAttribute("style", e.join("")),
                this.updateZoomState()
            }
            zoomUp(t) {
                if (!this.mediaElement)
                    return void this.logger.error("MediaElement not exists");
                const {type: e} = t;
                if ("click" === e && this.isDrag)
                    return;
                const i = t.offsetX
                  , n = t.offsetY;
                this.scale = Math.min(this.scale * this.config.scaleOptions.scaleStep, this.config.scaleOptions.maxScale),
                this.playerEmitter.emit(g.SCALE_CHANGE, this.scale),
                this.scale > this.config.scaleOptions.maxScale || (this.mediaElement.style.transformOrigin = `${i}px ${n}px`,
                this.judgeBoundary(),
                this.mediaElement.style.transform = `translate(${this.movePoint.x}px, ${this.movePoint.y}px) scale(${this.scale})`)
            }
            zoomValue(t) {
                this.mediaElement ? (this.scale = Math.min(t, this.config.scaleOptions.maxScale),
                this.playerEmitter.emit(g.SCALE_CHANGE, this.scale),
                t > this.config.scaleOptions.maxScale || (this.scale = t,
                this.judgeBoundary(),
                this.mediaElement.style.transform = `translate(${this.movePoint.x}px, ${this.movePoint.y}px) scale(${this.scale})`)) : this.logger.error("MediaElement not exists")
            }
            zoomDown() {
                this.mediaElement ? (this.scale /= this.config.scaleOptions.scaleStep,
                this.scale <= 1 ? this.resetZoom() : (this.playerEmitter.emit(g.SCALE_CHANGE, this.scale),
                this.judgeBoundary(),
                this.mediaElement.style.transform = `translate(${this.movePoint.x}px, ${this.movePoint.y}px) scale(${this.scale})`)) : this.logger.error("MediaElement not exists")
            }
            resetZoom() {
                this.scale = 1,
                this.playerEmitter.emit(g.SCALE_CHANGE, this.scale),
                this.mediaElement.style.transform = `translate(0px, 0px) scale(${this.scale})`
            }
            renderFrame() {}
            changePlayBackRate(t) {
                const e = this.config.changePtsRates.includes(t);
                this.playerEmitter.emit(g.CHANGE_PLAYBACK_RATE, {
                    isChangePts: e,
                    playbackRate: t
                }),
                e || (this.mediaElement.playbackRate = t)
            }
            onVideoSegment(t) {
                this.videoSegmentHook = t
            }
        }
        var M = i(1633)
          , P = i(34805);
        class k extends n.KG {
            constructor(t) {
                super(t),
                this.id = t.id
            }
            get loaderEmitter() {
                const t = this.id;
                return k.emitter[t] || (k.emitter[t] = this.emitter),
                k.emitter[t]
            }
            destroy() {
                delete k.emitter[this.id]
            }
            static clear() {
                k.emitter = {}
            }
        }
        k.emitter = {};
        class O extends k {
            destroy() {
                super.destroy()
            }
            get state() {
                return this.status
            }
        }
        const R = (t, e) => {
            const {method: i, headers: n} = t
              , r = {
                method: i,
                headers: n,
                credentials: "same-origin",
                mode: "cors",
                cache: "default",
                body: t.data,
                signal: e
            }
              , o = new Request(t.url,r);
            return self.fetch(o)
        }
        ;
        class D extends O {
            constructor(t) {
                super(t.baseConfig),
                this.requestAbortFlag = !1,
                this.receivedLength = 0,
                this.range = {
                    from: 0,
                    to: -1
                },
                this.status = M.GM.Idle,
                this.stashBuffer = new Uint8Array(0)
            }
            fetch(t) {
                return this.abortController = new AbortController,
                Promise.race([new Promise(( (t, e) => {
                    setTimeout(( () => {
                        this.status === M.GM.Connecting && e(new Error("Fetch stream timeout."))
                    }
                    ), M.cK)
                }
                )), R({
                    url: t.url,
                    headers: t.headers,
                    method: "post",
                    data: t.body
                }, this.abortController.signal)])
            }
            pump(t) {
                t.read().then((e => {
                    if (e.done)
                        return this.status = M.GM.Complete,
                        void this.loaderEmitter.emit(M.Xr.Complete);
                    {
                        if (!0 === this.requestAbortFlag && this.status === M.GM.Idle)
                            return this.requestAbortFlag = !1,
                            this.status = M.GM.Complete,
                            t.cancel();
                        this.status = M.GM.Buffering;
                        const i = e.value.buffer
                          , n = this.range.from + this.receivedLength;
                        return this.receivedLength += i.byteLength,
                        this.loaderEmitter.emit(M.Xr.Data, {
                            buffer: i,
                            byteStart: n
                        }),
                        this.provide(i),
                        this.pump(t)
                    }
                }
                ))
            }
            open(t) {
                this.status !== M.GM.Buffering ? (this.status = M.GM.Connecting,
                this.fetch(t).then((t => {
                    if (t instanceof Error)
                        return;
                    const e = {};
                    for (const i of t.headers.entries())
                        e[i[0]] = i[1];
                    if (this.loaderEmitter.emit(M.Xr.Headers, e),
                    this.fetchSuccessHook && !1 === this.fetchSuccessHook(t))
                        return;
                    const i = t.body;
                    i && (this.dataReadyHook || this.logger.warn("Data Consumer not found."),
                    this.pump(i.getReader()))
                }
                )).catch((t => {
                    "AbortError" !== t.name ? this.loaderEmitter.emit(M.Xr.Error, t) : this.loaderEmitter.emit(M.nm.ABORT_ERROR)
                }
                ))) : this.logger.warn("Loader is already connected.")
            }
            abort() {
                var t;
                null === (t = this.abortController) || void 0 === t || t.abort(),
                this.requestAbortFlag = !0,
                this.status = M.GM.Idle
            }
            preConnectPlay() {}
            destroy() {
                super.destroy(),
                this.status !== M.GM.Buffering && this.status !== M.GM.Connecting || this.abort(),
                this.range = {
                    from: 0,
                    to: -1
                },
                this.receivedLength = 0,
                this.status = M.GM.Idle
            }
            provide(t) {
                if (!this.dataReadyHook)
                    return;
                const e = (0,
                P.c)(this.stashBuffer, new Uint8Array(t))
                  , i = this.dataReadyHook(e.buffer);
                i < e.byteLength ? this.stashBuffer = new Uint8Array(e.buffer,i) : this.stashBuffer = new Uint8Array(0)
            }
            send() {}
            onFetchSuccess(t) {
                this.fetchSuccessHook = t
            }
            onDataReady(t) {
                this.dataReadyHook = t
            }
            onAuthenticate(t) {
                this.authenticateHook = t
            }
        }
        class L extends O {
            constructor(t) {
                super(t.baseConfig),
                this.ws = null,
                this.requestAbort = !1,
                this.receivedLength = 0,
                this.heartBeatTimer = null,
                this.params = null,
                this.status = M.GM.Idle,
                this.options = {
                    preConnect: !1
                },
                this.stashBuffer = new Uint8Array(0),
                this.onWebSocketOpen = () => {
                    if (this.status = M.GM.Connected,
                    this.options.preConnect)
                        return this.loaderEmitter.emit(M.Xr.Connect),
                        void this.startHeartBeat();
                    this.playCommand()
                }
                ,
                this.onWebSocketClose = t => {
                    this.heartBeatTimer && clearInterval(this.heartBeatTimer),
                    !0 === this.requestAbort ? this.requestAbort = !1 : (this.status = M.GM.Complete,
                    this.loaderEmitter.emit(M.Xr.Complete, t)),
                    this.loaderEmitter.emit(M.Xr.Close, t)
                }
                ,
                this.onWebSocketMessage = t => {
                    if (this.status = M.GM.Buffering,
                    "string" == typeof t.data)
                        this.handleAuthMsg(t.data);
                    else if (t.data instanceof ArrayBuffer) {
                        const e = t.data
                          , i = this.receivedLength;
                        this.receivedLength += e.byteLength,
                        this.loaderEmitter.emit(M.Xr.Data, {
                            buffer: e,
                            byteStart: i
                        }),
                        this.provide(e)
                    } else if (t.data instanceof Blob) {
                        const e = new FileReader;
                        e.onload = () => {
                            this.provide(e.result)
                        }
                        ,
                        e.readAsArrayBuffer(t.data)
                    } else {
                        this.status = M.GM.Error;
                        const e = {
                            code: -1,
                            msg: "Unsupported WebSocket message type: " + t.data.constructor.name
                        };
                        this.loaderEmitter.emit(M.Xr.Error, e)
                    }
                }
                ,
                this.onWebSocketError = t => {
                    [M.GM.Buffering, M.GM.Connecting, M.GM.Connected].includes(this.status) && (this.status = M.GM.Error,
                    this.loaderEmitter.emit(M.Xr.Error, t))
                }
                ,
                this.handleAuthMsg = t => {
                    var e;
                    const i = JSON.parse(t)
                      , {type: n, params: r} = i;
                    switch (n) {
                    case M.Gr.Notification:
                        null === (e = this.authenticateHook) || void 0 === e || e.call(this, r);
                        break;
                    case M.Gr.Response:
                        {
                            const {error_code: t} = r;
                            0 === t && this.params ? this.send({
                                msg: this.params.body
                            }) : this.logger.warn("Authenticate Failed");
                            break
                        }
                    }
                }
            }
            open(t, e) {
                if (this.status === M.GM.Buffering)
                    return void this.logger.warn("Loader is already connected.");
                this.params = t;
                const {headers: i, url: n} = t;
                Object.assign(this.options, null != e ? e : {});
                try {
                    const t = this.ws = new WebSocket(n,[encodeURIComponent(JSON.stringify(i))]);
                    t.binaryType = "arraybuffer",
                    t.onopen = this.onWebSocketOpen,
                    t.onclose = this.onWebSocketClose,
                    t.onmessage = this.onWebSocketMessage,
                    t.onerror = this.onWebSocketError,
                    this.status = M.GM.Connecting
                } catch (t) {
                    this.status = M.GM.Error,
                    this.loaderEmitter.emit(M.Xr.Error, t)
                }
            }
            send(t) {
                var e;
                const i = t.msg;
                if (this.status === M.GM.Buffering || this.status === M.GM.Connected)
                    null === (e = this.ws) || void 0 === e || e.send(i);
                else {
                    const t = {
                        code: -1,
                        msg: "Send message failed for unconnected websocket."
                    };
                    this.loaderEmitter.emit(M.Xr.Error, t)
                }
            }
            preConnectPlay(t) {
                if (t)
                    this.send({
                        msg: t
                    });
                else if (this.params) {
                    const {body: t} = this.params;
                    this.send({
                        msg: t
                    })
                }
            }
            playCommand() {
                if (this.params) {
                    const {body: t} = this.params;
                    this.send({
                        msg: t
                    }),
                    this.startHeartBeat()
                }
            }
            abort() {
                const t = this.ws;
                if (t && (0 === t.readyState || 1 === t.readyState)) {
                    const e = {
                        service: "killclient"
                    }
                      , i = this.generatePayload(e);
                    this.status === M.GM.Buffering && this.send({
                        msg: i
                    }),
                    this.requestAbort = !0,
                    t.close()
                }
                this.ws = null,
                this.status = M.GM.Complete
            }
            destroy() {
                [M.GM.Buffering, M.GM.Connecting, M.GM.Connected].includes(this.status) && this.abort(),
                this.heartBeatTimer && clearInterval(this.heartBeatTimer),
                this.params = null,
                super.destroy(),
                this.receivedLength = 0,
                this.status = M.GM.Idle
            }
            provide(t) {
                if (!this.dataReadyHook)
                    return;
                const e = (0,
                P.c)(this.stashBuffer, new Uint8Array(t))
                  , i = this.dataReadyHook(e.buffer);
                i < e.byteLength ? this.stashBuffer = new Uint8Array(e.buffer,i) : this.stashBuffer = new Uint8Array(0)
            }
            startHeartBeat() {
                this.heartBeatTimer && (clearInterval(this.heartBeatTimer),
                this.heartBeatTimer = null);
                const t = this.generatePayload({
                    service: "heartbeat"
                });
                this.heartBeatTimer = setInterval(( () => {
                    this.send({
                        msg: t
                    })
                }
                ), 4e4)
            }
            generatePayload(t) {
                const e = JSON.stringify(t);
                return "----client-stream-boundary--\r\n" + ("Content-Type: control\r\nContent-Length: " + e.length + "\r\n\r\n") + e
            }
            get state() {
                return this.status
            }
            onFetchSuccess(t) {
                this.fetchSuccessHook = t
            }
            onDataReady(t) {
                this.dataReadyHook = t
            }
            onAuthenticate(t) {
                this.authenticateHook = t
            }
        }
        var B = i(86490);
        const z = (t, e, i) => {
            const n = F(e, i)
              , r = N(t);
            return !!r.result && r.data.includes(n)
        }
          , F = (t, e) => {
            let i;
            switch (t) {
            case T.DD.MIXED:
                i = e ? T.EW.MP2T_BOUNDARY : T.EW.DATA_BOUNDARY;
                break;
            case T.DD.AUDIO:
                i = T.EW.AUDIO_BOUNDARY;
                break;
            case T.DD.VIDEO:
                i = T.EW.VIDEO_BOUNDARY;
                break;
            default:
                throw new Error("Unsupported media type.")
            }
            return i
        }
          , N = (t, e=0, i) => {
            const n = new Uint8Array(t,e,i)
              , r = n.findIndex((t => 10 === t));
            if (r < 0)
                return {
                    result: !1,
                    data: "",
                    offset: 0
                };
            let o = "";
            return o = 13 === n[r - 1] ? (0,
            P._)(t, e, r - 1) : (0,
            P._)(t, e, r),
            {
                result: !0,
                data: o,
                offset: r + 1
            }
        }
          , j = (t, e=0) => {
            let i, n = e;
            do {
                if (i = N(t, n),
                !i.result)
                    break;
                if (0 !== i.data.length)
                    break;
                n += i.offset
            } while (i.result);
            return n
        }
          , U = t => {
            for (const e in t)
                if (Object.prototype.hasOwnProperty.call(t, e)) {
                    const i = t[e];
                    switch (e) {
                    case T.fj.CONTENT_LENGTH:
                    case T.fj.X_FRAME_TYPE:
                    case T.fj.X_AUDIO:
                    case T.fj.X_TIMELEFT:
                    case T.fj.X_DATA_SEQUENCE:
                        t[e] = parseInt(i);
                        break;
                    case T.fj.X_TIMESTAMP:
                        t[e] = parseFloat(i);
                        break;
                    default:
                        t[e] = String(i)
                    }
                }
        }
        ;
        var V = i(52180)
          , G = i(3174)
          , Z = i(25108);
        class q extends V.P {
            constructor(t) {
                super(t.baseConfig),
                this.audioTrack = {
                    type: G.z.AUDIO_G711A,
                    samples: []
                },
                this.videoTrack = {
                    type: G.z.VIDEO_H264,
                    samples: []
                },
                this.audioSample = {
                    data: [],
                    size: 0
                },
                this.videoSample = {
                    data: [],
                    size: 0
                },
                this.pmtPid = -1,
                this.audioPid = -1,
                this.videoPid = -1,
                this.lastUTC = 0,
                this.timestamp = 0,
                this.flushFlag = !1,
                this.aCodec = "",
                this.vCodec = "",
                this.prePts = 0,
                this.timestampUpdatedFlag = !1,
                this.isVirtualKeyframe = !1,
                this.calculateTimestampRule = {
                    playbackRate: 1,
                    isChangePts: !1
                },
                this.transformerEmitter.on(g.CHANGE_PLAYBACK_RATE, (t => {
                    this.calculateTimestampRule = t
                }
                ))
            }
            static probe(t) {
                const e = q._syncOffset(t);
                return e && Z.warn(`MPEG2-TS detected but first sync word found at offset ${e}.`),
                e >= 0
            }
            static _syncOffset(t) {
                return t.findIndex((t => 71 === t))
            }
            parse(t) {
                let e, i, n, r, o, s, a, l, c = 0, h = t.byteLength, u = T.CO.VIDEO, d = this.pmtPid, f = this.videoPid, p = this.audioPid;
                const m = q._syncOffset(t);
                for (h -= (h + m) % 188,
                e = m; e < h; e += 188)
                    if (c = 4,
                    71 === t[e]) {
                        if (i = e + 188,
                        a = t.slice(e, i),
                        s = i >= h,
                        n = !!(64 & a[1]),
                        r = ((31 & a[1]) << 8) + a[2],
                        o = (48 & a[3]) >> 4,
                        !(o > 1 && (c += 1 + a[4],
                        188 === c)))
                            switch (r) {
                            case 8191:
                                this._parseNullPacket(a, c);
                                break;
                            case 0:
                                if (d > 0)
                                    break;
                                n && (c += a[c] + 1),
                                d = this.pmtPid = this._parsePAT(a.slice(c));
                                break;
                            case d:
                                n && (c += a[c] + 1),
                                l = this._parsePMT(a.slice(c)),
                                f = (null == l ? void 0 : l.video) || -1,
                                p = (null == l ? void 0 : l.audio) || -1;
                                break;
                            case f:
                                u = T.CO.VIDEO,
                                this.flushFlag = this._processPES(a.slice(c), u, n, s);
                                break;
                            case p:
                                u = T.CO.AUDIO,
                                this.flushFlag = this._processPES(a.slice(c), u, n, s);
                                break;
                            default:
                                this.logger.warn(`unknown PID ${r} is found.`)
                            }
                    } else
                        this.logger.error("TS packet did not start with 0x47");
                return this._trackHandler()
            }
            _parseNullPacket(t, e) {
                31 === t[1] && 255 === t[2] && (1 == (255 & t[e]) ? (this.timestamp = this.lastUTC = (255 & t[e + 3]) * (1 << 56) + 65536 * (255 & t[e + 4]) + 256 * (255 & t[e + 5]) + 1 * (255 & t[e + 6]) + (255 & t[e + 7]) * (1 << 24) + 65536 * (255 & t[e + 8]) + 256 * (255 & t[e + 9]) + (255 & t[e + 10]),
                this.timestampUpdatedFlag = !0,
                88 === t[e + 11] && 70 === t[e + 12] && 73 === t[e + 13] && 84 === t[e + 14] && 0 != (128 & t[e + 15]) && (this.isVirtualKeyframe = !0)) : 242 == (255 & t[e]) && this.logger.log("The type of null packet is repeated."))
            }
            _parsePAT(t) {
                return (31 & t[10]) << 8 | t[11]
            }
            _parsePMT(t) {
                let e;
                const i = {
                    audio: -1,
                    video: -1
                };
                if (!(1 & t[5]))
                    return;
                const n = 3 + ((15 & t[1]) << 8 | t[2]) - 4;
                for (e = 12 + ((15 & t[10]) << 8 | t[11]); e < n; ) {
                    const n = t[e]
                      , r = (31 & t[e + 1]) << 8 | t[e + 2];
                    switch (n) {
                    case 3:
                        this.audioPid = i.audio = r,
                        this.audioTrack.type = G.z.AUDIO_MPEG,
                        this.aCodec = G.z.AUDIO_MPEG;
                        break;
                    case 144:
                        this.audioPid = i.audio = r,
                        this.audioTrack.type = G.z.AUDIO_G711A,
                        this.aCodec = G.z.AUDIO_G711A;
                        break;
                    case 145:
                        this.audioPid = i.audio = r,
                        this.audioTrack.type = G.z.AUDIO_G711U,
                        this.aCodec = G.z.AUDIO_G711U;
                        break;
                    case 146:
                        this.audioPid = i.audio = r,
                        this.audioTrack.type = G.z.AUDIO_WAV;
                        break;
                    case 27:
                        this.videoPid = i.video = r,
                        this.videoTrack.type = G.z.VIDEO_H264,
                        this.vCodec !== G.z.VIDEO_H264 && (this.vCodec = G.z.VIDEO_H264,
                        this.transformerEmitter.emit(B.K7.VIDEO_CODE, G.z.VIDEO_H264));
                        break;
                    case 36:
                        this.videoPid = i.video = r,
                        this.videoTrack.type = G.z.VIDEO_H265,
                        this.vCodec !== G.z.VIDEO_H265 && (this.vCodec = G.z.VIDEO_H265,
                        this.transformerEmitter.emit(B.K7.VIDEO_CODE, G.z.VIDEO_H265));
                        break;
                    default:
                        this.logger.warn(`Unsupported stream type: ${n}`)
                    }
                    e += 5 + ((15 & t[e + 3]) << 8 | t[e + 4])
                }
                return i
            }
            isHEVC() {
                return this.vCodec == G.z.VIDEO_H265
            }
            _processPES(t, e, i, n) {
                let r = e === T.CO.AUDIO ? this.audioSample : this.videoSample
                  , o = !1;
                return i && (o = this._flushStream(r, e),
                r = {
                    data: [],
                    size: 0
                }),
                r.data.push(t),
                r.size += t.byteLength,
                n && (o = this._flushStream(r, e),
                r = {
                    data: [],
                    size: 0
                }),
                e === T.CO.AUDIO ? this.audioSample = r : this.videoSample = r,
                o
            }
            _flushStream(t, e) {
                if (!t.data.length || t.size < 9)
                    return !1;
                const i = new Uint8Array(t.size);
                let n = 0;
                return t.data.forEach((t => {
                    i.set(t, n),
                    n += t.byteLength
                }
                )),
                this._parsePES(i, e)
            }
            _parsePES(t, e) {
                const i = t[7]
                  , n = {
                    pts: 0,
                    dts: 0,
                    data: new Uint8Array(0),
                    offset: 0,
                    length: 0,
                    type: "",
                    codeType: G.z.VIDEO_H264,
                    timestamp: 0
                };
                192 & i && (n.pts = (14 & t[9]) << 27 | (255 & t[10]) << 20 | (254 & t[11]) << 12 | (255 & t[12]) << 5 | (254 & t[13]) >>> 3,
                n.pts *= 4,
                n.pts += (6 & t[13]) >>> 1,
                n.dts = n.pts,
                64 & i && (n.dts = (14 & t[14]) << 27 | (255 & t[15]) << 20 | (254 & t[16]) << 12 | (255 & t[17]) << 5 | (254 & t[18]) >>> 3,
                n.dts *= 4,
                n.dts += (6 & t[18]) >>> 1));
                const r = 9 + t[8];
                return n.data = t,
                n.offset = r,
                n.length = t.byteLength - r,
                n.type = e,
                n.codeType = this[`${e}Track`].type,
                n.timestamp = this.calculateTimestamp(n),
                e === T.CO.AUDIO ? this.audioTrack.samples.push(n) : this.videoTrack.samples.push(n),
                !0
            }
            calculateTimestamp(t) {
                let e = 0;
                if (this.timestampUpdatedFlag && this.timestamp)
                    return e = this.timestamp,
                    this.prePts = t.pts,
                    this.timestampUpdatedFlag = !1,
                    e;
                if (this.prePts) {
                    const {isChangePts: i, playbackRate: n} = this.calculateTimestampRule
                      , r = (t.pts - this.prePts) / 9e4
                      , o = i ? Math.floor(r * n) : Math.floor(r);
                    return e = this.timestamp + o,
                    e
                }
                return e
            }
            _trackHandler() {
                if (!1 === this.flushFlag)
                    return null;
                const t = {
                    videoTrack: Object.assign(Object.assign({}, this.videoTrack), {
                        virtualKeyframe: this.isVirtualKeyframe,
                        samples: this.videoTrack.samples.map((t => Object.assign(Object.assign({}, t), {
                            data: new Uint8Array(t.data)
                        })))
                    }),
                    audioTrack: Object.assign(Object.assign({}, this.audioTrack), {
                        samples: this.audioTrack.samples.map((t => Object.assign(Object.assign({}, t), {
                            data: new Uint8Array(t.data)
                        })))
                    })
                };
                return this.isVirtualKeyframe = !1,
                this.videoTrack.samples.length = 0,
                this.audioTrack.samples.length = 0,
                t
            }
            clearPid() {
                this.pmtPid = -1,
                this.audioPid = -1,
                this.videoPid = -1
            }
        }
        var W = q;
        class H extends V.P {
            constructor() {
                super(...arguments),
                this.onvSeeking = !1
            }
            clear() {}
        }
        class $ {
            constructor(t={}) {
                this.worker = new Worker(new URL(i.p + i.u(7685),i.b),{
                    name: "ffmpeg.worker",
                    type: void 0
                }),
                this.messages = [],
                this.ready = !1,
                this.options = t
            }
            onmessage(t) {
                this.worker.onmessage = e => {
                    if (e.data.ready)
                        return this.ready = !0,
                        void this.deliver();
                    e.data.data && t(e),
                    this.messages.length > 0 && this.messages.shift(),
                    this.deliver()
                }
            }
            deliver() {
                this.messages.length && this.worker.postMessage(this.messages[0])
            }
            postMessage(t) {
                t.isKeyframe && !this.ready && (this.messages.length = 0),
                this.messages.push(t),
                1 === this.messages.length && this.ready && this.deliver()
            }
            terminate(t=!1) {
                var e;
                (null === (e = this.options) || void 0 === e ? void 0 : e.singleton) && !t ? this.messages.length = 0 : this.worker.terminate()
            }
            static getInstance() {
                return $.instance || ($.instance = new $({
                    singleton: !0
                })),
                $.instance
            }
        }
        $.instance = null;
        class X extends H {
            constructor(t) {
                super(t.baseConfig),
                this.firstSegmentDispatched = !1,
                this.worker = t.reuseWorker ? $.getInstance() : new $,
                this.worker.onmessage((t => {
                    if (this.onvSeeking)
                        return;
                    if (!(t.data && t.data.data instanceof ArrayBuffer))
                        return void this.logger.error("Worker decode error.");
                    const e = t.data.width
                      , i = t.data.height
                      , n = e * i
                      , r = e / 2 * (i / 2);
                    this.firstSegmentDispatched || (this.transformerEmitter.emit(B.K7.FIRST_SEGMENT),
                    this.firstSegmentDispatched = !0),
                    this.transformerEmitter.emit(B.K7.VIDEO_SAMPLE, {
                        data: Object.assign(Object.assign({}, t.data), {
                            uOffset: n,
                            vOffset: r,
                            dts: t.data.pts
                        }),
                        pts: t.data.pts
                    })
                }
                )),
                this.transformerEmitter.on(B.K7.SEEK_FINISHED, ( () => {
                    this.onvSeeking = !1
                }
                ))
            }
            handle(t) {
                if (this.onvSeeking)
                    return;
                const {buffer: e, codecType: i, pts: n, isKeyframe: r, timestamp: o, seq: s} = t;
                this.worker.postMessage({
                    cmd: "decode",
                    data: e,
                    code_type: i == G.z.VIDEO_H264 ? 0 : 1,
                    pts: n,
                    isKeyframe: r,
                    timestamp: o,
                    seq: s
                })
            }
            seek() {
                this.worker.terminate(),
                this.onvSeeking = !0
            }
            destroy() {
                this.worker.terminate()
            }
        }
        var Y = i(35171)
          , K = i(3359)
          , J = i(14988)
          , Q = i(7677)
          , tt = i(88087);
        class et extends H {
            constructor(t) {
                super(t.baseConfig),
                this.firstSegmentDispatched = !1,
                this.mp4Metadata = null,
                this.videoMetadata = {},
                this.videoMetaChanged = !1,
                this.cacheInitSegment = null,
                this.forceFirstIDR = !1,
                this.dtsBase = -1,
                this.timescale = 9e4,
                this.prevVideoSample = null,
                this.firstIFrame = !0,
                this.options = Object.assign({
                    maxFrameDuration: 1500
                }, t),
                this.forceFirstIDR = !(!E.chrome || !(E.version.major < 50 || 50 === E.version.major && E.version.build < 2661)),
                this.transformerEmitter.on(B.K7.SEEK_FINISHED, ( () => {
                    this.onvSeeking = !1
                }
                ))
            }
            handle(t) {
                const {buffer: e, codecType: i, pts: n} = t;
                switch (i) {
                case G.z.VIDEO_H264:
                    {
                        let i = new Uint8Array(0);
                        const r = new Y.GV(new Uint8Array(e));
                        let o = null;
                        for (; null != (o = r.readNextNaluPayload()); ) {
                            const t = new Y.vf(o);
                            if (t.type === Y.k_.kSliceSPS) {
                                const e = tt.Z.parseSPS(o.data);
                                this.firstSegmentDispatched ? this.detectVideoMetadataChange(e) && (this.logger.log("H264: Critical h264 metadata has been changed, attempt to re-generate InitSegment"),
                                this.videoMetaChanged = !0,
                                this.videoMetadata = {
                                    vps: void 0,
                                    sps: t,
                                    pps: void 0,
                                    details: e
                                }) : (this.videoMetadata.sps = t,
                                this.videoMetadata.details = e)
                            } else
                                t.type === Y.k_.kSlicePPS && (this.firstSegmentDispatched && !this.videoMetaChanged || (this.videoMetadata.pps = t,
                                this.videoMetadata.sps && this.videoMetadata.pps && this.dispatchVideoInitSegment()));
                            this.firstSegmentDispatched && (i = (0,
                            P.c)(i, t.data))
                        }
                        if (!i.byteLength)
                            return;
                        const s = Object.assign(Object.assign({}, t), {
                            buffer: i.buffer,
                            dts: Math.floor(n / 90),
                            pts: Math.floor(n / 90)
                        });
                        this.dispatchVideoMediaSegment(s);
                        break
                    }
                case G.z.VIDEO_H265:
                    {
                        let i = new Uint8Array(0);
                        const r = new J.iA(new Uint8Array(e));
                        let o = null;
                        const s = {};
                        for (; null != (o = r.readNextNaluPayload()); ) {
                            const t = new J.zW(o);
                            if (t.type === J.Xn.kSliceVPS) {
                                if (!this.firstSegmentDispatched || this.videoMetaChanged || !this.videoMetadata.vps) {
                                    const e = K.Z.parseVPS(o.data);
                                    this.videoMetadata.vps = t,
                                    Object.assign(s, e)
                                }
                            } else if (t.type === J.Xn.kSliceSPS) {
                                const e = K.Z.parseSPS(o.data);
                                this.firstSegmentDispatched ? this.detectVideoMetadataChange(e) && (this.logger.log("H265: Critical h265 metadata has been changed, attempt to re-generate InitSegment"),
                                this.videoMetaChanged = !0,
                                this.videoMetadata = {
                                    vps: this.videoMetadata.vps,
                                    sps: t,
                                    pps: void 0
                                }) : this.videoMetadata.sps = t,
                                Object.assign(s, e)
                            } else if (t.type === J.Xn.kSlicePPS && (!this.firstSegmentDispatched || this.videoMetaChanged)) {
                                const e = K.Z.parsePPS(o.data);
                                this.videoMetadata.pps = t,
                                Object.assign(s, e),
                                this.videoMetadata.details = s,
                                this.videoMetadata.vps && this.videoMetadata.sps && this.videoMetadata.pps && this.dispatchVideoInitSegment()
                            }
                            this.firstSegmentDispatched && (i = (0,
                            P.c)(i, t.data))
                        }
                        if (!i.byteLength)
                            return;
                        const a = Object.assign(Object.assign({}, t), {
                            buffer: i.buffer,
                            dts: Math.floor(n / 90),
                            pts: Math.floor(n / 90)
                        });
                        this.dispatchVideoMediaSegment(a);
                        break
                    }
                }
            }
            detectVideoMetadataChange(t) {
                var e, i, n, r, o, s, a;
                if (t.codec_mimetype !== (null === (e = this.videoMetadata.details) || void 0 === e ? void 0 : e.codec_mimetype))
                    return this.logger.log(`Video: Codec mimeType changed from ${null === (i = this.videoMetadata.details) || void 0 === i ? void 0 : i.codec_mimetype} to ${t.codec_mimetype}`),
                    !0;
                if (t.codec_size.width !== (null === (n = this.videoMetadata.details) || void 0 === n ? void 0 : n.codec_size.width) || t.codec_size.height !== (null === (r = this.videoMetadata.details) || void 0 === r ? void 0 : r.codec_size.height)) {
                    const e = null === (o = this.videoMetadata.details) || void 0 === o ? void 0 : o.codec_size
                      , i = t.codec_size;
                    return this.logger.log(`Video: Coded Resolution changed from ${e.width}x${e.height} to ${i.width}x${i.height}`),
                    !0
                }
                return t.present_size.width !== (null === (s = this.videoMetadata.details) || void 0 === s ? void 0 : s.present_size.width) && (this.logger.log(`Video: Present resolution width changed from ${null === (a = this.videoMetadata.details) || void 0 === a ? void 0 : a.present_size.width} to ${t.present_size.width}`),
                !0)
            }
            dispatchVideoInitSegment() {
                const {details: t, sps: e, pps: i, vps: n} = this.videoMetadata;
                if (!e || !i || !t)
                    return void this.logger.error("SPS or PPS or video meta not found.");
                const r = t.frame_rate.fps_den
                  , o = t.frame_rate.fps_num;
                if (this.mp4Metadata = {
                    type: T.CO.VIDEO,
                    id: 1,
                    timescale: 1e3,
                    duration: 0,
                    creationTime: 0,
                    sequenceNumber: 0,
                    codecWidth: t.codec_size.width,
                    codecHeight: t.codec_size.height,
                    presentWidth: t.present_size.width,
                    presentHeight: t.present_size.height,
                    codec: t.codec_mimetype,
                    profile: "profile_string"in t ? t.profile_string : "",
                    level: t.level_string,
                    bitDepth: t.bit_depth,
                    chromaFormat: t.chroma_format,
                    sarRatio: t.sar_ratio,
                    frameRate: t.frame_rate,
                    refSampleDuration: r / o * 1e3,
                    hvcc: new Uint8Array(0),
                    avcc: new Uint8Array(0)
                },
                n) {
                    const r = n.data.subarray(4)
                      , o = e.data.subarray(4)
                      , s = i.data.subarray(4)
                      , a = new J.L5(r,o,s,t);
                    this.mp4Metadata.hvcc = a.getData(),
                    !1 === this.firstSegmentDispatched && this.logger.log(`Generated first HEVCDecoderConfigurationRecord for mimeType: ${this.mp4Metadata.codec}`)
                } else {
                    const n = e.data.subarray(4)
                      , r = i.data.subarray(4)
                      , o = new Y.JQ(n,r,t);
                    this.mp4Metadata.avcc = o.getData(),
                    !1 === this.firstSegmentDispatched && this.logger.log(`Generated first AVCDecoderConfigurationRecord for mimeType: ${this.mp4Metadata.codec}`)
                }
                const s = {
                    fmp4: !0,
                    creationTime: 0,
                    timescale: 9e4,
                    duration: 0,
                    nextTrackId: 1,
                    audioTracks: [],
                    videoTracks: [this.mp4Metadata]
                }
                  , a = Q.Z.generateInitSegment(s)
                  , {type: l, codec: c} = this.mp4Metadata
                  , h = {
                    pts: 0,
                    dts: 0,
                    type: l,
                    data: a.buffer,
                    codec: c,
                    container: `${l}/mp4`
                };
                this.logger.log("Init segment dispatched."),
                this.prevVideoSample ? this.cacheInitSegment = h : this.transformerEmitter.emit(B.K7.MSE_INIT_SEGMENT, h),
                this.firstSegmentDispatched = !0,
                this.videoMetaChanged = !1
            }
            dispatchVideoMediaSegment(t) {
                var e, i;
                if (!this.firstIFrame) {
                    if (!t.isKeyframe)
                        return;
                    this.firstIFrame = !0
                }
                if (this.onvSeeking)
                    return;
                if (!this.prevVideoSample)
                    return this.dtsBase = t.dts,
                    void (this.prevVideoSample = t);
                const n = Object.assign({}, this.mp4Metadata, {
                    type: T.CO.VIDEO,
                    id: 1,
                    sequenceNumber: 0,
                    samples: []
                })
                  , r = this.prevVideoSample
                  , o = t;
                let s = r.dts - this.dtsBase;
                if (s < 0)
                    return this.dtsBase = r.dts,
                    s = 0,
                    void (this.prevVideoSample = o);
                const a = r.cts
                  , l = s + a;
                let c = o.dts - r.dts;
                (c > this.options.maxFrameDuration || c < 0) && (this.dtsBase += c - 1,
                c = 1);
                const h = r.isKeyframe
                  , u = 8 + r.buffer.byteLength
                  , d = new Uint8Array(u);
                d[0] = u >>> 24 & 255,
                d[1] = u >>> 16 & 255,
                d[2] = u >>> 8 & 255,
                d[3] = 255 & u,
                d.set(Q.Z.types.mdat, 4),
                d.set(new Uint8Array(r.buffer), 8);
                const f = {
                    dts: s,
                    pts: l,
                    cts: a,
                    size: r.buffer.byteLength,
                    isKeyframe: h,
                    duration: c,
                    originalDts: s,
                    flags: {
                        isLeading: 0,
                        dependsOn: h ? 2 : 1,
                        isDependedOn: h ? 1 : 0,
                        hasRedundancy: 0,
                        isNonSync: h ? 0 : 1
                    }
                };
                if (this.forceFirstIDR) {
                    const t = f.flags;
                    t.dependsOn = 2,
                    t.isNonSync = 0
                }
                const p = [];
                p.push(f),
                n.samples = p,
                n.sequenceNumber++;
                const m = Q.Z.moof(n, s);
                this.prevVideoSample = o;
                const g = {
                    type: T.CO.VIDEO,
                    data: (0,
                    P.c)(m, d).buffer,
                    sampleCount: p.length,
                    duration: c,
                    pts: s,
                    dts: s,
                    timestamp: r.timestamp,
                    seq: r.seq,
                    width: null === (e = this.videoMetadata.details) || void 0 === e ? void 0 : e.codec_size.width,
                    height: null === (i = this.videoMetadata.details) || void 0 === i ? void 0 : i.codec_size.height
                };
                this.transformerEmitter.emit(B.K7.VIDEO_SAMPLE, g),
                this.cacheInitSegment && (this.transformerEmitter.emit(B.K7.MSE_INIT_SEGMENT, this.cacheInitSegment),
                this.cacheInitSegment = null)
            }
            seek() {
                this.onvSeeking = !0,
                this.prevVideoSample = null
            }
            clear() {
                this.firstIFrame = !1
            }
            destroy() {}
        }
        var it, nt = i(65499);
        class rt extends H {
            constructor(t) {
                super(t.baseConfig),
                this.firstSegmentDispatched = !1,
                this.videoMetadata = {},
                this.videoMetaChanged = !1,
                this.transformerEmitter.on(B.K7.SEEK_FINISHED, ( () => {
                    this.onvSeeking = !1
                }
                )),
                this.callback = {
                    output: t => {
                        this.transformerEmitter.emit(B.K7.VIDEO_SAMPLE, {
                            data: t,
                            pts: t.timestamp
                        })
                    }
                    ,
                    error: () => {
                        this.decoder = null,
                        this.curVideoType = ""
                    }
                },
                this.decoder = null,
                "VideoDecoder"in window && (this.decoder = new VideoDecoder(this.callback)),
                this.Iframe = new Uint8Array,
                this.curVideoType = ""
            }
            getVideoType(t) {
                var e, i, n, r;
                if (!this.decoder)
                    return;
                const {buffer: o, codecType: s, isKeyframe: a, dts: l} = t;
                switch (this.Iframe = new Uint8Array,
                s) {
                case G.z.VIDEO_H264:
                    {
                        const t = new Y.GV(new Uint8Array(o));
                        let n = null;
                        for (; null != (n = t.readNextNaluPayload()); ) {
                            if (new Y.vf(n).type === Y.k_.kSliceSPS) {
                                const t = tt.Z.parseSPS(n.data)
                                  , {codec_mimetype: r, codec_size: s, colorSpace: c} = t;
                                this.decoder.configure({
                                    codec: r || "avc1.64001e",
                                    codedHeight: null !== (e = null == s ? void 0 : s.height) && void 0 !== e ? e : 1280,
                                    codedWidth: null !== (i = null == s ? void 0 : s.width) && void 0 !== i ? i : 720,
                                    colorSpace: c
                                });
                                const h = new EncodedVideoChunk({
                                    timestamp: l,
                                    type: a ? "key" : "delta",
                                    data: o
                                });
                                return void this.decoder.decode(h)
                            }
                        }
                        break
                    }
                case G.z.VIDEO_H265:
                    {
                        const t = new J.iA(new Uint8Array(o));
                        let e, i, s, c = null;
                        for (; null != (c = t.readNextNaluPayload()); ) {
                            const t = new J.zW(c);
                            if (t.type === J.Xn.kSliceSPS) {
                                const n = K.Z.parseSPS(c.data)
                                  , {codec_mimetype: r, codec_size: o, colorSpace: a} = n;
                                s = a,
                                e = r,
                                i = o,
                                this.concatenateIFrame(t.data)
                            } else
                                (t.type === J.Xn.kSliceVPS || t.type === J.Xn.kSlicePPS || t.type === J.Xn.kSliceIDR_W_RADL) && this.concatenateIFrame(t.data)
                        }
                        this.decoder.configure({
                            codec: e || "hvc1.1.1.L150.B0",
                            codedWidth: null !== (n = null == i ? void 0 : i.width) && void 0 !== n ? n : 720,
                            codedHeight: null !== (r = null == i ? void 0 : i.height) && void 0 !== r ? r : 1280,
                            colorSpace: s
                        });
                        const h = {
                            timestamp: l,
                            type: a ? "key" : "delta",
                            data: this.Iframe
                        }
                          , u = new EncodedVideoChunk(h);
                        this.decoder.decode(u);
                        break
                    }
                }
            }
            concatenateIFrame(t) {
                this.Iframe = this.concatenate(this.Iframe, new Uint8Array([0, 0, 0, 1])),
                this.Iframe = this.concatenate(this.Iframe, t.subarray(4))
            }
            concatenate(...t) {
                let e = 0;
                for (const i of t)
                    e += i.byteLength;
                const i = new Uint8Array(e);
                let n = 0;
                for (const e of t) {
                    const t = new Uint8Array(e);
                    i.set(t, n),
                    n += e.byteLength
                }
                return i
            }
            handle(t) {
                var e;
                if (this.onvSeeking)
                    return;
                if (this.decoder || (this.decoder = new VideoDecoder(this.callback),
                this.curVideoType = ""),
                this.detectSpsInfo(t),
                this.curVideoType !== t.codecType || this.videoMetaChanged) {
                    if (null === (e = this.decoder) || void 0 === e || e.reset(),
                    !t.isKeyframe)
                        return;
                    return this.getVideoType(t),
                    this.curVideoType = t.codecType,
                    void (this.videoMetaChanged = !1)
                }
                const {buffer: i, isKeyframe: n, dts: r} = t;
                switch (this.decoder.state) {
                case "closed":
                    if (n) {
                        this.decoder = new VideoDecoder(this.callback),
                        this.getVideoType(t),
                        this.curVideoType = t.codecType;
                        break
                    }
                    return;
                case "unconfigured":
                    if (n) {
                        this.getVideoType(t),
                        this.curVideoType = t.codecType;
                        break
                    }
                    return
                }
                const o = new EncodedVideoChunk({
                    timestamp: r,
                    type: n ? "key" : "delta",
                    data: i
                });
                this.decoder.decode(o)
            }
            detectSpsInfo(t) {
                const {buffer: e, codecType: i} = t;
                switch (i) {
                case G.z.VIDEO_H264:
                    {
                        const t = new Y.GV(new Uint8Array(e));
                        let i = null;
                        for (; null != (i = t.readNextNaluPayload()); ) {
                            const t = new Y.vf(i);
                            if (t.type === Y.k_.kSliceSPS) {
                                const e = tt.Z.parseSPS(i.data);
                                this.firstSegmentDispatched ? this.detectVideoMetadataChange(e) && (this.logger.log("H264: Critical h264 metadata has been changed, attempt to re-generate InitSegment"),
                                this.videoMetaChanged = !0,
                                this.videoMetadata = {
                                    vps: void 0,
                                    sps: t,
                                    pps: void 0,
                                    details: e
                                }) : (this.videoMetadata.sps = t,
                                this.videoMetadata.details = e,
                                this.firstSegmentDispatched = !0)
                            }
                        }
                        break
                    }
                case G.z.VIDEO_H265:
                    {
                        const t = new J.iA(new Uint8Array(e));
                        let i = null;
                        for (; null != (i = t.readNextNaluPayload()); ) {
                            const t = new J.zW(i);
                            if (t.type === J.Xn.kSliceSPS) {
                                const e = K.Z.parseSPS(i.data);
                                this.firstSegmentDispatched ? this.detectVideoMetadataChange(e) && (this.logger.log("H265: Critical h265 metadata has been changed, attempt to re-generate InitSegment"),
                                this.videoMetaChanged = !0,
                                this.videoMetadata = {
                                    vps: this.videoMetadata.vps,
                                    sps: t,
                                    pps: void 0,
                                    details: e
                                }) : (this.videoMetadata.sps = t,
                                this.videoMetadata.details = e,
                                this.firstSegmentDispatched = !0)
                            }
                        }
                        break
                    }
                }
            }
            detectVideoMetadataChange(t) {
                var e, i, n, r, o, s, a;
                if (t.codec_mimetype !== (null === (e = this.videoMetadata.details) || void 0 === e ? void 0 : e.codec_mimetype))
                    return this.logger.log(`Video: Codec mimeType changed from ${null === (i = this.videoMetadata.details) || void 0 === i ? void 0 : i.codec_mimetype} to ${t.codec_mimetype}`),
                    !0;
                if (t.codec_size.width !== (null === (n = this.videoMetadata.details) || void 0 === n ? void 0 : n.codec_size.width) || t.codec_size.height !== (null === (r = this.videoMetadata.details) || void 0 === r ? void 0 : r.codec_size.height)) {
                    const e = null === (o = this.videoMetadata.details) || void 0 === o ? void 0 : o.codec_size
                      , i = t.codec_size;
                    return this.logger.log(`Video: Coded Resolution changed from ${e.width}x${e.height} to ${i.width}x${i.height}`),
                    !0
                }
                return t.present_size.width !== (null === (s = this.videoMetadata.details) || void 0 === s ? void 0 : s.present_size.width) && (this.logger.log(`Video: Present resolution width changed from ${null === (a = this.videoMetadata.details) || void 0 === a ? void 0 : a.present_size.width} to ${t.present_size.width}`),
                !0)
            }
            seek() {
                throw new Error("Method not implemented.")
            }
            destroy() {
                var t, e;
                null === (e = null === (t = this.decoder) || void 0 === t ? void 0 : t.close) || void 0 === e || e.call(t),
                this.decoder = null
            }
        }
        class ot extends V.P {
            constructor(t) {
                var e;
                super(t.baseConfig),
                this.responseSeq = 0,
                this.prevPacket = {
                    dataSeq: -1,
                    data: null
                },
                this.onvSeeking = !1,
                this.dataSeqBase = -1,
                this.dataSequence = -1,
                this.consume = t => (z(t, this.options.mediaType, !0) || this.logger.warn("Boundary parse failed."),
                this.parseChunks(t)),
                this.parseFirstChunk = t => {
                    z(t, this.options.mediaType, !0) || this.logger.warn("Boundary parse failed.");
                    let e = j(t);
                    for (; e < t.byteLength && !(e + this.boundary.length > t.byteLength); ) {
                        let i = 0;
                        const {offset: n, forward: r} = this.parseChunkBoundary(t, e + i);
                        if (!r)
                            break;
                        i += n;
                        const {headerOffset: o, httpHeader: s, forward: a} = this.parseChunkHeader(t, e + i);
                        if (!a)
                            break;
                        i += o;
                        const l = s[T.fj.CONTENT_TYPE]
                          , c = s[T.fj.CONTENT_LENGTH];
                        if (e + i + c > t.byteLength)
                            break;
                        switch (l) {
                        case G.z.VIDEO_MP2T:
                            this.resetParseInfo(),
                            this.transformerEmitter.emit(B.K7.SWITCH_STREAM_FINISH, {
                                switchStreamSuccess: !0
                            }),
                            this.consume(t);
                            break;
                        case G.z.APPLICATION_JSON:
                            let n = e + i + c + 2;
                            n > t.byteLength && (n = t.byteLength);
                            try {
                                const i = (0,
                                P._)(t, e, n - e);
                                (0,
                                _.Oq)(i).forEach((t => {
                                    this.handleNewStreamJson(t)
                                }
                                ))
                            } catch (t) {
                                this.logger.log(t)
                            }
                        }
                        i += c,
                        e += i,
                        e = j(t, e)
                    }
                    return e
                }
                ,
                this.options = Object.assign({
                    videoPlayerType: d.WEBGL,
                    mediaType: T.DD.MIXED,
                    isTransportStream: !0,
                    useRecorderWorker: !1,
                    supportWebcodecs: !1
                }, t),
                this.logger.log(`Transformer init with ${null === (e = this.options) || void 0 === e ? void 0 : e.videoPlayerType} Player.`),
                this.boundary = F(this.options.mediaType, this.options.isTransportStream),
                this.demuxer = new W(t),
                this.transformerEmitter.on(B.K7.VIDEO_CODE, (t => {
                    this.handler || (this.handler = this.getHandler(t))
                }
                )),
                this.recorder = (0,
                nt.Qr)({
                    isWorker: this.options.useRecorderWorker,
                    options: [{
                        baseConfig: this.options.baseConfig
                    }]
                })
            }
            seek() {
                this.onvSeeking = !0,
                this.handler.seek()
            }
            destroy() {
                var t;
                super.destroy(),
                null === (t = this.handler) || void 0 === t || t.destroy(),
                this.recorder.destroy()
            }
            getHandler(t) {
                switch (this.options.videoPlayerType) {
                case d.WEBGL:
                    return this.transformerEmitter.emit(B.K7.PLAYER_TYPE, d.WEBGL),
                    this.options.supportWebcodecs ? new rt({
                        baseConfig: this.options.baseConfig
                    }) : new X({
                        baseConfig: this.options.baseConfig,
                        reuseWorker: !1
                    });
                case d.MSE:
                    return this.transformerEmitter.emit(B.K7.PLAYER_TYPE, d.MSE),
                    new et({
                        baseConfig: this.options.baseConfig
                    });
                case d.AUTO:
                    if (t === G.z.VIDEO_H265) {
                        const t = o.supportMseHevcPlayback();
                        return this.transformerEmitter.emit(B.K7.PLAYER_TYPE, t ? d.MSE : d.WEBGL),
                        t ? new et({
                            baseConfig: this.options.baseConfig
                        }) : new X({
                            baseConfig: this.options.baseConfig
                        })
                    }
                    {
                        const t = o.supportMseAvcPlayback();
                        return this.transformerEmitter.emit(B.K7.PLAYER_TYPE, t ? d.MSE : d.WEBGL),
                        t ? new et({
                            baseConfig: this.options.baseConfig
                        }) : new X({
                            baseConfig: this.options.baseConfig
                        })
                    }
                default:
                    throw new Error(this.logger.getLog("Unknown player type."))
                }
            }
            parseChunks(t) {
                let e = j(t);
                for (; e < t.byteLength && !(e + this.boundary.length > t.byteLength); ) {
                    let i = 0;
                    const {offset: n, forward: r} = this.parseChunkBoundary(t, e + i);
                    if (!r)
                        break;
                    i += n;
                    const {headerOffset: o, httpHeader: s, forward: a} = this.parseChunkHeader(t, e + i);
                    if (!a)
                        break;
                    i += o;
                    const l = s[T.fj.X_DATA_SEQUENCE];
                    void 0 !== l && (-1 === this.dataSeqBase && (this.dataSeqBase = l),
                    this.transformerEmitter.emit(B.K7.SEQUENCE_RECEIVED, l),
                    this.dataSequence = l);
                    const c = s[T.fj.CONTENT_TYPE]
                      , h = s[T.fj.CONTENT_LENGTH];
                    if (e + i + h > t.byteLength)
                        break;
                    switch (c) {
                    case G.z.VIDEO_MP2T:
                        this.getFullTSPacket(t, e + i, s);
                        break;
                    case G.z.APPLICATION_JSON:
                        let n = e + i + h + 2;
                        n > t.byteLength && (n = t.byteLength);
                        try {
                            const i = (0,
                            P._)(t, e, n - e);
                            (0,
                            _.Oq)(i).forEach((t => {
                                var e;
                                const i = null === (e = this.jsonParseHook) || void 0 === e ? void 0 : e.call(this, t);
                                (null == i ? void 0 : i.seekSuccess) && (this.dataSeqBase = -1,
                                this.onvSeeking = !1,
                                this.transformerEmitter.emit(B.K7.SEEK_FINISHED)),
                                (null == i ? void 0 : i.dataFinished) && this.transformerEmitter.emit(B.K7.DATA_FINISHED, this.dataSequence),
                                this.transformerEmitter.emit(B.K7.JSON_RECEIVED, t)
                            }
                            ))
                        } catch (t) {
                            this.logger.log(t)
                        }
                    }
                    i += h,
                    e += i,
                    e = j(t, e)
                }
                return e
            }
            parseChunkBoundary(t, e) {
                let i = 0;
                const n = N(t, e);
                if (!n.result)
                    return {
                        offset: i,
                        forward: !1
                    };
                {
                    const t = n.data;
                    if (t !== this.boundary)
                        throw this.transformerEmitter.emit(B.mF.FORMAT_UNSUPPORTED, `wrong format - ${t}`),
                        new Error(this.logger.getLog(`parse boundary break: wrong format - ${t}`));
                    i += n.offset
                }
                return {
                    offset: i,
                    forward: !0
                }
            }
            parseChunkHeader(t, e) {
                const i = {};
                let n = ""
                  , r = 0;
                do {
                    const o = N(t, e + r);
                    if (!o.result) {
                        n = B.vm.PRE_EPILOGUE;
                        break
                    }
                    {
                        r += o.offset;
                        const t = o.data;
                        if (0 === t.length) {
                            n = B.vm.HEADER,
                            U(i),
                            this.checkBoundaryHeader(i) || (n = B.vm.PRE_EPILOGUE);
                            break
                        }
                        const e = t.split(":");
                        if (!(e.length >= 2)) {
                            n = B.vm.PRE_EPILOGUE;
                            break
                        }
                        {
                            const n = t.indexOf(e[1]);
                            i[e[0]] = t.substring(n).trim()
                        }
                    }
                } while (n !== B.vm.HEADER);
                if (n !== B.vm.HEADER)
                    return this.logger.warn("Headers parse failed."),
                    {
                        headerOffset: r,
                        httpHeader: i,
                        forward: !1
                    };
                return r + i[T.fj.CONTENT_LENGTH] > t.byteLength ? {
                    headerOffset: r,
                    httpHeader: i,
                    forward: !1
                } : {
                    headerOffset: r,
                    httpHeader: i,
                    forward: !0
                }
            }
            checkBoundaryHeader(t) {
                const e = [];
                for (let i = 0; i < T.kK.length; i++) {
                    const n = T.kK[i];
                    Object.prototype.hasOwnProperty.call(t, n) || e.push(n)
                }
                e.length > 0 && (this.transformerEmitter.emit(B.mF.MISSING_REQUIRED_HEADER, e.join(", ")),
                this.logger.warn("Missing required headers: ", e.join(", ")));
                const i = t[T.fj.CONTENT_LENGTH];
                return !("number" != typeof i || i <= 0) || (this.logger.warn(`Wrong ${T.fj.CONTENT_LENGTH}: ${t[T.fj.CONTENT_LENGTH]}`),
                !1)
            }
            getFullTSPacket(t, e, i) {
                var n, r;
                const o = i[T.fj.X_DATA_SEQUENCE]
                  , s = i[T.fj.CONTENT_LENGTH]
                  , a = new Uint8Array(t,e,s);
                if (-1 === this.prevPacket.dataSeq || this.prevPacket.dataSeq !== o) {
                    !(-1 !== this.prevPacket.dataSeq) && o || !this.prevPacket.data || this.parseData(Object.assign({}, this.prevPacket));
                    const t = new Uint8Array(s);
                    t.set(a),
                    this.prevPacket = {
                        data: t,
                        dataSeq: null != o ? o : -1
                    }
                } else if (this.prevPacket.data) {
                    this.logger.log("ts packet concat");
                    const t = this.prevPacket.data
                      , e = t.byteLength;
                    this.prevPacket = Object.assign(Object.assign({}, this.prevPacket), {
                        data: new Uint8Array(e + s)
                    }),
                    null === (n = this.prevPacket.data) || void 0 === n || n.set(t),
                    null === (r = this.prevPacket.data) || void 0 === r || r.set(a, e)
                }
            }
            parseData(t) {
                const {data: e, dataSeq: i} = t;
                if (!e)
                    return;
                const n = this.demuxer.parse(e);
                if (n) {
                    const t = n.videoTrack
                      , e = n.audioTrack;
                    t.samples.length && t.samples.forEach((e => {
                        this.parseVideoData(t, Object.assign(Object.assign({}, e), {
                            seq: i
                        }))
                    }
                    )),
                    e.samples.length && e.samples.forEach((t => {
                        this.transformerEmitter.emit(B.K7.AUDIO_SAMPLE, t),
                        this.recorder.cache({
                            buffer: t.data.slice(t.offset).buffer,
                            codecType: t.codeType,
                            pts: t.pts,
                            dts: t.dts,
                            cts: 0,
                            seq: t.seq || 0,
                            timestamp: t.timestamp,
                            isKeyframe: !1,
                            isVirtualKeyframe: !1,
                            isNextVirtualKeyframe: !1
                        })
                    }
                    ))
                }
            }
            parseVideoData(t, e) {
                const {pts: i, offset: n, timestamp: r, seq: o=0, dts: s} = e;
                if (this.onvSeeking || o < this.dataSeqBase)
                    return;
                const a = new Uint8Array(e.data.buffer,n)
                  , l = this.getFrameType(e.data.buffer, n, t.type)
                  , c = l === B.Qp.IDR;
                if (-1 === l)
                    return void this.logger.error("Frame type not exist.");
                const h = {
                    buffer: new Uint8Array(a).buffer,
                    codecType: t.type,
                    pts: i,
                    dts: s,
                    cts: 0,
                    seq: o,
                    timestamp: r,
                    isKeyframe: c,
                    isVirtualKeyframe: !!t.virtualKeyframe,
                    isNextVirtualKeyframe: !1
                };
                this.handler.handle(h),
                this.recorder.cache(h)
            }
            getFrameType(t, e, i) {
                const n = new Uint8Array(t,e,5);
                let r = -1
                  , o = 0;
                if (0 !== n[0] || 0 !== n[1])
                    return this.transformerEmitter.emit(B.mF.FORMAT_ERR, `unknown nalu header: ${n.toString()}`),
                    -1;
                if (1 === n[2] ? o = n[3] : 0 === n[2] && 1 === n[3] ? o = n[4] : this.transformerEmitter.emit(B.mF.FORMAT_ERR, `unknown nalu header: ${n.toString()}`),
                i == G.z.VIDEO_H264)
                    switch (31 & o) {
                    case 1:
                        r = B.Qp.P;
                        break;
                    case 7:
                        r = B.Qp.IDR;
                        break;
                    default:
                        this.transformerEmitter.emit(B.mF.FORMAT_ERR, `unknown frame type: ${n.toString()}`)
                    }
                else
                    switch ((126 & o) >> 1) {
                    case 0:
                    case 1:
                        r = B.Qp.P;
                        break;
                    case 32:
                    case 33:
                    case 34:
                        r = B.Qp.IDR;
                        break;
                    default:
                        this.transformerEmitter.emit(B.mF.FORMAT_ERR, `unknown frame type: ${n.toString()}`)
                    }
                return r
            }
            handleNewStreamJson(t) {
                const {params: {error_code: e}} = t
                  , i = {
                    switchStreamSuccess: !1,
                    json: t
                };
                e && this.transformerEmitter.emit(B.K7.SWITCH_STREAM_FINISH, i)
            }
            resetParseInfo() {
                this.dataSeqBase = -1,
                this.prevPacket = {
                    dataSeq: -1,
                    data: null
                },
                this.demuxer.clearPid(),
                this.handler.clear()
            }
            onTSParse(t) {
                this.tsParseHook = t
            }
            onJsonParse(t) {
                this.jsonParseHook = t
            }
        }
        class st extends a {
            constructor(t) {
                super(t.baseConfig)
            }
        }
        !function(t) {
            t[t.AUDIO_PCM = 1] = "AUDIO_PCM",
            t[t.AUDIO_G711A = 6] = "AUDIO_G711A",
            t[t.AUDIO_G711U = 7] = "AUDIO_G711U"
        }(it || (it = {}));
        const at = new Map([["live", {
            needCacheAudioData: !1
        }], ["playback", {
            needCacheAudioData: !0
        }]])
          , lt = {
            encoding: "16bitInt",
            channels: 1,
            sampleRate: 8e3,
            flushingTime: 100,
            muted: !0,
            needCacheAudioData: !1
        };
        class ct extends st {
            constructor(t) {
                super(t),
                this.startTime = 0,
                this.pcm = new Uint8Array(0),
                this.pcm_pay = new Float32Array(0),
                this.samples = new Float32Array(0),
                this.maxValue = 0,
                this.audioFormat = it.AUDIO_G711A,
                this.paused = !1,
                this.options = Object.assign({}, Object.assign({}, lt), t);
                const {audioCtx: e, gainNode: i} = this.init();
                this.audioCtx = e,
                this.gainNode = i
            }
            init() {
                return this.samples = new Float32Array,
                this.flush = this.flush.bind(this),
                this.interval = setInterval(this.flush, this.options.flushingTime),
                this.maxValue = this.getMaxValue(),
                this.createContext()
            }
            createContext() {
                const t = new (window.AudioContext || window.webkitAudioContext)
                  , e = t.createGain();
                return e.gain.value = this.options.muted ? 0 : 2,
                e.connect(t.destination),
                this.startTime = t.currentTime,
                {
                    audioCtx: t,
                    gainNode: e
                }
            }
            configWithCodeType(t, e) {
                switch (t) {
                case G.z.AUDIO_G711A:
                    this.setSampleRate(8e3),
                    this.audioFormat = it.AUDIO_G711A,
                    this.setEncoding("16bitInt");
                    break;
                case G.z.AUDIO_G711U:
                    this.audioFormat = it.AUDIO_G711U,
                    this.setSampleRate(16e3),
                    this.setEncoding("16bitInt");
                    break;
                case G.z.AUDIO_WAV:
                    e && this.configWithWaveHeader(e);
                case G.z.AUDIO_MPEG:
                }
            }
            configWithWaveHeader(t) {
                const e = t.slice(20, 22)
                  , i = new Uint16Array(e)[0];
                this.audioFormat = i;
                const n = t.slice(22, 24).buffer
                  , r = new Uint16Array(n)[0];
                this.setChannels(r);
                const o = t.slice(24, 28).buffer
                  , s = new Uint32Array(o)[0];
                this.setSampleRate(s);
                const a = t.slice(34, 36).buffer
                  , l = new Uint16Array(a)[0] + "bitInt";
                this.setEncoding(l)
            }
            setChannels(t) {
                this.options.channels = t
            }
            setSampleRate(t) {
                this.options.sampleRate = t
            }
            setEncoding(t) {
                this.options.encoding = t,
                this.maxValue = this.getMaxValue()
            }
            getMaxValue() {
                const t = {
                    "8bitInt": 128,
                    "16bitInt": 32768,
                    "32bitInt": 2147483648,
                    "32bitFloat": 1
                };
                return t[this.options.encoding] ? t[this.options.encoding] : t["16bitInt"]
            }
            getTypedArray(t) {
                switch (this.options.encoding) {
                case "8bitInt":
                    return new Int8Array(t);
                case "32bitInt":
                    return new Int32Array(t);
                case "32bitFloat":
                    return new Float32Array(t);
                default:
                    return new Int16Array(t)
                }
            }
            isTypedArray(t) {
                return t.byteLength && t.buffer && t.buffer.constructor == ArrayBuffer
            }
            convertToPcm(t, e) {
                let i;
                switch (e) {
                case it.AUDIO_PCM:
                    i = new Uint8Array(t);
                    break;
                case it.AUDIO_G711A:
                    i = this.convertPCMAToPcm(t);
                    break;
                case it.AUDIO_G711U:
                    i = this.convertPCMUToPcm(t)
                }
                return i
            }
            convertPCMAToPcm(t) {
                const e = new Int16Array(t.length);
                for (let i = 0; i < t.length; i++) {
                    const n = 85 ^ t[i];
                    let r = (15 & n) << 4;
                    const o = (112 & n) >> 4;
                    switch (o) {
                    case 0:
                        r += 8;
                        break;
                    case 1:
                        r += 264;
                        break;
                    default:
                        r += 264,
                        r <<= o - 1
                    }
                    e[i] = 128 & n ? r : -r
                }
                return e
            }
            convertPCMUToPcm(t) {
                const e = new Int16Array(t.length);
                for (let i = 0; i < t.length; i++) {
                    const n = ~t[i];
                    let r = 132 + ((15 & n) << 3);
                    r <<= (112 & n) >> 4,
                    e[i] = 128 & n ? 132 - r : r - 132
                }
                return e
            }
            appendSegment(t) {
                const e = t.data;
                let i = new Uint8Array(e.slice(t.offset));
                const n = t.codeType;
                if (n == G.z.AUDIO_WAV) {
                    const t = i.slice(0, 44);
                    this.configWithCodeType(n, t),
                    i = i.slice(44)
                } else
                    this.configWithCodeType(n);
                if (!this.isTypedArray(i))
                    return;
                const r = this.convertToPcm(i, this.audioFormat);
                if (!r)
                    return;
                this.pcm_pay = this.getFormattedValue(r);
                const o = new Float32Array(this.samples.length + this.pcm_pay.length);
                o.set(this.samples, 0),
                o.set(this.pcm_pay, this.samples.length),
                this.samples = o
            }
            getFormattedValue(t) {
                const e = this.getTypedArray(t.buffer)
                  , i = new Float32Array(e.length);
                let n = 0;
                for (n = 0; n < e.length; n++)
                    i[n] = e[n] / this.maxValue;
                return i
            }
            set volume(t) {
                this.gainNode.gain.value = 2 * t
            }
            get volume() {
                return this.gainNode.gain.value / 2
            }
            clear() {}
            destroy() {
                var t;
                this.interval && clearInterval(this.interval),
                null === (t = this.audioCtx) || void 0 === t || t.close()
            }
            flush() {
                if (!this.samples.length)
                    return;
                const t = this.audioCtx.createBufferSource()
                  , e = this.samples.length / this.options.channels
                  , i = this.audioCtx.createBuffer(this.options.channels, e, this.options.sampleRate);
                let n, r, o, s, a;
                for (r = 0; r < this.options.channels; r++)
                    for (n = i.getChannelData(r),
                    o = r,
                    a = 50,
                    s = 0; s < e; s++)
                        n[s] = this.samples[o],
                        s < 50 && (n[s] = n[s] * s / 50),
                        s >= e - 51 && (n[s] = n[s] * a-- / 50),
                        o += this.options.channels;
                this.startTime < this.audioCtx.currentTime && (this.startTime = this.audioCtx.currentTime),
                this.paused && !this.options.needCacheAudioData || (t.buffer = i,
                t.connect(this.gainNode),
                t.start(this.startTime),
                this.startTime += i.duration),
                this.samples = new Float32Array
            }
            pause() {
                this.audioCtx.suspend(),
                this.paused = !0
            }
            resume() {
                this.audioCtx.resume(),
                this.paused = !1
            }
        }
        ct.getInstance = t => (ct.instance || (ct.instance = new ct(t)),
        ct.instance);
        var ht, ut = ct, dt = i(25108);
        const ft = n.in.Warn;
        class pt extends n.KG {
            constructor(t, e) {
                const i = {
                    videoPlayerType: d.AUTO,
                    audioPlayerType: p.G711A,
                    loaderType: M.tY.HTTP,
                    mediaType: "mixed",
                    mode: "live",
                    video: {},
                    audio: {},
                    baseConfig: {
                        id: Math.random(),
                        log: {
                            level: ft
                        }
                    }
                };
                (0,
                _.Gm)(i, e || {}),
                super(i.baseConfig),
                this.wrapper = null,
                this.playerState = f.UN_INIT,
                this.id = i.baseConfig.id,
                t && (this.wrapper = this.createWrapper(t)),
                this.options = i,
                this.audioPlayer = this.getAudioPlayer(),
                this.loader = this.getLoader(),
                this.transformer = new ot({
                    baseConfig: i.baseConfig,
                    videoPlayerType: this.options.videoPlayerType,
                    supportWebcodecs: ht.isSupportWebcodecs
                }),
                this.listen(),
                this.on(B.K7.PLAYER_TYPE, (t => {
                    this.videoPlayer = this.getVideoPlayer(t),
                    this.listenPlayerEvents()
                }
                )),
                this.on(B.K7.SWITCH_STREAM_FINISH, (t => {
                    this.handleSwitchStream(t)
                }
                )),
                this.onDataReady(this.transformer.consume),
                this.on(B.K7.MSE_INIT_SEGMENT, (t => {
                    this.videoPlayer.appendInitSegment(t)
                }
                )),
                this.on(B.K7.VIDEO_SAMPLE, (t => {
                    this.videoPlayer.appendMediaSegment(t)
                }
                )),
                this.on(B.K7.AUDIO_SAMPLE, (t => {
                    var e;
                    ht.userHasClicked && (null === (e = this.audioPlayer) || void 0 === e || e.appendSegment(t))
                }
                )),
                this.on(g.CHANGE_PLAYBACK_RATE, (t => {
                    this.transformer.transformerEmitter.emit(g.CHANGE_PLAYBACK_RATE, t)
                }
                )),
                this.on(B.K7.DATA_FINISHED, (t => {
                    this.videoPlayer.lastFrameSequence = t
                }
                ))
            }
            destroy(t=!1) {
                var e, i, n;
                this.cancelListen(),
                this.loader.destroy(),
                this.transformer.destroy(),
                null === (e = this.audioPlayer) || void 0 === e || e.destroy(),
                t ? null === (i = this.videoPlayer) || void 0 === i || i.pause() : (null === (n = this.videoPlayer) || void 0 === n || n.destroy(),
                this.detachWrapper())
            }
            disConnectKeepLastFrame() {
                var t, e;
                this.cancelListen(),
                this.loader.destroy(),
                this.transformer.destroy(),
                null === (t = this.audioPlayer) || void 0 === t || t.destroy(),
                null === (e = this.videoPlayer) || void 0 === e || e.disConnectKeepLastFrame()
            }
            listen() {
                for (const t of Object.values(M.Xr))
                    this.loader.loaderEmitter.on(t, (e => {
                        this.emitter.emit(t, e)
                    }
                    ));
                for (const t of Object.values(B.K7))
                    this.transformer.transformerEmitter.on(t, (e => {
                        this.emitter.emit(t, e)
                    }
                    ))
            }
            cancelListen() {
                const t = [...Object.values(g), ...Object.values(m), ...Object.values(M.Xr), ...Object.values(B.K7)];
                for (const e of t)
                    this.off(e)
            }
            listenPlayerEvents() {
                const t = [...Object.values(m), ...Object.values(g)];
                for (const e of t)
                    this.videoPlayer.playerEmitter.on(e, (t => {
                        this.emitter.emit(e, t)
                    }
                    ))
            }
            createWrapper(t) {
                const e = document.createElement("div");
                return e.setAttribute("style", ["width: 100%;", "height: 100%;", "box-sizing: border-box;", "position: relative;", "display: flex;", "justify-content: center;", "align-items: center;"].join("")),
                t.innerHTML = "",
                t.appendChild(e),
                e
            }
            detachWrapper() {
                var t;
                null === (t = this.wrapper) || void 0 === t || t.remove()
            }
            getVideoPlayer(t) {
                const e = this.options.video
                  , {baseConfig: i, mode: n} = this.options
                  , r = Object.assign({}, {
                    baseConfig: i,
                    mode: n,
                    supportWebcodecs: ht.isSupportWebcodecs
                }, e);
                let s;
                if (!this.wrapper)
                    throw this.logger.getLog("Unbound Player Container.");
                switch (t) {
                case d.AUTO:
                    o.supportMseHevcPlayback() ? (this.options.videoPlayerType = d.MSE,
                    s = new I(this.wrapper,r)) : this.options.videoPlayerType = d.AUTO;
                    break;
                case d.WEBGL:
                    s = new b(this.wrapper,r);
                    break;
                case d.MSE:
                    s = new I(this.wrapper,r);
                    break;
                default:
                    throw this.logger.getLog("Player type invalid.")
                }
                return s
            }
            getAudioPlayer() {
                const {audioPlayerType: t, audio: e} = this.options
                  , {baseConfig: i, mode: n} = this.options
                  , r = Object.assign({}, {
                    baseConfig: i
                }, at.get(n), e);
                let o = null;
                switch (t) {
                case p.AUTO:
                    break;
                case p.G711A:
                    o = new ut(r);
                    break;
                case p.MP3:
                    break;
                default:
                    throw this.logger.getLog("audioPlayer type invalid.")
                }
                return o
            }
            getLoader() {
                const {loaderType: t, baseConfig: e} = this.options;
                let i = null;
                switch (t) {
                case M.tY.HTTP:
                case M.tY.M3U8:
                    i = new D({
                        baseConfig: e
                    });
                    break;
                case M.tY.WS:
                    i = new L({
                        baseConfig: e
                    });
                    break;
                default:
                    throw this.logger.getLog("Loader type invalid.")
                }
                return i
            }
            handleSwitchStream(t) {
                const {switchStreamSuccess: e} = t;
                e ? this.handleSwitchStreamSuccess() : this.switchStreamFail()
            }
            handleSwitchStreamSuccess() {
                const t = [...Object.values(M.Xr)];
                for (const e of t)
                    this.off(e);
                if (this.loader.destroy(),
                this.prepareLoader) {
                    this.prepareLoader.onDataReady(this.transformer.consume),
                    this.loader = this.prepareLoader;
                    for (const t of Object.values(M.Xr))
                        this.loader.loaderEmitter.on(t, (e => {
                            this.emitter.emit(t, e)
                        }
                        ))
                }
            }
            switchStreamFail() {
                var t;
                null === (t = this.prepareLoader) || void 0 === t || t.destroy()
            }
            switchStream() {
                const t = this.getLoader();
                return t.onDataReady(this.transformer.parseFirstChunk),
                this.prepareLoader = t,
                this.transformer.transformerEmitter.emit(B.K7.SWITCH_STREAM),
                t
            }
            attachWrapper(t) {
                this.wrapper = this.createWrapper(t)
            }
            startRecord(...t) {
                this.transformer.recorder.start(...t)
            }
            stopRecord(t) {
                this.transformer.recorder.stop(t)
            }
            seek() {
                this.videoPlayer.seek(),
                this.transformer.seek()
            }
            pause() {
                var t, e;
                null === (t = this.videoPlayer) || void 0 === t || t.pause(),
                null === (e = this.audioPlayer) || void 0 === e || e.pause()
            }
            resume() {
                this.videoPlayer.resume(),
                this.audioPlayer.resume()
            }
            onFetchSuccess(t) {
                this.loader.onFetchSuccess(t)
            }
            onVideoSegment(t) {
                this.videoPlayer.onVideoSegment(t)
            }
            onDataReady(t) {
                this.loader.onDataReady(t)
            }
            onTSParse(t) {
                this.logger.log(t)
            }
            onJsonParse(t) {
                this.transformer.onJsonParse(t)
            }
        }
        ht = pt,
        pt.userHasClicked = !1,
        pt.isSupportWebcodecs = !1,
        pt.isSupported = () => o.supportMseHevcPlayback(),
        window.addEventListener("mousedown", ( () => {
            ht.userHasClicked = !0
        }
        ), {
            once: !0
        }),
        pt.checkSupportWebcodecs = async () => {
            if ("VideoDecoder"in window) {
                const t = await VideoDecoder.isConfigSupported({
                    codec: "avc1.64001e"
                })
                  , e = await VideoDecoder.isConfigSupported({
                    codec: "hvc1.1.1.L150.B0"
                });
                return t.supported && e.supported ? (dt.log("Browser supports H.265 (HEVC) hard decoding with WebCodecs."),
                !0) : t.supported && !e.supported ? (dt.log("Browser does not support H.265 (HEVC) hard decoding with WebCodecs."),
                !1) : (dt.log("Browser does not support H.264 hard decoding with WebCodecs."),
                !1)
            }
            return dt.log("Browser does not support WebCodecs VideoDecoder API."),
            !1
        }
        ,
        ht.checkSupportWebcodecs().then((t => {
            ht.isSupportWebcodecs = t
        }
        ));
        var mt = pt
    },
    49871: function(t, e, i) {
        "use strict";
        var n = i(19131)
          , r = i(3174)
          , o = i(35171)
          , s = i(14988)
          , a = i(7677)
          , l = i(88087)
          , c = i(3359)
          , h = i(52180)
          , u = i(34805)
          , d = i(80309)
          , f = i(86490)
          , p = i(65499);
        const m = 1e3
          , g = ["codec_mimetype", "codec_size", "frame_rate"];
        class _ extends h.P {
            constructor(t) {
                super(t.baseConfig),
                this.recording = !1,
                this.cacheUsed = !1,
                this.callback = null,
                this.pendingFrames = [],
                this.fileIndex = 0,
                this.fileName = (0,
                d.QZ)("video_clips"),
                this.trackId = 1,
                this.currentVideoStartPTS = -1,
                this.initSegmentDispatched = !1,
                this.audioSampleDuration = 0,
                this.gapDuration = 0,
                this.spsFrameDuration = 0,
                this.totalDuration = 0,
                this.videoMetadata = {},
                this.audioMetadata = {
                    codec: r.d.ALAW,
                    channelCount: 1,
                    sampleRate: 8e3
                },
                this.tracks = [],
                this.prevVideoSample = null,
                this.moovBox = new Uint8Array(0),
                this.emitProgress = (0,
                d.Gc)((t => {
                    self.document ? this.transformerEmitter.emit(f.K7.RECORDER_PROGRESS, t) : self.postMessage({
                        [p.wH.progress]: t
                    })
                }
                ), 50),
                this.currentVideoTrack = this.createVideoTrack(),
                this.currentAudioTrack = this.createAudioTrack()
            }
            destroy() {
                this.clear()
            }
            cache(t) {
                if (t.isKeyframe ? this.pendingFrames = [t] : this.pendingFrames.length && (t.isVirtualKeyframe ? this.pendingFrames = [this.pendingFrames[0], t] : this.pendingFrames.push(t)),
                this.recording)
                    if (this.cacheUsed)
                        this.record(t);
                    else {
                        const t = [...this.pendingFrames];
                        t.length > 1 && t[1].isVirtualKeyframe && (t[0].isNextVirtualKeyframe = !0),
                        t.forEach((t => {
                            this.record(t)
                        }
                        )),
                        this.cacheUsed = !0
                    }
            }
            start(t) {
                if (this.recording)
                    return !1;
                this.recording = !0,
                this.cacheUsed = !1,
                t && (this.callback = t),
                self.document ? this.callback && this.callback(!0) : self.postMessage({
                    [p.wH.startCallback]: !0
                })
            }
            cancel() {
                this.clear()
            }
            stop(t="video_clips") {
                if (!this.recording)
                    return !1;
                this.fileName = (0,
                d.QZ)(t);
                const e = this.generateFile();
                this.download(e.buffer),
                this.emitProgress({
                    duration: 0,
                    pts: 0,
                    done: !0
                }),
                self.document ? this.callback && this.callback(!1) : self.postMessage({
                    [p.wH.startCallback]: !1
                }),
                this.clear()
            }
            segment() {
                const t = this.generateFile();
                this.download(t.buffer),
                this.totalDuration += this.tracks[0].track.duration,
                this.fileIndex++,
                this.clearFlags()
            }
            generateFile() {
                const t = a.Z.box(a.Z.types.ftyp, a.Z.constants.FTYP);
                let e = 8
                  , i = 0;
                for (let t = 0; t < this.tracks.length; t++) {
                    e += this.tracks[t].length
                }
                this.generateChunk(t.byteLength),
                this.generateMoovBox();
                const n = new Uint8Array(t.byteLength + e + this.moovBox.byteLength);
                n.set(t, 0),
                i += t.byteLength,
                n[i + 0] = e >>> 24 & 255,
                n[i + 1] = e >>> 16 & 255,
                n[i + 2] = e >>> 8 & 255,
                n[i + 3] = 255 & e,
                n.set(a.Z.types.mdat, i + 4),
                i += 8;
                for (let t = 0; t < this.tracks.length; t++) {
                    const e = this.tracks[t].data;
                    for (let t = 0; t < e.length; t++)
                        n.set(e[t], i),
                        i += e[t].byteLength
                }
                return i !== t.byteLength + e && this.logger.warn("mdat offset calc error."),
                n.set(this.moovBox, i),
                n
            }
            download(t) {
                if (self.document) {
                    const e = document.createElement("a")
                      , i = new Blob([t])
                      , n = window.URL.createObjectURL(i);
                    e.style.display = "none",
                    e.href = n,
                    e.download = this.getDownloadFilename(),
                    document.body.appendChild(e),
                    e.click(),
                    e.remove()
                } else
                    self.postMessage({
                        [p.wH.download]: {
                            data: t,
                            filename: this.getDownloadFilename()
                        }
                    })
            }
            getDownloadFilename() {
                return `${this.fileName}${this.fileIndex ? "_" + this.fileIndex : ""}.mp4`
            }
            clear() {
                this.clearStatus(),
                this.clearFlags()
            }
            clearStatus() {
                this.recording = !1,
                this.cacheUsed = !1,
                this.callback = null,
                this.fileIndex = 0,
                this.totalDuration = 0,
                this.gapDuration = 0
            }
            clearFlags() {
                this.trackId = 1,
                this.currentVideoStartPTS = -1,
                this.initSegmentDispatched = !1,
                this.audioSampleDuration = 0,
                this.videoMetadata = {},
                this.tracks = [],
                this.currentVideoTrack = this.createVideoTrack(),
                this.currentAudioTrack = this.createAudioTrack(),
                this.prevVideoSample = null,
                this.moovBox = new Uint8Array(0)
            }
            createVideoTrack() {
                const t = {
                    track: Object.assign({}, (0,
                    a.R)(), {
                        type: n.CO.VIDEO
                    }),
                    data: [],
                    length: 0
                };
                return this.tracks.push(t),
                t
            }
            createAudioTrack() {
                const t = {
                    track: Object.assign({}, (0,
                    a.R)(), {
                        type: n.CO.AUDIO
                    }),
                    data: [],
                    length: 0
                };
                return this.tracks.push(t),
                t
            }
            record(t) {
                const {buffer: e, codecType: i, pts: n, isKeyframe: a} = t;
                switch (i) {
                case r.z.VIDEO_H264:
                    {
                        let i = new Uint8Array(0);
                        const r = new o.GV(new Uint8Array(e));
                        let s = null;
                        const c = {};
                        for (; null != (s = r.readNextNaluPayload()); ) {
                            const t = new o.vf(s);
                            if (t.type !== o.k_.kSliceSPS)
                                t.type !== o.k_.kSlicePPS ? this.initSegmentDispatched && (i = (0,
                                u.c)(i, t.data)) : (c.pps = t,
                                c.sps && c.pps && (this.initSegmentDispatched = !0));
                            else {
                                const e = l.Z.parseSPS(s.data);
                                c.sps = t,
                                c.details = e,
                                this.spsFrameDuration = 1e3 / e.frame_rate.fps
                            }
                        }
                        if (this.handleCodecChange(c.details) && this.segment(),
                        Object.assign(this.videoMetadata, c),
                        Object.assign(this.currentVideoTrack, this.videoMetadata),
                        !i.byteLength)
                            return;
                        const h = Object.assign(Object.assign({}, t), {
                            buffer: i.buffer,
                            dts: Math.floor(n / 90),
                            pts: Math.floor(n / 90)
                        });
                        this.currentVideoTrack.track.sampleIndex++,
                        a && this.currentVideoTrack.track.keyframes.push(this.currentVideoTrack.track.sampleIndex),
                        this.recordVideo(h);
                        break
                    }
                case r.z.VIDEO_H265:
                    {
                        let i = new Uint8Array(0);
                        const r = new s.iA(new Uint8Array(e));
                        let o = null;
                        const l = {}
                          , h = {};
                        for (; null != (o = r.readNextNaluPayload()); ) {
                            const t = new s.zW(o);
                            if (t.type === s.Xn.kSliceVPS) {
                                const e = c.Z.parseVPS(o.data);
                                l.vps = t,
                                Object.assign(h, e)
                            } else if (t.type === s.Xn.kSliceSPS) {
                                const e = c.Z.parseSPS(o.data);
                                l.sps = t,
                                l.details = e,
                                this.spsFrameDuration = 1e3 / e.frame_rate.fps
                            } else if (t.type === s.Xn.kSlicePPS) {
                                const e = c.Z.parsePPS(o.data);
                                l.pps = t,
                                Object.assign(h, e),
                                l.vps && l.sps && l.pps && (this.initSegmentDispatched = !0)
                            }
                            this.initSegmentDispatched && (i = (0,
                            u.c)(i, t.data))
                        }
                        if (this.handleCodecChange(l.details) && this.segment(),
                        Object.assign(this.videoMetadata, l),
                        Object.assign(this.currentVideoTrack, this.videoMetadata),
                        !i.byteLength)
                            return;
                        const d = Object.assign(Object.assign({}, t), {
                            buffer: i.buffer,
                            dts: Math.floor(n / 90),
                            pts: Math.floor(n / 90)
                        });
                        this.currentVideoTrack.track.sampleIndex++,
                        a && this.currentVideoTrack.track.keyframes.push(this.currentVideoTrack.track.sampleIndex),
                        this.recordVideo(d);
                        break
                    }
                case r.z.AUDIO_G711A:
                    this.audioMetadata.codec = r.d.ALAW,
                    this.recordAudio(e, this.currentVideoTrack.track.sampleIndex);
                    break;
                case r.z.AUDIO_WAV:
                    this.configAudioMetadata(e),
                    this.recordAudio(e, this.currentVideoTrack.track.sampleIndex);
                    break;
                default:
                    this.logger.warn(`Unrecognized media type ${i}`)
                }
            }
            isEqual(t, e) {
                return typeof t == typeof e && ("object" != typeof t || null == t || null == e ? t === e : Object.keys(t).every((i => {
                    const n = i;
                    return this.isEqual(t[n], e[n])
                }
                )))
            }
            handleCodecChange(t) {
                const {details: e} = this.videoMetadata;
                let i = !1;
                return t && e ? (g.forEach((n => {
                    const r = n;
                    this.isEqual(t[r], e[r]) || (i = !0)
                }
                )),
                i) : i
            }
            configAudioMetadata(t) {
                const e = t.slice(0, 44)
                  , i = e.slice(22, 24);
                this.audioMetadata.channelCount = new Uint16Array(i)[0];
                const n = e.slice(24, 28);
                this.audioMetadata.sampleRate = new Uint32Array(n)[0],
                this.audioMetadata.codec = r.d.WAV
            }
            recordVideo(t) {
                if (!this.prevVideoSample)
                    return void (this.prevVideoSample = t);
                const e = this.prevVideoSample;
                let i = t.pts - e.pts;
                const {track: {sampleOffset: n, sampleSize: r}} = this.currentVideoTrack;
                i > 4 * this.spsFrameDuration && -1 !== this.currentVideoStartPTS && (this.gapDuration += i - this.spsFrameDuration,
                i = this.spsFrameDuration,
                this.logger.log(`Frame duration: ${this.spsFrameDuration}, Gap duration: ${this.gapDuration}`)),
                -1 === this.currentVideoStartPTS && (e.isNextVirtualKeyframe ? e.isVirtualKeyframe && (this.currentVideoStartPTS = e.pts) : this.currentVideoStartPTS = e.pts),
                e.isKeyframe && e.isNextVirtualKeyframe ? n.push({
                    sampleDelta: 0,
                    sampleCount: 1
                }) : n.length && n[n.length - 1].sampleDelta === i ? (n[n.length - 1].sampleCount++,
                this.audioSampleDuration += i) : (n.push({
                    sampleDelta: i,
                    sampleCount: 1
                }),
                this.audioSampleDuration += i),
                this.currentVideoTrack.track.duration = e.pts - this.currentVideoStartPTS - this.gapDuration,
                r.push(e.buffer.byteLength),
                this.currentVideoTrack.data.push(new Uint8Array(e.buffer)),
                this.currentVideoTrack.length += e.buffer.byteLength,
                this.prevVideoSample = t,
                this.emitProgress({
                    duration: this.totalDuration + this.tracks[0].track.duration,
                    pts: e.pts,
                    done: !1
                })
            }
            recordAudio(t, e) {
                const {track: {sampleOffset: i, sampleSize: n}} = this.currentAudioTrack
                  , o = this.audioMetadata.codec === r.d.WAV ? t.slice(44) : t
                  , s = this.audioSampleDuration;
                i.length && i[i.length - 1].sampleDelta === s ? i[i.length - 1].sampleCount++ : i.push({
                    sampleDelta: s,
                    sampleCount: 1
                }),
                n.push(o.byteLength),
                this.currentAudioTrack.data.push(new Uint8Array(o)),
                this.currentVideoTrack.length += o.byteLength,
                this.currentAudioTrack.track.sampleIndex = e,
                this.audioSampleDuration = 0
            }
            generateChunk(t) {
                let e = t + 8;
                this.tracks.filter((t => t.track.type === n.CO.VIDEO)).forEach((t => {
                    const {chunkOffset: i, sampleToChunk: n, sampleSize: r} = t.track;
                    n.push({
                        firstChunk: 1,
                        samplesPerChunk: 1,
                        sampleDesc: 1
                    });
                    for (let t = 0; t < r.length; t++)
                        i.push(e),
                        e += r[t]
                }
                ));
                const {sampleSize: i, chunkOffset: r} = this.currentAudioTrack.track;
                for (let t = 0; t < i.length; t++)
                    r.push(e),
                    e += i[t]
            }
            generateVideoMoov(t, e) {
                const {keyframes: i} = t
                  , {details: r, sps: a, pps: l, vps: c} = this.videoMetadata;
                if (!a || !l || !r)
                    return this.logger.error("SPS or PPS or video meta not found."),
                    t;
                if (Object.assign(t, {
                    id: this.trackId++,
                    type: n.CO.VIDEO,
                    codec: r.codec_mimetype,
                    timescale: e.timescale,
                    codecWidth: r.codec_size.width,
                    codecHeight: r.codec_size.height,
                    presentWidth: r.present_size.width,
                    presentHeight: r.present_size.height,
                    profile: "profile_string"in r ? r.profile_string : "",
                    level: r.level_string,
                    bitDepth: r.bit_depth,
                    chromaFormat: r.chroma_format,
                    sarRatio: r.sar_ratio,
                    frameRate: r.frame_rate,
                    keyframeCount: i.length,
                    keyframeIndex: i,
                    creationTime: e.creationTime
                }),
                c) {
                    const e = c.data.subarray(4)
                      , i = a.data.subarray(4)
                      , n = l.data.subarray(4)
                      , o = new s.L5(e,i,n,r);
                    t.hvcc = o.getData()
                } else {
                    const e = a.data.subarray(4)
                      , i = l.data.subarray(4)
                      , n = new o.JQ(e,i,r);
                    t.avcc = n.getData()
                }
                return t
            }
            generateAudioMoov(t, e) {
                const {sampleOffset: i, sampleSize: o, chunkOffset: s} = t
                  , a = Object.assign(t, this.audioMetadata);
                return a.id = this.trackId++,
                a.type = n.CO.AUDIO,
                a.codec = r.d.ALAW,
                a.timescale = e.timescale,
                a.duration = e.duration,
                a.sampleOffset = i,
                a.sampleToChunk = [{
                    firstChunk: 1,
                    samplesPerChunk: 1,
                    sampleDesc: 1
                }],
                a.sampleSize = o,
                a.chunkOffset = s,
                a
            }
            generateMoovBox() {
                const t = {
                    nextTrackId: 1,
                    timescale: m,
                    duration: this.tracks.reduce(( (t, e) => t + (e.track.type === n.CO.VIDEO ? e.track.duration : 0)), 0),
                    creationTime: Math.floor(((new Date).getTime() - new Date("1904-01-01 00:00:00").getTime()) / 1e3),
                    videoTracks: [],
                    audioTracks: []
                };
                this.tracks.forEach((e => {
                    switch (e.track.type) {
                    case n.CO.VIDEO:
                        t.videoTracks.push(this.generateVideoMoov(e.track, t));
                        break;
                    case n.CO.AUDIO:
                        t.audioTracks.push(this.generateAudioMoov(e.track, t))
                    }
                }
                )),
                t.nextTrackId = this.trackId,
                this.moovBox = a.Z.moov(t)
            }
        }
        e.Z = _
    },
    65499: function(t, e, i) {
        "use strict";
        i.d(e, {
            Qr: function() {
                return l
            },
            wH: function() {
                return n
            }
        });
        var n, r = i(86490), o = i(52180), s = i(49871);
        !function(t) {
            t.download = "download",
            t.progress = "recorder-progress",
            t.startCallback = "startCallback"
        }(n || (n = {}));
        class a extends o.P {
            constructor(...t) {
                super(t[0].baseConfig),
                this.callback = null,
                this.worker = new Worker(new URL(i.p + i.u(8708),i.b),{
                    name: "recorder.worker",
                    type: void 0
                }),
                this.worker.postMessage({
                    init: t
                }),
                this.worker.onmessage = t => {
                    Object.keys(t.data).forEach((e => {
                        const i = e;
                        switch (i) {
                        case n.download:
                            this.download(t.data[i]);
                            break;
                        case n.progress:
                            this.transformerEmitter.emit(r.K7.RECORDER_PROGRESS, t.data[i]);
                            break;
                        case n.startCallback:
                            this.callback && this.callback(t.data[i])
                        }
                    }
                    ))
                }
            }
            destroy() {
                this.worker.terminate()
            }
            cache(...t) {
                this.worker.postMessage({
                    cache: t
                })
            }
            start(...t) {
                this.callback = t[0] || null,
                this.worker.postMessage({
                    start: []
                })
            }
            stop(...t) {
                this.worker.postMessage({
                    stop: t
                })
            }
            download({data: t, filename: e}) {
                const i = document.createElement("a")
                  , n = new Blob([t])
                  , r = window.URL.createObjectURL(n);
                i.style.display = "none",
                i.href = r,
                i.download = e || "media - " + (new Date).getTime() + ".mp4",
                document.body.appendChild(i),
                i.click(),
                i.remove()
            }
        }
        const l = ({isWorker: t, options: e}) => t ? new a(...e) : new s.Z(...e)
    },
    52180: function(t, e, i) {
        "use strict";
        i.d(e, {
            P: function() {
                return r
            }
        });
        var n = i(26700);
        class r extends n.KG {
            constructor(t) {
                super(t),
                this.id = t.id
            }
            get transformerEmitter() {
                const t = this.id;
                return r.emitter[t] || (r.emitter[t] = this.emitter),
                r.emitter[t]
            }
            destroy() {
                delete r.emitter[this.id]
            }
            static clear() {
                r.emitter = {}
            }
        }
        r.emitter = {}
    },
    34805: function(t, e, i) {
        "use strict";
        i.d(e, {
            _: function() {
                return r
            },
            c: function() {
                return n
            }
        });
        const n = (t, e) => {
            const i = new Uint8Array(t.byteLength + e.byteLength);
            return i.set(t, 0),
            i.set(e, t.byteLength),
            i
        }
          , r = (t, e, i) => String.fromCharCode.apply(null, Array.from(new Uint8Array(t,e,i)))
    },
    80309: function(t, e, i) {
        "use strict";
        i.d(e, {
            Gc: function() {
                return s
            },
            Gm: function() {
                return o
            },
            Mb: function() {
                return l
            },
            Oq: function() {
                return r
            },
            QZ: function() {
                return a
            }
        });
        const n = t => `${t}`.padStart(2, "0")
          , r = t => {
            const e = t.match(/\r\n{.+?}\r\n/g);
            return (null == e ? void 0 : e.map((t => {
                const e = t.slice(2, t.length - 2);
                return JSON.parse(e)
            }
            ))) || []
        }
          , o = (t, e) => (Object.keys(e).forEach((i => {
            const n = i;
            "object" != typeof t[n] || "object" != typeof e[n] || Array.isArray(e[n]) ? t[n] = e[n] : t[n] = o(t[n], e[n])
        }
        )),
        t)
          , s = (t, e) => {
            let i = null
              , n = null;
            return (...r) => {
                n && clearTimeout(n),
                n = setTimeout(( () => {
                    t(...r)
                }
                ), e),
                i || (t(...r),
                clearTimeout(n),
                i = setTimeout(( () => {
                    i = null
                }
                ), e))
            }
        }
          , a = (t="", e="") => {
            const i = new Date;
            return `${t}_${`${i.getFullYear()}${n(i.getMonth() + 1)}${n(i.getDate())}`}${`${n(i.getHours())}${n(i.getMinutes())}${n(i.getSeconds())}`}_ ${i.getMilliseconds()}${e}`
        }
          , l = (t, e) => {
            let i, n;
            const r = t.offsetWidth
              , o = t.offsetHeight;
            return r / o >= e ? (n = o,
            i = o * e) : (i = r,
            n = r / e),
            {
                width: i,
                height: n
            }
        }
    },
    26700: function(t, e, i) {
        "use strict";
        i.d(e, {
            KG: function() {
                return n.K
            },
            in: function() {
                return r.i
            }
        });
        var n = i(7706)
          , r = i(39092)
    },
    39092: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return o
            },
            i: function() {
                return n
            }
        });
        var n, r = i(25108);
        !function(t) {
            t[t.None = 0] = "None",
            t[t.Error = 1] = "Error",
            t[t.Warn = 2] = "Warn",
            t[t.Info = 3] = "Info"
        }(n || (n = {}));
        class o {
            constructor({name: t, level: e}) {
                this.level = n.Warn,
                this.logger = r,
                this.name = "",
                this.name = t,
                e && (this.level = e)
            }
            log(...t) {
                this.level > 2 && this.logger.log(this.getLog(...t))
            }
            warn(...t) {
                this.level > 1 && this.logger.warn(this.getLog(...t))
            }
            error(...t) {
                this.level > 0 && this.logger.error(this.getLog(...t))
            }
            getLog(...t) {
                let e = "";
                return 1 === t.length ? e = JSON.stringify(t[0]) : t.length > 1 && t.forEach((t => {
                    e += `\n- ${JSON.stringify(t)}`
                }
                )),
                `[${this.name}] => ${e}`
            }
            setLevel(t) {
                this.level = t
            }
        }
    },
    86612: function(t, e, i) {
        "use strict";
        function n(t, e, i) {
            if (null !== t)
                for (var r, o, s, a, l, c, h, u, d = 0, f = 0, p = t.type, m = "FeatureCollection" === p, g = "Feature" === p, _ = m ? t.features.length : 1, y = 0; y < _; y++) {
                    l = (u = !!(h = m ? t.features[y].geometry : g ? t.geometry : t) && "GeometryCollection" === h.type) ? h.geometries.length : 1;
                    for (var v = 0; v < l; v++) {
                        var x = 0
                          , b = 0;
                        if (null !== (a = u ? h.geometries[v] : h)) {
                            c = a.coordinates;
                            var w = a.type;
                            switch (d = !i || "Polygon" !== w && "MultiPolygon" !== w ? 0 : 1,
                            w) {
                            case null:
                                break;
                            case "Point":
                                if (!1 === e(c, f, y, x, b))
                                    return !1;
                                f++,
                                x++;
                                break;
                            case "LineString":
                            case "MultiPoint":
                                for (r = 0; r < c.length; r++) {
                                    if (!1 === e(c[r], f, y, x, b))
                                        return !1;
                                    f++,
                                    "MultiPoint" === w && x++
                                }
                                "LineString" === w && x++;
                                break;
                            case "Polygon":
                            case "MultiLineString":
                                for (r = 0; r < c.length; r++) {
                                    for (o = 0; o < c[r].length - d; o++) {
                                        if (!1 === e(c[r][o], f, y, x, b))
                                            return !1;
                                        f++
                                    }
                                    "MultiLineString" === w && x++,
                                    "Polygon" === w && b++
                                }
                                "Polygon" === w && x++;
                                break;
                            case "MultiPolygon":
                                for (r = 0; r < c.length; r++) {
                                    for (b = 0,
                                    o = 0; o < c[r].length; o++) {
                                        for (s = 0; s < c[r][o].length - d; s++) {
                                            if (!1 === e(c[r][o][s], f, y, x, b))
                                                return !1;
                                            f++
                                        }
                                        b++
                                    }
                                    x++
                                }
                                break;
                            case "GeometryCollection":
                                for (r = 0; r < a.geometries.length; r++)
                                    if (!1 === n(a.geometries[r], e, i))
                                        return !1;
                                break;
                            default:
                                throw new Error("Unknown Geometry Type")
                            }
                        }
                    }
                }
        }
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var r = function(t, e={}) {
            if (null != t.bbox && !0 !== e.recompute)
                return t.bbox;
            const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            return n(t, (t => {
                i[0] > t[0] && (i[0] = t[0]),
                i[1] > t[1] && (i[1] = t[1]),
                i[2] < t[0] && (i[2] = t[0]),
                i[3] < t[1] && (i[3] = t[1])
            }
            )),
            i
        }
    },
    66309: function(t, e, i) {
        "use strict";
        i.d(e, {
            Iyq: function() {
                return B
            },
            JLS: function() {
                return d
            },
            O1d: function() {
                return S
            },
            O9U: function() {
                return M
            },
            S1d: function() {
                return P
            },
            jYR: function() {
                return k
            },
            jsu: function() {
                return s
            },
            v1O: function() {
                return A
            }
        });
        var n = i(41218)
          , r = i(2262)
          , o = i(66252);
        i(25108);
        function s(t, e, i) {
            let s;
            s = (0,
            r.dq)(i) ? {
                evaluating: i
            } : i || {};
            const {lazy: a=!1, evaluating: l, shallow: c=!1, onError: h=n.ZT} = s
              , u = (0,
            r.iH)(!a)
              , d = c ? (0,
            r.XI)(e) : (0,
            r.iH)(e);
            let f = 0;
            return (0,
            o.m0)((async e => {
                if (!u.value)
                    return;
                f++;
                const i = f;
                let n = !1;
                l && Promise.resolve().then(( () => {
                    l.value = !0
                }
                ));
                try {
                    const r = await t((t => {
                        e(( () => {
                            l && (l.value = !1),
                            n || t()
                        }
                        ))
                    }
                    ));
                    i === f && (d.value = r)
                } catch (t) {
                    h(t)
                } finally {
                    l && i === f && (l.value = !1),
                    n = !0
                }
            }
            )),
            a ? (0,
            o.Fl)(( () => (u.value = !0,
            d.value))) : d
        }
        function a(t) {
            var e;
            const i = (0,
            n.Ly)(t);
            return null != (e = null == i ? void 0 : i.$el) ? e : i
        }
        const l = n.C5 ? window : void 0
          , c = n.C5 ? window.document : void 0;
        n.C5 && window.navigator,
        n.C5 && window.location;
        function h(...t) {
            let e, i, r, s;
            if ((0,
            n.HD)(t[0]) || Array.isArray(t[0]) ? ([i,r,s] = t,
            e = l) : [e,i,r,s] = t,
            !e)
                return n.ZT;
            Array.isArray(i) || (i = [i]),
            Array.isArray(r) || (r = [r]);
            const c = []
              , h = () => {
                c.forEach((t => t())),
                c.length = 0
            }
              , u = (0,
            o.YP)(( () => [a(e), (0,
            n.Ly)(s)]), ( ([t,e]) => {
                h(),
                t && c.push(...i.flatMap((i => r.map((n => ( (t, e, i, n) => (t.addEventListener(e, i, n),
                () => t.removeEventListener(e, i, n)))(t, i, n, e))))))
            }
            ), {
                immediate: !0,
                flush: "post"
            })
              , d = () => {
                u(),
                h()
            }
            ;
            return (0,
            n.IY)(d),
            d
        }
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        const u = t => "function" == typeof t ? t : "string" == typeof t ? e => e.key === t : Array.isArray(t) ? e => t.includes(e.key) : () => !0;
        function d(...t) {
            let e, i, n = {};
            3 === t.length ? (e = t[0],
            i = t[1],
            n = t[2]) : 2 === t.length ? "object" == typeof t[1] ? (e = !0,
            i = t[0],
            n = t[1]) : (e = t[0],
            i = t[1]) : (e = !0,
            i = t[0]);
            const {target: r=l, eventName: o="keydown", passive: s=!1} = n
              , a = u(e);
            return h(r, o, (t => {
                a(t) && i(t)
            }
            ), s)
        }
        function f(t, e=!1) {
            const i = (0,
            r.iH)()
              , o = () => i.value = Boolean(t());
            return o(),
            (0,
            n.u7)(o, e),
            i
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        const p = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}
          , m = "__vueuse_ssr_handlers__";
        p[m] = p[m] || {};
        p[m];
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        var g = Object.defineProperty
          , _ = Object.defineProperties
          , y = Object.getOwnPropertyDescriptors
          , v = Object.getOwnPropertySymbols
          , x = Object.prototype.hasOwnProperty
          , b = Object.prototype.propertyIsEnumerable
          , w = (t, e, i) => e in t ? g(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: i
        }) : t[e] = i
          , E = (t, e) => {
            for (var i in e || (e = {}))
                x.call(e, i) && w(t, i, e[i]);
            if (v)
                for (var i of v(e))
                    b.call(e, i) && w(t, i, e[i]);
            return t
        }
          , T = (t, e) => _(t, y(e));
        function S(t, e={}) {
            var i, s, a;
            const c = null != (i = e.draggingElement) ? i : l
              , u = null != (s = e.handle) ? s : t
              , d = (0,
            r.iH)(null != (a = (0,
            n.Ly)(e.initialValue)) ? a : {
                x: 0,
                y: 0
            })
              , f = (0,
            r.iH)()
              , p = t => !e.pointerTypes || e.pointerTypes.includes(t.pointerType)
              , m = t => {
                (0,
                n.Ly)(e.preventDefault) && t.preventDefault(),
                (0,
                n.Ly)(e.stopPropagation) && t.stopPropagation()
            }
              , g = i => {
                var r;
                if (!p(i))
                    return;
                if ((0,
                n.Ly)(e.exact) && i.target !== (0,
                n.Ly)(t))
                    return;
                const o = (0,
                n.Ly)(t).getBoundingClientRect()
                  , s = {
                    x: i.clientX - o.left,
                    y: i.clientY - o.top
                };
                !1 !== (null == (r = e.onStart) ? void 0 : r.call(e, s, i)) && (f.value = s,
                m(i))
            }
              , _ = t => {
                var i;
                p(t) && f.value && (d.value = {
                    x: t.clientX - f.value.x,
                    y: t.clientY - f.value.y
                },
                null == (i = e.onMove) || i.call(e, d.value, t),
                m(t))
            }
              , y = t => {
                var i;
                p(t) && f.value && (f.value = void 0,
                null == (i = e.onEnd) || i.call(e, d.value, t),
                m(t))
            }
            ;
            return n.C5 && (h(u, "pointerdown", g, !0),
            h(c, "pointermove", _, !0),
            h(c, "pointerup", y, !0)),
            T(E({}, (0,
            n.BK)(d)), {
                position: d,
                isDragging: (0,
                o.Fl)(( () => !!f.value)),
                style: (0,
                o.Fl)(( () => `left:${d.value.x}px;top:${d.value.y}px;`))
            })
        }
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        const C = new Map;
        function A(t) {
            const e = (0,
            r.nZ)();
            function i(i) {
                var r;
                const o = C.get(t) || [];
                o.push(i),
                C.set(t, o);
                const s = () => n(i);
                return null == (r = null == e ? void 0 : e.cleanups) || r.push(s),
                s
            }
            function n(e) {
                const i = C.get(t);
                if (!i)
                    return;
                const n = i.indexOf(e);
                n > -1 && i.splice(n, 1),
                i.length || C.delete(t)
            }
            return {
                on: i,
                once: function(t) {
                    return i((function e(...i) {
                        n(e),
                        t(...i)
                    }
                    ))
                },
                off: n,
                emit: function(e, i) {
                    var n;
                    null == (n = C.get(t)) || n.forEach((t => t(e, i)))
                },
                reset: function() {
                    C.delete(t)
                }
            }
        }
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        const I = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"], ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"], ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"], ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]];
        function M(t, e={}) {
            const {document: i=c, autoExit: o=!1} = e
              , s = t || (null == i ? void 0 : i.querySelector("html"))
              , l = (0,
            r.iH)(!1);
            let u = I[0];
            const d = f(( () => {
                if (!i)
                    return !1;
                for (const t of I)
                    if (t[1]in i)
                        return u = t,
                        !0;
                return !1
            }
            ))
              , [p,m,g,,_] = u;
            async function y() {
                d.value && ((null == i ? void 0 : i[g]) && await i[m](),
                l.value = !1)
            }
            async function v() {
                if (!d.value)
                    return;
                await y();
                const t = a(s);
                t && (await t[p](),
                l.value = !0)
            }
            return i && h(i, _, ( () => {
                l.value = !!(null == i ? void 0 : i[g])
            }
            ), !1),
            o && (0,
            n.IY)(y),
            {
                isSupported: d,
                isFullscreen: l,
                enter: v,
                exit: y,
                toggle: async function() {
                    l.value ? await y() : await v()
                }
            }
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        function P(t, e, i={}) {
            const {root: r, rootMargin: s="0px", threshold: c=.1, window: h=l} = i
              , u = f(( () => h && "IntersectionObserver"in h));
            let d = n.ZT;
            const p = u.value ? (0,
            o.YP)(( () => ({
                el: a(t),
                root: a(r)
            })), ( ({el: t, root: i}) => {
                if (d(),
                !t)
                    return;
                const r = new IntersectionObserver(e,{
                    root: i,
                    rootMargin: s,
                    threshold: c
                });
                r.observe(t),
                d = () => {
                    r.disconnect(),
                    d = n.ZT
                }
            }
            ), {
                immediate: !0,
                flush: "post"
            }) : n.ZT
              , m = () => {
                d(),
                p()
            }
            ;
            return (0,
            n.IY)(m),
            {
                isSupported: u,
                stop: m
            }
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        function k(t, e={}) {
            const {handleOutside: i=!0, window: n=l} = e
              , {x: s, y: c, sourceType: u} = function(t={}) {
                const {type: e="page", touch: i=!0, resetOnTouchEnds: n=!1, initialValue: o={
                    x: 0,
                    y: 0
                }, window: s=l, eventFilter: a} = t
                  , c = (0,
                r.iH)(o.x)
                  , u = (0,
                r.iH)(o.y)
                  , d = (0,
                r.iH)(null)
                  , f = t => {
                    "page" === e ? (c.value = t.pageX,
                    u.value = t.pageY) : "client" === e ? (c.value = t.clientX,
                    u.value = t.clientY) : "movement" === e && (c.value = t.movementX,
                    u.value = t.movementY),
                    d.value = "mouse"
                }
                  , p = () => {
                    c.value = o.x,
                    u.value = o.y
                }
                  , m = t => {
                    if (t.touches.length > 0) {
                        const i = t.touches[0];
                        "page" === e ? (c.value = i.pageX,
                        u.value = i.pageY) : "client" === e && (c.value = i.clientX,
                        u.value = i.clientY),
                        d.value = "touch"
                    }
                }
                  , g = t => void 0 === a ? f(t) : a(( () => f(t)), {})
                  , _ = t => void 0 === a ? m(t) : a(( () => m(t)), {});
                return s && (h(s, "mousemove", g, {
                    passive: !0
                }),
                h(s, "dragover", g, {
                    passive: !0
                }),
                i && "movement" !== e && (h(s, "touchstart", _, {
                    passive: !0
                }),
                h(s, "touchmove", _, {
                    passive: !0
                }),
                n && h(s, "touchend", p, {
                    passive: !0
                }))),
                {
                    x: c,
                    y: u,
                    sourceType: d
                }
            }(e)
              , d = (0,
            r.iH)(null != t ? t : null == n ? void 0 : n.document.body)
              , f = (0,
            r.iH)(0)
              , p = (0,
            r.iH)(0)
              , m = (0,
            r.iH)(0)
              , g = (0,
            r.iH)(0)
              , _ = (0,
            r.iH)(0)
              , y = (0,
            r.iH)(0)
              , v = (0,
            r.iH)(!0);
            let x = () => {}
            ;
            return n && (x = (0,
            o.YP)([d, s, c], ( () => {
                const t = a(d);
                if (!t)
                    return;
                const {left: e, top: r, width: o, height: l} = t.getBoundingClientRect();
                m.value = e + n.pageXOffset,
                g.value = r + n.pageYOffset,
                _.value = l,
                y.value = o;
                const h = s.value - m.value
                  , u = c.value - g.value;
                v.value = 0 === o || 0 === l || h < 0 || u < 0 || h > o || u > l,
                !i && v.value || (f.value = h,
                p.value = u)
            }
            ), {
                immediate: !0
            }),
            h(document, "mouseleave", ( () => {
                v.value = !0
            }
            ))),
            {
                x: s,
                y: c,
                sourceType: u,
                elementX: f,
                elementY: p,
                elementPositionX: m,
                elementPositionY: g,
                elementHeight: _,
                elementWidth: y,
                isOutside: v,
                stop: x
            }
        }
        var O = Object.getOwnPropertySymbols
          , R = Object.prototype.hasOwnProperty
          , D = Object.prototype.propertyIsEnumerable
          , L = (t, e) => {
            var i = {};
            for (var n in t)
                R.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
            if (null != t && O)
                for (var n of O(t))
                    e.indexOf(n) < 0 && D.call(t, n) && (i[n] = t[n]);
            return i
        }
        ;
        function B(t, e, i={}) {
            const r = i
              , {window: s=l} = r
              , c = L(r, ["window"]);
            let h;
            const u = f(( () => s && "MutationObserver"in s))
              , d = () => {
                h && (h.disconnect(),
                h = void 0)
            }
              , p = (0,
            o.YP)(( () => a(t)), (t => {
                d(),
                u.value && s && t && (h = new MutationObserver(e),
                h.observe(t, c))
            }
            ), {
                immediate: !0
            })
              , m = () => {
                d(),
                p()
            }
            ;
            return (0,
            n.IY)(m),
            {
                isSupported: u,
                stop: m
            }
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        var z, F;
        (F = z || (z = {})).UP = "UP",
        F.RIGHT = "RIGHT",
        F.DOWN = "DOWN",
        F.LEFT = "LEFT",
        F.NONE = "NONE";
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        var N = Object.defineProperty
          , j = Object.getOwnPropertySymbols
          , U = Object.prototype.hasOwnProperty
          , V = Object.prototype.propertyIsEnumerable
          , G = (t, e, i) => e in t ? N(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: i
        }) : t[e] = i;
        ( (t, e) => {
            for (var i in e || (e = {}))
                U.call(e, i) && G(t, i, e[i]);
            if (j)
                for (var i of j(e))
                    V.call(e, i) && G(t, i, e[i])
        }
        )({
            linear: n.yR
        }, {
            easeInSine: [.12, 0, .39, 0],
            easeOutSine: [.61, 1, .88, 1],
            easeInOutSine: [.37, 0, .63, 1],
            easeInQuad: [.11, 0, .5, 0],
            easeOutQuad: [.5, 1, .89, 1],
            easeInOutQuad: [.45, 0, .55, 1],
            easeInCubic: [.32, 0, .67, 0],
            easeOutCubic: [.33, 1, .68, 1],
            easeInOutCubic: [.65, 0, .35, 1],
            easeInQuart: [.5, 0, .75, 0],
            easeOutQuart: [.25, 1, .5, 1],
            easeInOutQuart: [.76, 0, .24, 1],
            easeInQuint: [.64, 0, .78, 0],
            easeOutQuint: [.22, 1, .36, 1],
            easeInOutQuint: [.83, 0, .17, 1],
            easeInExpo: [.7, 0, .84, 0],
            easeOutExpo: [.16, 1, .3, 1],
            easeInOutExpo: [.87, 0, .13, 1],
            easeInCirc: [.55, 0, 1, .45],
            easeOutCirc: [0, .55, .45, 1],
            easeInOutCirc: [.85, 0, .15, 1],
            easeInBack: [.36, 0, .66, -.56],
            easeOutBack: [.34, 1.56, .64, 1],
            easeInOutBack: [.68, -.6, .32, 1.6]
        })
    },
    41218: function(t, e, i) {
        "use strict";
        i.d(e, {
            yR: function() {
                return m
            },
            C5: function() {
                return a
            },
            HD: function() {
                return c
            },
            ZT: function() {
                return h
            },
            Ly: function() {
                return u
            },
            t8: function() {
                return x
            },
            YL: function() {
                return _
            },
            BK: function() {
                return P
            },
            u7: function() {
                return k
            },
            IY: function() {
                return g
            },
            DI: function() {
                return y
            },
            Zv: function() {
                return O
            },
            vA: function() {
                return v
            },
            f8: function() {
                return R
            }
        });
        var n = i(2262)
          , r = !1;
        var o, s = i(66252);
        i(25108),
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        const a = "undefined" != typeof window
          , l = (Object.prototype.toString,
        t => "function" == typeof t)
          , c = t => "string" == typeof t
          , h = () => {}
        ;
        a && (null == (o = null == window ? void 0 : window.navigator) ? void 0 : o.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
        function u(t) {
            return "function" == typeof t ? t() : (0,
            n.SU)(t)
        }
        function d(t, e) {
            return function(...i) {
                return new Promise(( (n, r) => {
                    Promise.resolve(t(( () => e.apply(this, i)), {
                        fn: e,
                        thisArg: this,
                        args: i
                    })).then(n).catch(r)
                }
                ))
            }
        }
        function f(t, e={}) {
            let i, n, r = h;
            const o = t => {
                clearTimeout(t),
                r(),
                r = h
            }
            ;
            return s => {
                const a = u(t)
                  , l = u(e.maxWait);
                return i && o(i),
                a <= 0 || void 0 !== l && l <= 0 ? (n && (o(n),
                n = null),
                Promise.resolve(s())) : new Promise(( (t, c) => {
                    r = e.rejectOnCancel ? c : t,
                    l && !n && (n = setTimeout(( () => {
                        i && o(i),
                        n = null,
                        t(s())
                    }
                    ), l)),
                    i = setTimeout(( () => {
                        n && o(n),
                        n = null,
                        t(s())
                    }
                    ), a)
                }
                ))
            }
        }
        function p(t, e=!0, i=!0, n=!1) {
            let r, o, s = 0, a = !0, l = h;
            const c = () => {
                r && (clearTimeout(r),
                r = void 0,
                l(),
                l = h)
            }
            ;
            return h => {
                const d = u(t)
                  , f = Date.now() - s
                  , p = () => o = h();
                return c(),
                d <= 0 ? (s = Date.now(),
                p()) : (f > d && (i || !a) ? (s = Date.now(),
                p()) : e && (o = new Promise(( (t, e) => {
                    l = n ? e : t,
                    r = setTimeout(( () => {
                        s = Date.now(),
                        a = !0,
                        t(p()),
                        c()
                    }
                    ), Math.max(0, d - f))
                }
                ))),
                i || r || (r = setTimeout(( () => a = !0), d)),
                a = !1,
                o)
            }
        }
        function m(t) {
            return t
        }
        function g(t) {
            return !!(0,
            n.nZ)() && ((0,
            n.EB)(t),
            !0)
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        function _(t) {
            if (!(0,
            n.dq)(t))
                return (0,
                n.qj)(t);
            const e = new Proxy({},{
                get(e, i, r) {
                    return (0,
                    n.SU)(Reflect.get(t.value, i, r))
                },
                set(e, i, r) {
                    return (0,
                    n.dq)(t.value[i]) && !(0,
                    n.dq)(r) ? t.value[i].value = r : t.value[i] = r,
                    !0
                },
                deleteProperty(e, i) {
                    return Reflect.deleteProperty(t.value, i)
                },
                has(e, i) {
                    return Reflect.has(t.value, i)
                },
                ownKeys() {
                    return Object.keys(t.value)
                },
                getOwnPropertyDescriptor() {
                    return {
                        enumerable: !0,
                        configurable: !0
                    }
                }
            });
            return (0,
            n.qj)(e)
        }
        function y(t, e=200, i={}) {
            return d(f(e, i), t)
        }
        function v(t, e=200, i=!1, n=!0, r=!1) {
            return d(p(e, i, n, r), t)
        }
        function x(...t) {
            if (2 === t.length) {
                const [e,i] = t;
                e.value = i
            }
            if (3 === t.length)
                if (r)
                    !function(t, e, i) {
                        Array.isArray(t) ? (t.length = Math.max(t.length, e),
                        t.splice(e, 1, i)) : t[e] = i
                    }(...t);
                else {
                    const [e,i,n] = t;
                    e[i] = n
                }
        }
        var b = Object.defineProperty
          , w = Object.defineProperties
          , E = Object.getOwnPropertyDescriptors
          , T = Object.getOwnPropertySymbols
          , S = Object.prototype.hasOwnProperty
          , C = Object.prototype.propertyIsEnumerable
          , A = (t, e, i) => e in t ? b(t, e, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: i
        }) : t[e] = i
          , I = (t, e) => {
            for (var i in e || (e = {}))
                S.call(e, i) && A(t, i, e[i]);
            if (T)
                for (var i of T(e))
                    C.call(e, i) && A(t, i, e[i]);
            return t
        }
          , M = (t, e) => w(t, E(e));
        function P(t) {
            if (!(0,
            n.dq)(t))
                return (0,
                n.BK)(t);
            const e = Array.isArray(t.value) ? new Array(t.value.length) : {};
            for (const i in t.value)
                e[i] = (0,
                n.ZM)(( () => ({
                    get() {
                        return t.value[i]
                    },
                    set(e) {
                        if (Array.isArray(t.value)) {
                            const n = [...t.value];
                            n[i] = e,
                            t.value = n
                        } else {
                            const n = M(I({}, t.value), {
                                [i]: e
                            });
                            Object.setPrototypeOf(n, t.value),
                            t.value = n
                        }
                    }
                })));
            return e
        }
        function k(t, e=!0) {
            (0,
            s.FN)() ? (0,
            s.bv)(t) : e ? t() : (0,
            s.Y3)(t)
        }
        function O(t, e=1e3, i={}) {
            const {immediate: r=!0, immediateCallback: o=!1} = i;
            let c = null;
            const h = (0,
            n.iH)(!1);
            function d() {
                c && (clearInterval(c),
                c = null)
            }
            function f() {
                h.value = !1,
                d()
            }
            function p() {
                const i = u(e);
                i <= 0 || (h.value = !0,
                o && t(),
                d(),
                c = setInterval(t, i))
            }
            if (r && a && p(),
            (0,
            n.dq)(e) || l(e)) {
                g((0,
                s.YP)(e, ( () => {
                    h.value && a && p()
                }
                )))
            }
            return g(f),
            {
                isActive: h,
                pause: f,
                resume: p
            }
        }
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        function R(t, e, i) {
            const n = (0,
            s.YP)(t, ( (...t) => ((0,
            s.Y3)(( () => n())),
            e(...t))), i)
        }
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable;
        Object.defineProperty,
        Object.defineProperties,
        Object.getOwnPropertyDescriptors,
        Object.getOwnPropertySymbols,
        Object.prototype.hasOwnProperty,
        Object.prototype.propertyIsEnumerable
    },
    6154: function(t, e, i) {
        "use strict";
        function n(t, e) {
            return function() {
                return t.apply(e, arguments)
            }
        }
        i.d(e, {
            Z: function() {
                return Vt
            }
        });
        const {toString: r} = Object.prototype
          , {getPrototypeOf: o} = Object
          , s = (a = Object.create(null),
        t => {
            const e = r.call(t);
            return a[e] || (a[e] = e.slice(8, -1).toLowerCase())
        }
        );
        var a;
        const l = t => (t = t.toLowerCase(),
        e => s(e) === t)
          , c = t => e => typeof e === t
          , {isArray: h} = Array
          , u = c("undefined");
        const d = l("ArrayBuffer");
        const f = c("string")
          , p = c("function")
          , m = c("number")
          , g = t => null !== t && "object" == typeof t
          , _ = t => {
            if ("object" !== s(t))
                return !1;
            const e = o(t);
            return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || Symbol.toStringTag in t || Symbol.iterator in t)
        }
          , y = l("Date")
          , v = l("File")
          , x = l("Blob")
          , b = l("FileList")
          , w = l("URLSearchParams");
        function E(t, e, {allOwnKeys: i=!1}={}) {
            if (null == t)
                return;
            let n, r;
            if ("object" != typeof t && (t = [t]),
            h(t))
                for (n = 0,
                r = t.length; n < r; n++)
                    e.call(null, t[n], n, t);
            else {
                const r = i ? Object.getOwnPropertyNames(t) : Object.keys(t)
                  , o = r.length;
                let s;
                for (n = 0; n < o; n++)
                    s = r[n],
                    e.call(null, t[s], s, t)
            }
        }
        function T(t, e) {
            e = e.toLowerCase();
            const i = Object.keys(t);
            let n, r = i.length;
            for (; r-- > 0; )
                if (n = i[r],
                e === n.toLowerCase())
                    return n;
            return null
        }
        const S = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global
          , C = t => !u(t) && t !== S;
        const A = (I = "undefined" != typeof Uint8Array && o(Uint8Array),
        t => I && t instanceof I);
        var I;
        const M = l("HTMLFormElement")
          , P = ( ({hasOwnProperty: t}) => (e, i) => t.call(e, i))(Object.prototype)
          , k = l("RegExp")
          , O = (t, e) => {
            const i = Object.getOwnPropertyDescriptors(t)
              , n = {};
            E(i, ( (i, r) => {
                !1 !== e(i, r, t) && (n[r] = i)
            }
            )),
            Object.defineProperties(t, n)
        }
          , R = "abcdefghijklmnopqrstuvwxyz"
          , D = "0123456789"
          , L = {
            DIGIT: D,
            ALPHA: R,
            ALPHA_DIGIT: R + R.toUpperCase() + D
        };
        const B = l("AsyncFunction");
        var z = {
            isArray: h,
            isArrayBuffer: d,
            isBuffer: function(t) {
                return null !== t && !u(t) && null !== t.constructor && !u(t.constructor) && p(t.constructor.isBuffer) && t.constructor.isBuffer(t)
            },
            isFormData: t => {
                let e;
                return t && ("function" == typeof FormData && t instanceof FormData || p(t.append) && ("formdata" === (e = s(t)) || "object" === e && p(t.toString) && "[object FormData]" === t.toString()))
            }
            ,
            isArrayBufferView: function(t) {
                let e;
                return e = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && d(t.buffer),
                e
            },
            isString: f,
            isNumber: m,
            isBoolean: t => !0 === t || !1 === t,
            isObject: g,
            isPlainObject: _,
            isUndefined: u,
            isDate: y,
            isFile: v,
            isBlob: x,
            isRegExp: k,
            isFunction: p,
            isStream: t => g(t) && p(t.pipe),
            isURLSearchParams: w,
            isTypedArray: A,
            isFileList: b,
            forEach: E,
            merge: function t() {
                const {caseless: e} = C(this) && this || {}
                  , i = {}
                  , n = (n, r) => {
                    const o = e && T(i, r) || r;
                    _(i[o]) && _(n) ? i[o] = t(i[o], n) : _(n) ? i[o] = t({}, n) : h(n) ? i[o] = n.slice() : i[o] = n
                }
                ;
                for (let t = 0, e = arguments.length; t < e; t++)
                    arguments[t] && E(arguments[t], n);
                return i
            },
            extend: (t, e, i, {allOwnKeys: r}={}) => (E(e, ( (e, r) => {
                i && p(e) ? t[r] = n(e, i) : t[r] = e
            }
            ), {
                allOwnKeys: r
            }),
            t),
            trim: t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
            stripBOM: t => (65279 === t.charCodeAt(0) && (t = t.slice(1)),
            t),
            inherits: (t, e, i, n) => {
                t.prototype = Object.create(e.prototype, n),
                t.prototype.constructor = t,
                Object.defineProperty(t, "super", {
                    value: e.prototype
                }),
                i && Object.assign(t.prototype, i)
            }
            ,
            toFlatObject: (t, e, i, n) => {
                let r, s, a;
                const l = {};
                if (e = e || {},
                null == t)
                    return e;
                do {
                    for (r = Object.getOwnPropertyNames(t),
                    s = r.length; s-- > 0; )
                        a = r[s],
                        n && !n(a, t, e) || l[a] || (e[a] = t[a],
                        l[a] = !0);
                    t = !1 !== i && o(t)
                } while (t && (!i || i(t, e)) && t !== Object.prototype);
                return e
            }
            ,
            kindOf: s,
            kindOfTest: l,
            endsWith: (t, e, i) => {
                t = String(t),
                (void 0 === i || i > t.length) && (i = t.length),
                i -= e.length;
                const n = t.indexOf(e, i);
                return -1 !== n && n === i
            }
            ,
            toArray: t => {
                if (!t)
                    return null;
                if (h(t))
                    return t;
                let e = t.length;
                if (!m(e))
                    return null;
                const i = new Array(e);
                for (; e-- > 0; )
                    i[e] = t[e];
                return i
            }
            ,
            forEachEntry: (t, e) => {
                const i = (t && t[Symbol.iterator]).call(t);
                let n;
                for (; (n = i.next()) && !n.done; ) {
                    const i = n.value;
                    e.call(t, i[0], i[1])
                }
            }
            ,
            matchAll: (t, e) => {
                let i;
                const n = [];
                for (; null !== (i = t.exec(e)); )
                    n.push(i);
                return n
            }
            ,
            isHTMLForm: M,
            hasOwnProperty: P,
            hasOwnProp: P,
            reduceDescriptors: O,
            freezeMethods: t => {
                O(t, ( (e, i) => {
                    if (p(t) && -1 !== ["arguments", "caller", "callee"].indexOf(i))
                        return !1;
                    const n = t[i];
                    p(n) && (e.enumerable = !1,
                    "writable"in e ? e.writable = !1 : e.set || (e.set = () => {
                        throw Error("Can not rewrite read-only method '" + i + "'")
                    }
                    ))
                }
                ))
            }
            ,
            toObjectSet: (t, e) => {
                const i = {}
                  , n = t => {
                    t.forEach((t => {
                        i[t] = !0
                    }
                    ))
                }
                ;
                return h(t) ? n(t) : n(String(t).split(e)),
                i
            }
            ,
            toCamelCase: t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, (function(t, e, i) {
                return e.toUpperCase() + i
            }
            )),
            noop: () => {}
            ,
            toFiniteNumber: (t, e) => (t = +t,
            Number.isFinite(t) ? t : e),
            findKey: T,
            global: S,
            isContextDefined: C,
            ALPHABET: L,
            generateString: (t=16, e=L.ALPHA_DIGIT) => {
                let i = "";
                const {length: n} = e;
                for (; t--; )
                    i += e[Math.random() * n | 0];
                return i
            }
            ,
            isSpecCompliantForm: function(t) {
                return !!(t && p(t.append) && "FormData" === t[Symbol.toStringTag] && t[Symbol.iterator])
            },
            toJSONObject: t => {
                const e = new Array(10)
                  , i = (t, n) => {
                    if (g(t)) {
                        if (e.indexOf(t) >= 0)
                            return;
                        if (!("toJSON"in t)) {
                            e[n] = t;
                            const r = h(t) ? [] : {};
                            return E(t, ( (t, e) => {
                                const o = i(t, n + 1);
                                !u(o) && (r[e] = o)
                            }
                            )),
                            e[n] = void 0,
                            r
                        }
                    }
                    return t
                }
                ;
                return i(t, 0)
            }
            ,
            isAsyncFn: B,
            isThenable: t => t && (g(t) || p(t)) && p(t.then) && p(t.catch)
        };
        function F(t, e, i, n, r) {
            Error.call(this),
            Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack,
            this.message = t,
            this.name = "AxiosError",
            e && (this.code = e),
            i && (this.config = i),
            n && (this.request = n),
            r && (this.response = r)
        }
        z.inherits(F, Error, {
            toJSON: function() {
                return {
                    message: this.message,
                    name: this.name,
                    description: this.description,
                    number: this.number,
                    fileName: this.fileName,
                    lineNumber: this.lineNumber,
                    columnNumber: this.columnNumber,
                    stack: this.stack,
                    config: z.toJSONObject(this.config),
                    code: this.code,
                    status: this.response && this.response.status ? this.response.status : null
                }
            }
        });
        const N = F.prototype
          , j = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((t => {
            j[t] = {
                value: t
            }
        }
        )),
        Object.defineProperties(F, j),
        Object.defineProperty(N, "isAxiosError", {
            value: !0
        }),
        F.from = (t, e, i, n, r, o) => {
            const s = Object.create(N);
            return z.toFlatObject(t, s, (function(t) {
                return t !== Error.prototype
            }
            ), (t => "isAxiosError" !== t)),
            F.call(s, t.message, e, i, n, r),
            s.cause = t,
            s.name = t.name,
            o && Object.assign(s, o),
            s
        }
        ;
        var U = F
          , V = i(48764).lW;
        function G(t) {
            return z.isPlainObject(t) || z.isArray(t)
        }
        function Z(t) {
            return z.endsWith(t, "[]") ? t.slice(0, -2) : t
        }
        function q(t, e, i) {
            return t ? t.concat(e).map((function(t, e) {
                return t = Z(t),
                !i && e ? "[" + t + "]" : t
            }
            )).join(i ? "." : "") : e
        }
        const W = z.toFlatObject(z, {}, null, (function(t) {
            return /^is[A-Z]/.test(t)
        }
        ));
        var H = function(t, e, i) {
            if (!z.isObject(t))
                throw new TypeError("target must be an object");
            e = e || new FormData;
            const n = (i = z.toFlatObject(i, {
                metaTokens: !0,
                dots: !1,
                indexes: !1
            }, !1, (function(t, e) {
                return !z.isUndefined(e[t])
            }
            ))).metaTokens
              , r = i.visitor || c
              , o = i.dots
              , s = i.indexes
              , a = (i.Blob || "undefined" != typeof Blob && Blob) && z.isSpecCompliantForm(e);
            if (!z.isFunction(r))
                throw new TypeError("visitor must be a function");
            function l(t) {
                if (null === t)
                    return "";
                if (z.isDate(t))
                    return t.toISOString();
                if (!a && z.isBlob(t))
                    throw new U("Blob is not supported. Use a Buffer instead.");
                return z.isArrayBuffer(t) || z.isTypedArray(t) ? a && "function" == typeof Blob ? new Blob([t]) : V.from(t) : t
            }
            function c(t, i, r) {
                let a = t;
                if (t && !r && "object" == typeof t)
                    if (z.endsWith(i, "{}"))
                        i = n ? i : i.slice(0, -2),
                        t = JSON.stringify(t);
                    else if (z.isArray(t) && function(t) {
                        return z.isArray(t) && !t.some(G)
                    }(t) || (z.isFileList(t) || z.endsWith(i, "[]")) && (a = z.toArray(t)))
                        return i = Z(i),
                        a.forEach((function(t, n) {
                            !z.isUndefined(t) && null !== t && e.append(!0 === s ? q([i], n, o) : null === s ? i : i + "[]", l(t))
                        }
                        )),
                        !1;
                return !!G(t) || (e.append(q(r, i, o), l(t)),
                !1)
            }
            const h = []
              , u = Object.assign(W, {
                defaultVisitor: c,
                convertValue: l,
                isVisitable: G
            });
            if (!z.isObject(t))
                throw new TypeError("data must be an object");
            return function t(i, n) {
                if (!z.isUndefined(i)) {
                    if (-1 !== h.indexOf(i))
                        throw Error("Circular reference detected in " + n.join("."));
                    h.push(i),
                    z.forEach(i, (function(i, o) {
                        !0 === (!(z.isUndefined(i) || null === i) && r.call(e, i, z.isString(o) ? o.trim() : o, n, u)) && t(i, n ? n.concat(o) : [o])
                    }
                    )),
                    h.pop()
                }
            }(t),
            e
        };
        function $(t) {
            const e = {
                "!": "%21",
                "'": "%27",
                "(": "%28",
                ")": "%29",
                "~": "%7E",
                "%20": "+",
                "%00": "\0"
            };
            return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, (function(t) {
                return e[t]
            }
            ))
        }
        function X(t, e) {
            this._pairs = [],
            t && H(t, this, e)
        }
        const Y = X.prototype;
        Y.append = function(t, e) {
            this._pairs.push([t, e])
        }
        ,
        Y.toString = function(t) {
            const e = t ? function(e) {
                return t.call(this, e, $)
            }
            : $;
            return this._pairs.map((function(t) {
                return e(t[0]) + "=" + e(t[1])
            }
            ), "").join("&")
        }
        ;
        var K = X;
        function J(t) {
            return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }
        function Q(t, e, i) {
            if (!e)
                return t;
            const n = i && i.encode || J
              , r = i && i.serialize;
            let o;
            if (o = r ? r(e, i) : z.isURLSearchParams(e) ? e.toString() : new K(e,i).toString(n),
            o) {
                const e = t.indexOf("#");
                -1 !== e && (t = t.slice(0, e)),
                t += (-1 === t.indexOf("?") ? "?" : "&") + o
            }
            return t
        }
        var tt = class {
            constructor() {
                this.handlers = []
            }
            use(t, e, i) {
                return this.handlers.push({
                    fulfilled: t,
                    rejected: e,
                    synchronous: !!i && i.synchronous,
                    runWhen: i ? i.runWhen : null
                }),
                this.handlers.length - 1
            }
            eject(t) {
                this.handlers[t] && (this.handlers[t] = null)
            }
            clear() {
                this.handlers && (this.handlers = [])
            }
            forEach(t) {
                z.forEach(this.handlers, (function(e) {
                    null !== e && t(e)
                }
                ))
            }
        }
          , et = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
        };
        var it = {
            isBrowser: !0,
            classes: {
                URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : K,
                FormData: "undefined" != typeof FormData ? FormData : null,
                Blob: "undefined" != typeof Blob ? Blob : null
            },
            isStandardBrowserEnv: ( () => {
                let t;
                return ("undefined" == typeof navigator || "ReactNative" !== (t = navigator.product) && "NativeScript" !== t && "NS" !== t) && ("undefined" != typeof window && "undefined" != typeof document)
            }
            )(),
            isStandardBrowserWebWorkerEnv: "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
            protocols: ["http", "https", "file", "blob", "url", "data"]
        };
        var nt = function(t) {
            function e(t, i, n, r) {
                let o = t[r++];
                const s = Number.isFinite(+o)
                  , a = r >= t.length;
                if (o = !o && z.isArray(n) ? n.length : o,
                a)
                    return z.hasOwnProp(n, o) ? n[o] = [n[o], i] : n[o] = i,
                    !s;
                n[o] && z.isObject(n[o]) || (n[o] = []);
                return e(t, i, n[o], r) && z.isArray(n[o]) && (n[o] = function(t) {
                    const e = {}
                      , i = Object.keys(t);
                    let n;
                    const r = i.length;
                    let o;
                    for (n = 0; n < r; n++)
                        o = i[n],
                        e[o] = t[o];
                    return e
                }(n[o])),
                !s
            }
            if (z.isFormData(t) && z.isFunction(t.entries)) {
                const i = {};
                return z.forEachEntry(t, ( (t, n) => {
                    e(function(t) {
                        return z.matchAll(/\w+|\[(\w*)]/g, t).map((t => "[]" === t[0] ? "" : t[1] || t[0]))
                    }(t), n, i, 0)
                }
                )),
                i
            }
            return null
        };
        const rt = {
            "Content-Type": void 0
        };
        const ot = {
            transitional: et,
            adapter: ["xhr", "http"],
            transformRequest: [function(t, e) {
                const i = e.getContentType() || ""
                  , n = i.indexOf("application/json") > -1
                  , r = z.isObject(t);
                r && z.isHTMLForm(t) && (t = new FormData(t));
                if (z.isFormData(t))
                    return n && n ? JSON.stringify(nt(t)) : t;
                if (z.isArrayBuffer(t) || z.isBuffer(t) || z.isStream(t) || z.isFile(t) || z.isBlob(t))
                    return t;
                if (z.isArrayBufferView(t))
                    return t.buffer;
                if (z.isURLSearchParams(t))
                    return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
                    t.toString();
                let o;
                if (r) {
                    if (i.indexOf("application/x-www-form-urlencoded") > -1)
                        return function(t, e) {
                            return H(t, new it.classes.URLSearchParams, Object.assign({
                                visitor: function(t, e, i, n) {
                                    return it.isNode && z.isBuffer(t) ? (this.append(e, t.toString("base64")),
                                    !1) : n.defaultVisitor.apply(this, arguments)
                                }
                            }, e))
                        }(t, this.formSerializer).toString();
                    if ((o = z.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
                        const e = this.env && this.env.FormData;
                        return H(o ? {
                            "files[]": t
                        } : t, e && new e, this.formSerializer)
                    }
                }
                return r || n ? (e.setContentType("application/json", !1),
                function(t, e, i) {
                    if (z.isString(t))
                        try {
                            return (e || JSON.parse)(t),
                            z.trim(t)
                        } catch (t) {
                            if ("SyntaxError" !== t.name)
                                throw t
                        }
                    return (i || JSON.stringify)(t)
                }(t)) : t
            }
            ],
            transformResponse: [function(t) {
                const e = this.transitional || ot.transitional
                  , i = e && e.forcedJSONParsing
                  , n = "json" === this.responseType;
                if (t && z.isString(t) && (i && !this.responseType || n)) {
                    const i = !(e && e.silentJSONParsing) && n;
                    try {
                        return JSON.parse(t)
                    } catch (t) {
                        if (i) {
                            if ("SyntaxError" === t.name)
                                throw U.from(t, U.ERR_BAD_RESPONSE, this, null, this.response);
                            throw t
                        }
                    }
                }
                return t
            }
            ],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            maxBodyLength: -1,
            env: {
                FormData: it.classes.FormData,
                Blob: it.classes.Blob
            },
            validateStatus: function(t) {
                return t >= 200 && t < 300
            },
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                }
            }
        };
        z.forEach(["delete", "get", "head"], (function(t) {
            ot.headers[t] = {}
        }
        )),
        z.forEach(["post", "put", "patch"], (function(t) {
            ot.headers[t] = z.merge(rt)
        }
        ));
        var st = ot;
        const at = z.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
        const lt = Symbol("internals");
        function ct(t) {
            return t && String(t).trim().toLowerCase()
        }
        function ht(t) {
            return !1 === t || null == t ? t : z.isArray(t) ? t.map(ht) : String(t)
        }
        function ut(t, e, i, n, r) {
            return z.isFunction(n) ? n.call(this, e, i) : (r && (e = i),
            z.isString(e) ? z.isString(n) ? -1 !== e.indexOf(n) : z.isRegExp(n) ? n.test(e) : void 0 : void 0)
        }
        class dt {
            constructor(t) {
                t && this.set(t)
            }
            set(t, e, i) {
                const n = this;
                function r(t, e, i) {
                    const r = ct(e);
                    if (!r)
                        throw new Error("header name must be a non-empty string");
                    const o = z.findKey(n, r);
                    (!o || void 0 === n[o] || !0 === i || void 0 === i && !1 !== n[o]) && (n[o || e] = ht(t))
                }
                const o = (t, e) => z.forEach(t, ( (t, i) => r(t, i, e)));
                return z.isPlainObject(t) || t instanceof this.constructor ? o(t, e) : z.isString(t) && (t = t.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()) ? o((t => {
                    const e = {};
                    let i, n, r;
                    return t && t.split("\n").forEach((function(t) {
                        r = t.indexOf(":"),
                        i = t.substring(0, r).trim().toLowerCase(),
                        n = t.substring(r + 1).trim(),
                        !i || e[i] && at[i] || ("set-cookie" === i ? e[i] ? e[i].push(n) : e[i] = [n] : e[i] = e[i] ? e[i] + ", " + n : n)
                    }
                    )),
                    e
                }
                )(t), e) : null != t && r(e, t, i),
                this
            }
            get(t, e) {
                if (t = ct(t)) {
                    const i = z.findKey(this, t);
                    if (i) {
                        const t = this[i];
                        if (!e)
                            return t;
                        if (!0 === e)
                            return function(t) {
                                const e = Object.create(null)
                                  , i = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                                let n;
                                for (; n = i.exec(t); )
                                    e[n[1]] = n[2];
                                return e
                            }(t);
                        if (z.isFunction(e))
                            return e.call(this, t, i);
                        if (z.isRegExp(e))
                            return e.exec(t);
                        throw new TypeError("parser must be boolean|regexp|function")
                    }
                }
            }
            has(t, e) {
                if (t = ct(t)) {
                    const i = z.findKey(this, t);
                    return !(!i || void 0 === this[i] || e && !ut(0, this[i], i, e))
                }
                return !1
            }
            delete(t, e) {
                const i = this;
                let n = !1;
                function r(t) {
                    if (t = ct(t)) {
                        const r = z.findKey(i, t);
                        !r || e && !ut(0, i[r], r, e) || (delete i[r],
                        n = !0)
                    }
                }
                return z.isArray(t) ? t.forEach(r) : r(t),
                n
            }
            clear(t) {
                const e = Object.keys(this);
                let i = e.length
                  , n = !1;
                for (; i--; ) {
                    const r = e[i];
                    t && !ut(0, this[r], r, t, !0) || (delete this[r],
                    n = !0)
                }
                return n
            }
            normalize(t) {
                const e = this
                  , i = {};
                return z.forEach(this, ( (n, r) => {
                    const o = z.findKey(i, r);
                    if (o)
                        return e[o] = ht(n),
                        void delete e[r];
                    const s = t ? function(t) {
                        return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ( (t, e, i) => e.toUpperCase() + i))
                    }(r) : String(r).trim();
                    s !== r && delete e[r],
                    e[s] = ht(n),
                    i[s] = !0
                }
                )),
                this
            }
            concat(...t) {
                return this.constructor.concat(this, ...t)
            }
            toJSON(t) {
                const e = Object.create(null);
                return z.forEach(this, ( (i, n) => {
                    null != i && !1 !== i && (e[n] = t && z.isArray(i) ? i.join(", ") : i)
                }
                )),
                e
            }
            [Symbol.iterator]() {
                return Object.entries(this.toJSON())[Symbol.iterator]()
            }
            toString() {
                return Object.entries(this.toJSON()).map(( ([t,e]) => t + ": " + e)).join("\n")
            }
            get[Symbol.toStringTag]() {
                return "AxiosHeaders"
            }
            static from(t) {
                return t instanceof this ? t : new this(t)
            }
            static concat(t, ...e) {
                const i = new this(t);
                return e.forEach((t => i.set(t))),
                i
            }
            static accessor(t) {
                const e = (this[lt] = this[lt] = {
                    accessors: {}
                }).accessors
                  , i = this.prototype;
                function n(t) {
                    const n = ct(t);
                    e[n] || (!function(t, e) {
                        const i = z.toCamelCase(" " + e);
                        ["get", "set", "has"].forEach((n => {
                            Object.defineProperty(t, n + i, {
                                value: function(t, i, r) {
                                    return this[n].call(this, e, t, i, r)
                                },
                                configurable: !0
                            })
                        }
                        ))
                    }(i, t),
                    e[n] = !0)
                }
                return z.isArray(t) ? t.forEach(n) : n(t),
                this
            }
        }
        dt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]),
        z.freezeMethods(dt.prototype),
        z.freezeMethods(dt);
        var ft = dt;
        function pt(t, e) {
            const i = this || st
              , n = e || i
              , r = ft.from(n.headers);
            let o = n.data;
            return z.forEach(t, (function(t) {
                o = t.call(i, o, r.normalize(), e ? e.status : void 0)
            }
            )),
            r.normalize(),
            o
        }
        function mt(t) {
            return !(!t || !t.__CANCEL__)
        }
        function gt(t, e, i) {
            U.call(this, null == t ? "canceled" : t, U.ERR_CANCELED, e, i),
            this.name = "CanceledError"
        }
        z.inherits(gt, U, {
            __CANCEL__: !0
        });
        var _t = gt;
        var yt = it.isStandardBrowserEnv ? {
            write: function(t, e, i, n, r, o) {
                const s = [];
                s.push(t + "=" + encodeURIComponent(e)),
                z.isNumber(i) && s.push("expires=" + new Date(i).toGMTString()),
                z.isString(n) && s.push("path=" + n),
                z.isString(r) && s.push("domain=" + r),
                !0 === o && s.push("secure"),
                document.cookie = s.join("; ")
            },
            read: function(t) {
                const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
                return e ? decodeURIComponent(e[3]) : null
            },
            remove: function(t) {
                this.write(t, "", Date.now() - 864e5)
            }
        } : {
            write: function() {},
            read: function() {
                return null
            },
            remove: function() {}
        };
        function vt(t, e) {
            return t && !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) ? function(t, e) {
                return e ? t.replace(/\/+$/, "") + "/" + e.replace(/^\/+/, "") : t
            }(t, e) : e
        }
        var xt = it.isStandardBrowserEnv ? function() {
            const t = /(msie|trident)/i.test(navigator.userAgent)
              , e = document.createElement("a");
            let i;
            function n(i) {
                let n = i;
                return t && (e.setAttribute("href", n),
                n = e.href),
                e.setAttribute("href", n),
                {
                    href: e.href,
                    protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
                    host: e.host,
                    search: e.search ? e.search.replace(/^\?/, "") : "",
                    hash: e.hash ? e.hash.replace(/^#/, "") : "",
                    hostname: e.hostname,
                    port: e.port,
                    pathname: "/" === e.pathname.charAt(0) ? e.pathname : "/" + e.pathname
                }
            }
            return i = n(window.location.href),
            function(t) {
                const e = z.isString(t) ? n(t) : t;
                return e.protocol === i.protocol && e.host === i.host
            }
        }() : function() {
            return !0
        }
        ;
        var bt = function(t, e) {
            t = t || 10;
            const i = new Array(t)
              , n = new Array(t);
            let r, o = 0, s = 0;
            return e = void 0 !== e ? e : 1e3,
            function(a) {
                const l = Date.now()
                  , c = n[s];
                r || (r = l),
                i[o] = a,
                n[o] = l;
                let h = s
                  , u = 0;
                for (; h !== o; )
                    u += i[h++],
                    h %= t;
                if (o = (o + 1) % t,
                o === s && (s = (s + 1) % t),
                l - r < e)
                    return;
                const d = c && l - c;
                return d ? Math.round(1e3 * u / d) : void 0
            }
        };
        function wt(t, e) {
            let i = 0;
            const n = bt(50, 250);
            return r => {
                const o = r.loaded
                  , s = r.lengthComputable ? r.total : void 0
                  , a = o - i
                  , l = n(a);
                i = o;
                const c = {
                    loaded: o,
                    total: s,
                    progress: s ? o / s : void 0,
                    bytes: a,
                    rate: l || void 0,
                    estimated: l && s && o <= s ? (s - o) / l : void 0,
                    event: r
                };
                c[e ? "download" : "upload"] = !0,
                t(c)
            }
        }
        const Et = {
            http: null,
            xhr: "undefined" != typeof XMLHttpRequest && function(t) {
                return new Promise((function(e, i) {
                    let n = t.data;
                    const r = ft.from(t.headers).normalize()
                      , o = t.responseType;
                    let s;
                    function a() {
                        t.cancelToken && t.cancelToken.unsubscribe(s),
                        t.signal && t.signal.removeEventListener("abort", s)
                    }
                    z.isFormData(n) && (it.isStandardBrowserEnv || it.isStandardBrowserWebWorkerEnv ? r.setContentType(!1) : r.setContentType("multipart/form-data;", !1));
                    let l = new XMLHttpRequest;
                    if (t.auth) {
                        const e = t.auth.username || ""
                          , i = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
                        r.set("Authorization", "Basic " + btoa(e + ":" + i))
                    }
                    const c = vt(t.baseURL, t.url);
                    function h() {
                        if (!l)
                            return;
                        const n = ft.from("getAllResponseHeaders"in l && l.getAllResponseHeaders());
                        !function(t, e, i) {
                            const n = i.config.validateStatus;
                            i.status && n && !n(i.status) ? e(new U("Request failed with status code " + i.status,[U.ERR_BAD_REQUEST, U.ERR_BAD_RESPONSE][Math.floor(i.status / 100) - 4],i.config,i.request,i)) : t(i)
                        }((function(t) {
                            e(t),
                            a()
                        }
                        ), (function(t) {
                            i(t),
                            a()
                        }
                        ), {
                            data: o && "text" !== o && "json" !== o ? l.response : l.responseText,
                            status: l.status,
                            statusText: l.statusText,
                            headers: n,
                            config: t,
                            request: l
                        }),
                        l = null
                    }
                    if (l.open(t.method.toUpperCase(), Q(c, t.params, t.paramsSerializer), !0),
                    l.timeout = t.timeout,
                    "onloadend"in l ? l.onloadend = h : l.onreadystatechange = function() {
                        l && 4 === l.readyState && (0 !== l.status || l.responseURL && 0 === l.responseURL.indexOf("file:")) && setTimeout(h)
                    }
                    ,
                    l.onabort = function() {
                        l && (i(new U("Request aborted",U.ECONNABORTED,t,l)),
                        l = null)
                    }
                    ,
                    l.onerror = function() {
                        i(new U("Network Error",U.ERR_NETWORK,t,l)),
                        l = null
                    }
                    ,
                    l.ontimeout = function() {
                        let e = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
                        const n = t.transitional || et;
                        t.timeoutErrorMessage && (e = t.timeoutErrorMessage),
                        i(new U(e,n.clarifyTimeoutError ? U.ETIMEDOUT : U.ECONNABORTED,t,l)),
                        l = null
                    }
                    ,
                    it.isStandardBrowserEnv) {
                        const e = (t.withCredentials || xt(c)) && t.xsrfCookieName && yt.read(t.xsrfCookieName);
                        e && r.set(t.xsrfHeaderName, e)
                    }
                    void 0 === n && r.setContentType(null),
                    "setRequestHeader"in l && z.forEach(r.toJSON(), (function(t, e) {
                        l.setRequestHeader(e, t)
                    }
                    )),
                    z.isUndefined(t.withCredentials) || (l.withCredentials = !!t.withCredentials),
                    o && "json" !== o && (l.responseType = t.responseType),
                    "function" == typeof t.onDownloadProgress && l.addEventListener("progress", wt(t.onDownloadProgress, !0)),
                    "function" == typeof t.onUploadProgress && l.upload && l.upload.addEventListener("progress", wt(t.onUploadProgress)),
                    (t.cancelToken || t.signal) && (s = e => {
                        l && (i(!e || e.type ? new _t(null,t,l) : e),
                        l.abort(),
                        l = null)
                    }
                    ,
                    t.cancelToken && t.cancelToken.subscribe(s),
                    t.signal && (t.signal.aborted ? s() : t.signal.addEventListener("abort", s)));
                    const u = function(t) {
                        const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                        return e && e[1] || ""
                    }(c);
                    u && -1 === it.protocols.indexOf(u) ? i(new U("Unsupported protocol " + u + ":",U.ERR_BAD_REQUEST,t)) : l.send(n || null)
                }
                ))
            }
        };
        z.forEach(Et, ( (t, e) => {
            if (t) {
                try {
                    Object.defineProperty(t, "name", {
                        value: e
                    })
                } catch (t) {}
                Object.defineProperty(t, "adapterName", {
                    value: e
                })
            }
        }
        ));
        var Tt = t => {
            t = z.isArray(t) ? t : [t];
            const {length: e} = t;
            let i, n;
            for (let r = 0; r < e && (i = t[r],
            !(n = z.isString(i) ? Et[i.toLowerCase()] : i)); r++)
                ;
            if (!n) {
                if (!1 === n)
                    throw new U(`Adapter ${i} is not supported by the environment`,"ERR_NOT_SUPPORT");
                throw new Error(z.hasOwnProp(Et, i) ? `Adapter '${i}' is not available in the build` : `Unknown adapter '${i}'`)
            }
            if (!z.isFunction(n))
                throw new TypeError("adapter is not a function");
            return n
        }
        ;
        function St(t) {
            if (t.cancelToken && t.cancelToken.throwIfRequested(),
            t.signal && t.signal.aborted)
                throw new _t(null,t)
        }
        function Ct(t) {
            St(t),
            t.headers = ft.from(t.headers),
            t.data = pt.call(t, t.transformRequest),
            -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1);
            return Tt(t.adapter || st.adapter)(t).then((function(e) {
                return St(t),
                e.data = pt.call(t, t.transformResponse, e),
                e.headers = ft.from(e.headers),
                e
            }
            ), (function(e) {
                return mt(e) || (St(t),
                e && e.response && (e.response.data = pt.call(t, t.transformResponse, e.response),
                e.response.headers = ft.from(e.response.headers))),
                Promise.reject(e)
            }
            ))
        }
        const At = t => t instanceof ft ? t.toJSON() : t;
        function It(t, e) {
            e = e || {};
            const i = {};
            function n(t, e, i) {
                return z.isPlainObject(t) && z.isPlainObject(e) ? z.merge.call({
                    caseless: i
                }, t, e) : z.isPlainObject(e) ? z.merge({}, e) : z.isArray(e) ? e.slice() : e
            }
            function r(t, e, i) {
                return z.isUndefined(e) ? z.isUndefined(t) ? void 0 : n(void 0, t, i) : n(t, e, i)
            }
            function o(t, e) {
                if (!z.isUndefined(e))
                    return n(void 0, e)
            }
            function s(t, e) {
                return z.isUndefined(e) ? z.isUndefined(t) ? void 0 : n(void 0, t) : n(void 0, e)
            }
            function a(i, r, o) {
                return o in e ? n(i, r) : o in t ? n(void 0, i) : void 0
            }
            const l = {
                url: o,
                method: o,
                data: o,
                baseURL: s,
                transformRequest: s,
                transformResponse: s,
                paramsSerializer: s,
                timeout: s,
                timeoutMessage: s,
                withCredentials: s,
                adapter: s,
                responseType: s,
                xsrfCookieName: s,
                xsrfHeaderName: s,
                onUploadProgress: s,
                onDownloadProgress: s,
                decompress: s,
                maxContentLength: s,
                maxBodyLength: s,
                beforeRedirect: s,
                transport: s,
                httpAgent: s,
                httpsAgent: s,
                cancelToken: s,
                socketPath: s,
                responseEncoding: s,
                validateStatus: a,
                headers: (t, e) => r(At(t), At(e), !0)
            };
            return z.forEach(Object.keys(Object.assign({}, t, e)), (function(n) {
                const o = l[n] || r
                  , s = o(t[n], e[n], n);
                z.isUndefined(s) && o !== a || (i[n] = s)
            }
            )),
            i
        }
        const Mt = "1.4.0";
        var Pt = i(25108);
        const kt = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach(( (t, e) => {
            kt[t] = function(i) {
                return typeof i === t || "a" + (e < 1 ? "n " : " ") + t
            }
        }
        ));
        const Ot = {};
        kt.transitional = function(t, e, i) {
            function n(t, e) {
                return "[Axios v1.4.0] Transitional option '" + t + "'" + e + (i ? ". " + i : "")
            }
            return (i, r, o) => {
                if (!1 === t)
                    throw new U(n(r, " has been removed" + (e ? " in " + e : "")),U.ERR_DEPRECATED);
                return e && !Ot[r] && (Ot[r] = !0,
                Pt.warn(n(r, " has been deprecated since v" + e + " and will be removed in the near future"))),
                !t || t(i, r, o)
            }
        }
        ;
        var Rt = {
            assertOptions: function(t, e, i) {
                if ("object" != typeof t)
                    throw new U("options must be an object",U.ERR_BAD_OPTION_VALUE);
                const n = Object.keys(t);
                let r = n.length;
                for (; r-- > 0; ) {
                    const o = n[r]
                      , s = e[o];
                    if (s) {
                        const e = t[o]
                          , i = void 0 === e || s(e, o, t);
                        if (!0 !== i)
                            throw new U("option " + o + " must be " + i,U.ERR_BAD_OPTION_VALUE)
                    } else if (!0 !== i)
                        throw new U("Unknown option " + o,U.ERR_BAD_OPTION)
                }
            },
            validators: kt
        };
        const Dt = Rt.validators;
        class Lt {
            constructor(t) {
                this.defaults = t,
                this.interceptors = {
                    request: new tt,
                    response: new tt
                }
            }
            request(t, e) {
                "string" == typeof t ? (e = e || {}).url = t : e = t || {},
                e = It(this.defaults, e);
                const {transitional: i, paramsSerializer: n, headers: r} = e;
                let o;
                void 0 !== i && Rt.assertOptions(i, {
                    silentJSONParsing: Dt.transitional(Dt.boolean),
                    forcedJSONParsing: Dt.transitional(Dt.boolean),
                    clarifyTimeoutError: Dt.transitional(Dt.boolean)
                }, !1),
                null != n && (z.isFunction(n) ? e.paramsSerializer = {
                    serialize: n
                } : Rt.assertOptions(n, {
                    encode: Dt.function,
                    serialize: Dt.function
                }, !0)),
                e.method = (e.method || this.defaults.method || "get").toLowerCase(),
                o = r && z.merge(r.common, r[e.method]),
                o && z.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (t => {
                    delete r[t]
                }
                )),
                e.headers = ft.concat(o, r);
                const s = [];
                let a = !0;
                this.interceptors.request.forEach((function(t) {
                    "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous,
                    s.unshift(t.fulfilled, t.rejected))
                }
                ));
                const l = [];
                let c;
                this.interceptors.response.forEach((function(t) {
                    l.push(t.fulfilled, t.rejected)
                }
                ));
                let h, u = 0;
                if (!a) {
                    const t = [Ct.bind(this), void 0];
                    for (t.unshift.apply(t, s),
                    t.push.apply(t, l),
                    h = t.length,
                    c = Promise.resolve(e); u < h; )
                        c = c.then(t[u++], t[u++]);
                    return c
                }
                h = s.length;
                let d = e;
                for (u = 0; u < h; ) {
                    const t = s[u++]
                      , e = s[u++];
                    try {
                        d = t(d)
                    } catch (t) {
                        e.call(this, t);
                        break
                    }
                }
                try {
                    c = Ct.call(this, d)
                } catch (t) {
                    return Promise.reject(t)
                }
                for (u = 0,
                h = l.length; u < h; )
                    c = c.then(l[u++], l[u++]);
                return c
            }
            getUri(t) {
                return Q(vt((t = It(this.defaults, t)).baseURL, t.url), t.params, t.paramsSerializer)
            }
        }
        z.forEach(["delete", "get", "head", "options"], (function(t) {
            Lt.prototype[t] = function(e, i) {
                return this.request(It(i || {}, {
                    method: t,
                    url: e,
                    data: (i || {}).data
                }))
            }
        }
        )),
        z.forEach(["post", "put", "patch"], (function(t) {
            function e(e) {
                return function(i, n, r) {
                    return this.request(It(r || {}, {
                        method: t,
                        headers: e ? {
                            "Content-Type": "multipart/form-data"
                        } : {},
                        url: i,
                        data: n
                    }))
                }
            }
            Lt.prototype[t] = e(),
            Lt.prototype[t + "Form"] = e(!0)
        }
        ));
        var Bt = Lt;
        class zt {
            constructor(t) {
                if ("function" != typeof t)
                    throw new TypeError("executor must be a function.");
                let e;
                this.promise = new Promise((function(t) {
                    e = t
                }
                ));
                const i = this;
                this.promise.then((t => {
                    if (!i._listeners)
                        return;
                    let e = i._listeners.length;
                    for (; e-- > 0; )
                        i._listeners[e](t);
                    i._listeners = null
                }
                )),
                this.promise.then = t => {
                    let e;
                    const n = new Promise((t => {
                        i.subscribe(t),
                        e = t
                    }
                    )).then(t);
                    return n.cancel = function() {
                        i.unsubscribe(e)
                    }
                    ,
                    n
                }
                ,
                t((function(t, n, r) {
                    i.reason || (i.reason = new _t(t,n,r),
                    e(i.reason))
                }
                ))
            }
            throwIfRequested() {
                if (this.reason)
                    throw this.reason
            }
            subscribe(t) {
                this.reason ? t(this.reason) : this._listeners ? this._listeners.push(t) : this._listeners = [t]
            }
            unsubscribe(t) {
                if (!this._listeners)
                    return;
                const e = this._listeners.indexOf(t);
                -1 !== e && this._listeners.splice(e, 1)
            }
            static source() {
                let t;
                return {
                    token: new zt((function(e) {
                        t = e
                    }
                    )),
                    cancel: t
                }
            }
        }
        var Ft = zt;
        const Nt = {
            Continue: 100,
            SwitchingProtocols: 101,
            Processing: 102,
            EarlyHints: 103,
            Ok: 200,
            Created: 201,
            Accepted: 202,
            NonAuthoritativeInformation: 203,
            NoContent: 204,
            ResetContent: 205,
            PartialContent: 206,
            MultiStatus: 207,
            AlreadyReported: 208,
            ImUsed: 226,
            MultipleChoices: 300,
            MovedPermanently: 301,
            Found: 302,
            SeeOther: 303,
            NotModified: 304,
            UseProxy: 305,
            Unused: 306,
            TemporaryRedirect: 307,
            PermanentRedirect: 308,
            BadRequest: 400,
            Unauthorized: 401,
            PaymentRequired: 402,
            Forbidden: 403,
            NotFound: 404,
            MethodNotAllowed: 405,
            NotAcceptable: 406,
            ProxyAuthenticationRequired: 407,
            RequestTimeout: 408,
            Conflict: 409,
            Gone: 410,
            LengthRequired: 411,
            PreconditionFailed: 412,
            PayloadTooLarge: 413,
            UriTooLong: 414,
            UnsupportedMediaType: 415,
            RangeNotSatisfiable: 416,
            ExpectationFailed: 417,
            ImATeapot: 418,
            MisdirectedRequest: 421,
            UnprocessableEntity: 422,
            Locked: 423,
            FailedDependency: 424,
            TooEarly: 425,
            UpgradeRequired: 426,
            PreconditionRequired: 428,
            TooManyRequests: 429,
            RequestHeaderFieldsTooLarge: 431,
            UnavailableForLegalReasons: 451,
            InternalServerError: 500,
            NotImplemented: 501,
            BadGateway: 502,
            ServiceUnavailable: 503,
            GatewayTimeout: 504,
            HttpVersionNotSupported: 505,
            VariantAlsoNegotiates: 506,
            InsufficientStorage: 507,
            LoopDetected: 508,
            NotExtended: 510,
            NetworkAuthenticationRequired: 511
        };
        Object.entries(Nt).forEach(( ([t,e]) => {
            Nt[e] = t
        }
        ));
        var jt = Nt;
        const Ut = function t(e) {
            const i = new Bt(e)
              , r = n(Bt.prototype.request, i);
            return z.extend(r, Bt.prototype, i, {
                allOwnKeys: !0
            }),
            z.extend(r, i, null, {
                allOwnKeys: !0
            }),
            r.create = function(i) {
                return t(It(e, i))
            }
            ,
            r
        }(st);
        Ut.Axios = Bt,
        Ut.CanceledError = _t,
        Ut.CancelToken = Ft,
        Ut.isCancel = mt,
        Ut.VERSION = Mt,
        Ut.toFormData = H,
        Ut.AxiosError = U,
        Ut.Cancel = Ut.CanceledError,
        Ut.all = function(t) {
            return Promise.all(t)
        }
        ,
        Ut.spread = function(t) {
            return function(e) {
                return t.apply(null, e)
            }
        }
        ,
        Ut.isAxiosError = function(t) {
            return z.isObject(t) && !0 === t.isAxiosError
        }
        ,
        Ut.mergeConfig = It,
        Ut.AxiosHeaders = ft,
        Ut.formToJSON = t => nt(z.isHTMLForm(t) ? new FormData(t) : t),
        Ut.HttpStatusCode = jt,
        Ut.default = Ut;
        var Vt = Ut
    },
    59391: function(t, e, i) {
        "use strict";
        function n(t) {
            return {
                all: t = t || new Map,
                on: function(e, i) {
                    var n = t.get(e);
                    n ? n.push(i) : t.set(e, [i])
                },
                off: function(e, i) {
                    var n = t.get(e);
                    n && (i ? n.splice(n.indexOf(i) >>> 0, 1) : t.set(e, []))
                },
                emit: function(e, i) {
                    var n = t.get(e);
                    n && n.slice().map((function(t) {
                        t(i)
                    }
                    )),
                    (n = t.get("*")) && n.slice().map((function(t) {
                        t(e, i)
                    }
                    ))
                }
            }
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    6813: function(t, e) {
        "use strict";
        const i = {
            1: "The view center is not defined",
            2: "The view resolution is not defined",
            3: "The view rotation is not defined",
            4: "`image` and `src` cannot be provided at the same time",
            5: "`imgSize` must be set when `image` is provided",
            7: "`format` must be set when `url` is set",
            8: "Unknown `serverType` configured",
            9: "`url` must be configured or set using `#setUrl()`",
            10: "The default `geometryFunction` can only handle `Point` geometries",
            11: "`options.featureTypes` must be an Array",
            12: "`options.geometryName` must also be provided when `options.bbox` is set",
            13: "Invalid corner",
            14: "Invalid color",
            15: "Tried to get a value for a key that does not exist in the cache",
            16: "Tried to set a value for a key that is used already",
            17: "`resolutions` must be sorted in descending order",
            18: "Either `origin` or `origins` must be configured, never both",
            19: "Number of `tileSizes` and `resolutions` must be equal",
            20: "Number of `origins` and `resolutions` must be equal",
            22: "Either `tileSize` or `tileSizes` must be configured, never both",
            24: "Invalid extent or geometry provided as `geometry`",
            25: "Cannot fit empty extent provided as `geometry`",
            26: "Features must have an id set",
            27: "Features must have an id set",
            28: '`renderMode` must be `"hybrid"` or `"vector"`',
            30: "The passed `feature` was already added to the source",
            31: "Tried to enqueue an `element` that was already added to the queue",
            32: "Transformation matrix cannot be inverted",
            33: "Invalid units",
            34: "Invalid geometry layout",
            36: "Unknown SRS type",
            37: "Unknown geometry type found",
            38: "`styleMapValue` has an unknown type",
            39: "Unknown geometry type",
            40: "Expected `feature` to have a geometry",
            41: "Expected an `ol/style/Style` or an array of `ol/style/Style.js`",
            42: "Question unknown, the answer is 42",
            43: "Expected `layers` to be an array or a `Collection`",
            47: "Expected `controls` to be an array or an `ol/Collection`",
            48: "Expected `interactions` to be an array or an `ol/Collection`",
            49: "Expected `overlays` to be an array or an `ol/Collection`",
            50: "`options.featureTypes` should be an Array",
            51: "Either `url` or `tileJSON` options must be provided",
            52: "Unknown `serverType` configured",
            53: "Unknown `tierSizeCalculation` configured",
            55: "The {-y} placeholder requires a tile grid with extent",
            56: "mapBrowserEvent must originate from a pointer event",
            57: "At least 2 conditions are required",
            59: "Invalid command found in the PBF",
            60: "Missing or invalid `size`",
            61: "Cannot determine IIIF Image API version from provided image information JSON",
            62: "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`",
            64: "Layer opacity must be a number",
            66: "`forEachFeatureAtCoordinate` cannot be used on a WebGL layer if the hit detection logic has not been enabled. This is done by providing adequate shaders using the `hitVertexShader` and `hitFragmentShader` properties of `WebGLPointsLayerRenderer`",
            67: "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both",
            68: "A VectorTile source can only be rendered if it has a projection compatible with the view projection",
            69: "`width` or `height` cannot be provided together with `scale`"
        };
        class n extends Error {
            constructor(t) {
                const e = i[t];
                super(e),
                this.code = t,
                this.name = "AssertionError",
                this.message = e
            }
        }
        e.Z = n
    },
    78714: function(t, e, i) {
        "use strict";
        var n = i(6813)
          , r = i(72971)
          , o = i(42071)
          , s = i(291);
        const a = "length";
        class l extends s.ZP {
            constructor(t, e, i) {
                super(t),
                this.element = e,
                this.index = i
            }
        }
        class c extends r.Z {
            constructor(t, e) {
                if (super(),
                this.on,
                this.once,
                this.un,
                e = e || {},
                this.unique_ = !!e.unique,
                this.array_ = t || [],
                this.unique_)
                    for (let t = 0, e = this.array_.length; t < e; ++t)
                        this.assertUnique_(this.array_[t], t);
                this.updateLength_()
            }
            clear() {
                for (; this.getLength() > 0; )
                    this.pop()
            }
            extend(t) {
                for (let e = 0, i = t.length; e < i; ++e)
                    this.push(t[e]);
                return this
            }
            forEach(t) {
                const e = this.array_;
                for (let i = 0, n = e.length; i < n; ++i)
                    t(e[i], i, e)
            }
            getArray() {
                return this.array_
            }
            item(t) {
                return this.array_[t]
            }
            getLength() {
                return this.get(a)
            }
            insertAt(t, e) {
                if (t < 0 || t > this.getLength())
                    throw new Error("Index out of bounds: " + t);
                this.unique_ && this.assertUnique_(e),
                this.array_.splice(t, 0, e),
                this.updateLength_(),
                this.dispatchEvent(new l(o.Z.ADD,e,t))
            }
            pop() {
                return this.removeAt(this.getLength() - 1)
            }
            push(t) {
                this.unique_ && this.assertUnique_(t);
                const e = this.getLength();
                return this.insertAt(e, t),
                this.getLength()
            }
            remove(t) {
                const e = this.array_;
                for (let i = 0, n = e.length; i < n; ++i)
                    if (e[i] === t)
                        return this.removeAt(i)
            }
            removeAt(t) {
                if (t < 0 || t >= this.getLength())
                    return;
                const e = this.array_[t];
                return this.array_.splice(t, 1),
                this.updateLength_(),
                this.dispatchEvent(new l(o.Z.REMOVE,e,t)),
                e
            }
            setAt(t, e) {
                if (t >= this.getLength())
                    return void this.insertAt(t, e);
                if (t < 0)
                    throw new Error("Index out of bounds: " + t);
                this.unique_ && this.assertUnique_(e, t);
                const i = this.array_[t];
                this.array_[t] = e,
                this.dispatchEvent(new l(o.Z.REMOVE,i,t)),
                this.dispatchEvent(new l(o.Z.ADD,e,t))
            }
            updateLength_() {
                this.set(a, this.array_.length)
            }
            assertUnique_(t, e) {
                for (let i = 0, r = this.array_.length; i < r; ++i)
                    if (this.array_[i] === t && i !== e)
                        throw new n.Z(58)
            }
        }
        e.Z = c
    },
    42071: function(t, e) {
        "use strict";
        e.Z = {
            ADD: "add",
            REMOVE: "remove"
        }
    },
    55431: function(t, e) {
        "use strict";
        e.Z = class {
            constructor() {
                this.disposed = !1
            }
            dispose() {
                this.disposed || (this.disposed = !0,
                this.disposeInternal())
            }
            disposeInternal() {}
        }
    },
    81090: function(t, e, i) {
        "use strict";
        var n = i(72971)
          , r = i(85487)
          , o = i(99515)
          , s = i(65818);
        class a extends n.Z {
            constructor(t) {
                if (super(),
                this.on,
                this.once,
                this.un,
                this.id_ = void 0,
                this.geometryName_ = "geometry",
                this.style_ = null,
                this.styleFunction_ = void 0,
                this.geometryChangeKey_ = null,
                this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
                t)
                    if ("function" == typeof t.getSimplifiedGeometry) {
                        const e = t;
                        this.setGeometry(e)
                    } else {
                        const e = t;
                        this.setProperties(e)
                    }
            }
            clone() {
                const t = new a(this.hasProperties() ? this.getProperties() : null);
                t.setGeometryName(this.getGeometryName());
                const e = this.getGeometry();
                e && t.setGeometry(e.clone());
                const i = this.getStyle();
                return i && t.setStyle(i),
                t
            }
            getGeometry() {
                return this.get(this.geometryName_)
            }
            getId() {
                return this.id_
            }
            getGeometryName() {
                return this.geometryName_
            }
            getStyle() {
                return this.style_
            }
            getStyleFunction() {
                return this.styleFunction_
            }
            handleGeometryChange_() {
                this.changed()
            }
            handleGeometryChanged_() {
                this.geometryChangeKey_ && ((0,
                s.bN)(this.geometryChangeKey_),
                this.geometryChangeKey_ = null);
                const t = this.getGeometry();
                t && (this.geometryChangeKey_ = (0,
                s.oL)(t, r.Z.CHANGE, this.handleGeometryChange_, this)),
                this.changed()
            }
            setGeometry(t) {
                this.set(this.geometryName_, t)
            }
            setStyle(t) {
                this.style_ = t,
                this.styleFunction_ = t ? function(t) {
                    if ("function" == typeof t)
                        return t;
                    let e;
                    if (Array.isArray(t))
                        e = t;
                    else {
                        (0,
                        o.h)("function" == typeof t.getZIndex, 41);
                        e = [t]
                    }
                    return function() {
                        return e
                    }
                }(t) : void 0,
                this.changed()
            }
            setId(t) {
                this.id_ = t,
                this.changed()
            }
            setGeometryName(t) {
                this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_),
                this.geometryName_ = t,
                this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
                this.handleGeometryChanged_()
            }
        }
        e.Z = a
    },
    18096: function(t, e, i) {
        "use strict";
        i.d(e, {
            K: function() {
                return h
            }
        });
        var n = i(85487)
          , r = i(31798)
          , o = i(70553)
          , s = i(40177)
          , a = i(28641)
          , l = i(65818);
        class c extends r.Z {
            constructor(t, e, i, n, r, s, a) {
                super(t, e, i, o.Z.IDLE),
                this.src_ = n,
                this.image_ = new Image,
                null !== r && (this.image_.crossOrigin = r),
                this.context_ = a,
                this.unlisten_ = null,
                this.state = o.Z.IDLE,
                this.imageLoadFunction_ = s
            }
            getImage() {
                if (this.state == o.Z.LOADED && this.context_ && !(this.image_ instanceof HTMLCanvasElement)) {
                    const t = this.context_.canvas;
                    t.width = this.image_.width,
                    t.height = this.image_.height,
                    this.context_.drawImage(this.image_, 0, 0),
                    this.image_ = this.context_.canvas
                }
                return this.image_
            }
            handleImageError_() {
                this.state = o.Z.ERROR,
                this.unlistenImage_(),
                this.changed()
            }
            handleImageLoad_() {
                void 0 === this.resolution && (this.resolution = (0,
                a.Cr)(this.extent) / this.image_.height),
                this.state = o.Z.LOADED,
                this.unlistenImage_(),
                this.changed()
            }
            load() {
                this.state != o.Z.IDLE && this.state != o.Z.ERROR || (this.state = o.Z.LOADING,
                this.changed(),
                this.imageLoadFunction_(this, this.src_),
                this.unlisten_ = h(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)))
            }
            setImage(t) {
                this.image_ = t,
                this.resolution = (0,
                a.Cr)(this.extent) / this.image_.height
            }
            unlistenImage_() {
                this.unlisten_ && (this.unlisten_(),
                this.unlisten_ = null)
            }
        }
        function h(t, e, i) {
            const r = t;
            let o = !0
              , a = !1
              , c = !1;
            const h = [(0,
            l.Vx)(r, n.Z.LOAD, (function() {
                c = !0,
                a || e()
            }
            ))];
            return r.src && s.Tp ? (a = !0,
            r.decode().then((function() {
                o && e()
            }
            )).catch((function(t) {
                o && (c ? e() : i())
            }
            ))) : h.push((0,
            l.Vx)(r, n.Z.ERROR, i)),
            function() {
                o = !1,
                h.forEach(l.bN)
            }
        }
        e.Z = c
    },
    31798: function(t, e, i) {
        "use strict";
        var n = i(208)
          , r = i(85487)
          , o = i(74187);
        class s extends n.Z {
            constructor(t, e, i, n) {
                super(),
                this.extent = t,
                this.pixelRatio_ = i,
                this.resolution = e,
                this.state = n
            }
            changed() {
                this.dispatchEvent(r.Z.CHANGE)
            }
            getExtent() {
                return this.extent
            }
            getImage() {
                return (0,
                o.O3)()
            }
            getPixelRatio() {
                return this.pixelRatio_
            }
            getResolution() {
                return this.resolution
            }
            getState() {
                return this.state
            }
            load() {
                (0,
                o.O3)()
            }
        }
        e.Z = s
    },
    70553: function(t, e) {
        "use strict";
        e.Z = {
            IDLE: 0,
            LOADING: 1,
            LOADED: 2,
            ERROR: 3,
            EMPTY: 4
        }
    },
    48630: function(t, e, i) {
        "use strict";
        var n = i(43536);
        class r extends n.Z {
            constructor(t, e, i, n, r, o) {
                super(t, e, r),
                this.originalEvent = i,
                this.pixel_ = null,
                this.coordinate_ = null,
                this.dragging = void 0 !== n && n,
                this.activePointers = o
            }
            get pixel() {
                return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)),
                this.pixel_
            }
            set pixel(t) {
                this.pixel_ = t
            }
            get coordinate() {
                return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)),
                this.coordinate_
            }
            set coordinate(t) {
                this.coordinate_ = t
            }
            preventDefault() {
                super.preventDefault(),
                "preventDefault"in this.originalEvent && this.originalEvent.preventDefault()
            }
            stopPropagation() {
                super.stopPropagation(),
                "stopPropagation"in this.originalEvent && this.originalEvent.stopPropagation()
            }
        }
        e.Z = r
    },
    92217: function(t, e, i) {
        "use strict";
        var n = i(85487);
        e.Z = {
            SINGLECLICK: "singleclick",
            CLICK: n.Z.CLICK,
            DBLCLICK: n.Z.DBLCLICK,
            POINTERDRAG: "pointerdrag",
            POINTERMOVE: "pointermove",
            POINTERDOWN: "pointerdown",
            POINTERUP: "pointerup",
            POINTEROVER: "pointerover",
            POINTEROUT: "pointerout",
            POINTERENTER: "pointerenter",
            POINTERLEAVE: "pointerleave",
            POINTERCANCEL: "pointercancel"
        }
    },
    43536: function(t, e, i) {
        "use strict";
        var n = i(291);
        class r extends n.ZP {
            constructor(t, e, i) {
                super(t),
                this.map = e,
                this.frameState = void 0 !== i ? i : null
            }
        }
        e.Z = r
    },
    72971: function(t, e, i) {
        "use strict";
        var n = i(291)
          , r = i(35990)
          , o = i(62706)
          , s = i(74187)
          , a = i(69374);
        class l extends n.ZP {
            constructor(t, e, i) {
                super(t),
                this.key = e,
                this.oldValue = i
            }
        }
        class c extends o.Z {
            constructor(t) {
                super(),
                this.on,
                this.once,
                this.un,
                (0,
                s.sq)(this),
                this.values_ = null,
                void 0 !== t && this.setProperties(t)
            }
            get(t) {
                let e;
                return this.values_ && this.values_.hasOwnProperty(t) && (e = this.values_[t]),
                e
            }
            getKeys() {
                return this.values_ && Object.keys(this.values_) || []
            }
            getProperties() {
                return this.values_ && Object.assign({}, this.values_) || {}
            }
            hasProperties() {
                return !!this.values_
            }
            notify(t, e) {
                let i;
                i = `change:${t}`,
                this.hasListener(i) && this.dispatchEvent(new l(i,t,e)),
                i = r.Z.PROPERTYCHANGE,
                this.hasListener(i) && this.dispatchEvent(new l(i,t,e))
            }
            addChangeListener(t, e) {
                this.addEventListener(`change:${t}`, e)
            }
            removeChangeListener(t, e) {
                this.removeEventListener(`change:${t}`, e)
            }
            set(t, e, i) {
                const n = this.values_ || (this.values_ = {});
                if (i)
                    n[t] = e;
                else {
                    const i = n[t];
                    n[t] = e,
                    i !== e && this.notify(t, i)
                }
            }
            setProperties(t, e) {
                for (const i in t)
                    this.set(i, t[i], e)
            }
            applyProperties(t) {
                t.values_ && Object.assign(this.values_ || (this.values_ = {}), t.values_)
            }
            unset(t, e) {
                if (this.values_ && t in this.values_) {
                    const i = this.values_[t];
                    delete this.values_[t],
                    (0,
                    a.x)(this.values_) && (this.values_ = null),
                    e || this.notify(t, i)
                }
            }
        }
        e.Z = c
    },
    35990: function(t, e) {
        "use strict";
        e.Z = {
            PROPERTYCHANGE: "propertychange"
        }
    },
    62706: function(t, e, i) {
        "use strict";
        i.d(e, {
            B: function() {
                return a
            }
        });
        var n = i(208)
          , r = i(85487)
          , o = i(65818);
        class s extends n.Z {
            constructor() {
                super(),
                this.on = this.onInternal,
                this.once = this.onceInternal,
                this.un = this.unInternal,
                this.revision_ = 0
            }
            changed() {
                ++this.revision_,
                this.dispatchEvent(r.Z.CHANGE)
            }
            getRevision() {
                return this.revision_
            }
            onInternal(t, e) {
                if (Array.isArray(t)) {
                    const i = t.length
                      , n = new Array(i);
                    for (let r = 0; r < i; ++r)
                        n[r] = (0,
                        o.oL)(this, t[r], e);
                    return n
                }
                return (0,
                o.oL)(this, t, e)
            }
            onceInternal(t, e) {
                let i;
                if (Array.isArray(t)) {
                    const n = t.length;
                    i = new Array(n);
                    for (let r = 0; r < n; ++r)
                        i[r] = (0,
                        o.Vx)(this, t[r], e)
                } else
                    i = (0,
                    o.Vx)(this, t, e);
                return e.ol_key = i,
                i
            }
            unInternal(t, e) {
                const i = e.ol_key;
                if (i)
                    a(i);
                else if (Array.isArray(t))
                    for (let i = 0, n = t.length; i < n; ++i)
                        this.removeEventListener(t[i], e);
                else
                    this.removeEventListener(t, e)
            }
        }
        function a(t) {
            if (Array.isArray(t))
                for (let e = 0, i = t.length; e < i; ++e)
                    (0,
                    o.bN)(t[e]);
            else
                (0,
                o.bN)(t)
        }
        s.prototype.on,
        s.prototype.once,
        s.prototype.un,
        e.Z = s
    },
    12327: function(t, e, i) {
        "use strict";
        i.d(e, {
            ZP: function() {
                return S
            }
        });
        var n = i(72971)
          , r = i(37755)
          , o = {
            CENTER: "center",
            RESOLUTION: "resolution",
            ROTATION: "rotation"
        };
        var s = i(26835)
          , a = i(36885)
          , l = i(91900)
          , c = i(99515)
          , h = i(33983);
        function u(t, e, i) {
            return function(n, r, o, s, a) {
                if (!n)
                    return;
                if (!r && !e)
                    return n;
                const l = e ? 0 : o[0] * r
                  , c = e ? 0 : o[1] * r
                  , u = a ? a[0] : 0
                  , d = a ? a[1] : 0;
                let f = t[0] + l / 2 + u
                  , p = t[2] - l / 2 + u
                  , m = t[1] + c / 2 + d
                  , g = t[3] - c / 2 + d;
                f > p && (f = (p + f) / 2,
                p = f),
                m > g && (m = (g + m) / 2,
                g = m);
                let _ = (0,
                h.uZ)(n[0], f, p)
                  , y = (0,
                h.uZ)(n[1], m, g);
                if (s && i && r) {
                    const t = 30 * r;
                    _ += -t * Math.log(1 + Math.max(0, f - n[0]) / t) + t * Math.log(1 + Math.max(0, n[0] - p) / t),
                    y += -t * Math.log(1 + Math.max(0, m - n[1]) / t) + t * Math.log(1 + Math.max(0, n[1] - g) / t)
                }
                return [_, y]
            }
        }
        function d(t) {
            return t
        }
        var f = i(28641)
          , p = i(65537);
        function m(t, e, i, n) {
            const r = (0,
            f.dz)(e) / i[0]
              , o = (0,
            f.Cr)(e) / i[1];
            return n ? Math.min(t, Math.max(r, o)) : Math.min(t, Math.min(r, o))
        }
        function g(t, e, i) {
            let n = Math.min(t, e);
            return n *= Math.log(1 + 50 * Math.max(0, t / e - 1)) / 50 + 1,
            i && (n = Math.max(n, i),
            n /= Math.log(1 + 50 * Math.max(0, i / t - 1)) / 50 + 1),
            (0,
            h.uZ)(n, i / 2, 2 * e)
        }
        function _(t, e, i, n, r) {
            return i = void 0 === i || i,
            function(o, s, a, l) {
                if (void 0 !== o) {
                    const s = n ? m(t, n, a, r) : t;
                    return i && l ? g(o, s, e) : (0,
                    h.uZ)(o, e, s)
                }
            }
        }
        var y = i(60828)
          , v = i(31015)
          , x = i(69242);
        class b extends n.Z {
            constructor(t) {
                super(),
                this.on,
                this.once,
                this.un,
                t = Object.assign({}, t),
                this.hints_ = [0, 0],
                this.animations_ = [],
                this.updateAnimationKey_,
                this.projection_ = (0,
                s.UQ)(t.projection, "EPSG:3857"),
                this.viewportSize_ = [100, 100],
                this.targetCenter_ = null,
                this.targetResolution_,
                this.targetRotation_,
                this.nextCenter_ = null,
                this.nextResolution_,
                this.nextRotation_,
                this.cancelAnchor_ = void 0,
                t.projection && (0,
                s.h_)(),
                t.center && (t.center = (0,
                s.Vs)(t.center, this.projection_)),
                t.extent && (t.extent = (0,
                s.dY)(t.extent, this.projection_)),
                this.applyOptions_(t)
            }
            applyOptions_(t) {
                const e = Object.assign({}, t);
                for (const t in o)
                    delete e[t];
                this.setProperties(e, !0);
                const i = function(t) {
                    let e, i, n;
                    const r = 28
                      , o = 2;
                    let a = void 0 !== t.minZoom ? t.minZoom : 0
                      , l = void 0 !== t.maxZoom ? t.maxZoom : r;
                    const c = void 0 !== t.zoomFactor ? t.zoomFactor : o
                      , u = void 0 !== t.multiWorld && t.multiWorld
                      , d = void 0 === t.smoothResolutionConstraint || t.smoothResolutionConstraint
                      , y = void 0 !== t.showFullExtent && t.showFullExtent
                      , v = (0,
                    s.UQ)(t.projection, "EPSG:3857")
                      , x = v.getExtent();
                    let b = t.constrainOnlyCenter
                      , w = t.extent;
                    u || w || !v.isGlobal() || (b = !1,
                    w = x);
                    if (void 0 !== t.resolutions) {
                        const r = t.resolutions;
                        i = r[a],
                        n = void 0 !== r[l] ? r[l] : r[r.length - 1],
                        e = t.constrainResolution ? function(t, e, i, n) {
                            return e = void 0 === e || e,
                            function(r, o, s, a) {
                                if (void 0 !== r) {
                                    const l = t[0]
                                      , c = t[t.length - 1]
                                      , u = i ? m(l, i, s, n) : l;
                                    if (a)
                                        return e ? g(r, u, c) : (0,
                                        h.uZ)(r, c, u);
                                    const d = Math.min(u, r)
                                      , f = Math.floor((0,
                                    p.h7)(t, d, o));
                                    return t[f] > u && f < t.length - 1 ? t[f + 1] : t[f]
                                }
                            }
                        }(r, d, !b && w, y) : _(i, n, d, !b && w, y)
                    } else {
                        const u = (x ? Math.max((0,
                        f.dz)(x), (0,
                        f.Cr)(x)) : 360 * s.Wm.degrees / v.getMetersPerUnit()) / 256 / Math.pow(o, 0)
                          , p = u / Math.pow(o, r - 0);
                        i = t.maxResolution,
                        void 0 !== i ? a = 0 : i = u / Math.pow(c, a),
                        n = t.minResolution,
                        void 0 === n && (n = void 0 !== t.maxZoom ? void 0 !== t.maxResolution ? i / Math.pow(c, l) : u / Math.pow(c, l) : p),
                        l = a + Math.floor(Math.log(i / n) / Math.log(c)),
                        n = i / Math.pow(c, l - a),
                        e = t.constrainResolution ? function(t, e, i, n, r, o) {
                            return n = void 0 === n || n,
                            i = void 0 !== i ? i : 0,
                            function(s, a, l, c) {
                                if (void 0 !== s) {
                                    const u = r ? m(e, r, l, o) : e;
                                    if (c)
                                        return n ? g(s, u, i) : (0,
                                        h.uZ)(s, i, u);
                                    const d = 1e-9
                                      , f = Math.ceil(Math.log(e / u) / Math.log(t) - d)
                                      , p = -a * (.5 - d) + .5
                                      , _ = Math.min(u, s)
                                      , y = Math.floor(Math.log(e / _) / Math.log(t) + p)
                                      , v = Math.max(f, y)
                                      , x = e / Math.pow(t, v);
                                    return (0,
                                    h.uZ)(x, i, u)
                                }
                            }
                        }(c, i, n, d, !b && w, y) : _(i, n, d, !b && w, y)
                    }
                    return {
                        constraint: e,
                        maxResolution: i,
                        minResolution: n,
                        minZoom: a,
                        zoomFactor: c
                    }
                }(t);
                this.maxResolution_ = i.maxResolution,
                this.minResolution_ = i.minResolution,
                this.zoomFactor_ = i.zoomFactor,
                this.resolutions_ = t.resolutions,
                this.padding_ = t.padding,
                this.minZoom_ = i.minZoom;
                const n = function(t) {
                    if (void 0 !== t.extent) {
                        const e = void 0 === t.smoothExtentConstraint || t.smoothExtentConstraint;
                        return u(t.extent, t.constrainOnlyCenter, e)
                    }
                    const e = (0,
                    s.UQ)(t.projection, "EPSG:3857");
                    if (!0 !== t.multiWorld && e.isGlobal()) {
                        const t = e.getExtent().slice();
                        return t[0] = -1 / 0,
                        t[2] = 1 / 0,
                        u(t, !1, !1)
                    }
                    return d
                }(t)
                  , r = i.constraint
                  , a = function(t) {
                    const e = void 0 === t.enableRotation || t.enableRotation;
                    if (e) {
                        const e = t.constrainRotation;
                        return void 0 === e || !0 === e ? (0,
                        y.Gw)() : !1 === e ? y.YP : "number" == typeof e ? (0,
                        y.gE)(e) : y.YP
                    }
                    return y.h$
                }(t);
                this.constraints_ = {
                    center: n,
                    resolution: r,
                    rotation: a
                },
                this.setRotation(void 0 !== t.rotation ? t.rotation : 0),
                this.setCenterInternal(void 0 !== t.center ? t.center : null),
                void 0 !== t.resolution ? this.setResolution(t.resolution) : void 0 !== t.zoom && this.setZoom(t.zoom)
            }
            get padding() {
                return this.padding_
            }
            set padding(t) {
                let e = this.padding_;
                this.padding_ = t;
                const i = this.getCenterInternal();
                if (i) {
                    const n = t || [0, 0, 0, 0];
                    e = e || [0, 0, 0, 0];
                    const r = this.getResolution()
                      , o = r / 2 * (n[3] - e[3] + e[1] - n[1])
                      , s = r / 2 * (n[0] - e[0] + e[2] - n[2]);
                    this.setCenterInternal([i[0] + o, i[1] - s])
                }
            }
            getUpdatedOptions_(t) {
                const e = this.getProperties();
                return void 0 !== e.resolution ? e.resolution = this.getResolution() : e.zoom = this.getZoom(),
                e.center = this.getCenterInternal(),
                e.rotation = this.getRotation(),
                Object.assign({}, e, t)
            }
            animate(t) {
                this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
                const e = new Array(arguments.length);
                for (let t = 0; t < e.length; ++t) {
                    let i = arguments[t];
                    i.center && (i = Object.assign({}, i),
                    i.center = (0,
                    s.Vs)(i.center, this.getProjection())),
                    i.anchor && (i = Object.assign({}, i),
                    i.anchor = (0,
                    s.Vs)(i.anchor, this.getProjection())),
                    e[t] = i
                }
                this.animateInternal.apply(this, e)
            }
            animateInternal(t) {
                let e, i = arguments.length;
                i > 1 && "function" == typeof arguments[i - 1] && (e = arguments[i - 1],
                --i);
                let n = 0;
                for (; n < i && !this.isDef(); ++n) {
                    const t = arguments[n];
                    t.center && this.setCenterInternal(t.center),
                    void 0 !== t.zoom ? this.setZoom(t.zoom) : t.resolution && this.setResolution(t.resolution),
                    void 0 !== t.rotation && this.setRotation(t.rotation)
                }
                if (n === i)
                    return void (e && w(e, !0));
                let o = Date.now()
                  , s = this.targetCenter_.slice()
                  , a = this.targetResolution_
                  , l = this.targetRotation_;
                const c = [];
                for (; n < i; ++n) {
                    const t = arguments[n]
                      , i = {
                        start: o,
                        complete: !1,
                        anchor: t.anchor,
                        duration: void 0 !== t.duration ? t.duration : 1e3,
                        easing: t.easing || v.rd,
                        callback: e
                    };
                    if (t.center && (i.sourceCenter = s,
                    i.targetCenter = t.center.slice(),
                    s = i.targetCenter),
                    void 0 !== t.zoom ? (i.sourceResolution = a,
                    i.targetResolution = this.getResolutionForZoom(t.zoom),
                    a = i.targetResolution) : t.resolution && (i.sourceResolution = a,
                    i.targetResolution = t.resolution,
                    a = i.targetResolution),
                    void 0 !== t.rotation) {
                        i.sourceRotation = l;
                        const e = (0,
                        h.$W)(t.rotation - l + Math.PI, 2 * Math.PI) - Math.PI;
                        i.targetRotation = l + e,
                        l = i.targetRotation
                    }
                    E(i) ? i.complete = !0 : o += i.duration,
                    c.push(i)
                }
                this.animations_.push(c),
                this.setHint(r.Z.ANIMATING, 1),
                this.updateAnimations_()
            }
            getAnimating() {
                return this.hints_[r.Z.ANIMATING] > 0
            }
            getInteracting() {
                return this.hints_[r.Z.INTERACTING] > 0
            }
            cancelAnimations() {
                let t;
                this.setHint(r.Z.ANIMATING, -this.hints_[r.Z.ANIMATING]);
                for (let e = 0, i = this.animations_.length; e < i; ++e) {
                    const i = this.animations_[e];
                    if (i[0].callback && w(i[0].callback, !1),
                    !t)
                        for (let e = 0, n = i.length; e < n; ++e) {
                            const n = i[e];
                            if (!n.complete) {
                                t = n.anchor;
                                break
                            }
                        }
                }
                this.animations_.length = 0,
                this.cancelAnchor_ = t,
                this.nextCenter_ = null,
                this.nextResolution_ = NaN,
                this.nextRotation_ = NaN
            }
            updateAnimations_() {
                if (void 0 !== this.updateAnimationKey_ && (cancelAnimationFrame(this.updateAnimationKey_),
                this.updateAnimationKey_ = void 0),
                !this.getAnimating())
                    return;
                const t = Date.now();
                let e = !1;
                for (let i = this.animations_.length - 1; i >= 0; --i) {
                    const n = this.animations_[i];
                    let o = !0;
                    for (let i = 0, r = n.length; i < r; ++i) {
                        const r = n[i];
                        if (r.complete)
                            continue;
                        const s = t - r.start;
                        let a = r.duration > 0 ? s / r.duration : 1;
                        a >= 1 ? (r.complete = !0,
                        a = 1) : o = !1;
                        const l = r.easing(a);
                        if (r.sourceCenter) {
                            const t = r.sourceCenter[0]
                              , e = r.sourceCenter[1]
                              , i = r.targetCenter[0]
                              , n = r.targetCenter[1];
                            this.nextCenter_ = r.targetCenter;
                            const o = t + l * (i - t)
                              , s = e + l * (n - e);
                            this.targetCenter_ = [o, s]
                        }
                        if (r.sourceResolution && r.targetResolution) {
                            const t = 1 === l ? r.targetResolution : r.sourceResolution + l * (r.targetResolution - r.sourceResolution);
                            if (r.anchor) {
                                const e = this.getViewportSize_(this.getRotation())
                                  , i = this.constraints_.resolution(t, 0, e, !0);
                                this.targetCenter_ = this.calculateCenterZoom(i, r.anchor)
                            }
                            this.nextResolution_ = r.targetResolution,
                            this.targetResolution_ = t,
                            this.applyTargetState_(!0)
                        }
                        if (void 0 !== r.sourceRotation && void 0 !== r.targetRotation) {
                            const t = 1 === l ? (0,
                            h.$W)(r.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : r.sourceRotation + l * (r.targetRotation - r.sourceRotation);
                            if (r.anchor) {
                                const e = this.constraints_.rotation(t, !0);
                                this.targetCenter_ = this.calculateCenterRotate(e, r.anchor)
                            }
                            this.nextRotation_ = r.targetRotation,
                            this.targetRotation_ = t
                        }
                        if (this.applyTargetState_(!0),
                        e = !0,
                        !r.complete)
                            break
                    }
                    if (o) {
                        this.animations_[i] = null,
                        this.setHint(r.Z.ANIMATING, -1),
                        this.nextCenter_ = null,
                        this.nextResolution_ = NaN,
                        this.nextRotation_ = NaN;
                        const t = n[0].callback;
                        t && w(t, !0)
                    }
                }
                this.animations_ = this.animations_.filter(Boolean),
                e && void 0 === this.updateAnimationKey_ && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)))
            }
            calculateCenterRotate(t, e) {
                let i;
                const n = this.getCenterInternal();
                return void 0 !== n && (i = [n[0] - e[0], n[1] - e[1]],
                (0,
                l.U1)(i, t - this.getRotation()),
                (0,
                l.IH)(i, e)),
                i
            }
            calculateCenterZoom(t, e) {
                let i;
                const n = this.getCenterInternal()
                  , r = this.getResolution();
                if (void 0 !== n && void 0 !== r) {
                    i = [e[0] - t * (e[0] - n[0]) / r, e[1] - t * (e[1] - n[1]) / r]
                }
                return i
            }
            getViewportSize_(t) {
                const e = this.viewportSize_;
                if (t) {
                    const i = e[0]
                      , n = e[1];
                    return [Math.abs(i * Math.cos(t)) + Math.abs(n * Math.sin(t)), Math.abs(i * Math.sin(t)) + Math.abs(n * Math.cos(t))]
                }
                return e
            }
            setViewportSize(t) {
                this.viewportSize_ = Array.isArray(t) ? t.slice() : [100, 100],
                this.getAnimating() || this.resolveConstraints(0)
            }
            getCenter() {
                const t = this.getCenterInternal();
                return t ? (0,
                s.lO)(t, this.getProjection()) : t
            }
            getCenterInternal() {
                return this.get(o.CENTER)
            }
            getConstraints() {
                return this.constraints_
            }
            getConstrainResolution() {
                return this.get("constrainResolution")
            }
            getHints(t) {
                return void 0 !== t ? (t[0] = this.hints_[0],
                t[1] = this.hints_[1],
                t) : this.hints_.slice()
            }
            calculateExtent(t) {
                const e = this.calculateExtentInternal(t);
                return (0,
                s.Fj)(e, this.getProjection())
            }
            calculateExtentInternal(t) {
                t = t || this.getViewportSizeMinusPadding_();
                const e = this.getCenterInternal();
                (0,
                c.h)(e, 1);
                const i = this.getResolution();
                (0,
                c.h)(void 0 !== i, 2);
                const n = this.getRotation();
                return (0,
                c.h)(void 0 !== n, 3),
                (0,
                f.p8)(e, i, n, t)
            }
            getMaxResolution() {
                return this.maxResolution_
            }
            getMinResolution() {
                return this.minResolution_
            }
            getMaxZoom() {
                return this.getZoomForResolution(this.minResolution_)
            }
            setMaxZoom(t) {
                this.applyOptions_(this.getUpdatedOptions_({
                    maxZoom: t
                }))
            }
            getMinZoom() {
                return this.getZoomForResolution(this.maxResolution_)
            }
            setMinZoom(t) {
                this.applyOptions_(this.getUpdatedOptions_({
                    minZoom: t
                }))
            }
            setConstrainResolution(t) {
                this.applyOptions_(this.getUpdatedOptions_({
                    constrainResolution: t
                }))
            }
            getProjection() {
                return this.projection_
            }
            getResolution() {
                return this.get(o.RESOLUTION)
            }
            getResolutions() {
                return this.resolutions_
            }
            getResolutionForExtent(t, e) {
                return this.getResolutionForExtentInternal((0,
                s.dY)(t, this.getProjection()), e)
            }
            getResolutionForExtentInternal(t, e) {
                e = e || this.getViewportSizeMinusPadding_();
                const i = (0,
                f.dz)(t) / e[0]
                  , n = (0,
                f.Cr)(t) / e[1];
                return Math.max(i, n)
            }
            getResolutionForValueFunction(t) {
                t = t || 2;
                const e = this.getConstrainedResolution(this.maxResolution_)
                  , i = this.minResolution_
                  , n = Math.log(e / i) / Math.log(t);
                return function(i) {
                    return e / Math.pow(t, i * n)
                }
            }
            getRotation() {
                return this.get(o.ROTATION)
            }
            getValueForResolutionFunction(t) {
                const e = Math.log(t || 2)
                  , i = this.getConstrainedResolution(this.maxResolution_)
                  , n = this.minResolution_
                  , r = Math.log(i / n) / e;
                return function(t) {
                    return Math.log(i / t) / e / r
                }
            }
            getViewportSizeMinusPadding_(t) {
                let e = this.getViewportSize_(t);
                const i = this.padding_;
                return i && (e = [e[0] - i[1] - i[3], e[1] - i[0] - i[2]]),
                e
            }
            getState() {
                const t = this.getProjection()
                  , e = this.getResolution()
                  , i = this.getRotation();
                let n = this.getCenterInternal();
                const r = this.padding_;
                if (r) {
                    const t = this.getViewportSizeMinusPadding_();
                    n = T(n, this.getViewportSize_(), [t[0] / 2 + r[3], t[1] / 2 + r[0]], e, i)
                }
                return {
                    center: n.slice(0),
                    projection: void 0 !== t ? t : null,
                    resolution: e,
                    nextCenter: this.nextCenter_,
                    nextResolution: this.nextResolution_,
                    nextRotation: this.nextRotation_,
                    rotation: i,
                    zoom: this.getZoom()
                }
            }
            getViewStateAndExtent() {
                return {
                    viewState: this.getState(),
                    extent: this.calculateExtent()
                }
            }
            getZoom() {
                let t;
                const e = this.getResolution();
                return void 0 !== e && (t = this.getZoomForResolution(e)),
                t
            }
            getZoomForResolution(t) {
                let e, i, n = this.minZoom_ || 0;
                if (this.resolutions_) {
                    const r = (0,
                    p.h7)(this.resolutions_, t, 1);
                    n = r,
                    e = this.resolutions_[r],
                    i = r == this.resolutions_.length - 1 ? 2 : e / this.resolutions_[r + 1]
                } else
                    e = this.maxResolution_,
                    i = this.zoomFactor_;
                return n + Math.log(e / t) / Math.log(i)
            }
            getResolutionForZoom(t) {
                if (this.resolutions_) {
                    if (this.resolutions_.length <= 1)
                        return 0;
                    const e = (0,
                    h.uZ)(Math.floor(t), 0, this.resolutions_.length - 2)
                      , i = this.resolutions_[e] / this.resolutions_[e + 1];
                    return this.resolutions_[e] / Math.pow(i, (0,
                    h.uZ)(t - e, 0, 1))
                }
                return this.maxResolution_ / Math.pow(this.zoomFactor_, t - this.minZoom_)
            }
            fit(t, e) {
                let i;
                if ((0,
                c.h)(Array.isArray(t) || "function" == typeof t.getSimplifiedGeometry, 24),
                Array.isArray(t)) {
                    (0,
                    c.h)(!(0,
                    f.xb)(t), 25);
                    const e = (0,
                    s.dY)(t, this.getProjection());
                    i = (0,
                    x.oJ)(e)
                } else if ("Circle" === t.getType()) {
                    const e = (0,
                    s.dY)(t.getExtent(), this.getProjection());
                    i = (0,
                    x.oJ)(e),
                    i.rotate(this.getRotation(), (0,
                    f.qg)(e))
                } else {
                    const e = (0,
                    s.Cs)();
                    i = e ? t.clone().transform(e, this.getProjection()) : t
                }
                this.fitInternal(i, e)
            }
            rotatedExtentForGeometry(t) {
                const e = this.getRotation()
                  , i = Math.cos(e)
                  , n = Math.sin(-e)
                  , r = t.getFlatCoordinates()
                  , o = t.getStride();
                let s = 1 / 0
                  , a = 1 / 0
                  , l = -1 / 0
                  , c = -1 / 0;
                for (let t = 0, e = r.length; t < e; t += o) {
                    const e = r[t] * i - r[t + 1] * n
                      , o = r[t] * n + r[t + 1] * i;
                    s = Math.min(s, e),
                    a = Math.min(a, o),
                    l = Math.max(l, e),
                    c = Math.max(c, o)
                }
                return [s, a, l, c]
            }
            fitInternal(t, e) {
                let i = (e = e || {}).size;
                i || (i = this.getViewportSizeMinusPadding_());
                const n = void 0 !== e.padding ? e.padding : [0, 0, 0, 0]
                  , r = void 0 !== e.nearest && e.nearest;
                let o;
                o = void 0 !== e.minResolution ? e.minResolution : void 0 !== e.maxZoom ? this.getResolutionForZoom(e.maxZoom) : 0;
                const s = this.rotatedExtentForGeometry(t);
                let l = this.getResolutionForExtentInternal(s, [i[0] - n[1] - n[3], i[1] - n[0] - n[2]]);
                l = isNaN(l) ? o : Math.max(l, o),
                l = this.getConstrainedResolution(l, r ? 0 : 1);
                const c = this.getRotation()
                  , h = Math.sin(c)
                  , u = Math.cos(c)
                  , d = (0,
                f.qg)(s);
                d[0] += (n[1] - n[3]) / 2 * l,
                d[1] += (n[0] - n[2]) / 2 * l;
                const p = d[0] * u - d[1] * h
                  , m = d[1] * u + d[0] * h
                  , g = this.getConstrainedCenter([p, m], l)
                  , _ = e.callback ? e.callback : a.Zn;
                void 0 !== e.duration ? this.animateInternal({
                    resolution: l,
                    center: g,
                    duration: e.duration,
                    easing: e.easing
                }, _) : (this.targetResolution_ = l,
                this.targetCenter_ = g,
                this.applyTargetState_(!1, !0),
                w(_, !0))
            }
            centerOn(t, e, i) {
                this.centerOnInternal((0,
                s.Vs)(t, this.getProjection()), e, i)
            }
            centerOnInternal(t, e, i) {
                this.setCenterInternal(T(t, e, i, this.getResolution(), this.getRotation()))
            }
            calculateCenterShift(t, e, i, n) {
                let r;
                const o = this.padding_;
                if (o && t) {
                    const s = this.getViewportSizeMinusPadding_(-i)
                      , a = T(t, n, [s[0] / 2 + o[3], s[1] / 2 + o[0]], e, i);
                    r = [t[0] - a[0], t[1] - a[1]]
                }
                return r
            }
            isDef() {
                return !!this.getCenterInternal() && void 0 !== this.getResolution()
            }
            adjustCenter(t) {
                const e = (0,
                s.lO)(this.targetCenter_, this.getProjection());
                this.setCenter([e[0] + t[0], e[1] + t[1]])
            }
            adjustCenterInternal(t) {
                const e = this.targetCenter_;
                this.setCenterInternal([e[0] + t[0], e[1] + t[1]])
            }
            adjustResolution(t, e) {
                e = e && (0,
                s.Vs)(e, this.getProjection()),
                this.adjustResolutionInternal(t, e)
            }
            adjustResolutionInternal(t, e) {
                const i = this.getAnimating() || this.getInteracting()
                  , n = this.getViewportSize_(this.getRotation())
                  , r = this.constraints_.resolution(this.targetResolution_ * t, 0, n, i);
                e && (this.targetCenter_ = this.calculateCenterZoom(r, e)),
                this.targetResolution_ *= t,
                this.applyTargetState_()
            }
            adjustZoom(t, e) {
                this.adjustResolution(Math.pow(this.zoomFactor_, -t), e)
            }
            adjustRotation(t, e) {
                e && (e = (0,
                s.Vs)(e, this.getProjection())),
                this.adjustRotationInternal(t, e)
            }
            adjustRotationInternal(t, e) {
                const i = this.getAnimating() || this.getInteracting()
                  , n = this.constraints_.rotation(this.targetRotation_ + t, i);
                e && (this.targetCenter_ = this.calculateCenterRotate(n, e)),
                this.targetRotation_ += t,
                this.applyTargetState_()
            }
            setCenter(t) {
                this.setCenterInternal(t ? (0,
                s.Vs)(t, this.getProjection()) : t)
            }
            setCenterInternal(t) {
                this.targetCenter_ = t,
                this.applyTargetState_()
            }
            setHint(t, e) {
                return this.hints_[t] += e,
                this.changed(),
                this.hints_[t]
            }
            setResolution(t) {
                this.targetResolution_ = t,
                this.applyTargetState_()
            }
            setRotation(t) {
                this.targetRotation_ = t,
                this.applyTargetState_()
            }
            setZoom(t) {
                this.setResolution(this.getResolutionForZoom(t))
            }
            applyTargetState_(t, e) {
                const i = this.getAnimating() || this.getInteracting() || e
                  , n = this.constraints_.rotation(this.targetRotation_, i)
                  , r = this.getViewportSize_(n)
                  , s = this.constraints_.resolution(this.targetResolution_, 0, r, i)
                  , a = this.constraints_.center(this.targetCenter_, s, r, i, this.calculateCenterShift(this.targetCenter_, s, n, r));
                this.get(o.ROTATION) !== n && this.set(o.ROTATION, n),
                this.get(o.RESOLUTION) !== s && (this.set(o.RESOLUTION, s),
                this.set("zoom", this.getZoom(), !0)),
                a && this.get(o.CENTER) && (0,
                l.fS)(this.get(o.CENTER), a) || this.set(o.CENTER, a),
                this.getAnimating() && !t && this.cancelAnimations(),
                this.cancelAnchor_ = void 0
            }
            resolveConstraints(t, e, i) {
                t = void 0 !== t ? t : 200;
                const n = e || 0
                  , r = this.constraints_.rotation(this.targetRotation_)
                  , o = this.getViewportSize_(r)
                  , s = this.constraints_.resolution(this.targetResolution_, n, o)
                  , a = this.constraints_.center(this.targetCenter_, s, o, !1, this.calculateCenterShift(this.targetCenter_, s, r, o));
                if (0 === t && !this.cancelAnchor_)
                    return this.targetResolution_ = s,
                    this.targetRotation_ = r,
                    this.targetCenter_ = a,
                    void this.applyTargetState_();
                i = i || (0 === t ? this.cancelAnchor_ : void 0),
                this.cancelAnchor_ = void 0,
                this.getResolution() === s && this.getRotation() === r && this.getCenterInternal() && (0,
                l.fS)(this.getCenterInternal(), a) || (this.getAnimating() && this.cancelAnimations(),
                this.animateInternal({
                    rotation: r,
                    center: a,
                    resolution: s,
                    duration: t,
                    easing: v.Vv,
                    anchor: i
                }))
            }
            beginInteraction() {
                this.resolveConstraints(0),
                this.setHint(r.Z.INTERACTING, 1)
            }
            endInteraction(t, e, i) {
                i = i && (0,
                s.Vs)(i, this.getProjection()),
                this.endInteractionInternal(t, e, i)
            }
            endInteractionInternal(t, e, i) {
                this.getInteracting() && (this.setHint(r.Z.INTERACTING, -1),
                this.resolveConstraints(t, e, i))
            }
            getConstrainedCenter(t, e) {
                const i = this.getViewportSize_(this.getRotation());
                return this.constraints_.center(t, e || this.getResolution(), i)
            }
            getConstrainedZoom(t, e) {
                const i = this.getResolutionForZoom(t);
                return this.getZoomForResolution(this.getConstrainedResolution(i, e))
            }
            getConstrainedResolution(t, e) {
                e = e || 0;
                const i = this.getViewportSize_(this.getRotation());
                return this.constraints_.resolution(t, e, i)
            }
        }
        function w(t, e) {
            setTimeout((function() {
                t(e)
            }
            ), 0)
        }
        function E(t) {
            return !(t.sourceCenter && t.targetCenter && !(0,
            l.fS)(t.sourceCenter, t.targetCenter)) && (t.sourceResolution === t.targetResolution && t.sourceRotation === t.targetRotation)
        }
        function T(t, e, i, n, r) {
            const o = Math.cos(-r);
            let s = Math.sin(-r)
              , a = t[0] * o - t[1] * s
              , l = t[1] * o + t[0] * s;
            a += (e[0] / 2 - i[0]) * n,
            l += (i[1] - e[1] / 2) * n,
            s = -s;
            return [a * o - l * s, l * o + a * s]
        }
        var S = b
    },
    37755: function(t, e) {
        "use strict";
        e.Z = {
            ANIMATING: 0,
            INTERACTING: 1
        }
    },
    65537: function(t, e, i) {
        "use strict";
        function n(t, e, i) {
            let n, o;
            i = i || r;
            let s = 0
              , a = t.length
              , l = !1;
            for (; s < a; )
                n = s + (a - s >> 1),
                o = +i(t[n], e),
                o < 0 ? s = n + 1 : (a = n,
                l = !o);
            return l ? s : ~s
        }
        function r(t, e) {
            return t > e ? 1 : t < e ? -1 : 0
        }
        function o(t, e, i) {
            if (t[0] <= e)
                return 0;
            const n = t.length;
            if (e <= t[n - 1])
                return n - 1;
            if ("function" == typeof i) {
                for (let r = 1; r < n; ++r) {
                    const n = t[r];
                    if (n === e)
                        return r;
                    if (n < e)
                        return i(e, t[r - 1], n) > 0 ? r - 1 : r
                }
                return n - 1
            }
            if (i > 0) {
                for (let i = 1; i < n; ++i)
                    if (t[i] < e)
                        return i - 1;
                return n - 1
            }
            if (i < 0) {
                for (let i = 1; i < n; ++i)
                    if (t[i] <= e)
                        return i;
                return n - 1
            }
            for (let i = 1; i < n; ++i) {
                if (t[i] == e)
                    return i;
                if (t[i] < e)
                    return t[i - 1] - e < e - t[i] ? i - 1 : i
            }
            return n - 1
        }
        function s(t, e, i) {
            for (; e < i; ) {
                const n = t[e];
                t[e] = t[i],
                t[i] = n,
                ++e,
                --i
            }
        }
        function a(t, e) {
            const i = Array.isArray(e) ? e : [e]
              , n = i.length;
            for (let e = 0; e < n; e++)
                t[t.length] = i[e]
        }
        function l(t, e) {
            const i = t.length;
            if (i !== e.length)
                return !1;
            for (let n = 0; n < i; n++)
                if (t[n] !== e[n])
                    return !1;
            return !0
        }
        i.d(e, {
            FZ: function() {
                return s
            },
            fS: function() {
                return l
            },
            h7: function() {
                return o
            },
            j2: function() {
                return r
            },
            l7: function() {
                return a
            },
            ry: function() {
                return n
            }
        })
    },
    99515: function(t, e, i) {
        "use strict";
        i.d(e, {
            h: function() {
                return r
            }
        });
        var n = i(6813);
        function r(t, e) {
            if (!t)
                throw new n.Z(e)
        }
    },
    79706: function(t, e, i) {
        "use strict";
        i.d(e, {
            BB: function() {
                return d
            },
            XC: function() {
                return a
            },
            _2: function() {
                return h
            }
        });
        var n = i(99515)
          , r = i(33983);
        const o = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i
          , s = /^([a-z]*)$|^hsla?\(.*\)$/i;
        function a(t) {
            return "string" == typeof t ? t : d(t)
        }
        function l(t) {
            const e = document.createElement("div");
            if (e.style.color = t,
            "" !== e.style.color) {
                document.body.appendChild(e);
                const t = getComputedStyle(e).color;
                return document.body.removeChild(e),
                t
            }
            return ""
        }
        const c = function() {
            const t = {};
            let e = 0;
            return function(i) {
                let r;
                if (t.hasOwnProperty(i))
                    r = t[i];
                else {
                    if (e >= 1024) {
                        let i = 0;
                        for (const n in t)
                            0 == (3 & i++) && (delete t[n],
                            --e)
                    }
                    r = function(t) {
                        let e, i, r, a, c;
                        s.exec(t) && (t = l(t));
                        if (o.exec(t)) {
                            const n = t.length - 1;
                            let o;
                            o = n <= 4 ? 1 : 2;
                            const s = 4 === n || 8 === n;
                            e = parseInt(t.substr(1 + 0 * o, o), 16),
                            i = parseInt(t.substr(1 + 1 * o, o), 16),
                            r = parseInt(t.substr(1 + 2 * o, o), 16),
                            a = s ? parseInt(t.substr(1 + 3 * o, o), 16) : 255,
                            1 == o && (e = (e << 4) + e,
                            i = (i << 4) + i,
                            r = (r << 4) + r,
                            s && (a = (a << 4) + a)),
                            c = [e, i, r, a / 255]
                        } else
                            t.startsWith("rgba(") ? (c = t.slice(5, -1).split(",").map(Number),
                            u(c)) : t.startsWith("rgb(") ? (c = t.slice(4, -1).split(",").map(Number),
                            c.push(1),
                            u(c)) : (0,
                            n.h)(!1, 14);
                        return c
                    }(i),
                    t[i] = r,
                    ++e
                }
                return r
            }
        }();
        function h(t) {
            return Array.isArray(t) ? t : c(t)
        }
        function u(t) {
            return t[0] = (0,
            r.uZ)(t[0] + .5 | 0, 0, 255),
            t[1] = (0,
            r.uZ)(t[1] + .5 | 0, 0, 255),
            t[2] = (0,
            r.uZ)(t[2] + .5 | 0, 0, 255),
            t[3] = (0,
            r.uZ)(t[3], 0, 1),
            t
        }
        function d(t) {
            let e = t[0];
            e != (0 | e) && (e = e + .5 | 0);
            let i = t[1];
            i != (0 | i) && (i = i + .5 | 0);
            let n = t[2];
            n != (0 | n) && (n = n + .5 | 0);
            return "rgba(" + e + "," + i + "," + n + "," + (void 0 === t[3] ? 1 : Math.round(100 * t[3]) / 100) + ")"
        }
    },
    96620: function(t, e, i) {
        "use strict";
        i.d(e, {
            y: function() {
                return r
            }
        });
        var n = i(79706);
        function r(t) {
            return Array.isArray(t) ? (0,
            n.BB)(t) : t
        }
    },
    70044: function(t, e, i) {
        "use strict";
        i.d(e, {
            ZK: function() {
                return s
            }
        });
        var n = i(25108);
        const r = {
            info: 1,
            warn: 2,
            error: 3,
            none: 4
        };
        let o = r.info;
        function s(...t) {
            o > r.warn || n.warn(...t)
        }
    },
    91900: function(t, e, i) {
        "use strict";
        i.d(e, {
            Bs: function() {
                return d
            },
            Cf: function() {
                return f
            },
            Ed: function() {
                return o
            },
            IH: function() {
                return r
            },
            TE: function() {
                return u
            },
            U1: function() {
                return l
            },
            bA: function() {
                return c
            },
            bI: function() {
                return h
            },
            fS: function() {
                return a
            },
            oL: function() {
                return s
            }
        });
        var n = i(28641);
        function r(t, e) {
            return t[0] += +e[0],
            t[1] += +e[1],
            t
        }
        function o(t, e) {
            const i = e.getRadius()
              , n = e.getCenter()
              , r = n[0]
              , o = n[1];
            let s = t[0] - r;
            const a = t[1] - o;
            0 === s && 0 === a && (s = 1);
            const l = Math.sqrt(s * s + a * a);
            return [r + i * s / l, o + i * a / l]
        }
        function s(t, e) {
            const i = t[0]
              , n = t[1]
              , r = e[0]
              , o = e[1]
              , s = r[0]
              , a = r[1]
              , l = o[0]
              , c = o[1]
              , h = l - s
              , u = c - a
              , d = 0 === h && 0 === u ? 0 : (h * (i - s) + u * (n - a)) / (h * h + u * u || 0);
            let f, p;
            return d <= 0 ? (f = s,
            p = a) : d >= 1 ? (f = l,
            p = c) : (f = s + d * h,
            p = a + d * u),
            [f, p]
        }
        function a(t, e) {
            let i = !0;
            for (let n = t.length - 1; n >= 0; --n)
                if (t[n] != e[n]) {
                    i = !1;
                    break
                }
            return i
        }
        function l(t, e) {
            const i = Math.cos(e)
              , n = Math.sin(e)
              , r = t[0] * i - t[1] * n
              , o = t[1] * i + t[0] * n;
            return t[0] = r,
            t[1] = o,
            t
        }
        function c(t, e) {
            return t[0] *= e,
            t[1] *= e,
            t
        }
        function h(t, e) {
            const i = t[0] - e[0]
              , n = t[1] - e[1];
            return i * i + n * n
        }
        function u(t, e) {
            return Math.sqrt(h(t, e))
        }
        function d(t, e) {
            return h(t, s(t, e))
        }
        function f(t, e) {
            if (e.canWrapX()) {
                const i = (0,
                n.dz)(e.getExtent())
                  , r = function(t, e, i) {
                    const r = e.getExtent();
                    let o = 0;
                    e.canWrapX() && (t[0] < r[0] || t[0] > r[2]) && (i = i || (0,
                    n.dz)(r),
                    o = Math.floor((t[0] - r[0]) / i));
                    return o
                }(t, e, i);
                r && (t[0] -= r * i)
            }
            return t
        }
    },
    10245: function(t, e, i) {
        "use strict";
        i.d(e, {
            $A: function() {
                return r
            },
            XV: function() {
                return o
            },
            hN: function() {
                return a
            },
            hg: function() {
                return s
            },
            oj: function() {
                return n
            },
            p: function() {
                return h
            }
        });
        const n = "ol-hidden"
          , r = "ol-selectable"
          , o = "ol-unselectable"
          , s = "ol-control"
          , a = "ol-collapsed"
          , l = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", "?\\s*([-,\\\"\\'\\sa-z]+?)\\s*$"].join(""),"i")
          , c = ["style", "variant", "weight", "size", "lineHeight", "family"]
          , h = function(t) {
            const e = t.match(l);
            if (!e)
                return null;
            const i = {
                lineHeight: "normal",
                size: "1.2em",
                style: "normal",
                weight: "normal",
                variant: "normal"
            };
            for (let t = 0, n = c.length; t < n; ++t) {
                const n = e[t + 1];
                void 0 !== n && (i[c[t]] = n)
            }
            return i.families = i.family.split(/,\s?/),
            i
        }
    },
    68326: function(t, e, i) {
        "use strict";
        i.d(e, {
            $H: function() {
                return l
            },
            E4: function() {
                return r
            },
            Pb: function() {
                return a
            },
            ZF: function() {
                return c
            },
            ep: function() {
                return h
            },
            hF: function() {
                return u
            },
            iO: function() {
                return s
            },
            jy: function() {
                return o
            }
        });
        var n = i(40177);
        function r(t, e, i, r) {
            let o;
            return o = i && i.length ? i.shift() : n.Id ? new OffscreenCanvas(t || 300,e || 300) : document.createElement("canvas"),
            t && (o.width = t),
            e && (o.height = e),
            o.getContext("2d", r)
        }
        function o(t) {
            const e = t.canvas;
            e.width = 1,
            e.height = 1,
            t.clearRect(0, 0, 1, 1)
        }
        function s(t) {
            let e = t.offsetWidth;
            const i = getComputedStyle(t);
            return e += parseInt(i.marginLeft, 10) + parseInt(i.marginRight, 10),
            e
        }
        function a(t) {
            let e = t.offsetHeight;
            const i = getComputedStyle(t);
            return e += parseInt(i.marginTop, 10) + parseInt(i.marginBottom, 10),
            e
        }
        function l(t, e) {
            const i = e.parentNode;
            i && i.replaceChild(t, e)
        }
        function c(t) {
            return t && t.parentNode ? t.parentNode.removeChild(t) : null
        }
        function h(t) {
            for (; t.lastChild; )
                t.removeChild(t.lastChild)
        }
        function u(t, e) {
            const i = t.childNodes;
            for (let n = 0; ; ++n) {
                const r = i[n]
                  , o = e[n];
                if (!r && !o)
                    break;
                r !== o && (r ? o ? t.insertBefore(o, r) : (t.removeChild(r),
                --n) : t.appendChild(o))
            }
        }
    },
    31015: function(t, e, i) {
        "use strict";
        function n(t) {
            return 1 - function(t) {
                return Math.pow(t, 3)
            }(1 - t)
        }
        function r(t) {
            return 3 * t * t - 2 * t * t * t
        }
        function o(t) {
            return t
        }
        i.d(e, {
            GE: function() {
                return o
            },
            Vv: function() {
                return n
            },
            rd: function() {
                return r
            }
        })
    },
    65818: function(t, e, i) {
        "use strict";
        i.d(e, {
            Vx: function() {
                return o
            },
            bN: function() {
                return s
            },
            oL: function() {
                return r
            }
        });
        var n = i(69374);
        function r(t, e, i, n, r) {
            if (n && n !== t && (i = i.bind(n)),
            r) {
                const n = i;
                i = function() {
                    t.removeEventListener(e, i),
                    n.apply(this, arguments)
                }
            }
            const o = {
                target: t,
                type: e,
                listener: i
            };
            return t.addEventListener(e, i),
            o
        }
        function o(t, e, i, n) {
            return r(t, e, i, n, !0)
        }
        function s(t) {
            t && t.target && (t.target.removeEventListener(t.type, t.listener),
            (0,
            n.Z)(t))
        }
    },
    291: function(t, e, i) {
        "use strict";
        e.ZP = class {
            constructor(t) {
                this.propagationStopped,
                this.defaultPrevented,
                this.type = t,
                this.target = null
            }
            preventDefault() {
                this.defaultPrevented = !0
            }
            stopPropagation() {
                this.propagationStopped = !0
            }
        }
    },
    85487: function(t, e) {
        "use strict";
        e.Z = {
            CHANGE: "change",
            ERROR: "error",
            BLUR: "blur",
            CLEAR: "clear",
            CONTEXTMENU: "contextmenu",
            CLICK: "click",
            DBLCLICK: "dblclick",
            DRAGENTER: "dragenter",
            DRAGOVER: "dragover",
            DROP: "drop",
            FOCUS: "focus",
            KEYDOWN: "keydown",
            KEYPRESS: "keypress",
            LOAD: "load",
            RESIZE: "resize",
            TOUCHMOVE: "touchmove",
            WHEEL: "wheel"
        }
    },
    208: function(t, e, i) {
        "use strict";
        var n = i(55431)
          , r = i(291)
          , o = i(36885)
          , s = i(69374);
        class a extends n.Z {
            constructor(t) {
                super(),
                this.eventTarget_ = t,
                this.pendingRemovals_ = null,
                this.dispatching_ = null,
                this.listeners_ = null
            }
            addEventListener(t, e) {
                if (!t || !e)
                    return;
                const i = this.listeners_ || (this.listeners_ = {})
                  , n = i[t] || (i[t] = []);
                n.includes(e) || n.push(e)
            }
            dispatchEvent(t) {
                const e = "string" == typeof t
                  , i = e ? t : t.type
                  , n = this.listeners_ && this.listeners_[i];
                if (!n)
                    return;
                const s = e ? new r.ZP(t) : t;
                s.target || (s.target = this.eventTarget_ || this);
                const a = this.dispatching_ || (this.dispatching_ = {})
                  , l = this.pendingRemovals_ || (this.pendingRemovals_ = {});
                let c;
                i in a || (a[i] = 0,
                l[i] = 0),
                ++a[i];
                for (let t = 0, e = n.length; t < e; ++t)
                    if (c = "handleEvent"in n[t] ? n[t].handleEvent(s) : n[t].call(this, s),
                    !1 === c || s.propagationStopped) {
                        c = !1;
                        break
                    }
                if (0 == --a[i]) {
                    let t = l[i];
                    for (delete l[i]; t--; )
                        this.removeEventListener(i, o.Zn);
                    delete a[i]
                }
                return c
            }
            disposeInternal() {
                this.listeners_ && (0,
                s.Z)(this.listeners_)
            }
            getListeners(t) {
                return this.listeners_ && this.listeners_[t] || void 0
            }
            hasListener(t) {
                return !!this.listeners_ && (t ? t in this.listeners_ : Object.keys(this.listeners_).length > 0)
            }
            removeEventListener(t, e) {
                const i = this.listeners_ && this.listeners_[t];
                if (i) {
                    const n = i.indexOf(e);
                    -1 !== n && (this.pendingRemovals_ && t in this.pendingRemovals_ ? (i[n] = o.Zn,
                    ++this.pendingRemovals_[t]) : (i.splice(n, 1),
                    0 === i.length && delete this.listeners_[t]))
                }
            }
        }
        e.Z = a
    },
    98683: function(t, e, i) {
        "use strict";
        i.d(e, {
            $6: function() {
                return a
            },
            Bx: function() {
                return u
            },
            Fi: function() {
                return f
            },
            Kf: function() {
                return m
            },
            Ko: function() {
                return l
            },
            MJ: function() {
                return p
            },
            QL: function() {
                return v
            },
            TN: function() {
                return y
            },
            Xp: function() {
                return x
            },
            aj: function() {
                return c
            },
            rM: function() {
                return g
            },
            v8: function() {
                return d
            },
            vY: function() {
                return _
            },
            yZ: function() {
                return h
            }
        });
        var n = i(92217)
          , r = i(36885)
          , o = i(40177)
          , s = i(99515);
        function a(t) {
            const e = arguments;
            return function(t) {
                let i = !0;
                for (let n = 0, r = e.length; n < r && (i = i && e[n](t),
                i); ++n)
                    ;
                return i
            }
        }
        const l = function(t) {
            const e = t.originalEvent;
            return e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
        }
          , c = function(t) {
            const e = t.originalEvent;
            return e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
        }
          , h = function(t) {
            return !t.map.getTargetElement().hasAttribute("tabindex") || function(t) {
                const e = t.map.getTargetElement()
                  , i = t.map.getOwnerDocument().activeElement;
                return e.contains(i)
            }(t)
        }
          , u = r.uX
          , d = function(t) {
            const e = t.originalEvent;
            return 0 == e.button && !(o.G$ && o.tK && e.ctrlKey)
        }
          , f = r.Dv
          , p = function(t) {
            return "pointermove" == t.type
        }
          , m = function(t) {
            return t.type == n.Z.SINGLECLICK
        }
          , g = function(t) {
            const e = t.originalEvent;
            return !e.altKey && !(e.metaKey || e.ctrlKey) && !e.shiftKey
        }
          , _ = function(t) {
            const e = t.originalEvent;
            return !e.altKey && !(e.metaKey || e.ctrlKey) && e.shiftKey
        }
          , y = function(t) {
            const e = t.originalEvent
              , i = e.target.tagName;
            return "INPUT" !== i && "SELECT" !== i && "TEXTAREA" !== i && !e.target.isContentEditable
        }
          , v = function(t) {
            const e = t.originalEvent;
            return (0,
            s.h)(void 0 !== e, 56),
            "mouse" == e.pointerType
        }
          , x = function(t) {
            const e = t.originalEvent;
            return (0,
            s.h)(void 0 !== e, 56),
            e.isPrimary && 0 === e.button
        }
    },
    28641: function(t, e, i) {
        "use strict";
        i.d(e, {
            Cf: function() {
                return F
            },
            Cr: function() {
                return I
            },
            EO: function() {
                return L
            },
            Ed: function() {
                return M
            },
            GN: function() {
                return g
            },
            H6: function() {
                return w
            },
            HK: function() {
                return m
            },
            I7: function() {
                return B
            },
            MV: function() {
                return N
            },
            Ne: function() {
                return z
            },
            T9: function() {
                return f
            },
            Wj: function() {
                return v
            },
            Xv: function() {
                return k
            },
            YN: function() {
                return p
            },
            b8: function() {
                return l
            },
            bg: function() {
                return E
            },
            d9: function() {
                return s
            },
            dz: function() {
                return O
            },
            f3: function() {
                return o
            },
            fS: function() {
                return _
            },
            hC: function() {
                return T
            },
            hI: function() {
                return r
            },
            jE: function() {
                return h
            },
            kK: function() {
                return R
            },
            l7: function() {
                return y
            },
            lJ: function() {
                return d
            },
            p8: function() {
                return A
            },
            pX: function() {
                return u
            },
            qP: function() {
                return x
            },
            qf: function() {
                return a
            },
            qg: function() {
                return C
            },
            r4: function() {
                return c
            },
            rL: function() {
                return P
            },
            w$: function() {
                return S
            },
            xb: function() {
                return D
            }
        });
        var n = i(28716);
        function r(t) {
            const e = d();
            for (let i = 0, n = t.length; i < n; ++i)
                v(e, t[i]);
            return e
        }
        function o(t, e, i) {
            return i ? (i[0] = t[0] - e,
            i[1] = t[1] - e,
            i[2] = t[2] + e,
            i[3] = t[3] + e,
            i) : [t[0] - e, t[1] - e, t[2] + e, t[3] + e]
        }
        function s(t, e) {
            return e ? (e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e) : t.slice()
        }
        function a(t, e, i) {
            let n, r;
            return n = e < t[0] ? t[0] - e : t[2] < e ? e - t[2] : 0,
            r = i < t[1] ? t[1] - i : t[3] < i ? i - t[3] : 0,
            n * n + r * r
        }
        function l(t, e) {
            return h(t, e[0], e[1])
        }
        function c(t, e) {
            return t[0] <= e[0] && e[2] <= t[2] && t[1] <= e[1] && e[3] <= t[3]
        }
        function h(t, e, i) {
            return t[0] <= e && e <= t[2] && t[1] <= i && i <= t[3]
        }
        function u(t, e) {
            const i = t[0]
              , r = t[1]
              , o = t[2]
              , s = t[3]
              , a = e[0]
              , l = e[1];
            let c = n.Z.UNKNOWN;
            return a < i ? c |= n.Z.LEFT : a > o && (c |= n.Z.RIGHT),
            l < r ? c |= n.Z.BELOW : l > s && (c |= n.Z.ABOVE),
            c === n.Z.UNKNOWN && (c = n.Z.INTERSECTING),
            c
        }
        function d() {
            return [1 / 0, 1 / 0, -1 / 0, -1 / 0]
        }
        function f(t, e, i, n, r) {
            return r ? (r[0] = t,
            r[1] = e,
            r[2] = i,
            r[3] = n,
            r) : [t, e, i, n]
        }
        function p(t) {
            return f(1 / 0, 1 / 0, -1 / 0, -1 / 0, t)
        }
        function m(t, e) {
            const i = t[0]
              , n = t[1];
            return f(i, n, i, n, e)
        }
        function g(t, e, i, n, r) {
            return x(p(r), t, e, i, n)
        }
        function _(t, e) {
            return t[0] == e[0] && t[2] == e[2] && t[1] == e[1] && t[3] == e[3]
        }
        function y(t, e) {
            return e[0] < t[0] && (t[0] = e[0]),
            e[2] > t[2] && (t[2] = e[2]),
            e[1] < t[1] && (t[1] = e[1]),
            e[3] > t[3] && (t[3] = e[3]),
            t
        }
        function v(t, e) {
            e[0] < t[0] && (t[0] = e[0]),
            e[0] > t[2] && (t[2] = e[0]),
            e[1] < t[1] && (t[1] = e[1]),
            e[1] > t[3] && (t[3] = e[1])
        }
        function x(t, e, i, n, r) {
            for (; i < n; i += r)
                b(t, e[i], e[i + 1]);
            return t
        }
        function b(t, e, i) {
            t[0] = Math.min(t[0], e),
            t[1] = Math.min(t[1], i),
            t[2] = Math.max(t[2], e),
            t[3] = Math.max(t[3], i)
        }
        function w(t, e) {
            let i;
            return i = e(T(t)),
            i || (i = e(S(t)),
            i || (i = e(k(t)),
            i || (i = e(P(t)),
            i || !1)))
        }
        function E(t) {
            let e = 0;
            return D(t) || (e = O(t) * I(t)),
            e
        }
        function T(t) {
            return [t[0], t[1]]
        }
        function S(t) {
            return [t[2], t[1]]
        }
        function C(t) {
            return [(t[0] + t[2]) / 2, (t[1] + t[3]) / 2]
        }
        function A(t, e, i, n, r) {
            const [o,s,a,l,c,h,u,d] = function(t, e, i, n) {
                const r = e * n[0] / 2
                  , o = e * n[1] / 2
                  , s = Math.cos(i)
                  , a = Math.sin(i)
                  , l = r * s
                  , c = r * a
                  , h = o * s
                  , u = o * a
                  , d = t[0]
                  , f = t[1];
                return [d - l + u, f - c - h, d - l - u, f - c + h, d + l - u, f + c + h, d + l + u, f + c - h, d - l + u, f - c - h]
            }(t, e, i, n);
            return f(Math.min(o, a, c, u), Math.min(s, l, h, d), Math.max(o, a, c, u), Math.max(s, l, h, d), r)
        }
        function I(t) {
            return t[3] - t[1]
        }
        function M(t, e, i) {
            const n = i || [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            return R(t, e) ? (t[0] > e[0] ? n[0] = t[0] : n[0] = e[0],
            t[1] > e[1] ? n[1] = t[1] : n[1] = e[1],
            t[2] < e[2] ? n[2] = t[2] : n[2] = e[2],
            t[3] < e[3] ? n[3] = t[3] : n[3] = e[3]) : p(n),
            n
        }
        function P(t) {
            return [t[0], t[3]]
        }
        function k(t) {
            return [t[2], t[3]]
        }
        function O(t) {
            return t[2] - t[0]
        }
        function R(t, e) {
            return t[0] <= e[2] && t[2] >= e[0] && t[1] <= e[3] && t[3] >= e[1]
        }
        function D(t) {
            return t[2] < t[0] || t[3] < t[1]
        }
        function L(t, e) {
            return e ? (e[0] = t[0],
            e[1] = t[1],
            e[2] = t[2],
            e[3] = t[3],
            e) : t
        }
        function B(t, e, i) {
            let r = !1;
            const o = u(t, e)
              , s = u(t, i);
            if (o === n.Z.INTERSECTING || s === n.Z.INTERSECTING)
                r = !0;
            else {
                const a = t[0]
                  , l = t[1]
                  , c = t[2]
                  , h = t[3]
                  , u = e[0]
                  , d = e[1]
                  , f = i[0]
                  , p = i[1]
                  , m = (p - d) / (f - u);
                let g, _;
                s & n.Z.ABOVE && !(o & n.Z.ABOVE) && (g = f - (p - h) / m,
                r = g >= a && g <= c),
                r || !(s & n.Z.RIGHT) || o & n.Z.RIGHT || (_ = p - (f - c) * m,
                r = _ >= l && _ <= h),
                r || !(s & n.Z.BELOW) || o & n.Z.BELOW || (g = f - (p - l) / m,
                r = g >= a && g <= c),
                r || !(s & n.Z.LEFT) || o & n.Z.LEFT || (_ = p - (f - a) * m,
                r = _ >= l && _ <= h)
            }
            return r
        }
        function z(t, e, i, n) {
            if (D(t))
                return p(i);
            let r = [];
            if (n > 1) {
                const e = t[2] - t[0]
                  , i = t[3] - t[1];
                for (let o = 0; o < n; ++o)
                    r.push(t[0] + e * o / n, t[1], t[2], t[1] + i * o / n, t[2] - e * o / n, t[3], t[0], t[3] - i * o / n)
            } else
                r = [t[0], t[1], t[2], t[1], t[2], t[3], t[0], t[3]];
            e(r, r, 2);
            const o = []
              , s = [];
            for (let t = 0, e = r.length; t < e; t += 2)
                o.push(r[t]),
                s.push(r[t + 1]);
            return function(t, e, i) {
                return f(Math.min.apply(null, t), Math.min.apply(null, e), Math.max.apply(null, t), Math.max.apply(null, e), i)
            }(o, s, i)
        }
        function F(t, e) {
            const i = e.getExtent()
              , n = C(t);
            if (e.canWrapX() && (n[0] < i[0] || n[0] >= i[2])) {
                const e = O(i)
                  , r = Math.floor((n[0] - i[0]) / e) * e;
                t[0] -= r,
                t[2] -= r
            }
            return t
        }
        function N(t, e) {
            if (e.canWrapX()) {
                const i = e.getExtent();
                if (!isFinite(t[0]) || !isFinite(t[2]))
                    return [[i[0], t[1], i[2], t[3]]];
                F(t, e);
                const n = O(i);
                if (O(t) > n)
                    return [[i[0], t[1], i[2], t[3]]];
                if (t[0] < i[0])
                    return [[t[0] + n, t[1], i[2], t[3]], [i[0], t[1], t[2], t[3]]];
                if (t[2] > i[2])
                    return [[t[0], t[1], i[2], t[3]], [i[0], t[1], t[2] - n, t[3]]]
            }
            return [t]
        }
    },
    28716: function(t, e) {
        "use strict";
        e.Z = {
            UNKNOWN: 0,
            INTERSECTING: 1,
            ABOVE: 2,
            RIGHT: 4,
            BELOW: 8,
            LEFT: 16
        }
    },
    36885: function(t, e, i) {
        "use strict";
        i.d(e, {
            Dv: function() {
                return o
            },
            Zn: function() {
                return s
            },
            qe: function() {
                return a
            },
            uX: function() {
                return r
            }
        });
        var n = i(65537);
        function r() {
            return !0
        }
        function o() {
            return !1
        }
        function s() {}
        function a(t) {
            let e, i, r, o = !1;
            return function() {
                const s = Array.prototype.slice.call(arguments);
                return o && this === r && (0,
                n.fS)(s, i) || (o = !0,
                r = this,
                i = s,
                e = t.apply(this, arguments)),
                e
            }
        }
    },
    57276: function(t, e, i) {
        "use strict";
        var n = i(72967)
          , r = i(28641)
          , o = i(18527)
          , s = i(76442);
        class a extends n.ZP {
            constructor(t, e, i) {
                super(),
                void 0 !== i && void 0 === e ? this.setFlatCoordinates(i, t) : (e = e || 0,
                this.setCenterAndRadius(t, e, i))
            }
            clone() {
                const t = new a(this.flatCoordinates.slice(),void 0,this.layout);
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                const r = this.flatCoordinates
                  , o = t - r[0]
                  , s = e - r[1]
                  , a = o * o + s * s;
                if (a < n) {
                    if (0 === a)
                        for (let t = 0; t < this.stride; ++t)
                            i[t] = r[t];
                    else {
                        const t = this.getRadius() / Math.sqrt(a);
                        i[0] = r[0] + t * o,
                        i[1] = r[1] + t * s;
                        for (let t = 2; t < this.stride; ++t)
                            i[t] = r[t]
                    }
                    return i.length = this.stride,
                    a
                }
                return n
            }
            containsXY(t, e) {
                const i = this.flatCoordinates
                  , n = t - i[0]
                  , r = e - i[1];
                return n * n + r * r <= this.getRadiusSquared_()
            }
            getCenter() {
                return this.flatCoordinates.slice(0, this.stride)
            }
            computeExtent(t) {
                const e = this.flatCoordinates
                  , i = e[this.stride] - e[0];
                return (0,
                r.T9)(e[0] - i, e[1] - i, e[0] + i, e[1] + i, t)
            }
            getRadius() {
                return Math.sqrt(this.getRadiusSquared_())
            }
            getRadiusSquared_() {
                const t = this.flatCoordinates[this.stride] - this.flatCoordinates[0]
                  , e = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
                return t * t + e * e
            }
            getType() {
                return "Circle"
            }
            intersectsExtent(t) {
                const e = this.getExtent();
                if ((0,
                r.kK)(t, e)) {
                    const e = this.getCenter();
                    return t[0] <= e[0] && t[2] >= e[0] || (t[1] <= e[1] && t[3] >= e[1] || (0,
                    r.H6)(t, this.intersectsCoordinate.bind(this)))
                }
                return !1
            }
            setCenter(t) {
                const e = this.stride
                  , i = this.flatCoordinates[e] - this.flatCoordinates[0]
                  , n = t.slice();
                n[e] = n[0] + i;
                for (let i = 1; i < e; ++i)
                    n[e + i] = t[i];
                this.setFlatCoordinates(this.layout, n),
                this.changed()
            }
            setCenterAndRadius(t, e, i) {
                this.setLayout(i, t, 0),
                this.flatCoordinates || (this.flatCoordinates = []);
                const n = this.flatCoordinates;
                let r = (0,
                o.IG)(n, 0, t, this.stride);
                n[r++] = n[0] + e;
                for (let t = 1, e = this.stride; t < e; ++t)
                    n[r++] = n[t];
                n.length = r,
                this.changed()
            }
            getCoordinates() {
                return null
            }
            setCoordinates(t, e) {}
            setRadius(t) {
                this.flatCoordinates[this.stride] = this.flatCoordinates[0] + t,
                this.changed()
            }
            rotate(t, e) {
                const i = this.getCenter()
                  , n = this.getStride();
                this.setCenter((0,
                s.U1)(i, 0, i.length, n, t, e, i)),
                this.changed()
            }
        }
        a.prototype.transform,
        e.Z = a
    },
    71694: function(t, e, i) {
        "use strict";
        var n = i(72971)
          , r = i(74187)
          , o = i(6101)
          , s = i(28641)
          , a = i(26835)
          , l = i(36885)
          , c = i(76442);
        const h = (0,
        o.Ue)();
        class u extends n.Z {
            constructor() {
                super(),
                this.extent_ = (0,
                s.lJ)(),
                this.extentRevision_ = -1,
                this.simplifiedGeometryMaxMinSquaredTolerance = 0,
                this.simplifiedGeometryRevision = 0,
                this.simplifyTransformedInternal = (0,
                l.qe)((function(t, e, i) {
                    if (!i)
                        return this.getSimplifiedGeometry(e);
                    const n = this.clone();
                    return n.applyTransform(i),
                    n.getSimplifiedGeometry(e)
                }
                ))
            }
            simplifyTransformed(t, e) {
                return this.simplifyTransformedInternal(this.getRevision(), t, e)
            }
            clone() {
                return (0,
                r.O3)()
            }
            closestPointXY(t, e, i, n) {
                return (0,
                r.O3)()
            }
            containsXY(t, e) {
                const i = this.getClosestPoint([t, e]);
                return i[0] === t && i[1] === e
            }
            getClosestPoint(t, e) {
                return e = e || [NaN, NaN],
                this.closestPointXY(t[0], t[1], e, 1 / 0),
                e
            }
            intersectsCoordinate(t) {
                return this.containsXY(t[0], t[1])
            }
            computeExtent(t) {
                return (0,
                r.O3)()
            }
            getExtent(t) {
                if (this.extentRevision_ != this.getRevision()) {
                    const t = this.computeExtent(this.extent_);
                    (isNaN(t[0]) || isNaN(t[1])) && (0,
                    s.YN)(t),
                    this.extentRevision_ = this.getRevision()
                }
                return (0,
                s.EO)(this.extent_, t)
            }
            rotate(t, e) {
                (0,
                r.O3)()
            }
            scale(t, e, i) {
                (0,
                r.O3)()
            }
            simplify(t) {
                return this.getSimplifiedGeometry(t * t)
            }
            getSimplifiedGeometry(t) {
                return (0,
                r.O3)()
            }
            getType() {
                return (0,
                r.O3)()
            }
            applyTransform(t) {
                (0,
                r.O3)()
            }
            intersectsExtent(t) {
                return (0,
                r.O3)()
            }
            translate(t, e) {
                (0,
                r.O3)()
            }
            transform(t, e) {
                const i = (0,
                a.U2)(t)
                  , n = "tile-pixels" == i.getUnits() ? function(t, n, r) {
                    const l = i.getExtent()
                      , u = i.getWorldExtent()
                      , d = (0,
                    s.Cr)(u) / (0,
                    s.Cr)(l);
                    return (0,
                    o.qC)(h, u[0], u[3], d, -d, 0, 0, 0),
                    (0,
                    c.vT)(t, 0, t.length, r, h, n),
                    (0,
                    a.Ck)(i, e)(t, n, r)
                }
                : (0,
                a.Ck)(i, e);
                return this.applyTransform(n),
                this
            }
        }
        e.Z = u
    },
    92083: function(t, e, i) {
        "use strict";
        var n = i(72967)
          , r = i(53042)
          , o = i(28641)
          , s = i(18527)
          , a = i(80226)
          , l = i(65537)
          , c = i(93032)
          , h = i(89241)
          , u = i(49405)
          , d = i(63746)
          , f = i(27374);
        class p extends n.ZP {
            constructor(t, e) {
                super(),
                this.flatMidpoint_ = null,
                this.flatMidpointRevision_ = -1,
                this.maxDelta_ = -1,
                this.maxDeltaRevision_ = -1,
                void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t)
            }
            appendCoordinate(t) {
                this.flatCoordinates ? (0,
                l.l7)(this.flatCoordinates, t) : this.flatCoordinates = t.slice(),
                this.changed()
            }
            clone() {
                const t = new p(this.flatCoordinates.slice(),this.layout);
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                return n < (0,
                o.qf)(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,
                r.Bv)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)),
                this.maxDeltaRevision_ = this.getRevision()),
                (0,
                r.H$)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, t, e, i, n))
            }
            forEachSegment(t) {
                return (0,
                c.E)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
            }
            getCoordinateAtM(t, e) {
                return "XYM" != this.layout && "XYZM" != this.layout ? null : (e = void 0 !== e && e,
                (0,
                u.iJ)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e))
            }
            getCoordinates() {
                return (0,
                h.Ml)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
            }
            getCoordinateAt(t, e) {
                return (0,
                u.WW)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, this.stride)
            }
            getLength() {
                return (0,
                f.W)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
            }
            getFlatMidpoint() {
                return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_),
                this.flatMidpointRevision_ = this.getRevision()),
                this.flatMidpoint_
            }
            getSimplifiedGeometryInternal(t) {
                const e = [];
                return e.length = (0,
                a.dt)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0),
                new p(e,"XY")
            }
            getType() {
                return "LineString"
            }
            intersectsExtent(t) {
                return (0,
                d.Kz)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 1),
                this.flatCoordinates || (this.flatCoordinates = []),
                this.flatCoordinates.length = (0,
                s.Sg)(this.flatCoordinates, 0, t, this.stride),
                this.changed()
            }
        }
        e.Z = p
    },
    36259: function(t, e, i) {
        "use strict";
        var n = i(60188)
          , r = i(72967)
          , o = i(28641)
          , s = i(18527)
          , a = i(65537)
          , l = i(89241)
          , c = i(33983);
        class h extends r.ZP {
            constructor(t, e) {
                super(),
                e && !Array.isArray(t[0]) ? this.setFlatCoordinates(e, t) : this.setCoordinates(t, e)
            }
            appendPoint(t) {
                this.flatCoordinates ? (0,
                a.l7)(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
                this.changed()
            }
            clone() {
                const t = new h(this.flatCoordinates.slice(),this.layout);
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                if (n < (0,
                o.qf)(this.getExtent(), t, e))
                    return n;
                const r = this.flatCoordinates
                  , s = this.stride;
                for (let o = 0, a = r.length; o < a; o += s) {
                    const a = (0,
                    c.bI)(t, e, r[o], r[o + 1]);
                    if (a < n) {
                        n = a;
                        for (let t = 0; t < s; ++t)
                            i[t] = r[o + t];
                        i.length = s
                    }
                }
                return n
            }
            getCoordinates() {
                return (0,
                l.Ml)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
            }
            getPoint(t) {
                const e = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
                return t < 0 || e <= t ? null : new n.Z(this.flatCoordinates.slice(t * this.stride, (t + 1) * this.stride),this.layout)
            }
            getPoints() {
                const t = this.flatCoordinates
                  , e = this.layout
                  , i = this.stride
                  , r = [];
                for (let o = 0, s = t.length; o < s; o += i) {
                    const s = new n.Z(t.slice(o, o + i),e);
                    r.push(s)
                }
                return r
            }
            getType() {
                return "MultiPoint"
            }
            intersectsExtent(t) {
                const e = this.flatCoordinates
                  , i = this.stride;
                for (let n = 0, r = e.length; n < r; n += i) {
                    const i = e[n]
                      , r = e[n + 1];
                    if ((0,
                    o.jE)(t, i, r))
                        return !0
                }
                return !1
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 1),
                this.flatCoordinates || (this.flatCoordinates = []),
                this.flatCoordinates.length = (0,
                s.Sg)(this.flatCoordinates, 0, t, this.stride),
                this.changed()
            }
        }
        e.Z = h
    },
    60188: function(t, e, i) {
        "use strict";
        var n = i(72967)
          , r = i(28641)
          , o = i(18527)
          , s = i(33983);
        class a extends n.ZP {
            constructor(t, e) {
                super(),
                this.setCoordinates(t, e)
            }
            clone() {
                const t = new a(this.flatCoordinates.slice(),this.layout);
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                const r = this.flatCoordinates
                  , o = (0,
                s.bI)(t, e, r[0], r[1]);
                if (o < n) {
                    const t = this.stride;
                    for (let e = 0; e < t; ++e)
                        i[e] = r[e];
                    return i.length = t,
                    o
                }
                return n
            }
            getCoordinates() {
                return this.flatCoordinates ? this.flatCoordinates.slice() : []
            }
            computeExtent(t) {
                return (0,
                r.HK)(this.flatCoordinates, t)
            }
            getType() {
                return "Point"
            }
            intersectsExtent(t) {
                return (0,
                r.jE)(t, this.flatCoordinates[0], this.flatCoordinates[1])
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 0),
                this.flatCoordinates || (this.flatCoordinates = []),
                this.flatCoordinates.length = (0,
                o.IG)(this.flatCoordinates, 0, t, this.stride),
                this.changed()
            }
        }
        e.Z = a
    },
    69242: function(t, e, i) {
        "use strict";
        i.d(e, {
            ZP: function() {
                return x
            },
            Bb: function() {
                return w
            },
            oJ: function() {
                return b
            }
        });
        var n = i(72967)
          , r = i(53042)
          , o = i(28641)
          , s = i(18527)
          , a = i(80226)
          , l = i(89241)
          , c = i(14078);
        class h extends n.ZP {
            constructor(t, e) {
                super(),
                this.maxDelta_ = -1,
                this.maxDeltaRevision_ = -1,
                void 0 === e || Array.isArray(t[0]) ? this.setCoordinates(t, e) : this.setFlatCoordinates(e, t)
            }
            clone() {
                return new h(this.flatCoordinates.slice(),this.layout)
            }
            closestPointXY(t, e, i, n) {
                return n < (0,
                o.qf)(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,
                r.Bv)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)),
                this.maxDeltaRevision_ = this.getRevision()),
                (0,
                r.H$)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, t, e, i, n))
            }
            getArea() {
                return (0,
                c.QQ)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
            }
            getCoordinates() {
                return (0,
                l.Ml)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
            }
            getSimplifiedGeometryInternal(t) {
                const e = [];
                return e.length = (0,
                a.dt)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t, e, 0),
                new h(e,"XY")
            }
            getType() {
                return "LinearRing"
            }
            intersectsExtent(t) {
                return !1
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 1),
                this.flatCoordinates || (this.flatCoordinates = []),
                this.flatCoordinates.length = (0,
                s.Sg)(this.flatCoordinates, 0, t, this.stride),
                this.changed()
            }
        }
        var u = h
          , d = i(60188)
          , f = i(65537)
          , p = i(73448)
          , m = i(63746)
          , g = i(74772)
          , _ = i(79679)
          , y = i(33983);
        class v extends n.ZP {
            constructor(t, e, i) {
                super(),
                this.ends_ = [],
                this.flatInteriorPointRevision_ = -1,
                this.flatInteriorPoint_ = null,
                this.maxDelta_ = -1,
                this.maxDeltaRevision_ = -1,
                this.orientedRevision_ = -1,
                this.orientedFlatCoordinates_ = null,
                void 0 !== e && i ? (this.setFlatCoordinates(e, t),
                this.ends_ = i) : this.setCoordinates(t, e)
            }
            appendLinearRing(t) {
                this.flatCoordinates ? (0,
                f.l7)(this.flatCoordinates, t.getFlatCoordinates()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
                this.ends_.push(this.flatCoordinates.length),
                this.changed()
            }
            clone() {
                const t = new v(this.flatCoordinates.slice(),this.layout,this.ends_.slice());
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                return n < (0,
                o.qf)(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,
                r.Af)(this.flatCoordinates, 0, this.ends_, this.stride, 0)),
                this.maxDeltaRevision_ = this.getRevision()),
                (0,
                r.Xl)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, t, e, i, n))
            }
            containsXY(t, e) {
                return (0,
                _.wY)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, e)
            }
            getArea() {
                return (0,
                c.KP)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride)
            }
            getCoordinates(t) {
                let e;
                return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(),
                (0,
                g.zX)(e, 0, this.ends_, this.stride, t)) : e = this.flatCoordinates,
                (0,
                l.o1)(e, 0, this.ends_, this.stride)
            }
            getEnds() {
                return this.ends_
            }
            getFlatInteriorPoint() {
                if (this.flatInteriorPointRevision_ != this.getRevision()) {
                    const t = (0,
                    o.qg)(this.getExtent());
                    this.flatInteriorPoint_ = (0,
                    p.X)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t, 0),
                    this.flatInteriorPointRevision_ = this.getRevision()
                }
                return this.flatInteriorPoint_
            }
            getInteriorPoint() {
                return new d.Z(this.getFlatInteriorPoint(),"XYM")
            }
            getLinearRingCount() {
                return this.ends_.length
            }
            getLinearRing(t) {
                return t < 0 || this.ends_.length <= t ? null : new u(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]),this.layout)
            }
            getLinearRings() {
                const t = this.layout
                  , e = this.flatCoordinates
                  , i = this.ends_
                  , n = [];
                let r = 0;
                for (let o = 0, s = i.length; o < s; ++o) {
                    const s = i[o]
                      , a = new u(e.slice(r, s),t);
                    n.push(a),
                    r = s
                }
                return n
            }
            getOrientedFlatCoordinates() {
                if (this.orientedRevision_ != this.getRevision()) {
                    const t = this.flatCoordinates;
                    (0,
                    g.$v)(t, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(),
                    this.orientedFlatCoordinates_.length = (0,
                    g.zX)(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)),
                    this.orientedRevision_ = this.getRevision()
                }
                return this.orientedFlatCoordinates_
            }
            getSimplifiedGeometryInternal(t) {
                const e = []
                  , i = [];
                return e.length = (0,
                a.Zh)(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(t), e, 0, i),
                new v(e,"XY",i)
            }
            getType() {
                return "Polygon"
            }
            intersectsExtent(t) {
                return (0,
                m.ac)(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, t)
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 2),
                this.flatCoordinates || (this.flatCoordinates = []);
                const i = (0,
                s._5)(this.flatCoordinates, 0, t, this.stride, this.ends_);
                this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1],
                this.changed()
            }
        }
        var x = v;
        function b(t) {
            const e = t[0]
              , i = t[1]
              , n = t[2]
              , r = t[3]
              , o = [e, i, e, r, n, r, n, i, e, i];
            return new v(o,"XY",[o.length])
        }
        function w(t, e, i) {
            e = e || 32;
            const n = t.getStride()
              , r = t.getLayout()
              , o = t.getCenter()
              , s = n * (e + 1)
              , a = new Array(s);
            for (let t = 0; t < s; t += n) {
                a[t] = 0,
                a[t + 1] = 0;
                for (let e = 2; e < n; e++)
                    a[t + e] = o[e]
            }
            const l = [a.length]
              , c = new v(a,r,l);
            return function(t, e, i, n) {
                const r = t.getFlatCoordinates()
                  , o = t.getStride()
                  , s = r.length / o - 1
                  , a = n || 0;
                for (let t = 0; t <= s; ++t) {
                    const n = t * o
                      , l = a + 2 * (0,
                    y.$W)(t, s) * Math.PI / s;
                    r[n] = e[0] + i * Math.cos(l),
                    r[n + 1] = e[1] + i * Math.sin(l)
                }
                t.changed()
            }(c, o, t.getRadius(), i),
            c
        }
    },
    72967: function(t, e, i) {
        "use strict";
        i.d(e, {
            Kr: function() {
                return c
            },
            tP: function() {
                return l
            }
        });
        var n = i(71694)
          , r = i(74187)
          , o = i(28641)
          , s = i(76442);
        class a extends n.Z {
            constructor() {
                super(),
                this.layout = "XY",
                this.stride = 2,
                this.flatCoordinates = null
            }
            computeExtent(t) {
                return (0,
                o.GN)(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, t)
            }
            getCoordinates() {
                return (0,
                r.O3)()
            }
            getFirstCoordinate() {
                return this.flatCoordinates.slice(0, this.stride)
            }
            getFlatCoordinates() {
                return this.flatCoordinates
            }
            getLastCoordinate() {
                return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride)
            }
            getLayout() {
                return this.layout
            }
            getSimplifiedGeometry(t) {
                if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0,
                this.simplifiedGeometryRevision = this.getRevision()),
                t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t <= this.simplifiedGeometryMaxMinSquaredTolerance)
                    return this;
                const e = this.getSimplifiedGeometryInternal(t);
                return e.getFlatCoordinates().length < this.flatCoordinates.length ? e : (this.simplifiedGeometryMaxMinSquaredTolerance = t,
                this)
            }
            getSimplifiedGeometryInternal(t) {
                return this
            }
            getStride() {
                return this.stride
            }
            setFlatCoordinates(t, e) {
                this.stride = l(t),
                this.layout = t,
                this.flatCoordinates = e
            }
            setCoordinates(t, e) {
                (0,
                r.O3)()
            }
            setLayout(t, e, i) {
                let n;
                if (t)
                    n = l(t);
                else {
                    for (let t = 0; t < i; ++t) {
                        if (0 === e.length)
                            return this.layout = "XY",
                            void (this.stride = 2);
                        e = e[0]
                    }
                    n = e.length,
                    t = function(t) {
                        let e;
                        2 == t ? e = "XY" : 3 == t ? e = "XYZ" : 4 == t && (e = "XYZM");
                        return e
                    }(n)
                }
                this.layout = t,
                this.stride = n
            }
            applyTransform(t) {
                this.flatCoordinates && (t(this.flatCoordinates, this.flatCoordinates, this.stride),
                this.changed())
            }
            rotate(t, e) {
                const i = this.getFlatCoordinates();
                if (i) {
                    const n = this.getStride();
                    (0,
                    s.U1)(i, 0, i.length, n, t, e, i),
                    this.changed()
                }
            }
            scale(t, e, i) {
                void 0 === e && (e = t),
                i || (i = (0,
                o.qg)(this.getExtent()));
                const n = this.getFlatCoordinates();
                if (n) {
                    const r = this.getStride();
                    (0,
                    s.bA)(n, 0, n.length, r, t, e, i, n),
                    this.changed()
                }
            }
            translate(t, e) {
                const i = this.getFlatCoordinates();
                if (i) {
                    const n = this.getStride();
                    (0,
                    s.Iu)(i, 0, i.length, n, t, e, i),
                    this.changed()
                }
            }
        }
        function l(t) {
            let e;
            return "XY" == t ? e = 2 : "XYZ" == t || "XYM" == t ? e = 3 : "XYZM" == t && (e = 4),
            e
        }
        function c(t, e, i) {
            const n = t.getFlatCoordinates();
            if (!n)
                return null;
            const r = t.getStride();
            return (0,
            s.vT)(n, 0, n.length, r, e, i)
        }
        e.ZP = a
    },
    14078: function(t, e, i) {
        "use strict";
        function n(t, e, i, n) {
            let r = 0
              , o = t[i - n]
              , s = t[i - n + 1];
            for (; e < i; e += n) {
                const i = t[e]
                  , n = t[e + 1];
                r += s * i - o * n,
                o = i,
                s = n
            }
            return r / 2
        }
        function r(t, e, i, r) {
            let o = 0;
            for (let s = 0, a = i.length; s < a; ++s) {
                const a = i[s];
                o += n(t, e, a, r),
                e = a
            }
            return o
        }
        function o(t, e, i, n) {
            let o = 0;
            for (let s = 0, a = i.length; s < a; ++s) {
                const a = i[s];
                o += r(t, e, a, n),
                e = a[a.length - 1]
            }
            return o
        }
        i.d(e, {
            Eu: function() {
                return o
            },
            KP: function() {
                return r
            },
            QQ: function() {
                return n
            }
        })
    },
    53042: function(t, e, i) {
        "use strict";
        i.d(e, {
            Af: function() {
                return s
            },
            Bv: function() {
                return o
            },
            H$: function() {
                return l
            },
            Xl: function() {
                return c
            },
            gI: function() {
                return h
            },
            sD: function() {
                return a
            }
        });
        var n = i(33983);
        function r(t, e, i, r, o, s, a) {
            const l = t[e]
              , c = t[e + 1]
              , h = t[i] - l
              , u = t[i + 1] - c;
            let d;
            if (0 === h && 0 === u)
                d = e;
            else {
                const f = ((o - l) * h + (s - c) * u) / (h * h + u * u);
                if (f > 1)
                    d = i;
                else {
                    if (f > 0) {
                        for (let o = 0; o < r; ++o)
                            a[o] = (0,
                            n.t7)(t[e + o], t[i + o], f);
                        return void (a.length = r)
                    }
                    d = e
                }
            }
            for (let e = 0; e < r; ++e)
                a[e] = t[d + e];
            a.length = r
        }
        function o(t, e, i, r, o) {
            let s = t[e]
              , a = t[e + 1];
            for (e += r; e < i; e += r) {
                const i = t[e]
                  , r = t[e + 1]
                  , l = (0,
                n.bI)(s, a, i, r);
                l > o && (o = l),
                s = i,
                a = r
            }
            return o
        }
        function s(t, e, i, n, r) {
            for (let s = 0, a = i.length; s < a; ++s) {
                const a = i[s];
                r = o(t, e, a, n, r),
                e = a
            }
            return r
        }
        function a(t, e, i, n, r) {
            for (let o = 0, a = i.length; o < a; ++o) {
                const a = i[o];
                r = s(t, e, a, n, r),
                e = a[a.length - 1]
            }
            return r
        }
        function l(t, e, i, o, s, a, l, c, h, u, d) {
            if (e == i)
                return u;
            let f, p;
            if (0 === s) {
                if (p = (0,
                n.bI)(l, c, t[e], t[e + 1]),
                p < u) {
                    for (f = 0; f < o; ++f)
                        h[f] = t[e + f];
                    return h.length = o,
                    p
                }
                return u
            }
            d = d || [NaN, NaN];
            let m = e + o;
            for (; m < i; )
                if (r(t, m - o, m, o, l, c, d),
                p = (0,
                n.bI)(l, c, d[0], d[1]),
                p < u) {
                    for (u = p,
                    f = 0; f < o; ++f)
                        h[f] = d[f];
                    h.length = o,
                    m += o
                } else
                    m += o * Math.max((Math.sqrt(p) - Math.sqrt(u)) / s | 0, 1);
            if (a && (r(t, i - o, e, o, l, c, d),
            p = (0,
            n.bI)(l, c, d[0], d[1]),
            p < u)) {
                for (u = p,
                f = 0; f < o; ++f)
                    h[f] = d[f];
                h.length = o
            }
            return u
        }
        function c(t, e, i, n, r, o, s, a, c, h, u) {
            u = u || [NaN, NaN];
            for (let d = 0, f = i.length; d < f; ++d) {
                const f = i[d];
                h = l(t, e, f, n, r, o, s, a, c, h, u),
                e = f
            }
            return h
        }
        function h(t, e, i, n, r, o, s, a, l, h, u) {
            u = u || [NaN, NaN];
            for (let d = 0, f = i.length; d < f; ++d) {
                const f = i[d];
                h = c(t, e, f, n, r, o, s, a, l, h, u),
                e = f[f.length - 1]
            }
            return h
        }
    },
    79679: function(t, e, i) {
        "use strict";
        i.d(e, {
            TG: function() {
                return o
            },
            Zl: function() {
                return a
            },
            uG: function() {
                return r
            },
            wY: function() {
                return s
            }
        });
        var n = i(28641);
        function r(t, e, i, r, s) {
            return !(0,
            n.H6)(s, (function(n) {
                return !o(t, e, i, r, n[0], n[1])
            }
            ))
        }
        function o(t, e, i, n, r, o) {
            let s = 0
              , a = t[i - n]
              , l = t[i - n + 1];
            for (; e < i; e += n) {
                const i = t[e]
                  , n = t[e + 1];
                l <= o ? n > o && (i - a) * (o - l) - (r - a) * (n - l) > 0 && s++ : n <= o && (i - a) * (o - l) - (r - a) * (n - l) < 0 && s--,
                a = i,
                l = n
            }
            return 0 !== s
        }
        function s(t, e, i, n, r, s) {
            if (0 === i.length)
                return !1;
            if (!o(t, e, i[0], n, r, s))
                return !1;
            for (let e = 1, a = i.length; e < a; ++e)
                if (o(t, i[e - 1], i[e], n, r, s))
                    return !1;
            return !0
        }
        function a(t, e, i, n, r, o) {
            if (0 === i.length)
                return !1;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = i[a];
                if (s(t, e, l, n, r, o))
                    return !0;
                e = l[l.length - 1]
            }
            return !1
        }
    },
    18527: function(t, e, i) {
        "use strict";
        function n(t, e, i, n) {
            for (let n = 0, r = i.length; n < r; ++n)
                t[e++] = i[n];
            return e
        }
        function r(t, e, i, n) {
            for (let r = 0, o = i.length; r < o; ++r) {
                const o = i[r];
                for (let i = 0; i < n; ++i)
                    t[e++] = o[i]
            }
            return e
        }
        function o(t, e, i, n, o) {
            o = o || [];
            let s = 0;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = r(t, e, i[a], n);
                o[s++] = l,
                e = l
            }
            return o.length = s,
            o
        }
        function s(t, e, i, n, r) {
            r = r || [];
            let s = 0;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = o(t, e, i[a], n, r[s]);
                0 === l.length && (l[0] = e),
                r[s++] = l,
                e = l[l.length - 1]
            }
            return r.length = s,
            r
        }
        i.d(e, {
            IG: function() {
                return n
            },
            QT: function() {
                return s
            },
            Sg: function() {
                return r
            },
            _5: function() {
                return o
            }
        })
    },
    89241: function(t, e, i) {
        "use strict";
        function n(t, e, i, n, r) {
            r = void 0 !== r ? r : [];
            let o = 0;
            for (let s = e; s < i; s += n)
                r[o++] = t.slice(s, s + n);
            return r.length = o,
            r
        }
        function r(t, e, i, r, o) {
            o = void 0 !== o ? o : [];
            let s = 0;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = i[a];
                o[s++] = n(t, e, l, r, o[s]),
                e = l
            }
            return o.length = s,
            o
        }
        function o(t, e, i, n, o) {
            o = void 0 !== o ? o : [];
            let s = 0;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = i[a];
                o[s++] = 1 === l.length && l[0] === e ? [] : r(t, e, l, n, o[s]),
                e = l[l.length - 1]
            }
            return o.length = s,
            o
        }
        i.d(e, {
            Ml: function() {
                return n
            },
            o1: function() {
                return r
            },
            ug: function() {
                return o
            }
        })
    },
    73448: function(t, e, i) {
        "use strict";
        i.d(e, {
            U: function() {
                return s
            },
            X: function() {
                return o
            }
        });
        var n = i(65537)
          , r = i(79679);
        function o(t, e, i, o, s, a, l) {
            let c, h, u, d, f, p, m;
            const g = s[a + 1]
              , _ = [];
            for (let n = 0, r = i.length; n < r; ++n) {
                const r = i[n];
                for (d = t[r - o],
                p = t[r - o + 1],
                c = e; c < r; c += o)
                    f = t[c],
                    m = t[c + 1],
                    (g <= p && m <= g || p <= g && g <= m) && (u = (g - p) / (m - p) * (f - d) + d,
                    _.push(u)),
                    d = f,
                    p = m
            }
            let y = NaN
              , v = -1 / 0;
            for (_.sort(n.j2),
            d = _[0],
            c = 1,
            h = _.length; c < h; ++c) {
                f = _[c];
                const n = Math.abs(f - d);
                n > v && (u = (d + f) / 2,
                (0,
                r.wY)(t, e, i, o, u, g) && (y = u,
                v = n)),
                d = f
            }
            return isNaN(y) && (y = s[a]),
            l ? (l.push(y, g, v),
            l) : [y, g, v]
        }
        function s(t, e, i, n, r) {
            let s = [];
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = i[a];
                s = o(t, e, l, n, r, 2 * a, s),
                e = l[l.length - 1]
            }
            return s
        }
    },
    49405: function(t, e, i) {
        "use strict";
        i.d(e, {
            WW: function() {
                return o
            },
            dG: function() {
                return a
            },
            iJ: function() {
                return s
            }
        });
        var n = i(65537)
          , r = i(33983);
        function o(t, e, i, o, s, a, l) {
            let c, h;
            const u = (i - e) / o;
            if (1 === u)
                c = e;
            else if (2 === u)
                c = e,
                h = s;
            else if (0 !== u) {
                let r = t[e]
                  , a = t[e + 1]
                  , l = 0;
                const u = [0];
                for (let n = e + o; n < i; n += o) {
                    const e = t[n]
                      , i = t[n + 1];
                    l += Math.sqrt((e - r) * (e - r) + (i - a) * (i - a)),
                    u.push(l),
                    r = e,
                    a = i
                }
                const d = s * l
                  , f = (0,
                n.ry)(u, d);
                f < 0 ? (h = (d - u[-f - 2]) / (u[-f - 1] - u[-f - 2]),
                c = e + (-f - 2) * o) : c = e + f * o
            }
            l = l > 1 ? l : 2,
            a = a || new Array(l);
            for (let e = 0; e < l; ++e)
                a[e] = void 0 === c ? NaN : void 0 === h ? t[c + e] : (0,
                r.t7)(t[c + e], t[c + o + e], h);
            return a
        }
        function s(t, e, i, n, o, s) {
            if (i == e)
                return null;
            let a;
            if (o < t[e + n - 1])
                return s ? (a = t.slice(e, e + n),
                a[n - 1] = o,
                a) : null;
            if (t[i - 1] < o)
                return s ? (a = t.slice(i - n, i),
                a[n - 1] = o,
                a) : null;
            if (o == t[e + n - 1])
                return t.slice(e, e + n);
            let l = e / n
              , c = i / n;
            for (; l < c; ) {
                const e = l + c >> 1;
                o < t[(e + 1) * n - 1] ? c = e : l = e + 1
            }
            const h = t[l * n - 1];
            if (o == h)
                return t.slice((l - 1) * n, (l - 1) * n + n);
            const u = (o - h) / (t[(l + 1) * n - 1] - h);
            a = [];
            for (let e = 0; e < n - 1; ++e)
                a.push((0,
                r.t7)(t[(l - 1) * n + e], t[l * n + e], u));
            return a.push(o),
            a
        }
        function a(t, e, i, n, r, o, a) {
            if (a)
                return s(t, e, i[i.length - 1], n, r, o);
            let l;
            if (r < t[n - 1])
                return o ? (l = t.slice(0, n),
                l[n - 1] = r,
                l) : null;
            if (t[t.length - 1] < r)
                return o ? (l = t.slice(t.length - n),
                l[n - 1] = r,
                l) : null;
            for (let o = 0, a = i.length; o < a; ++o) {
                const a = i[o];
                if (e != a) {
                    if (r < t[e + n - 1])
                        return null;
                    if (r <= t[a - 1])
                        return s(t, e, a, n, r, !1);
                    e = a
                }
            }
            return null
        }
    },
    63746: function(t, e, i) {
        "use strict";
        i.d(e, {
            AW: function() {
                return a
            },
            Kz: function() {
                return s
            },
            ac: function() {
                return l
            },
            oW: function() {
                return c
            }
        });
        var n = i(28641)
          , r = i(93032)
          , o = i(79679);
        function s(t, e, i, o, s) {
            const a = (0,
            n.qP)((0,
            n.lJ)(), t, e, i, o);
            return !!(0,
            n.kK)(s, a) && (!!(0,
            n.r4)(s, a) || (a[0] >= s[0] && a[2] <= s[2] || (a[1] >= s[1] && a[3] <= s[3] || (0,
            r.E)(t, e, i, o, (function(t, e) {
                return (0,
                n.I7)(s, t, e)
            }
            )))))
        }
        function a(t, e, i, n, r) {
            for (let o = 0, a = i.length; o < a; ++o) {
                if (s(t, e, i[o], n, r))
                    return !0;
                e = i[o]
            }
            return !1
        }
        function l(t, e, i, n, r) {
            if (!function(t, e, i, n, r) {
                return !!(s(t, e, i, n, r) || (0,
                o.TG)(t, e, i, n, r[0], r[1]) || (0,
                o.TG)(t, e, i, n, r[0], r[3]) || (0,
                o.TG)(t, e, i, n, r[2], r[1]) || (0,
                o.TG)(t, e, i, n, r[2], r[3]))
            }(t, e, i[0], n, r))
                return !1;
            if (1 === i.length)
                return !0;
            for (let e = 1, a = i.length; e < a; ++e)
                if ((0,
                o.uG)(t, i[e - 1], i[e], n, r) && !s(t, i[e - 1], i[e], n, r))
                    return !1;
            return !0
        }
        function c(t, e, i, n, r) {
            for (let o = 0, s = i.length; o < s; ++o) {
                const s = i[o];
                if (l(t, e, s, n, r))
                    return !0;
                e = s[s.length - 1]
            }
            return !1
        }
    },
    27374: function(t, e, i) {
        "use strict";
        function n(t, e, i, n) {
            let r = t[e]
              , o = t[e + 1]
              , s = 0;
            for (let a = e + n; a < i; a += n) {
                const e = t[a]
                  , i = t[a + 1];
                s += Math.sqrt((e - r) * (e - r) + (i - o) * (i - o)),
                r = e,
                o = i
            }
            return s
        }
        i.d(e, {
            W: function() {
                return n
            }
        })
    },
    74772: function(t, e, i) {
        "use strict";
        function n(t, e, i, n) {
            for (; e < i - n; ) {
                for (let r = 0; r < n; ++r) {
                    const o = t[e + r];
                    t[e + r] = t[i - n + r],
                    t[i - n + r] = o
                }
                e += n,
                i -= n
            }
        }
        function r(t, e, i, n) {
            let r = 0
              , o = t[i - n]
              , s = t[i - n + 1];
            for (; e < i; e += n) {
                const i = t[e]
                  , n = t[e + 1];
                r += (i - o) * (n + s),
                o = i,
                s = n
            }
            return 0 === r ? void 0 : r > 0
        }
        function o(t, e, i, n, o) {
            o = void 0 !== o && o;
            for (let s = 0, a = i.length; s < a; ++s) {
                const a = i[s]
                  , l = r(t, e, a, n);
                if (0 === s) {
                    if (o && l || !o && !l)
                        return !1
                } else if (o && !l || !o && l)
                    return !1;
                e = a
            }
            return !0
        }
        function s(t, e, i, n, r) {
            for (let s = 0, a = i.length; s < a; ++s) {
                const a = i[s];
                if (!o(t, e, a, n, r))
                    return !1;
                a.length && (e = a[a.length - 1])
            }
            return !0
        }
        function a(t, e, i, o, s) {
            s = void 0 !== s && s;
            for (let a = 0, l = i.length; a < l; ++a) {
                const l = i[a]
                  , c = r(t, e, l, o);
                (0 === a ? s && c || !s && !c : s && !c || !s && c) && n(t, e, l, o),
                e = l
            }
            return e
        }
        function l(t, e, i, n, r) {
            for (let o = 0, s = i.length; o < s; ++o)
                e = a(t, e, i[o], n, r);
            return e
        }
        i.d(e, {
            $v: function() {
                return o
            },
            Oj: function() {
                return s
            },
            zX: function() {
                return a
            },
            dL: function() {
                return l
            }
        })
    },
    93032: function(t, e, i) {
        "use strict";
        function n(t, e, i, n, r) {
            let o;
            for (e += n; e < i; e += n)
                if (o = r(t.slice(e - n, e), t.slice(e, e + n)),
                o)
                    return o;
            return !1
        }
        i.d(e, {
            E: function() {
                return n
            }
        })
    },
    80226: function(t, e, i) {
        "use strict";
        i.d(e, {
            Pp: function() {
                return c
            },
            UJ: function() {
                return o
            },
            Zh: function() {
                return l
            },
            dt: function() {
                return r
            },
            uZ: function() {
                return s
            }
        });
        var n = i(33983);
        function r(t, e, i, r, o, s, a) {
            const l = (i - e) / r;
            if (l < 3) {
                for (; e < i; e += r)
                    s[a++] = t[e],
                    s[a++] = t[e + 1];
                return a
            }
            const c = new Array(l);
            c[0] = 1,
            c[l - 1] = 1;
            const h = [e, i - r];
            let u = 0;
            for (; h.length > 0; ) {
                const i = h.pop()
                  , s = h.pop();
                let a = 0;
                const l = t[s]
                  , d = t[s + 1]
                  , f = t[i]
                  , p = t[i + 1];
                for (let e = s + r; e < i; e += r) {
                    const i = t[e]
                      , r = t[e + 1]
                      , o = (0,
                    n.rU)(i, r, l, d, f, p);
                    o > a && (u = e,
                    a = o)
                }
                a > o && (c[(u - e) / r] = 1,
                s + r < u && h.push(s, u),
                u + r < i && h.push(u, i))
            }
            for (let i = 0; i < l; ++i)
                c[i] && (s[a++] = t[e + i * r],
                s[a++] = t[e + i * r + 1]);
            return a
        }
        function o(t, e, i, n, o, s, a, l) {
            for (let c = 0, h = i.length; c < h; ++c) {
                const h = i[c];
                a = r(t, e, h, n, o, s, a),
                l.push(a),
                e = h
            }
            return a
        }
        function s(t, e) {
            return e * Math.round(t / e)
        }
        function a(t, e, i, n, r, o, a) {
            if (e == i)
                return a;
            let l, c, h = s(t[e], r), u = s(t[e + 1], r);
            e += n,
            o[a++] = h,
            o[a++] = u;
            do {
                if (l = s(t[e], r),
                c = s(t[e + 1], r),
                (e += n) == i)
                    return o[a++] = l,
                    o[a++] = c,
                    a
            } while (l == h && c == u);
            for (; e < i; ) {
                const i = s(t[e], r)
                  , d = s(t[e + 1], r);
                if (e += n,
                i == l && d == c)
                    continue;
                const f = l - h
                  , p = c - u
                  , m = i - h
                  , g = d - u;
                f * g == p * m && (f < 0 && m < f || f == m || f > 0 && m > f) && (p < 0 && g < p || p == g || p > 0 && g > p) ? (l = i,
                c = d) : (o[a++] = l,
                o[a++] = c,
                h = l,
                u = c,
                l = i,
                c = d)
            }
            return o[a++] = l,
            o[a++] = c,
            a
        }
        function l(t, e, i, n, r, o, s, l) {
            for (let c = 0, h = i.length; c < h; ++c) {
                const h = i[c];
                s = a(t, e, h, n, r, o, s),
                l.push(s),
                e = h
            }
            return s
        }
        function c(t, e, i, n, r, o, s, a) {
            for (let c = 0, h = i.length; c < h; ++c) {
                const h = i[c]
                  , u = [];
                s = l(t, e, h, n, r, o, s, u),
                a.push(u),
                e = h[h.length - 1]
            }
            return s
        }
    },
    76442: function(t, e, i) {
        "use strict";
        function n(t, e, i, n, r, o) {
            o = o || [];
            let s = 0;
            for (let a = e; a < i; a += n) {
                const e = t[a]
                  , i = t[a + 1];
                o[s++] = r[0] * e + r[2] * i + r[4],
                o[s++] = r[1] * e + r[3] * i + r[5]
            }
            return o && o.length != s && (o.length = s),
            o
        }
        function r(t, e, i, n, r, o, s) {
            s = s || [];
            const a = Math.cos(r)
              , l = Math.sin(r)
              , c = o[0]
              , h = o[1];
            let u = 0;
            for (let r = e; r < i; r += n) {
                const e = t[r] - c
                  , i = t[r + 1] - h;
                s[u++] = c + e * a - i * l,
                s[u++] = h + e * l + i * a;
                for (let e = r + 2; e < r + n; ++e)
                    s[u++] = t[e]
            }
            return s && s.length != u && (s.length = u),
            s
        }
        function o(t, e, i, n, r, o, s, a) {
            a = a || [];
            const l = s[0]
              , c = s[1];
            let h = 0;
            for (let s = e; s < i; s += n) {
                const e = t[s] - l
                  , i = t[s + 1] - c;
                a[h++] = l + r * e,
                a[h++] = c + o * i;
                for (let e = s + 2; e < s + n; ++e)
                    a[h++] = t[e]
            }
            return a && a.length != h && (a.length = h),
            a
        }
        function s(t, e, i, n, r, o, s) {
            s = s || [];
            let a = 0;
            for (let l = e; l < i; l += n) {
                s[a++] = t[l] + r,
                s[a++] = t[l + 1] + o;
                for (let e = l + 2; e < l + n; ++e)
                    s[a++] = t[e]
            }
            return s && s.length != a && (s.length = a),
            s
        }
        i.d(e, {
            Iu: function() {
                return s
            },
            U1: function() {
                return r
            },
            bA: function() {
                return o
            },
            vT: function() {
                return n
            }
        })
    },
    40177: function(t, e, i) {
        "use strict";
        i.d(e, {
            G$: function() {
                return s
            },
            Id: function() {
                return c
            },
            ME: function() {
                return o
            },
            MP: function() {
                return l
            },
            Tp: function() {
                return h
            },
            V: function() {
                return r
            },
            bM: function() {
                return u
            },
            tK: function() {
                return a
            }
        });
        const n = "undefined" != typeof navigator && void 0 !== navigator.userAgent ? navigator.userAgent.toLowerCase() : ""
          , r = n.includes("firefox")
          , o = n.includes("safari") && !n.includes("chrom") && (n.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(n))
          , s = n.includes("webkit") && !n.includes("edge")
          , a = n.includes("macintosh")
          , l = "undefined" != typeof devicePixelRatio ? devicePixelRatio : 1
          , c = "undefined" != typeof WorkerGlobalScope && "undefined" != typeof OffscreenCanvas && self instanceof WorkerGlobalScope
          , h = "undefined" != typeof Image && Image.prototype.decode
          , u = function() {
            let t = !1;
            try {
                const e = Object.defineProperty({}, "passive", {
                    get: function() {
                        t = !0
                    }
                });
                window.addEventListener("_", null, e),
                window.removeEventListener("_", null, e)
            } catch (t) {}
            return t
        }()
    },
    1662: function(t, e, i) {
        "use strict";
        i.d(e, {
            dO: function() {
                return st
            },
            ZP: function() {
                return at
            }
        });
        var n = i(57276)
          , r = i(291)
          , o = i(85487)
          , s = i(81090)
          , a = i(71694)
          , l = i(28641)
          , c = i(65818);
        class h extends a.Z {
            constructor(t) {
                super(),
                this.geometries_ = t || null,
                this.changeEventsKeys_ = [],
                this.listenGeometriesChange_()
            }
            unlistenGeometriesChange_() {
                this.changeEventsKeys_.forEach(c.bN),
                this.changeEventsKeys_.length = 0
            }
            listenGeometriesChange_() {
                if (this.geometries_)
                    for (let t = 0, e = this.geometries_.length; t < e; ++t)
                        this.changeEventsKeys_.push((0,
                        c.oL)(this.geometries_[t], o.Z.CHANGE, this.changed, this))
            }
            clone() {
                const t = new h(null);
                return t.setGeometries(this.geometries_),
                t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                if (n < (0,
                l.qf)(this.getExtent(), t, e))
                    return n;
                const r = this.geometries_;
                for (let o = 0, s = r.length; o < s; ++o)
                    n = r[o].closestPointXY(t, e, i, n);
                return n
            }
            containsXY(t, e) {
                const i = this.geometries_;
                for (let n = 0, r = i.length; n < r; ++n)
                    if (i[n].containsXY(t, e))
                        return !0;
                return !1
            }
            computeExtent(t) {
                (0,
                l.YN)(t);
                const e = this.geometries_;
                for (let i = 0, n = e.length; i < n; ++i)
                    (0,
                    l.l7)(t, e[i].getExtent());
                return t
            }
            getGeometries() {
                return u(this.geometries_)
            }
            getGeometriesArray() {
                return this.geometries_
            }
            getGeometriesArrayRecursive() {
                let t = [];
                const e = this.geometries_;
                for (let i = 0, n = e.length; i < n; ++i)
                    e[i].getType() === this.getType() ? t = t.concat(e[i].getGeometriesArrayRecursive()) : t.push(e[i]);
                return t
            }
            getSimplifiedGeometry(t) {
                if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0,
                this.simplifiedGeometryRevision = this.getRevision()),
                t < 0 || 0 !== this.simplifiedGeometryMaxMinSquaredTolerance && t < this.simplifiedGeometryMaxMinSquaredTolerance)
                    return this;
                const e = []
                  , i = this.geometries_;
                let n = !1;
                for (let r = 0, o = i.length; r < o; ++r) {
                    const o = i[r]
                      , s = o.getSimplifiedGeometry(t);
                    e.push(s),
                    s !== o && (n = !0)
                }
                if (n) {
                    const t = new h(null);
                    return t.setGeometriesArray(e),
                    t
                }
                return this.simplifiedGeometryMaxMinSquaredTolerance = t,
                this
            }
            getType() {
                return "GeometryCollection"
            }
            intersectsExtent(t) {
                const e = this.geometries_;
                for (let i = 0, n = e.length; i < n; ++i)
                    if (e[i].intersectsExtent(t))
                        return !0;
                return !1
            }
            isEmpty() {
                return 0 === this.geometries_.length
            }
            rotate(t, e) {
                const i = this.geometries_;
                for (let n = 0, r = i.length; n < r; ++n)
                    i[n].rotate(t, e);
                this.changed()
            }
            scale(t, e, i) {
                i || (i = (0,
                l.qg)(this.getExtent()));
                const n = this.geometries_;
                for (let r = 0, o = n.length; r < o; ++r)
                    n[r].scale(t, e, i);
                this.changed()
            }
            setGeometries(t) {
                this.setGeometriesArray(u(t))
            }
            setGeometriesArray(t) {
                this.unlistenGeometriesChange_(),
                this.geometries_ = t,
                this.listenGeometriesChange_(),
                this.changed()
            }
            applyTransform(t) {
                const e = this.geometries_;
                for (let i = 0, n = e.length; i < n; ++i)
                    e[i].applyTransform(t);
                this.changed()
            }
            translate(t, e) {
                const i = this.geometries_;
                for (let n = 0, r = i.length; n < r; ++n)
                    i[n].translate(t, e);
                this.changed()
            }
            disposeInternal() {
                this.unlistenGeometriesChange_(),
                super.disposeInternal()
            }
        }
        function u(t) {
            const e = [];
            for (let i = 0, n = t.length; i < n; ++i)
                e.push(t[i].clone());
            return e
        }
        var d = h
          , f = i(54049)
          , p = i(92083)
          , m = i(48630)
          , g = i(92217)
          , _ = i(72967)
          , y = i(53042)
          , v = i(18527)
          , x = i(80226)
          , b = i(65537)
          , w = i(89241)
          , E = i(49405)
          , T = i(63746);
        class S extends _.ZP {
            constructor(t, e, i) {
                if (super(),
                this.ends_ = [],
                this.maxDelta_ = -1,
                this.maxDeltaRevision_ = -1,
                Array.isArray(t[0]))
                    this.setCoordinates(t, e);
                else if (void 0 !== e && i)
                    this.setFlatCoordinates(e, t),
                    this.ends_ = i;
                else {
                    let e = this.getLayout();
                    const i = t
                      , n = []
                      , r = [];
                    for (let t = 0, o = i.length; t < o; ++t) {
                        const o = i[t];
                        0 === t && (e = o.getLayout()),
                        (0,
                        b.l7)(n, o.getFlatCoordinates()),
                        r.push(n.length)
                    }
                    this.setFlatCoordinates(e, n),
                    this.ends_ = r
                }
            }
            appendLineString(t) {
                this.flatCoordinates ? (0,
                b.l7)(this.flatCoordinates, t.getFlatCoordinates().slice()) : this.flatCoordinates = t.getFlatCoordinates().slice(),
                this.ends_.push(this.flatCoordinates.length),
                this.changed()
            }
            clone() {
                const t = new S(this.flatCoordinates.slice(),this.layout,this.ends_.slice());
                return t.applyProperties(this),
                t
            }
            closestPointXY(t, e, i, n) {
                return n < (0,
                l.qf)(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,
                y.Af)(this.flatCoordinates, 0, this.ends_, this.stride, 0)),
                this.maxDeltaRevision_ = this.getRevision()),
                (0,
                y.Xl)(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, t, e, i, n))
            }
            getCoordinateAtM(t, e, i) {
                return "XYM" != this.layout && "XYZM" != this.layout || 0 === this.flatCoordinates.length ? null : (e = void 0 !== e && e,
                i = void 0 !== i && i,
                (0,
                E.dG)(this.flatCoordinates, 0, this.ends_, this.stride, t, e, i))
            }
            getCoordinates() {
                return (0,
                w.o1)(this.flatCoordinates, 0, this.ends_, this.stride)
            }
            getEnds() {
                return this.ends_
            }
            getLineString(t) {
                return t < 0 || this.ends_.length <= t ? null : new p.Z(this.flatCoordinates.slice(0 === t ? 0 : this.ends_[t - 1], this.ends_[t]),this.layout)
            }
            getLineStrings() {
                const t = this.flatCoordinates
                  , e = this.ends_
                  , i = this.layout
                  , n = [];
                let r = 0;
                for (let o = 0, s = e.length; o < s; ++o) {
                    const s = e[o]
                      , a = new p.Z(t.slice(r, s),i);
                    n.push(a),
                    r = s
                }
                return n
            }
            getFlatMidpoints() {
                const t = []
                  , e = this.flatCoordinates;
                let i = 0;
                const n = this.ends_
                  , r = this.stride;
                for (let o = 0, s = n.length; o < s; ++o) {
                    const s = n[o]
                      , a = (0,
                    E.WW)(e, i, s, r, .5);
                    (0,
                    b.l7)(t, a),
                    i = s
                }
                return t
            }
            getSimplifiedGeometryInternal(t) {
                const e = []
                  , i = [];
                return e.length = (0,
                x.UJ)(this.flatCoordinates, 0, this.ends_, this.stride, t, e, 0, i),
                new S(e,"XY",i)
            }
            getType() {
                return "MultiLineString"
            }
            intersectsExtent(t) {
                return (0,
                T.AW)(this.flatCoordinates, 0, this.ends_, this.stride, t)
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 2),
                this.flatCoordinates || (this.flatCoordinates = []);
                const i = (0,
                v._5)(this.flatCoordinates, 0, t, this.stride, this.ends_);
                this.flatCoordinates.length = 0 === i.length ? 0 : i[i.length - 1],
                this.changed()
            }
        }
        var C = S
          , A = i(36259)
          , I = i(69242)
          , M = i(73448)
          , P = i(74772)
          , k = i(14078);
        var O = i(79679);
        class R extends _.ZP {
            constructor(t, e, i) {
                if (super(),
                this.endss_ = [],
                this.flatInteriorPointsRevision_ = -1,
                this.flatInteriorPoints_ = null,
                this.maxDelta_ = -1,
                this.maxDeltaRevision_ = -1,
                this.orientedRevision_ = -1,
                this.orientedFlatCoordinates_ = null,
                !i && !Array.isArray(t[0])) {
                    let n = this.getLayout();
                    const r = t
                      , o = []
                      , s = [];
                    for (let t = 0, e = r.length; t < e; ++t) {
                        const e = r[t];
                        0 === t && (n = e.getLayout());
                        const i = o.length
                          , a = e.getEnds();
                        for (let t = 0, e = a.length; t < e; ++t)
                            a[t] += i;
                        (0,
                        b.l7)(o, e.getFlatCoordinates()),
                        s.push(a)
                    }
                    e = n,
                    t = o,
                    i = s
                }
                void 0 !== e && i ? (this.setFlatCoordinates(e, t),
                this.endss_ = i) : this.setCoordinates(t, e)
            }
            appendPolygon(t) {
                let e;
                if (this.flatCoordinates) {
                    const i = this.flatCoordinates.length;
                    (0,
                    b.l7)(this.flatCoordinates, t.getFlatCoordinates()),
                    e = t.getEnds().slice();
                    for (let t = 0, n = e.length; t < n; ++t)
                        e[t] += i
                } else
                    this.flatCoordinates = t.getFlatCoordinates().slice(),
                    e = t.getEnds().slice(),
                    this.endss_.push();
                this.endss_.push(e),
                this.changed()
            }
            clone() {
                const t = this.endss_.length
                  , e = new Array(t);
                for (let i = 0; i < t; ++i)
                    e[i] = this.endss_[i].slice();
                const i = new R(this.flatCoordinates.slice(),this.layout,e);
                return i.applyProperties(this),
                i
            }
            closestPointXY(t, e, i, n) {
                return n < (0,
                l.qf)(this.getExtent(), t, e) ? n : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt((0,
                y.sD)(this.flatCoordinates, 0, this.endss_, this.stride, 0)),
                this.maxDeltaRevision_ = this.getRevision()),
                (0,
                y.gI)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, t, e, i, n))
            }
            containsXY(t, e) {
                return (0,
                O.Zl)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t, e)
            }
            getArea() {
                return (0,
                k.Eu)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride)
            }
            getCoordinates(t) {
                let e;
                return void 0 !== t ? (e = this.getOrientedFlatCoordinates().slice(),
                (0,
                P.dL)(e, 0, this.endss_, this.stride, t)) : e = this.flatCoordinates,
                (0,
                w.ug)(e, 0, this.endss_, this.stride)
            }
            getEndss() {
                return this.endss_
            }
            getFlatInteriorPoints() {
                if (this.flatInteriorPointsRevision_ != this.getRevision()) {
                    const t = function(t, e, i, n) {
                        const r = [];
                        let o = (0,
                        l.lJ)();
                        for (let s = 0, a = i.length; s < a; ++s) {
                            const a = i[s];
                            o = (0,
                            l.GN)(t, e, a[0], n),
                            r.push((o[0] + o[2]) / 2, (o[1] + o[3]) / 2),
                            e = a[a.length - 1]
                        }
                        return r
                    }(this.flatCoordinates, 0, this.endss_, this.stride);
                    this.flatInteriorPoints_ = (0,
                    M.U)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t),
                    this.flatInteriorPointsRevision_ = this.getRevision()
                }
                return this.flatInteriorPoints_
            }
            getInteriorPoints() {
                return new A.Z(this.getFlatInteriorPoints().slice(),"XYM")
            }
            getOrientedFlatCoordinates() {
                if (this.orientedRevision_ != this.getRevision()) {
                    const t = this.flatCoordinates;
                    (0,
                    P.Oj)(t, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = t : (this.orientedFlatCoordinates_ = t.slice(),
                    this.orientedFlatCoordinates_.length = (0,
                    P.dL)(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)),
                    this.orientedRevision_ = this.getRevision()
                }
                return this.orientedFlatCoordinates_
            }
            getSimplifiedGeometryInternal(t) {
                const e = []
                  , i = [];
                return e.length = (0,
                x.Pp)(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(t), e, 0, i),
                new R(e,"XY",i)
            }
            getPolygon(t) {
                if (t < 0 || this.endss_.length <= t)
                    return null;
                let e;
                if (0 === t)
                    e = 0;
                else {
                    const i = this.endss_[t - 1];
                    e = i[i.length - 1]
                }
                const i = this.endss_[t].slice()
                  , n = i[i.length - 1];
                if (0 !== e)
                    for (let t = 0, n = i.length; t < n; ++t)
                        i[t] -= e;
                return new I.ZP(this.flatCoordinates.slice(e, n),this.layout,i)
            }
            getPolygons() {
                const t = this.layout
                  , e = this.flatCoordinates
                  , i = this.endss_
                  , n = [];
                let r = 0;
                for (let o = 0, s = i.length; o < s; ++o) {
                    const s = i[o].slice()
                      , a = s[s.length - 1];
                    if (0 !== r)
                        for (let t = 0, e = s.length; t < e; ++t)
                            s[t] -= r;
                    const l = new I.ZP(e.slice(r, a),t,s);
                    n.push(l),
                    r = a
                }
                return n
            }
            getType() {
                return "MultiPolygon"
            }
            intersectsExtent(t) {
                return (0,
                T.oW)(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, t)
            }
            setCoordinates(t, e) {
                this.setLayout(e, t, 3),
                this.flatCoordinates || (this.flatCoordinates = []);
                const i = (0,
                v.QT)(this.flatCoordinates, 0, t, this.stride, this.endss_);
                if (0 === i.length)
                    this.flatCoordinates.length = 0;
                else {
                    const t = i[i.length - 1];
                    this.flatCoordinates.length = 0 === t.length ? 0 : t[t.length - 1]
                }
                this.changed()
            }
        }
        var D = R
          , L = i(60188)
          , B = i(14515)
          , z = i(67315)
          , F = i(31361)
          , N = i(36885)
          , j = i(98683)
          , U = i(33983)
          , V = i(47539)
          , G = i(91900)
          , Z = i(26835);
        const q = "drawstart"
          , W = "drawend"
          , H = "drawabort";
        class $ extends r.ZP {
            constructor(t, e) {
                super(t),
                this.feature = e
            }
        }
        function X(t, e) {
            return (0,
            U.bI)(t[0], t[1], e[0], e[1])
        }
        function Y(t, e) {
            const i = t.length;
            return e < 0 ? t[e + i] : e >= i ? t[e - i] : t[e]
        }
        function K(t, e, i) {
            let n, r;
            e < i ? (n = e,
            r = i) : (n = i,
            r = e);
            const o = Math.ceil(n)
              , s = Math.floor(r);
            if (o > s) {
                return X(nt(t, n), nt(t, r))
            }
            let a = 0;
            if (n < o) {
                a += X(nt(t, n), Y(t, o))
            }
            if (s < r) {
                a += X(Y(t, s), nt(t, r))
            }
            for (let e = o; e < s - 1; ++e) {
                a += X(Y(t, e), Y(t, e + 1))
            }
            return a
        }
        function J(t, e, i) {
            if (e instanceof p.Z)
                tt(t, e.getCoordinates(), !1, i);
            else if (e instanceof C) {
                const n = e.getCoordinates();
                for (let e = 0, r = n.length; e < r; ++e)
                    tt(t, n[e], !1, i)
            } else if (e instanceof I.ZP) {
                const n = e.getCoordinates();
                for (let e = 0, r = n.length; e < r; ++e)
                    tt(t, n[e], !0, i)
            } else if (e instanceof D) {
                const n = e.getCoordinates();
                for (let e = 0, r = n.length; e < r; ++e) {
                    const r = n[e];
                    for (let e = 0, n = r.length; e < n; ++e)
                        tt(t, r[e], !0, i)
                }
            } else if (e instanceof d) {
                const n = e.getGeometries();
                for (let e = 0; e < n.length; ++e)
                    J(t, n[e], i)
            } else
                ;
        }
        const Q = {
            index: -1,
            endIndex: NaN
        };
        function tt(t, e, i, n) {
            const r = t[0]
              , o = t[1];
            for (let t = 0, s = e.length - 1; t < s; ++t) {
                const s = it(r, o, e[t], e[t + 1]);
                if (0 === s.squaredDistance) {
                    const r = t + s.along;
                    return void n.push({
                        coordinates: e,
                        ring: i,
                        startIndex: r,
                        endIndex: r
                    })
                }
            }
        }
        const et = {
            along: 0,
            squaredDistance: 0
        };
        function it(t, e, i, n) {
            const r = i[0]
              , o = i[1]
              , s = n[0] - r
              , a = n[1] - o;
            let l = 0
              , c = r
              , h = o;
            return 0 === s && 0 === a || (l = (0,
            U.uZ)(((t - r) * s + (e - o) * a) / (s * s + a * a), 0, 1),
            c += s * l,
            h += a * l),
            et.along = l,
            et.squaredDistance = (0,
            U.FH)((0,
            U.bI)(t, e, c, h), 10),
            et
        }
        function nt(t, e) {
            const i = t.length;
            let n = Math.floor(e);
            const r = e - n;
            n >= i ? n -= i : n < 0 && (n += i);
            let o = n + 1;
            o >= i && (o -= i);
            const s = t[n]
              , a = s[0]
              , l = s[1]
              , c = t[o];
            return [a + (c[0] - a) * r, l + (c[1] - l) * r]
        }
        class rt extends B.Z {
            constructor(t) {
                const e = t;
                e.stopDown || (e.stopDown = N.Dv),
                super(e),
                this.on,
                this.once,
                this.un,
                this.shouldHandle_ = !1,
                this.downPx_ = null,
                this.downTimeout_,
                this.lastDragTime_,
                this.pointerType_,
                this.freehand_ = !1,
                this.source_ = t.source ? t.source : null,
                this.features_ = t.features ? t.features : null,
                this.snapTolerance_ = t.snapTolerance ? t.snapTolerance : 12,
                this.type_ = t.type,
                this.mode_ = function(t) {
                    switch (t) {
                    case "Point":
                    case "MultiPoint":
                        return "Point";
                    case "LineString":
                    case "MultiLineString":
                        return "LineString";
                    case "Polygon":
                    case "MultiPolygon":
                        return "Polygon";
                    case "Circle":
                        return "Circle";
                    default:
                        throw new Error("Invalid type: " + t)
                    }
                }(this.type_),
                this.stopClick_ = !!t.stopClick,
                this.minPoints_ = t.minPoints ? t.minPoints : "Polygon" === this.mode_ ? 3 : 2,
                this.maxPoints_ = "Circle" === this.mode_ ? 2 : t.maxPoints ? t.maxPoints : 1 / 0,
                this.finishCondition_ = t.finishCondition ? t.finishCondition : N.uX,
                this.geometryLayout_ = t.geometryLayout ? t.geometryLayout : "XY";
                let i = t.geometryFunction;
                if (!i) {
                    const t = this.mode_;
                    if ("Circle" === t)
                        i = function(t, e, i) {
                            const r = e || new n.Z([NaN, NaN])
                              , o = (0,
                            Z.Vs)(t[0], i)
                              , s = (0,
                            G.bI)(o, (0,
                            Z.Vs)(t[t.length - 1], i));
                            r.setCenterAndRadius(o, Math.sqrt(s), this.geometryLayout_);
                            const a = (0,
                            Z.Cs)();
                            return a && r.transform(i, a),
                            r
                        }
                        ;
                    else {
                        let e;
                        "Point" === t ? e = L.Z : "LineString" === t ? e = p.Z : "Polygon" === t && (e = I.ZP),
                        i = function(i, n, r) {
                            return n ? "Polygon" === t ? i[0].length ? n.setCoordinates([i[0].concat([i[0][0]])], this.geometryLayout_) : n.setCoordinates([], this.geometryLayout_) : n.setCoordinates(i, this.geometryLayout_) : n = new e(i,this.geometryLayout_),
                            n
                        }
                    }
                }
                this.geometryFunction_ = i,
                this.dragVertexDelay_ = void 0 !== t.dragVertexDelay ? t.dragVertexDelay : 500,
                this.finishCoordinate_ = null,
                this.sketchFeature_ = null,
                this.sketchPoint_ = null,
                this.sketchCoords_ = null,
                this.sketchLine_ = null,
                this.sketchLineCoords_ = null,
                this.squaredClickTolerance_ = t.clickTolerance ? t.clickTolerance * t.clickTolerance : 36,
                this.overlay_ = new z.Z({
                    source: new F.Z({
                        useSpatialIndex: !1,
                        wrapX: !!t.wrapX && t.wrapX
                    }),
                    style: t.style ? t.style : ot(),
                    updateWhileInteracting: !0
                }),
                this.geometryName_ = t.geometryName,
                this.condition_ = t.condition ? t.condition : j.rM,
                this.freehandCondition_,
                t.freehand ? this.freehandCondition_ = j.Bx : this.freehandCondition_ = t.freehandCondition ? t.freehandCondition : j.vY,
                this.traceCondition_,
                this.setTrace(t.trace || !1),
                this.traceState_ = {
                    active: !1
                },
                this.traceSource_ = t.traceSource || t.source || null,
                this.addChangeListener(f.Z.ACTIVE, this.updateState_)
            }
            setTrace(t) {
                let e;
                e = t ? !0 === t ? j.Bx : t : j.Fi,
                this.traceCondition_ = e
            }
            setMap(t) {
                super.setMap(t),
                this.updateState_()
            }
            getOverlay() {
                return this.overlay_
            }
            handleEvent(t) {
                t.originalEvent.type === o.Z.CONTEXTMENU && t.originalEvent.preventDefault(),
                this.freehand_ = "Point" !== this.mode_ && this.freehandCondition_(t);
                let e = t.type === g.Z.POINTERMOVE
                  , i = !0;
                if (!this.freehand_ && this.lastDragTime_ && t.type === g.Z.POINTERDRAG) {
                    Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = t.pixel,
                    this.shouldHandle_ = !this.freehand_,
                    e = !0) : this.lastDragTime_ = void 0,
                    this.shouldHandle_ && void 0 !== this.downTimeout_ && (clearTimeout(this.downTimeout_),
                    this.downTimeout_ = void 0)
                }
                return this.freehand_ && t.type === g.Z.POINTERDRAG && null !== this.sketchFeature_ ? (this.addToDrawing_(t.coordinate),
                i = !1) : this.freehand_ && t.type === g.Z.POINTERDOWN ? i = !1 : e && this.getPointerCount() < 2 ? (i = t.type === g.Z.POINTERMOVE,
                i && this.freehand_ ? (this.handlePointerMove_(t),
                this.shouldHandle_ && t.originalEvent.preventDefault()) : ("mouse" === t.originalEvent.pointerType || t.type === g.Z.POINTERDRAG && void 0 === this.downTimeout_) && this.handlePointerMove_(t)) : t.type === g.Z.DBLCLICK && (i = !1),
                super.handleEvent(t) && i
            }
            handleDownEvent(t) {
                return this.shouldHandle_ = !this.freehand_,
                this.freehand_ ? (this.downPx_ = t.pixel,
                this.finishCoordinate_ || this.startDrawing_(t.coordinate),
                !0) : this.condition_(t) ? (this.lastDragTime_ = Date.now(),
                this.downTimeout_ = setTimeout(( () => {
                    this.handlePointerMove_(new m.Z(g.Z.POINTERMOVE,t.map,t.originalEvent,!1,t.frameState))
                }
                ), this.dragVertexDelay_),
                this.downPx_ = t.pixel,
                !0) : (this.lastDragTime_ = void 0,
                !1)
            }
            deactivateTrace_() {
                this.traceState_ = {
                    active: !1
                }
            }
            toggleTraceState_(t) {
                if (!this.traceSource_ || !this.traceCondition_(t))
                    return;
                if (this.traceState_.active)
                    return void this.deactivateTrace_();
                const e = this.getMap()
                  , i = e.getCoordinateFromPixel([t.pixel[0] - this.snapTolerance_, t.pixel[1] + this.snapTolerance_])
                  , n = e.getCoordinateFromPixel([t.pixel[0] + this.snapTolerance_, t.pixel[1] - this.snapTolerance_])
                  , r = (0,
                l.hI)([i, n])
                  , o = this.traceSource_.getFeaturesInExtent(r);
                if (0 === o.length)
                    return;
                const s = function(t, e) {
                    const i = [];
                    for (let n = 0; n < e.length; ++n)
                        J(t, e[n].getGeometry(), i);
                    return i
                }(t.coordinate, o);
                s.length && (this.traceState_ = {
                    active: !0,
                    startPx: t.pixel.slice(),
                    targets: s,
                    targetIndex: -1
                })
            }
            addOrRemoveTracedCoordinates_(t, e) {
                const i = t.startIndex <= t.endIndex;
                i === t.startIndex <= e ? i && e > t.endIndex || !i && e < t.endIndex ? this.addTracedCoordinates_(t, t.endIndex, e) : (i && e < t.endIndex || !i && e > t.endIndex) && this.removeTracedCoordinates_(e, t.endIndex) : (this.removeTracedCoordinates_(t.startIndex, t.endIndex),
                this.addTracedCoordinates_(t, t.startIndex, e))
            }
            removeTracedCoordinates_(t, e) {
                if (t === e)
                    return;
                let i = 0;
                if (t < e) {
                    const n = Math.ceil(t);
                    let r = Math.floor(e);
                    r === e && (r -= 1),
                    i = r - n + 1
                } else {
                    const n = Math.floor(t);
                    let r = Math.ceil(e);
                    r === e && (r += 1),
                    i = n - r + 1
                }
                i > 0 && this.removeLastPoints_(i)
            }
            addTracedCoordinates_(t, e, i) {
                if (e === i)
                    return;
                const n = [];
                if (e < i) {
                    const r = Math.ceil(e);
                    let o = Math.floor(i);
                    o === i && (o -= 1);
                    for (let e = r; e <= o; ++e)
                        n.push(Y(t.coordinates, e))
                } else {
                    const r = Math.floor(e);
                    let o = Math.ceil(i);
                    o === i && (o += 1);
                    for (let e = r; e >= o; --e)
                        n.push(Y(t.coordinates, e))
                }
                n.length && this.appendCoordinates(n)
            }
            updateTrace_(t) {
                const e = this.traceState_;
                if (!e.active)
                    return;
                if (-1 === e.targetIndex && (0,
                G.TE)(e.startPx, t.pixel) < this.snapTolerance_)
                    return;
                const i = function(t, e, i, n) {
                    const r = t[0]
                      , o = t[1];
                    let s = 1 / 0
                      , a = -1
                      , l = NaN;
                    for (let t = 0; t < e.targets.length; ++t) {
                        const i = e.targets[t]
                          , n = i.coordinates;
                        let c, h = 1 / 0;
                        for (let t = 0; t < n.length - 1; ++t) {
                            const e = it(r, o, n[t], n[t + 1]);
                            e.squaredDistance < h && (h = e.squaredDistance,
                            c = t + e.along)
                        }
                        h < s && (s = h,
                        i.ring && e.targetIndex === t && (i.endIndex > i.startIndex ? c < i.startIndex && (c += n.length) : i.endIndex < i.startIndex && c > i.startIndex && (c -= n.length)),
                        l = c,
                        a = t)
                    }
                    const c = e.targets[a];
                    let h = c.ring;
                    if (e.targetIndex === a && h) {
                        const t = nt(c.coordinates, l)
                          , r = i.getPixelFromCoordinate(t);
                        (0,
                        G.TE)(r, e.startPx) > n && (h = !1)
                    }
                    if (h) {
                        const t = c.coordinates
                          , e = t.length
                          , i = c.startIndex
                          , n = l;
                        if (i < n) {
                            const r = K(t, i, n);
                            K(t, i, n - e) < r && (l -= e)
                        } else {
                            const r = K(t, i, n);
                            K(t, i, n + e) < r && (l += e)
                        }
                    }
                    return Q.index = a,
                    Q.endIndex = l,
                    Q
                }(t.coordinate, e, this.getMap(), this.snapTolerance_);
                if (e.targetIndex !== i.index) {
                    if (-1 !== e.targetIndex) {
                        const t = e.targets[e.targetIndex];
                        this.removeTracedCoordinates_(t.startIndex, t.endIndex)
                    }
                    const t = e.targets[i.index];
                    this.addTracedCoordinates_(t, t.startIndex, i.endIndex)
                } else {
                    const t = e.targets[e.targetIndex];
                    this.addOrRemoveTracedCoordinates_(t, i.endIndex)
                }
                e.targetIndex = i.index;
                const n = e.targets[e.targetIndex];
                n.endIndex = i.endIndex;
                const r = nt(n.coordinates, n.endIndex)
                  , o = this.getMap().getPixelFromCoordinate(r);
                t.coordinate = r,
                t.pixel = [Math.round(o[0]), Math.round(o[1])]
            }
            handleUpEvent(t) {
                let e = !0;
                if (0 === this.getPointerCount()) {
                    this.downTimeout_ && (clearTimeout(this.downTimeout_),
                    this.downTimeout_ = void 0),
                    this.handlePointerMove_(t);
                    const i = this.traceState_.active;
                    if (this.toggleTraceState_(t),
                    this.shouldHandle_) {
                        const n = !this.finishCoordinate_;
                        n && this.startDrawing_(t.coordinate),
                        !n && this.freehand_ ? this.finishDrawing() : this.freehand_ || n && "Point" !== this.mode_ || (this.atFinish_(t.pixel, i) ? this.finishCondition_(t) && this.finishDrawing() : this.addToDrawing_(t.coordinate)),
                        e = !1
                    } else
                        this.freehand_ && this.abortDrawing()
                }
                return !e && this.stopClick_ && t.preventDefault(),
                e
            }
            handlePointerMove_(t) {
                if (this.pointerType_ = t.originalEvent.pointerType,
                this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
                    const e = this.downPx_
                      , i = t.pixel
                      , n = e[0] - i[0]
                      , r = e[1] - i[1]
                      , o = n * n + r * r;
                    if (this.shouldHandle_ = this.freehand_ ? o > this.squaredClickTolerance_ : o <= this.squaredClickTolerance_,
                    !this.shouldHandle_)
                        return
                }
                this.finishCoordinate_ ? (this.updateTrace_(t),
                this.modifyDrawing_(t.coordinate)) : this.createOrUpdateSketchPoint_(t.coordinate.slice())
            }
            atFinish_(t, e) {
                let i = !1;
                if (this.sketchFeature_) {
                    let n = !1
                      , r = [this.finishCoordinate_];
                    const o = this.mode_;
                    if ("Point" === o)
                        i = !0;
                    else if ("Circle" === o)
                        i = 2 === this.sketchCoords_.length;
                    else if ("LineString" === o)
                        n = !e && this.sketchCoords_.length > this.minPoints_;
                    else if ("Polygon" === o) {
                        const t = this.sketchCoords_;
                        n = t[0].length > this.minPoints_,
                        r = [t[0][0], t[0][t[0].length - 2]],
                        r = e ? [t[0][0]] : [t[0][0], t[0][t[0].length - 2]]
                    }
                    if (n) {
                        const e = this.getMap();
                        for (let n = 0, o = r.length; n < o; n++) {
                            const o = r[n]
                              , s = e.getPixelFromCoordinate(o)
                              , a = t[0] - s[0]
                              , l = t[1] - s[1]
                              , c = this.freehand_ ? 1 : this.snapTolerance_;
                            if (i = Math.sqrt(a * a + l * l) <= c,
                            i) {
                                this.finishCoordinate_ = o;
                                break
                            }
                        }
                    }
                }
                return i
            }
            createOrUpdateSketchPoint_(t) {
                if (this.sketchPoint_) {
                    this.sketchPoint_.getGeometry().setCoordinates(t)
                } else
                    this.sketchPoint_ = new s.Z(new L.Z(t)),
                    this.updateSketchFeatures_()
            }
            createOrUpdateCustomSketchLine_(t) {
                this.sketchLine_ || (this.sketchLine_ = new s.Z);
                const e = t.getLinearRing(0);
                let i = this.sketchLine_.getGeometry();
                i ? (i.setFlatCoordinates(e.getLayout(), e.getFlatCoordinates()),
                i.changed()) : (i = new p.Z(e.getFlatCoordinates(),e.getLayout()),
                this.sketchLine_.setGeometry(i))
            }
            startDrawing_(t) {
                const e = this.getMap().getView().getProjection()
                  , i = (0,
                _.tP)(this.geometryLayout_);
                for (; t.length < i; )
                    t.push(0);
                this.finishCoordinate_ = t,
                "Point" === this.mode_ ? this.sketchCoords_ = t.slice() : "Polygon" === this.mode_ ? (this.sketchCoords_ = [[t.slice(), t.slice()]],
                this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [t.slice(), t.slice()],
                this.sketchLineCoords_ && (this.sketchLine_ = new s.Z(new p.Z(this.sketchLineCoords_)));
                const n = this.geometryFunction_(this.sketchCoords_, void 0, e);
                this.sketchFeature_ = new s.Z,
                this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_),
                this.sketchFeature_.setGeometry(n),
                this.updateSketchFeatures_(),
                this.dispatchEvent(new $(q,this.sketchFeature_))
            }
            modifyDrawing_(t) {
                const e = this.getMap()
                  , i = this.sketchFeature_.getGeometry()
                  , n = e.getView().getProjection()
                  , r = (0,
                _.tP)(this.geometryLayout_);
                let o, s;
                for (; t.length < r; )
                    t.push(0);
                if ("Point" === this.mode_ ? s = this.sketchCoords_ : "Polygon" === this.mode_ ? (o = this.sketchCoords_[0],
                s = o[o.length - 1],
                this.atFinish_(e.getPixelFromCoordinate(t)) && (t = this.finishCoordinate_.slice())) : (o = this.sketchCoords_,
                s = o[o.length - 1]),
                s[0] = t[0],
                s[1] = t[1],
                this.geometryFunction_(this.sketchCoords_, i, n),
                this.sketchPoint_) {
                    this.sketchPoint_.getGeometry().setCoordinates(t)
                }
                if ("Polygon" === i.getType() && "Polygon" !== this.mode_)
                    this.createOrUpdateCustomSketchLine_(i);
                else if (this.sketchLineCoords_) {
                    this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)
                }
                this.updateSketchFeatures_()
            }
            addToDrawing_(t) {
                const e = this.sketchFeature_.getGeometry()
                  , i = this.getMap().getView().getProjection();
                let n, r;
                const o = this.mode_;
                "LineString" === o || "Circle" === o ? (this.finishCoordinate_ = t.slice(),
                r = this.sketchCoords_,
                r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0),
                r.push(t.slice()),
                this.geometryFunction_(r, e, i)) : "Polygon" === o && (r = this.sketchCoords_[0],
                r.length >= this.maxPoints_ && (this.freehand_ ? r.pop() : n = !0),
                r.push(t.slice()),
                n && (this.finishCoordinate_ = r[0]),
                this.geometryFunction_(this.sketchCoords_, e, i)),
                this.createOrUpdateSketchPoint_(t.slice()),
                this.updateSketchFeatures_(),
                n && this.finishDrawing()
            }
            removeLastPoints_(t) {
                if (!this.sketchFeature_)
                    return;
                const e = this.sketchFeature_.getGeometry()
                  , i = this.getMap().getView().getProjection()
                  , n = this.mode_;
                for (let r = 0; r < t; ++r) {
                    let t;
                    if ("LineString" === n || "Circle" === n) {
                        if (t = this.sketchCoords_,
                        t.splice(-2, 1),
                        t.length >= 2) {
                            this.finishCoordinate_ = t[t.length - 2].slice();
                            const e = this.finishCoordinate_.slice();
                            t[t.length - 1] = e,
                            this.createOrUpdateSketchPoint_(e)
                        }
                        this.geometryFunction_(t, e, i),
                        "Polygon" === e.getType() && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(e)
                    } else if ("Polygon" === n) {
                        t = this.sketchCoords_[0],
                        t.splice(-2, 1);
                        const n = this.sketchLine_.getGeometry();
                        if (t.length >= 2) {
                            const e = t[t.length - 2].slice();
                            t[t.length - 1] = e,
                            this.createOrUpdateSketchPoint_(e)
                        }
                        n.setCoordinates(t),
                        this.geometryFunction_(this.sketchCoords_, e, i)
                    }
                    if (1 === t.length) {
                        this.abortDrawing();
                        break
                    }
                }
                this.updateSketchFeatures_()
            }
            removeLastPoint() {
                this.removeLastPoints_(1)
            }
            finishDrawing() {
                const t = this.abortDrawing_();
                if (!t)
                    return;
                let e = this.sketchCoords_;
                const i = t.getGeometry()
                  , n = this.getMap().getView().getProjection();
                "LineString" === this.mode_ ? (e.pop(),
                this.geometryFunction_(e, i, n)) : "Polygon" === this.mode_ && (e[0].pop(),
                this.geometryFunction_(e, i, n),
                e = i.getCoordinates()),
                "MultiPoint" === this.type_ ? t.setGeometry(new A.Z([e])) : "MultiLineString" === this.type_ ? t.setGeometry(new C([e])) : "MultiPolygon" === this.type_ && t.setGeometry(new D([e])),
                this.dispatchEvent(new $(W,t)),
                this.features_ && this.features_.push(t),
                this.source_ && this.source_.addFeature(t)
            }
            abortDrawing_() {
                this.finishCoordinate_ = null;
                const t = this.sketchFeature_;
                return this.sketchFeature_ = null,
                this.sketchPoint_ = null,
                this.sketchLine_ = null,
                this.overlay_.getSource().clear(!0),
                this.deactivateTrace_(),
                t
            }
            abortDrawing() {
                const t = this.abortDrawing_();
                t && this.dispatchEvent(new $(H,t))
            }
            appendCoordinates(t) {
                const e = this.mode_
                  , i = !this.sketchFeature_;
                let n;
                if (i && this.startDrawing_(t[0]),
                "LineString" === e || "Circle" === e)
                    n = this.sketchCoords_;
                else {
                    if ("Polygon" !== e)
                        return;
                    n = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : []
                }
                i && n.shift(),
                n.pop();
                for (let e = 0; e < t.length; e++)
                    this.addToDrawing_(t[e]);
                const r = t[t.length - 1];
                this.addToDrawing_(r),
                this.modifyDrawing_(r)
            }
            extend(t) {
                const e = t.getGeometry();
                this.sketchFeature_ = t,
                this.sketchCoords_ = e.getCoordinates();
                const i = this.sketchCoords_[this.sketchCoords_.length - 1];
                this.finishCoordinate_ = i.slice(),
                this.sketchCoords_.push(i.slice()),
                this.sketchPoint_ = new s.Z(new L.Z(i)),
                this.updateSketchFeatures_(),
                this.dispatchEvent(new $(q,this.sketchFeature_))
            }
            updateSketchFeatures_() {
                const t = [];
                this.sketchFeature_ && t.push(this.sketchFeature_),
                this.sketchLine_ && t.push(this.sketchLine_),
                this.sketchPoint_ && t.push(this.sketchPoint_);
                const e = this.overlay_.getSource();
                e.clear(!0),
                e.addFeatures(t)
            }
            updateState_() {
                const t = this.getMap()
                  , e = this.getActive();
                t && e || this.abortDrawing(),
                this.overlay_.setMap(e ? t : null)
            }
        }
        function ot() {
            const t = (0,
            V.Ly)();
            return function(e, i) {
                return t[e.getGeometry().getType()]
            }
        }
        function st() {
            return function(t, e, i) {
                const n = (0,
                l.hI)([t[0], t[t.length - 1]].map((function(t) {
                    return (0,
                    Z.Vs)(t, i)
                }
                )))
                  , r = [[(0,
                l.hC)(n), (0,
                l.w$)(n), (0,
                l.Xv)(n), (0,
                l.rL)(n), (0,
                l.hC)(n)]];
                e ? e.setCoordinates(r) : e = new I.ZP(r);
                const o = (0,
                Z.Cs)();
                return o && e.transform(i, o),
                e
            }
        }
        var at = rt
    },
    47182: function(t, e, i) {
        "use strict";
        i.d(e, {
            Cv: function() {
                return a
            },
            FW: function() {
                return l
            }
        });
        var n = i(72971)
          , r = i(54049)
          , o = i(31015);
        class s extends n.Z {
            constructor(t) {
                super(),
                this.on,
                this.once,
                this.un,
                t && t.handleEvent && (this.handleEvent = t.handleEvent),
                this.map_ = null,
                this.setActive(!0)
            }
            getActive() {
                return this.get(r.Z.ACTIVE)
            }
            getMap() {
                return this.map_
            }
            handleEvent(t) {
                return !0
            }
            setActive(t) {
                this.set(r.Z.ACTIVE, t)
            }
            setMap(t) {
                this.map_ = t
            }
        }
        function a(t, e, i) {
            const n = t.getCenterInternal();
            if (n) {
                const r = [n[0] + e[0], n[1] + e[1]];
                t.animateInternal({
                    duration: void 0 !== i ? i : 250,
                    easing: o.GE,
                    center: t.getConstrainedCenter(r)
                })
            }
        }
        function l(t, e, i, n) {
            const r = t.getZoom();
            if (void 0 === r)
                return;
            const s = t.getConstrainedZoom(r + e)
              , a = t.getResolutionForZoom(s);
            t.getAnimating() && t.cancelAnimations(),
            t.animate({
                resolution: a,
                anchor: i,
                duration: void 0 !== n ? n : 250,
                easing: o.Vv
            })
        }
        e.ZP = s
    },
    78373: function(t, e, i) {
        "use strict";
        var n = i(78714)
          , r = i(42071)
          , o = i(291)
          , s = i(85487)
          , a = i(81090)
          , l = i(92217)
          , c = i(60188)
          , h = i(14515)
          , u = i(39781)
          , d = i(22796)
          , f = i(67315)
          , p = i(31361)
          , m = i(98683)
          , g = i(28641)
          , _ = i(91900)
          , y = i(47539)
          , v = i(65537)
          , x = i(69242)
          , b = i(26835)
          , w = i(74187);
        const E = [0, 0, 0, 0]
          , T = []
          , S = "modifystart"
          , C = "modifyend";
        class A extends o.ZP {
            constructor(t, e, i) {
                super(t),
                this.features = e,
                this.mapBrowserEvent = i
            }
        }
        class I extends h.Z {
            constructor(t) {
                let e;
                if (super(t),
                this.on,
                this.once,
                this.un,
                this.boundHandleFeatureChange_ = this.handleFeatureChange_.bind(this),
                this.condition_ = t.condition ? t.condition : m.Xp,
                this.defaultDeleteCondition_ = function(t) {
                    return (0,
                    m.Ko)(t) && (0,
                    m.Kf)(t)
                }
                ,
                this.deleteCondition_ = t.deleteCondition ? t.deleteCondition : this.defaultDeleteCondition_,
                this.insertVertexCondition_ = t.insertVertexCondition ? t.insertVertexCondition : m.Bx,
                this.vertexFeature_ = null,
                this.vertexSegments_ = null,
                this.lastPixel_ = [0, 0],
                this.ignoreNextSingleClick_ = !1,
                this.featuresBeingModified_ = null,
                this.rBush_ = new u.Z,
                this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10,
                this.snappedToVertex_ = !1,
                this.changingFeature_ = !1,
                this.dragSegments_ = [],
                this.overlay_ = new f.Z({
                    source: new p.Z({
                        useSpatialIndex: !1,
                        wrapX: !!t.wrapX
                    }),
                    style: t.style ? t.style : O(),
                    updateWhileAnimating: !0,
                    updateWhileInteracting: !0
                }),
                this.SEGMENT_WRITERS_ = {
                    Point: this.writePointGeometry_.bind(this),
                    LineString: this.writeLineStringGeometry_.bind(this),
                    LinearRing: this.writeLineStringGeometry_.bind(this),
                    Polygon: this.writePolygonGeometry_.bind(this),
                    MultiPoint: this.writeMultiPointGeometry_.bind(this),
                    MultiLineString: this.writeMultiLineStringGeometry_.bind(this),
                    MultiPolygon: this.writeMultiPolygonGeometry_.bind(this),
                    Circle: this.writeCircleGeometry_.bind(this),
                    GeometryCollection: this.writeGeometryCollectionGeometry_.bind(this)
                },
                this.source_ = null,
                this.hitDetection_ = null,
                t.features ? e = t.features : t.source && (this.source_ = t.source,
                e = new n.Z(this.source_.getFeatures()),
                this.source_.addEventListener(d.Z.ADDFEATURE, this.handleSourceAdd_.bind(this)),
                this.source_.addEventListener(d.Z.REMOVEFEATURE, this.handleSourceRemove_.bind(this))),
                !e)
                    throw new Error("The modify interaction requires features, a source or a layer");
                t.hitDetection && (this.hitDetection_ = t.hitDetection),
                this.features_ = e,
                this.features_.forEach(this.addFeature_.bind(this)),
                this.features_.addEventListener(r.Z.ADD, this.handleFeatureAdd_.bind(this)),
                this.features_.addEventListener(r.Z.REMOVE, this.handleFeatureRemove_.bind(this)),
                this.lastPointerEvent_ = null,
                this.delta_ = [0, 0],
                this.snapToPointer_ = void 0 === t.snapToPointer ? !this.hitDetection_ : t.snapToPointer
            }
            addFeature_(t) {
                const e = t.getGeometry();
                if (e) {
                    const i = this.SEGMENT_WRITERS_[e.getType()];
                    i && i(t, e)
                }
                const i = this.getMap();
                i && i.isRendered() && this.getActive() && this.handlePointerAtPixel_(this.lastPixel_, i),
                t.addEventListener(s.Z.CHANGE, this.boundHandleFeatureChange_)
            }
            willModifyFeatures_(t, e) {
                if (!this.featuresBeingModified_) {
                    this.featuresBeingModified_ = new n.Z;
                    const i = this.featuresBeingModified_.getArray();
                    for (let t = 0, n = e.length; t < n; ++t) {
                        const n = e[t];
                        for (let t = 0, e = n.length; t < e; ++t) {
                            const e = n[t].feature;
                            e && !i.includes(e) && this.featuresBeingModified_.push(e)
                        }
                    }
                    0 === this.featuresBeingModified_.getLength() ? this.featuresBeingModified_ = null : this.dispatchEvent(new A(S,this.featuresBeingModified_,t))
                }
            }
            removeFeature_(t) {
                this.removeFeatureSegmentData_(t),
                this.vertexFeature_ && 0 === this.features_.getLength() && (this.overlay_.getSource().removeFeature(this.vertexFeature_),
                this.vertexFeature_ = null),
                t.removeEventListener(s.Z.CHANGE, this.boundHandleFeatureChange_)
            }
            removeFeatureSegmentData_(t) {
                const e = this.rBush_
                  , i = [];
                e.forEach((function(e) {
                    t === e.feature && i.push(e)
                }
                ));
                for (let t = i.length - 1; t >= 0; --t) {
                    const n = i[t];
                    for (let t = this.dragSegments_.length - 1; t >= 0; --t)
                        this.dragSegments_[t][0] === n && this.dragSegments_.splice(t, 1);
                    e.remove(n)
                }
            }
            setActive(t) {
                this.vertexFeature_ && !t && (this.overlay_.getSource().removeFeature(this.vertexFeature_),
                this.vertexFeature_ = null),
                super.setActive(t)
            }
            setMap(t) {
                this.overlay_.setMap(t),
                super.setMap(t)
            }
            getOverlay() {
                return this.overlay_
            }
            handleSourceAdd_(t) {
                t.feature && this.features_.push(t.feature)
            }
            handleSourceRemove_(t) {
                t.feature && this.features_.remove(t.feature)
            }
            handleFeatureAdd_(t) {
                this.addFeature_(t.element)
            }
            handleFeatureChange_(t) {
                if (!this.changingFeature_) {
                    const e = t.target;
                    this.removeFeature_(e),
                    this.addFeature_(e)
                }
            }
            handleFeatureRemove_(t) {
                this.removeFeature_(t.element)
            }
            writePointGeometry_(t, e) {
                const i = e.getCoordinates()
                  , n = {
                    feature: t,
                    geometry: e,
                    segment: [i, i]
                };
                this.rBush_.insert(e.getExtent(), n)
            }
            writeMultiPointGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let n = 0, r = i.length; n < r; ++n) {
                    const r = i[n]
                      , o = {
                        feature: t,
                        geometry: e,
                        depth: [n],
                        index: n,
                        segment: [r, r]
                    };
                    this.rBush_.insert(e.getExtent(), o)
                }
            }
            writeLineStringGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let n = 0, r = i.length - 1; n < r; ++n) {
                    const r = i.slice(n, n + 2)
                      , o = {
                        feature: t,
                        geometry: e,
                        index: n,
                        segment: r
                    };
                    this.rBush_.insert((0,
                    g.hI)(r), o)
                }
            }
            writeMultiLineStringGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let n = 0, r = i.length; n < r; ++n) {
                    const r = i[n];
                    for (let i = 0, o = r.length - 1; i < o; ++i) {
                        const o = r.slice(i, i + 2)
                          , s = {
                            feature: t,
                            geometry: e,
                            depth: [n],
                            index: i,
                            segment: o
                        };
                        this.rBush_.insert((0,
                        g.hI)(o), s)
                    }
                }
            }
            writePolygonGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let n = 0, r = i.length; n < r; ++n) {
                    const r = i[n];
                    for (let i = 0, o = r.length - 1; i < o; ++i) {
                        const o = r.slice(i, i + 2)
                          , s = {
                            feature: t,
                            geometry: e,
                            depth: [n],
                            index: i,
                            segment: o
                        };
                        this.rBush_.insert((0,
                        g.hI)(o), s)
                    }
                }
            }
            writeMultiPolygonGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let n = 0, r = i.length; n < r; ++n) {
                    const r = i[n];
                    for (let i = 0, o = r.length; i < o; ++i) {
                        const o = r[i];
                        for (let r = 0, s = o.length - 1; r < s; ++r) {
                            const s = o.slice(r, r + 2)
                              , a = {
                                feature: t,
                                geometry: e,
                                depth: [i, n],
                                index: r,
                                segment: s
                            };
                            this.rBush_.insert((0,
                            g.hI)(s), a)
                        }
                    }
                }
            }
            writeCircleGeometry_(t, e) {
                const i = e.getCenter()
                  , n = {
                    feature: t,
                    geometry: e,
                    index: 0,
                    segment: [i, i]
                }
                  , r = {
                    feature: t,
                    geometry: e,
                    index: 1,
                    segment: [i, i]
                }
                  , o = [n, r];
                n.featureSegments = o,
                r.featureSegments = o,
                this.rBush_.insert((0,
                g.HK)(i), n);
                let s = e;
                const a = (0,
                b.Cs)();
                if (a && this.getMap()) {
                    const t = this.getMap().getView().getProjection();
                    s = s.clone().transform(a, t),
                    s = (0,
                    x.Bb)(s).transform(t, a)
                }
                this.rBush_.insert(s.getExtent(), r)
            }
            writeGeometryCollectionGeometry_(t, e) {
                const i = e.getGeometriesArray();
                for (let e = 0; e < i.length; ++e) {
                    const n = i[e];
                    (0,
                    this.SEGMENT_WRITERS_[n.getType()])(t, n)
                }
            }
            createOrUpdateVertexFeature_(t, e, i) {
                let n = this.vertexFeature_;
                if (n) {
                    n.getGeometry().setCoordinates(t)
                } else
                    n = new a.Z(new c.Z(t)),
                    this.vertexFeature_ = n,
                    this.overlay_.getSource().addFeature(n);
                return n.set("features", e),
                n.set("geometries", i),
                n
            }
            handleEvent(t) {
                if (!t.originalEvent)
                    return !0;
                let e;
                return this.lastPointerEvent_ = t,
                t.map.getView().getInteracting() || t.type != l.Z.POINTERMOVE || this.handlingDownUpSequence || this.handlePointerMove_(t),
                this.vertexFeature_ && this.deleteCondition_(t) && (e = !(t.type != l.Z.SINGLECLICK || !this.ignoreNextSingleClick_) || this.removePoint()),
                t.type == l.Z.SINGLECLICK && (this.ignoreNextSingleClick_ = !1),
                super.handleEvent(t) && !e
            }
            handleDragEvent(t) {
                this.ignoreNextSingleClick_ = !1,
                this.willModifyFeatures_(t, this.dragSegments_);
                const e = [t.coordinate[0] + this.delta_[0], t.coordinate[1] + this.delta_[1]]
                  , i = []
                  , n = [];
                for (let r = 0, o = this.dragSegments_.length; r < o; ++r) {
                    const o = this.dragSegments_[r]
                      , s = o[0]
                      , a = s.feature;
                    i.includes(a) || i.push(a);
                    const l = s.geometry;
                    n.includes(l) || n.push(l);
                    const c = s.depth;
                    let h;
                    const u = s.segment
                      , d = o[1];
                    for (; e.length < l.getStride(); )
                        e.push(u[d][e.length]);
                    switch (l.getType()) {
                    case "Point":
                        h = e,
                        u[0] = e,
                        u[1] = e;
                        break;
                    case "MultiPoint":
                        h = l.getCoordinates(),
                        h[s.index] = e,
                        u[0] = e,
                        u[1] = e;
                        break;
                    case "LineString":
                        h = l.getCoordinates(),
                        h[s.index + d] = e,
                        u[d] = e;
                        break;
                    case "MultiLineString":
                    case "Polygon":
                        h = l.getCoordinates(),
                        h[c[0]][s.index + d] = e,
                        u[d] = e;
                        break;
                    case "MultiPolygon":
                        h = l.getCoordinates(),
                        h[c[1]][c[0]][s.index + d] = e,
                        u[d] = e;
                        break;
                    case "Circle":
                        if (u[0] = e,
                        u[1] = e,
                        0 === s.index)
                            this.changingFeature_ = !0,
                            l.setCenter(e),
                            this.changingFeature_ = !1;
                        else {
                            this.changingFeature_ = !0;
                            const i = t.map.getView().getProjection();
                            let n = (0,
                            _.TE)((0,
                            b.Vs)(l.getCenter(), i), (0,
                            b.Vs)(e, i));
                            const r = (0,
                            b.Cs)();
                            if (r) {
                                const t = l.clone().transform(r, i);
                                t.setRadius(n),
                                n = t.transform(i, r).getRadius()
                            }
                            l.setRadius(n),
                            this.changingFeature_ = !1
                        }
                    }
                    h && this.setGeometryCoordinates_(l, h)
                }
                this.createOrUpdateVertexFeature_(e, i, n)
            }
            handleDownEvent(t) {
                if (!this.condition_(t))
                    return !1;
                const e = t.coordinate;
                this.handlePointerAtPixel_(t.pixel, t.map, e),
                this.dragSegments_.length = 0,
                this.featuresBeingModified_ = null;
                const i = this.vertexFeature_;
                if (i) {
                    const n = t.map.getView().getProjection()
                      , r = []
                      , o = i.getGeometry().getCoordinates()
                      , s = (0,
                    g.hI)([o])
                      , a = this.rBush_.getInExtent(s)
                      , l = {};
                    a.sort(M);
                    for (let i = 0, s = a.length; i < s; ++i) {
                        const s = a[i]
                          , c = s.segment;
                        let h = (0,
                        w.sq)(s.geometry);
                        const u = s.depth;
                        if (u && (h += "-" + u.join("-")),
                        l[h] || (l[h] = new Array(2)),
                        "Circle" !== s.geometry.getType() || 1 !== s.index)
                            if (!(0,
                            _.fS)(c[0], o) || l[h][0])
                                if (!(0,
                                _.fS)(c[1], o) || l[h][1])
                                    (0,
                                    w.sq)(c)in this.vertexSegments_ && !l[h][0] && !l[h][1] && this.insertVertexCondition_(t) && r.push(s);
                                else {
                                    if (l[h][0] && 0 === l[h][0].index) {
                                        let t = s.geometry.getCoordinates();
                                        switch (s.geometry.getType()) {
                                        case "LineString":
                                        case "MultiLineString":
                                            continue;
                                        case "MultiPolygon":
                                            t = t[u[1]];
                                        case "Polygon":
                                            if (s.index !== t[u[0]].length - 2)
                                                continue
                                        }
                                    }
                                    this.dragSegments_.push([s, 1]),
                                    l[h][1] = s
                                }
                            else
                                this.dragSegments_.push([s, 0]),
                                l[h][0] = s;
                        else {
                            const t = k(e, s, n);
                            (0,
                            _.fS)(t, o) && !l[h][0] && (this.dragSegments_.push([s, 0]),
                            l[h][0] = s)
                        }
                    }
                    r.length && this.willModifyFeatures_(t, [r]);
                    for (let t = r.length - 1; t >= 0; --t)
                        this.insertVertex_(r[t], o)
                }
                return !!this.vertexFeature_
            }
            handleUpEvent(t) {
                for (let e = this.dragSegments_.length - 1; e >= 0; --e) {
                    const i = this.dragSegments_[e][0]
                      , n = i.geometry;
                    if ("Circle" === n.getType()) {
                        const e = n.getCenter()
                          , r = i.featureSegments[0]
                          , o = i.featureSegments[1];
                        r.segment[0] = e,
                        r.segment[1] = e,
                        o.segment[0] = e,
                        o.segment[1] = e,
                        this.rBush_.update((0,
                        g.HK)(e), r);
                        let s = n;
                        const a = (0,
                        b.Cs)();
                        if (a) {
                            const e = t.map.getView().getProjection();
                            s = s.clone().transform(a, e),
                            s = (0,
                            x.Bb)(s).transform(e, a)
                        }
                        this.rBush_.update(s.getExtent(), o)
                    } else
                        this.rBush_.update((0,
                        g.hI)(i.segment), i)
                }
                return this.featuresBeingModified_ && (this.dispatchEvent(new A(C,this.featuresBeingModified_,t)),
                this.featuresBeingModified_ = null),
                !1
            }
            handlePointerMove_(t) {
                this.lastPixel_ = t.pixel,
                this.handlePointerAtPixel_(t.pixel, t.map, t.coordinate)
            }
            handlePointerAtPixel_(t, e, i) {
                const n = i || e.getCoordinateFromPixel(t)
                  , r = e.getView().getProjection()
                  , o = function(t, e) {
                    return P(n, t, r) - P(n, e, r)
                };
                let s, l;
                if (this.hitDetection_) {
                    const i = "object" == typeof this.hitDetection_ ? t => t === this.hitDetection_ : void 0;
                    e.forEachFeatureAtPixel(t, ( (t, e, i) => {
                        i && (i = new c.Z((0,
                        b.lO)(i.getCoordinates(), r)));
                        const n = i || t.getGeometry();
                        if ("Point" === n.getType() && t instanceof a.Z && this.features_.getArray().includes(t)) {
                            l = n;
                            const e = t.getGeometry().getFlatCoordinates().slice(0, 2);
                            s = [{
                                feature: t,
                                geometry: l,
                                segment: [e, e]
                            }]
                        }
                        return !0
                    }
                    ), {
                        layerFilter: i
                    })
                }
                if (!s) {
                    const t = (0,
                    b.dY)((0,
                    g.HK)(n, E), r)
                      , i = e.getView().getResolution() * this.pixelTolerance_
                      , o = (0,
                    b.Fj)((0,
                    g.f3)(t, i, E), r);
                    s = this.rBush_.getInExtent(o)
                }
                if (s && s.length > 0) {
                    const i = s.sort(o)[0]
                      , a = i.segment;
                    let c = k(n, i, r);
                    const h = e.getPixelFromCoordinate(c);
                    let u = (0,
                    _.TE)(t, h);
                    if (l || u <= this.pixelTolerance_) {
                        const t = {};
                        if (t[(0,
                        w.sq)(a)] = !0,
                        this.snapToPointer_ || (this.delta_[0] = c[0] - n[0],
                        this.delta_[1] = c[1] - n[1]),
                        "Circle" === i.geometry.getType() && 1 === i.index)
                            this.snappedToVertex_ = !0,
                            this.createOrUpdateVertexFeature_(c, [i.feature], [i.geometry]);
                        else {
                            const n = e.getPixelFromCoordinate(a[0])
                              , r = e.getPixelFromCoordinate(a[1])
                              , o = (0,
                            _.bI)(h, n)
                              , l = (0,
                            _.bI)(h, r);
                            u = Math.sqrt(Math.min(o, l)),
                            this.snappedToVertex_ = u <= this.pixelTolerance_,
                            this.snappedToVertex_ && (c = o > l ? a[1] : a[0]),
                            this.createOrUpdateVertexFeature_(c, [i.feature], [i.geometry]);
                            const d = {};
                            d[(0,
                            w.sq)(i.geometry)] = !0;
                            for (let e = 1, i = s.length; e < i; ++e) {
                                const i = s[e].segment;
                                if (!((0,
                                _.fS)(a[0], i[0]) && (0,
                                _.fS)(a[1], i[1]) || (0,
                                _.fS)(a[0], i[1]) && (0,
                                _.fS)(a[1], i[0])))
                                    break;
                                {
                                    const n = (0,
                                    w.sq)(s[e].geometry);
                                    n in d || (d[n] = !0,
                                    t[(0,
                                    w.sq)(i)] = !0)
                                }
                            }
                        }
                        return void (this.vertexSegments_ = t)
                    }
                }
                this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_),
                this.vertexFeature_ = null)
            }
            insertVertex_(t, e) {
                const i = t.segment
                  , n = t.feature
                  , r = t.geometry
                  , o = t.depth
                  , s = t.index;
                let a;
                for (; e.length < r.getStride(); )
                    e.push(0);
                switch (r.getType()) {
                case "MultiLineString":
                case "Polygon":
                    a = r.getCoordinates(),
                    a[o[0]].splice(s + 1, 0, e);
                    break;
                case "MultiPolygon":
                    a = r.getCoordinates(),
                    a[o[1]][o[0]].splice(s + 1, 0, e);
                    break;
                case "LineString":
                    a = r.getCoordinates(),
                    a.splice(s + 1, 0, e);
                    break;
                default:
                    return
                }
                this.setGeometryCoordinates_(r, a);
                const l = this.rBush_;
                l.remove(t),
                this.updateSegmentIndices_(r, s, o, 1);
                const c = {
                    segment: [i[0], e],
                    feature: n,
                    geometry: r,
                    depth: o,
                    index: s
                };
                l.insert((0,
                g.hI)(c.segment), c),
                this.dragSegments_.push([c, 1]);
                const h = {
                    segment: [e, i[1]],
                    feature: n,
                    geometry: r,
                    depth: o,
                    index: s + 1
                };
                l.insert((0,
                g.hI)(h.segment), h),
                this.dragSegments_.push([h, 0]),
                this.ignoreNextSingleClick_ = !0
            }
            removePoint() {
                if (this.lastPointerEvent_ && this.lastPointerEvent_.type != l.Z.POINTERDRAG) {
                    const t = this.lastPointerEvent_;
                    this.willModifyFeatures_(t, this.dragSegments_);
                    const e = this.removeVertex_();
                    return this.featuresBeingModified_ && this.dispatchEvent(new A(C,this.featuresBeingModified_,t)),
                    this.featuresBeingModified_ = null,
                    e
                }
                return !1
            }
            removeVertex_() {
                const t = this.dragSegments_
                  , e = {};
                let i, n, r, o, s, a, l, c, h, u, d, f = !1;
                for (s = t.length - 1; s >= 0; --s)
                    r = t[s],
                    u = r[0],
                    d = (0,
                    w.sq)(u.feature),
                    u.depth && (d += "-" + u.depth.join("-")),
                    d in e || (e[d] = {}),
                    0 === r[1] ? (e[d].right = u,
                    e[d].index = u.index) : 1 == r[1] && (e[d].left = u,
                    e[d].index = u.index + 1);
                for (d in e) {
                    switch (h = e[d].right,
                    l = e[d].left,
                    a = e[d].index,
                    c = a - 1,
                    u = void 0 !== l ? l : h,
                    c < 0 && (c = 0),
                    o = u.geometry,
                    n = o.getCoordinates(),
                    i = n,
                    f = !1,
                    o.getType()) {
                    case "MultiLineString":
                        n[u.depth[0]].length > 2 && (n[u.depth[0]].splice(a, 1),
                        f = !0);
                        break;
                    case "LineString":
                        n.length > 2 && (n.splice(a, 1),
                        f = !0);
                        break;
                    case "MultiPolygon":
                        i = i[u.depth[1]];
                    case "Polygon":
                        i = i[u.depth[0]],
                        i.length > 4 && (a == i.length - 1 && (a = 0),
                        i.splice(a, 1),
                        f = !0,
                        0 === a && (i.pop(),
                        i.push(i[0]),
                        c = i.length - 1))
                    }
                    if (f) {
                        this.setGeometryCoordinates_(o, n);
                        const e = [];
                        if (void 0 !== l && (this.rBush_.remove(l),
                        e.push(l.segment[0])),
                        void 0 !== h && (this.rBush_.remove(h),
                        e.push(h.segment[1])),
                        void 0 !== l && void 0 !== h) {
                            const t = {
                                depth: u.depth,
                                feature: u.feature,
                                geometry: u.geometry,
                                index: c,
                                segment: e
                            };
                            this.rBush_.insert((0,
                            g.hI)(t.segment), t)
                        }
                        this.updateSegmentIndices_(o, a, u.depth, -1),
                        this.vertexFeature_ && (this.overlay_.getSource().removeFeature(this.vertexFeature_),
                        this.vertexFeature_ = null),
                        t.length = 0
                    }
                }
                return f
            }
            setGeometryCoordinates_(t, e) {
                this.changingFeature_ = !0,
                t.setCoordinates(e),
                this.changingFeature_ = !1
            }
            updateSegmentIndices_(t, e, i, n) {
                this.rBush_.forEachInExtent(t.getExtent(), (function(r) {
                    r.geometry === t && (void 0 === i || void 0 === r.depth || (0,
                    v.fS)(r.depth, i)) && r.index > e && (r.index += n)
                }
                ))
            }
        }
        function M(t, e) {
            return t.index - e.index
        }
        function P(t, e, i) {
            const n = e.geometry;
            if ("Circle" === n.getType()) {
                let r = n;
                if (1 === e.index) {
                    const e = (0,
                    b.Cs)();
                    e && (r = r.clone().transform(e, i));
                    const n = (0,
                    _.bI)(r.getCenter(), (0,
                    b.Vs)(t, i))
                      , o = Math.sqrt(n) - r.getRadius();
                    return o * o
                }
            }
            const r = (0,
            b.Vs)(t, i);
            return T[0] = (0,
            b.Vs)(e.segment[0], i),
            T[1] = (0,
            b.Vs)(e.segment[1], i),
            (0,
            _.Bs)(r, T)
        }
        function k(t, e, i) {
            const n = e.geometry;
            if ("Circle" === n.getType() && 1 === e.index) {
                let e = n;
                const r = (0,
                b.Cs)();
                return r && (e = e.clone().transform(r, i)),
                (0,
                b.lO)(e.getClosestPoint((0,
                b.Vs)(t, i)), i)
            }
            const r = (0,
            b.Vs)(t, i);
            return T[0] = (0,
            b.Vs)(e.segment[0], i),
            T[1] = (0,
            b.Vs)(e.segment[1], i),
            (0,
            b.lO)((0,
            _.oL)(r, T), i)
        }
        function O() {
            const t = (0,
            y.Ly)();
            return function(e, i) {
                return t.Point
            }
        }
        e.Z = I
    },
    14515: function(t, e, i) {
        "use strict";
        i.d(e, {
            S: function() {
                return s
            }
        });
        var n = i(47182)
          , r = i(92217);
        class o extends n.ZP {
            constructor(t) {
                super(t = t || {}),
                t.handleDownEvent && (this.handleDownEvent = t.handleDownEvent),
                t.handleDragEvent && (this.handleDragEvent = t.handleDragEvent),
                t.handleMoveEvent && (this.handleMoveEvent = t.handleMoveEvent),
                t.handleUpEvent && (this.handleUpEvent = t.handleUpEvent),
                t.stopDown && (this.stopDown = t.stopDown),
                this.handlingDownUpSequence = !1,
                this.targetPointers = []
            }
            getPointerCount() {
                return this.targetPointers.length
            }
            handleDownEvent(t) {
                return !1
            }
            handleDragEvent(t) {}
            handleEvent(t) {
                if (!t.originalEvent)
                    return !0;
                let e = !1;
                if (this.updateTrackedPointers_(t),
                this.handlingDownUpSequence) {
                    if (t.type == r.Z.POINTERDRAG)
                        this.handleDragEvent(t),
                        t.originalEvent.preventDefault();
                    else if (t.type == r.Z.POINTERUP) {
                        const e = this.handleUpEvent(t);
                        this.handlingDownUpSequence = e && this.targetPointers.length > 0
                    }
                } else if (t.type == r.Z.POINTERDOWN) {
                    const i = this.handleDownEvent(t);
                    this.handlingDownUpSequence = i,
                    e = this.stopDown(i)
                } else
                    t.type == r.Z.POINTERMOVE && this.handleMoveEvent(t);
                return !e
            }
            handleMoveEvent(t) {}
            handleUpEvent(t) {
                return !1
            }
            stopDown(t) {
                return t
            }
            updateTrackedPointers_(t) {
                t.activePointers && (this.targetPointers = t.activePointers)
            }
        }
        function s(t) {
            const e = t.length;
            let i = 0
              , n = 0;
            for (let r = 0; r < e; r++)
                i += t[r].clientX,
                n += t[r].clientY;
            return {
                clientX: i / e,
                clientY: n / e
            }
        }
        e.Z = o
    },
    54049: function(t, e) {
        "use strict";
        e.Z = {
            ACTIVE: "active"
        }
    },
    6002: function(t, e, i) {
        "use strict";
        var n = i(42071)
          , r = i(85487)
          , o = i(14515)
          , s = i(39781)
          , a = i(22796)
          , l = i(36885)
          , c = i(28641)
          , h = i(91900)
          , u = i(69242)
          , d = i(26835)
          , f = i(74187)
          , p = i(65818);
        function m(t) {
            return t.feature ? t.feature : t.element ? t.element : null
        }
        const g = [];
        class _ extends o.Z {
            constructor(t) {
                const e = t = t || {};
                e.handleDownEvent || (e.handleDownEvent = l.uX),
                e.stopDown || (e.stopDown = l.Dv),
                super(e),
                this.source_ = t.source ? t.source : null,
                this.vertex_ = void 0 === t.vertex || t.vertex,
                this.edge_ = void 0 === t.edge || t.edge,
                this.features_ = t.features ? t.features : null,
                this.featuresListenerKeys_ = [],
                this.featureChangeListenerKeys_ = {},
                this.indexedFeaturesExtents_ = {},
                this.pendingFeatures_ = {},
                this.pixelTolerance_ = void 0 !== t.pixelTolerance ? t.pixelTolerance : 10,
                this.rBush_ = new s.Z,
                this.GEOMETRY_SEGMENTERS_ = {
                    Point: this.segmentPointGeometry_.bind(this),
                    LineString: this.segmentLineStringGeometry_.bind(this),
                    LinearRing: this.segmentLineStringGeometry_.bind(this),
                    Polygon: this.segmentPolygonGeometry_.bind(this),
                    MultiPoint: this.segmentMultiPointGeometry_.bind(this),
                    MultiLineString: this.segmentMultiLineStringGeometry_.bind(this),
                    MultiPolygon: this.segmentMultiPolygonGeometry_.bind(this),
                    GeometryCollection: this.segmentGeometryCollectionGeometry_.bind(this),
                    Circle: this.segmentCircleGeometry_.bind(this)
                }
            }
            addFeature(t, e) {
                e = void 0 === e || e;
                const i = (0,
                f.sq)(t)
                  , n = t.getGeometry();
                if (n) {
                    const e = this.GEOMETRY_SEGMENTERS_[n.getType()];
                    if (e) {
                        this.indexedFeaturesExtents_[i] = n.getExtent((0,
                        c.lJ)());
                        const r = [];
                        if (e(r, n),
                        1 === r.length)
                            this.rBush_.insert((0,
                            c.hI)(r[0]), {
                                feature: t,
                                segment: r[0]
                            });
                        else if (r.length > 1) {
                            const e = r.map((t => (0,
                            c.hI)(t)))
                              , i = r.map((e => ({
                                feature: t,
                                segment: e
                            })));
                            this.rBush_.load(e, i)
                        }
                    }
                }
                e && (this.featureChangeListenerKeys_[i] = (0,
                p.oL)(t, r.Z.CHANGE, this.handleFeatureChange_, this))
            }
            getFeatures_() {
                let t;
                return this.features_ ? t = this.features_ : this.source_ && (t = this.source_.getFeatures()),
                t
            }
            handleEvent(t) {
                const e = this.snapTo(t.pixel, t.coordinate, t.map);
                return e && (t.coordinate = e.vertex.slice(0, 2),
                t.pixel = e.vertexPixel),
                super.handleEvent(t)
            }
            handleFeatureAdd_(t) {
                const e = m(t);
                e && this.addFeature(e)
            }
            handleFeatureRemove_(t) {
                const e = m(t);
                e && this.removeFeature(e)
            }
            handleFeatureChange_(t) {
                const e = t.target;
                if (this.handlingDownUpSequence) {
                    const t = (0,
                    f.sq)(e);
                    t in this.pendingFeatures_ || (this.pendingFeatures_[t] = e)
                } else
                    this.updateFeature_(e)
            }
            handleUpEvent(t) {
                const e = Object.values(this.pendingFeatures_);
                return e.length && (e.forEach(this.updateFeature_.bind(this)),
                this.pendingFeatures_ = {}),
                !1
            }
            removeFeature(t, e) {
                const i = void 0 === e || e
                  , n = (0,
                f.sq)(t)
                  , r = this.indexedFeaturesExtents_[n];
                if (r) {
                    const e = this.rBush_
                      , i = [];
                    e.forEachInExtent(r, (function(e) {
                        t === e.feature && i.push(e)
                    }
                    ));
                    for (let t = i.length - 1; t >= 0; --t)
                        e.remove(i[t])
                }
                i && ((0,
                p.bN)(this.featureChangeListenerKeys_[n]),
                delete this.featureChangeListenerKeys_[n])
            }
            setMap(t) {
                const e = this.getMap()
                  , i = this.featuresListenerKeys_
                  , r = this.getFeatures_();
                e && (i.forEach(p.bN),
                i.length = 0,
                this.rBush_.clear(),
                Object.values(this.featureChangeListenerKeys_).forEach(p.bN),
                this.featureChangeListenerKeys_ = {}),
                super.setMap(t),
                t && (this.features_ ? i.push((0,
                p.oL)(this.features_, n.Z.ADD, this.handleFeatureAdd_, this), (0,
                p.oL)(this.features_, n.Z.REMOVE, this.handleFeatureRemove_, this)) : this.source_ && i.push((0,
                p.oL)(this.source_, a.Z.ADDFEATURE, this.handleFeatureAdd_, this), (0,
                p.oL)(this.source_, a.Z.REMOVEFEATURE, this.handleFeatureRemove_, this)),
                r.forEach((t => this.addFeature(t))))
            }
            snapTo(t, e, i) {
                const n = i.getView().getProjection()
                  , r = (0,
                d.Vs)(e, n)
                  , o = (0,
                d.Fj)((0,
                c.f3)((0,
                c.hI)([r]), i.getView().getResolution() * this.pixelTolerance_), n)
                  , s = this.rBush_.getInExtent(o)
                  , a = s.length;
                if (0 === a)
                    return null;
                let l, u = 1 / 0;
                const f = this.pixelTolerance_ * this.pixelTolerance_
                  , p = () => {
                    if (l) {
                        const e = i.getPixelFromCoordinate(l);
                        if ((0,
                        h.bI)(t, e) <= f)
                            return {
                                vertex: l,
                                vertexPixel: [Math.round(e[0]), Math.round(e[1])]
                            }
                    }
                    return null
                }
                ;
                if (this.vertex_) {
                    for (let t = 0; t < a; ++t) {
                        const e = s[t];
                        "Circle" !== e.feature.getGeometry().getType() && e.segment.forEach((t => {
                            const e = (0,
                            d.Vs)(t, n)
                              , i = (0,
                            h.bI)(r, e);
                            i < u && (l = t,
                            u = i)
                        }
                        ))
                    }
                    const t = p();
                    if (t)
                        return t
                }
                if (this.edge_) {
                    for (let t = 0; t < a; ++t) {
                        let e = null;
                        const i = s[t];
                        if ("Circle" === i.feature.getGeometry().getType()) {
                            let t = i.feature.getGeometry();
                            const o = (0,
                            d.Cs)();
                            o && (t = t.clone().transform(o, n)),
                            e = (0,
                            h.Ed)(r, t)
                        } else {
                            const [t,o] = i.segment;
                            o && (g[0] = (0,
                            d.Vs)(t, n),
                            g[1] = (0,
                            d.Vs)(o, n),
                            e = (0,
                            h.oL)(r, g))
                        }
                        if (e) {
                            const t = (0,
                            h.bI)(r, e);
                            t < u && (l = (0,
                            d.lO)(e, n),
                            u = t)
                        }
                    }
                    const t = p();
                    if (t)
                        return t
                }
                return null
            }
            updateFeature_(t) {
                this.removeFeature(t, !1),
                this.addFeature(t, !1)
            }
            segmentCircleGeometry_(t, e) {
                const i = this.getMap().getView().getProjection();
                let n = e;
                const r = (0,
                d.Cs)();
                r && (n = n.clone().transform(r, i));
                const o = (0,
                u.Bb)(n);
                r && o.transform(i, r);
                const s = o.getCoordinates()[0];
                for (let e = 0, i = s.length - 1; e < i; ++e)
                    t.push(s.slice(e, e + 2))
            }
            segmentGeometryCollectionGeometry_(t, e) {
                const i = e.getGeometriesArray();
                for (let e = 0; e < i.length; ++e) {
                    const n = this.GEOMETRY_SEGMENTERS_[i[e].getType()];
                    n && n(t, i[e])
                }
            }
            segmentLineStringGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let e = 0, n = i.length - 1; e < n; ++e)
                    t.push(i.slice(e, e + 2))
            }
            segmentMultiLineStringGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let e = 0, n = i.length; e < n; ++e) {
                    const n = i[e];
                    for (let e = 0, i = n.length - 1; e < i; ++e)
                        t.push(n.slice(e, e + 2))
                }
            }
            segmentMultiPointGeometry_(t, e) {
                e.getCoordinates().forEach((e => {
                    t.push([e])
                }
                ))
            }
            segmentMultiPolygonGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let e = 0, n = i.length; e < n; ++e) {
                    const n = i[e];
                    for (let e = 0, i = n.length; e < i; ++e) {
                        const i = n[e];
                        for (let e = 0, n = i.length - 1; e < n; ++e)
                            t.push(i.slice(e, e + 2))
                    }
                }
            }
            segmentPointGeometry_(t, e) {
                t.push([e.getCoordinates()])
            }
            segmentPolygonGeometry_(t, e) {
                const i = e.getCoordinates();
                for (let e = 0, n = i.length; e < n; ++e) {
                    const n = i[e];
                    for (let e = 0, i = n.length - 1; e < i; ++e)
                        t.push(n.slice(e, e + 2))
                }
            }
        }
        e.Z = _
    },
    947: function(t, e, i) {
        "use strict";
        var n = i(72971)
          , r = i(71912)
          , o = i(74187)
          , s = i(99515)
          , a = i(33983);
        class l extends n.Z {
            constructor(t) {
                super(),
                this.on,
                this.once,
                this.un,
                this.background_ = t.background;
                const e = Object.assign({}, t);
                "object" == typeof t.properties && (delete e.properties,
                Object.assign(e, t.properties)),
                e[r.Z.OPACITY] = void 0 !== t.opacity ? t.opacity : 1,
                (0,
                s.h)("number" == typeof e[r.Z.OPACITY], 64),
                e[r.Z.VISIBLE] = void 0 === t.visible || t.visible,
                e[r.Z.Z_INDEX] = t.zIndex,
                e[r.Z.MAX_RESOLUTION] = void 0 !== t.maxResolution ? t.maxResolution : 1 / 0,
                e[r.Z.MIN_RESOLUTION] = void 0 !== t.minResolution ? t.minResolution : 0,
                e[r.Z.MIN_ZOOM] = void 0 !== t.minZoom ? t.minZoom : -1 / 0,
                e[r.Z.MAX_ZOOM] = void 0 !== t.maxZoom ? t.maxZoom : 1 / 0,
                this.className_ = void 0 !== e.className ? e.className : "ol-layer",
                delete e.className,
                this.setProperties(e),
                this.state_ = null
            }
            getBackground() {
                return this.background_
            }
            getClassName() {
                return this.className_
            }
            getLayerState(t) {
                const e = this.state_ || {
                    layer: this,
                    managed: void 0 === t || t
                }
                  , i = this.getZIndex();
                return e.opacity = (0,
                a.uZ)(Math.round(100 * this.getOpacity()) / 100, 0, 1),
                e.visible = this.getVisible(),
                e.extent = this.getExtent(),
                e.zIndex = void 0 !== i || e.managed ? i : 1 / 0,
                e.maxResolution = this.getMaxResolution(),
                e.minResolution = Math.max(this.getMinResolution(), 0),
                e.minZoom = this.getMinZoom(),
                e.maxZoom = this.getMaxZoom(),
                this.state_ = e,
                e
            }
            getLayersArray(t) {
                return (0,
                o.O3)()
            }
            getLayerStatesArray(t) {
                return (0,
                o.O3)()
            }
            getExtent() {
                return this.get(r.Z.EXTENT)
            }
            getMaxResolution() {
                return this.get(r.Z.MAX_RESOLUTION)
            }
            getMinResolution() {
                return this.get(r.Z.MIN_RESOLUTION)
            }
            getMinZoom() {
                return this.get(r.Z.MIN_ZOOM)
            }
            getMaxZoom() {
                return this.get(r.Z.MAX_ZOOM)
            }
            getOpacity() {
                return this.get(r.Z.OPACITY)
            }
            getSourceState() {
                return (0,
                o.O3)()
            }
            getVisible() {
                return this.get(r.Z.VISIBLE)
            }
            getZIndex() {
                return this.get(r.Z.Z_INDEX)
            }
            setBackground(t) {
                this.background_ = t,
                this.changed()
            }
            setExtent(t) {
                this.set(r.Z.EXTENT, t)
            }
            setMaxResolution(t) {
                this.set(r.Z.MAX_RESOLUTION, t)
            }
            setMinResolution(t) {
                this.set(r.Z.MIN_RESOLUTION, t)
            }
            setMaxZoom(t) {
                this.set(r.Z.MAX_ZOOM, t)
            }
            setMinZoom(t) {
                this.set(r.Z.MIN_ZOOM, t)
            }
            setOpacity(t) {
                (0,
                s.h)("number" == typeof t, 64),
                this.set(r.Z.OPACITY, t)
            }
            setVisible(t) {
                this.set(r.Z.VISIBLE, t)
            }
            setZIndex(t) {
                this.set(r.Z.Z_INDEX, t)
            }
            disposeInternal() {
                this.state_ && (this.state_.layer = null,
                this.state_ = null),
                super.disposeInternal()
            }
        }
        e.Z = l
    },
    2989: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return v
            }
        });
        var n = i(1295)
          , r = i(82582)
          , o = i(47539)
          , s = i(30283)
          , a = i(51345)
          , l = i(81332)
          , c = i(35393)
          , h = i(58958)
          , u = i(21280);
        function d(t) {
            return new o.ZP({
                fill: f(t, ""),
                stroke: p(t, ""),
                text: m(t),
                image: g(t)
            })
        }
        function f(t, e) {
            const i = t[e + "fill-color"];
            if (i)
                return new a.Z({
                    color: i
                })
        }
        function p(t, e) {
            const i = t[e + "stroke-width"]
              , n = t[e + "stroke-color"];
            if (i || n)
                return new h.Z({
                    width: i,
                    color: n,
                    lineCap: t[e + "stroke-line-cap"],
                    lineJoin: t[e + "stroke-line-join"],
                    lineDash: t[e + "stroke-line-dash"],
                    lineDashOffset: t[e + "stroke-line-dash-offset"],
                    miterLimit: t[e + "stroke-miter-limit"]
                })
        }
        function m(t) {
            const e = t["text-value"];
            if (!e)
                return;
            return new u.Z({
                text: e,
                font: t["text-font"],
                maxAngle: t["text-max-angle"],
                offsetX: t["text-offset-x"],
                offsetY: t["text-offset-y"],
                overflow: t["text-overflow"],
                placement: t["text-placement"],
                repeat: t["text-repeat"],
                scale: t["text-scale"],
                rotateWithView: t["text-rotate-with-view"],
                rotation: t["text-rotation"],
                textAlign: t["text-align"],
                justify: t["text-justify"],
                textBaseline: t["text-baseline"],
                padding: t["text-padding"],
                fill: f(t, "text-"),
                backgroundFill: f(t, "text-background-"),
                stroke: p(t, "text-"),
                backgroundStroke: p(t, "text-background-")
            })
        }
        function g(t) {
            const e = t["icon-src"]
              , i = t["icon-img"];
            if (e || i) {
                return new l.Z({
                    src: e,
                    img: i,
                    imgSize: t["icon-img-size"],
                    anchor: t["icon-anchor"],
                    anchorOrigin: t["icon-anchor-origin"],
                    anchorXUnits: t["icon-anchor-x-units"],
                    anchorYUnits: t["icon-anchor-y-units"],
                    color: t["icon-color"],
                    crossOrigin: t["icon-cross-origin"],
                    offset: t["icon-offset"],
                    displacement: t["icon-displacement"],
                    opacity: t["icon-opacity"],
                    scale: t["icon-scale"],
                    width: t["icon-width"],
                    height: t["icon-height"],
                    rotation: t["icon-rotation"],
                    rotateWithView: t["icon-rotate-with-view"],
                    size: t["icon-size"],
                    declutterMode: t["icon-declutter-mode"]
                })
            }
            const n = t["shape-points"];
            if (n) {
                const e = "shape-";
                return new c.Z({
                    points: n,
                    fill: f(t, e),
                    stroke: p(t, e),
                    radius: t["shape-radius"],
                    radius1: t["shape-radius1"],
                    radius2: t["shape-radius2"],
                    angle: t["shape-angle"],
                    displacement: t["shape-displacement"],
                    rotation: t["shape-rotation"],
                    rotateWithView: t["shape-rotate-with-view"],
                    scale: t["shape-scale"],
                    declutterMode: t["shape-declutter-mode"]
                })
            }
            const r = t["circle-radius"];
            if (r) {
                const e = "circle-";
                return new s.Z({
                    radius: r,
                    fill: f(t, e),
                    stroke: p(t, e),
                    displacement: t["circle-displacement"],
                    scale: t["circle-scale"],
                    rotation: t["circle-rotation"],
                    rotateWithView: t["circle-rotate-with-view"],
                    declutterMode: t["circle-declutter-mode"]
                })
            }
        }
        const _ = "renderOrder";
        class y extends n.Z {
            constructor(t) {
                t = t || {};
                const e = Object.assign({}, t);
                delete e.style,
                delete e.renderBuffer,
                delete e.updateWhileAnimating,
                delete e.updateWhileInteracting,
                super(e),
                this.declutter_ = void 0 !== t.declutter && t.declutter,
                this.renderBuffer_ = void 0 !== t.renderBuffer ? t.renderBuffer : 100,
                this.style_ = null,
                this.styleFunction_ = void 0,
                this.setStyle(t.style),
                this.updateWhileAnimating_ = void 0 !== t.updateWhileAnimating && t.updateWhileAnimating,
                this.updateWhileInteracting_ = void 0 !== t.updateWhileInteracting && t.updateWhileInteracting
            }
            getDeclutter() {
                return this.declutter_
            }
            getFeatures(t) {
                return super.getFeatures(t)
            }
            getRenderBuffer() {
                return this.renderBuffer_
            }
            getRenderOrder() {
                return this.get(_)
            }
            getStyle() {
                return this.style_
            }
            getStyleFunction() {
                return this.styleFunction_
            }
            getUpdateWhileAnimating() {
                return this.updateWhileAnimating_
            }
            getUpdateWhileInteracting() {
                return this.updateWhileInteracting_
            }
            renderDeclutter(t) {
                t.declutterTree || (t.declutterTree = new r(9)),
                this.getRenderer().renderDeclutter(t)
            }
            setRenderOrder(t) {
                this.set(_, t)
            }
            setStyle(t) {
                let e;
                if (void 0 === t)
                    e = o.yF;
                else if (null === t)
                    e = null;
                else if ("function" == typeof t)
                    e = t;
                else if (t instanceof o.ZP)
                    e = t;
                else if (Array.isArray(t)) {
                    const i = t.length
                      , n = new Array(i);
                    for (let e = 0; e < i; ++e) {
                        const i = t[e];
                        i instanceof o.ZP ? n[e] = i : n[e] = d(i)
                    }
                    e = n
                } else
                    e = d(t);
                this.style_ = e,
                this.styleFunction_ = null === t ? void 0 : (0,
                o.J$)(this.style_),
                this.changed()
            }
        }
        var v = y
    },
    1295: function(t, e, i) {
        "use strict";
        i.d(e, {
            j: function() {
                return d
            }
        });
        var n = i(947)
          , r = i(85487)
          , o = i(71912)
          , s = i(98771)
          , a = i(12327)
          , l = i(99515)
          , c = i(28641)
          , h = i(65818);
        class u extends n.Z {
            constructor(t) {
                const e = Object.assign({}, t);
                delete e.source,
                super(e),
                this.on,
                this.once,
                this.un,
                this.mapPrecomposeKey_ = null,
                this.mapRenderKey_ = null,
                this.sourceChangeKey_ = null,
                this.renderer_ = null,
                this.sourceReady_ = !1,
                this.rendered = !1,
                t.render && (this.render = t.render),
                t.map && this.setMap(t.map),
                this.addChangeListener(o.Z.SOURCE, this.handleSourcePropertyChange_);
                const i = t.source ? t.source : null;
                this.setSource(i)
            }
            getLayersArray(t) {
                return (t = t || []).push(this),
                t
            }
            getLayerStatesArray(t) {
                return (t = t || []).push(this.getLayerState()),
                t
            }
            getSource() {
                return this.get(o.Z.SOURCE) || null
            }
            getRenderSource() {
                return this.getSource()
            }
            getSourceState() {
                const t = this.getSource();
                return t ? t.getState() : "undefined"
            }
            handleSourceChange_() {
                this.changed(),
                this.sourceReady_ || "ready" !== this.getSource().getState() || (this.sourceReady_ = !0,
                this.dispatchEvent("sourceready"))
            }
            handleSourcePropertyChange_() {
                this.sourceChangeKey_ && ((0,
                h.bN)(this.sourceChangeKey_),
                this.sourceChangeKey_ = null),
                this.sourceReady_ = !1;
                const t = this.getSource();
                t && (this.sourceChangeKey_ = (0,
                h.oL)(t, r.Z.CHANGE, this.handleSourceChange_, this),
                "ready" === t.getState() && (this.sourceReady_ = !0,
                setTimeout(( () => {
                    this.dispatchEvent("sourceready")
                }
                ), 0))),
                this.changed()
            }
            getFeatures(t) {
                return this.renderer_ ? this.renderer_.getFeatures(t) : Promise.resolve([])
            }
            getData(t) {
                return this.renderer_ && this.rendered ? this.renderer_.getData(t) : null
            }
            isVisible(t) {
                let e;
                const i = this.getMapInternal();
                let n;
                !t && i && (t = i.getView()),
                e = t instanceof a.ZP ? {
                    viewState: t.getState(),
                    extent: t.calculateExtent()
                } : t,
                !e.layerStatesArray && i && (e.layerStatesArray = i.getLayerGroup().getLayerStatesArray()),
                n = e.layerStatesArray ? e.layerStatesArray.find((t => t.layer === this)) : this.getLayerState();
                const r = this.getExtent();
                return d(n, e.viewState) && (!r || (0,
                c.kK)(r, e.extent))
            }
            getAttributions(t) {
                if (!this.isVisible(t))
                    return [];
                let e;
                const i = this.getSource();
                if (i && (e = i.getAttributions()),
                !e)
                    return [];
                let n = e(t instanceof a.ZP ? t.getViewStateAndExtent() : t);
                return Array.isArray(n) || (n = [n]),
                n
            }
            render(t, e) {
                const i = this.getRenderer();
                return i.prepareFrame(t) ? (this.rendered = !0,
                i.renderFrame(t, e)) : null
            }
            unrender() {
                this.rendered = !1
            }
            setMapInternal(t) {
                t || this.unrender(),
                this.set(o.Z.MAP, t)
            }
            getMapInternal() {
                return this.get(o.Z.MAP)
            }
            setMap(t) {
                this.mapPrecomposeKey_ && ((0,
                h.bN)(this.mapPrecomposeKey_),
                this.mapPrecomposeKey_ = null),
                t || this.changed(),
                this.mapRenderKey_ && ((0,
                h.bN)(this.mapRenderKey_),
                this.mapRenderKey_ = null),
                t && (this.mapPrecomposeKey_ = (0,
                h.oL)(t, s.Z.PRECOMPOSE, (function(t) {
                    const e = t.frameState.layerStatesArray
                      , i = this.getLayerState(!1);
                    (0,
                    l.h)(!e.some((function(t) {
                        return t.layer === i.layer
                    }
                    )), 67),
                    e.push(i)
                }
                ), this),
                this.mapRenderKey_ = (0,
                h.oL)(this, r.Z.CHANGE, t.render, t),
                this.changed())
            }
            setSource(t) {
                this.set(o.Z.SOURCE, t)
            }
            getRenderer() {
                return this.renderer_ || (this.renderer_ = this.createRenderer()),
                this.renderer_
            }
            hasRenderer() {
                return !!this.renderer_
            }
            createRenderer() {
                return null
            }
            disposeInternal() {
                this.renderer_ && (this.renderer_.dispose(),
                delete this.renderer_),
                this.setSource(null),
                super.disposeInternal()
            }
        }
        function d(t, e) {
            if (!t.visible)
                return !1;
            const i = e.resolution;
            if (i < t.minResolution || i >= t.maxResolution)
                return !1;
            const n = e.zoom;
            return n > t.minZoom && n <= t.maxZoom
        }
        e.Z = u
    },
    71912: function(t, e) {
        "use strict";
        e.Z = {
            OPACITY: "opacity",
            VISIBLE: "visible",
            EXTENT: "extent",
            Z_INDEX: "zIndex",
            MAX_RESOLUTION: "maxResolution",
            MIN_RESOLUTION: "minResolution",
            MAX_ZOOM: "maxZoom",
            MIN_ZOOM: "minZoom",
            SOURCE: "source",
            MAP: "map"
        }
    },
    67315: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return ft
            }
        });
        var n = i(2989);
        const r = {
            BEGIN_GEOMETRY: 0,
            BEGIN_PATH: 1,
            CIRCLE: 2,
            CLOSE_PATH: 3,
            CUSTOM: 4,
            DRAW_CHARS: 5,
            DRAW_IMAGE: 6,
            END_GEOMETRY: 7,
            FILL: 8,
            MOVE_TO_LINE_TO: 9,
            SET_FILL_STYLE: 10,
            SET_STROKE_STYLE: 11,
            STROKE: 12
        }
          , o = [r.FILL]
          , s = [r.STROKE]
          , a = [r.BEGIN_PATH]
          , l = [r.CLOSE_PATH];
        var c = r
          , h = i(28716);
        var u = class {
            drawCustom(t, e, i, n) {}
            drawGeometry(t) {}
            setStyle(t) {}
            drawCircle(t, e) {}
            drawFeature(t, e) {}
            drawGeometryCollection(t, e) {}
            drawLineString(t, e) {}
            drawMultiLineString(t, e) {}
            drawMultiPoint(t, e) {}
            drawMultiPolygon(t, e) {}
            drawPoint(t, e) {}
            drawPolygon(t, e) {}
            drawText(t, e) {}
            setFillStrokeStyle(t, e) {}
            setImageStyle(t, e) {}
            setTextStyle(t, e) {}
        }
          , d = i(96620)
          , f = i(28641)
          , p = i(50147)
          , m = i(65537)
          , g = i(89241);
        var _ = class extends u {
            constructor(t, e, i, n) {
                super(),
                this.tolerance = t,
                this.maxExtent = e,
                this.pixelRatio = n,
                this.maxLineWidth = 0,
                this.resolution = i,
                this.beginGeometryInstruction1_ = null,
                this.beginGeometryInstruction2_ = null,
                this.bufferedMaxExtent_ = null,
                this.instructions = [],
                this.coordinates = [],
                this.tmpCoordinate_ = [],
                this.hitDetectionInstructions = [],
                this.state = {}
            }
            applyPixelRatio(t) {
                const e = this.pixelRatio;
                return 1 == e ? t : t.map((function(t) {
                    return t * e
                }
                ))
            }
            appendFlatPointCoordinates(t, e) {
                const i = this.getBufferedMaxExtent()
                  , n = this.tmpCoordinate_
                  , r = this.coordinates;
                let o = r.length;
                for (let s = 0, a = t.length; s < a; s += e)
                    n[0] = t[s],
                    n[1] = t[s + 1],
                    (0,
                    f.b8)(i, n) && (r[o++] = n[0],
                    r[o++] = n[1]);
                return o
            }
            appendFlatLineCoordinates(t, e, i, n, r, o) {
                const s = this.coordinates;
                let a = s.length;
                const l = this.getBufferedMaxExtent();
                o && (e += n);
                let c = t[e]
                  , u = t[e + 1];
                const d = this.tmpCoordinate_;
                let p, m, g, _ = !0;
                for (p = e + n; p < i; p += n)
                    d[0] = t[p],
                    d[1] = t[p + 1],
                    g = (0,
                    f.pX)(l, d),
                    g !== m ? (_ && (s[a++] = c,
                    s[a++] = u,
                    _ = !1),
                    s[a++] = d[0],
                    s[a++] = d[1]) : g === h.Z.INTERSECTING ? (s[a++] = d[0],
                    s[a++] = d[1],
                    _ = !1) : _ = !0,
                    c = d[0],
                    u = d[1],
                    m = g;
                return (r && _ || p === e + n) && (s[a++] = c,
                s[a++] = u),
                a
            }
            drawCustomCoordinates_(t, e, i, n, r) {
                for (let o = 0, s = i.length; o < s; ++o) {
                    const s = i[o]
                      , a = this.appendFlatLineCoordinates(t, e, s, n, !1, !1);
                    r.push(a),
                    e = s
                }
                return e
            }
            drawCustom(t, e, i, n) {
                this.beginGeometry(t, e);
                const r = t.getType()
                  , o = t.getStride()
                  , s = this.coordinates.length;
                let a, l, h, u, d;
                switch (r) {
                case "MultiPolygon":
                    a = t.getOrientedFlatCoordinates(),
                    u = [];
                    const e = t.getEndss();
                    d = 0;
                    for (let t = 0, i = e.length; t < i; ++t) {
                        const i = [];
                        d = this.drawCustomCoordinates_(a, d, e[t], o, i),
                        u.push(i)
                    }
                    this.instructions.push([c.CUSTOM, s, u, t, i, g.ug]),
                    this.hitDetectionInstructions.push([c.CUSTOM, s, u, t, n || i, g.ug]);
                    break;
                case "Polygon":
                case "MultiLineString":
                    h = [],
                    a = "Polygon" == r ? t.getOrientedFlatCoordinates() : t.getFlatCoordinates(),
                    d = this.drawCustomCoordinates_(a, 0, t.getEnds(), o, h),
                    this.instructions.push([c.CUSTOM, s, h, t, i, g.o1]),
                    this.hitDetectionInstructions.push([c.CUSTOM, s, h, t, n || i, g.o1]);
                    break;
                case "LineString":
                case "Circle":
                    a = t.getFlatCoordinates(),
                    l = this.appendFlatLineCoordinates(a, 0, a.length, o, !1, !1),
                    this.instructions.push([c.CUSTOM, s, l, t, i, g.Ml]),
                    this.hitDetectionInstructions.push([c.CUSTOM, s, l, t, n || i, g.Ml]);
                    break;
                case "MultiPoint":
                    a = t.getFlatCoordinates(),
                    l = this.appendFlatPointCoordinates(a, o),
                    l > s && (this.instructions.push([c.CUSTOM, s, l, t, i, g.Ml]),
                    this.hitDetectionInstructions.push([c.CUSTOM, s, l, t, n || i, g.Ml]));
                    break;
                case "Point":
                    a = t.getFlatCoordinates(),
                    this.coordinates.push(a[0], a[1]),
                    l = this.coordinates.length,
                    this.instructions.push([c.CUSTOM, s, l, t, i]),
                    this.hitDetectionInstructions.push([c.CUSTOM, s, l, t, n || i])
                }
                this.endGeometry(e)
            }
            beginGeometry(t, e) {
                this.beginGeometryInstruction1_ = [c.BEGIN_GEOMETRY, e, 0, t],
                this.instructions.push(this.beginGeometryInstruction1_),
                this.beginGeometryInstruction2_ = [c.BEGIN_GEOMETRY, e, 0, t],
                this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)
            }
            finish() {
                return {
                    instructions: this.instructions,
                    hitDetectionInstructions: this.hitDetectionInstructions,
                    coordinates: this.coordinates
                }
            }
            reverseHitDetectionInstructions() {
                const t = this.hitDetectionInstructions;
                let e;
                t.reverse();
                const i = t.length;
                let n, r, o = -1;
                for (e = 0; e < i; ++e)
                    n = t[e],
                    r = n[0],
                    r == c.END_GEOMETRY ? o = e : r == c.BEGIN_GEOMETRY && (n[2] = e,
                    (0,
                    m.FZ)(this.hitDetectionInstructions, o, e),
                    o = -1)
            }
            setFillStrokeStyle(t, e) {
                const i = this.state;
                if (t) {
                    const e = t.getColor();
                    i.fillStyle = (0,
                    d.y)(e || p.bL)
                } else
                    i.fillStyle = void 0;
                if (e) {
                    const t = e.getColor();
                    i.strokeStyle = (0,
                    d.y)(t || p.Tx);
                    const n = e.getLineCap();
                    i.lineCap = void 0 !== n ? n : p.mb;
                    const r = e.getLineDash();
                    i.lineDash = r ? r.slice() : p.X9;
                    const o = e.getLineDashOffset();
                    i.lineDashOffset = o || p.He;
                    const s = e.getLineJoin();
                    i.lineJoin = void 0 !== s ? s : p.rc;
                    const a = e.getWidth();
                    i.lineWidth = void 0 !== a ? a : p.yC;
                    const l = e.getMiterLimit();
                    i.miterLimit = void 0 !== l ? l : p.V4,
                    i.lineWidth > this.maxLineWidth && (this.maxLineWidth = i.lineWidth,
                    this.bufferedMaxExtent_ = null)
                } else
                    i.strokeStyle = void 0,
                    i.lineCap = void 0,
                    i.lineDash = null,
                    i.lineDashOffset = void 0,
                    i.lineJoin = void 0,
                    i.lineWidth = void 0,
                    i.miterLimit = void 0
            }
            createFill(t) {
                const e = t.fillStyle
                  , i = [c.SET_FILL_STYLE, e];
                return "string" != typeof e && i.push(!0),
                i
            }
            applyStroke(t) {
                this.instructions.push(this.createStroke(t))
            }
            createStroke(t) {
                return [c.SET_STROKE_STYLE, t.strokeStyle, t.lineWidth * this.pixelRatio, t.lineCap, t.lineJoin, t.miterLimit, this.applyPixelRatio(t.lineDash), t.lineDashOffset * this.pixelRatio]
            }
            updateFillStyle(t, e) {
                const i = t.fillStyle;
                "string" == typeof i && t.currentFillStyle == i || (void 0 !== i && this.instructions.push(e.call(this, t)),
                t.currentFillStyle = i)
            }
            updateStrokeStyle(t, e) {
                const i = t.strokeStyle
                  , n = t.lineCap
                  , r = t.lineDash
                  , o = t.lineDashOffset
                  , s = t.lineJoin
                  , a = t.lineWidth
                  , l = t.miterLimit;
                (t.currentStrokeStyle != i || t.currentLineCap != n || r != t.currentLineDash && !(0,
                m.fS)(t.currentLineDash, r) || t.currentLineDashOffset != o || t.currentLineJoin != s || t.currentLineWidth != a || t.currentMiterLimit != l) && (void 0 !== i && e.call(this, t),
                t.currentStrokeStyle = i,
                t.currentLineCap = n,
                t.currentLineDash = r,
                t.currentLineDashOffset = o,
                t.currentLineJoin = s,
                t.currentLineWidth = a,
                t.currentMiterLimit = l)
            }
            endGeometry(t) {
                this.beginGeometryInstruction1_[2] = this.instructions.length,
                this.beginGeometryInstruction1_ = null,
                this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length,
                this.beginGeometryInstruction2_ = null;
                const e = [c.END_GEOMETRY, t];
                this.instructions.push(e),
                this.hitDetectionInstructions.push(e)
            }
            getBufferedMaxExtent() {
                if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = (0,
                f.d9)(this.maxExtent),
                this.maxLineWidth > 0)) {
                    const t = this.resolution * (this.maxLineWidth + 1) / 2;
                    (0,
                    f.f3)(this.bufferedMaxExtent_, t, this.bufferedMaxExtent_)
                }
                return this.bufferedMaxExtent_
            }
        }
        ;
        var y = class extends _ {
            constructor(t, e, i, n) {
                super(t, e, i, n),
                this.hitDetectionImage_ = null,
                this.image_ = null,
                this.imagePixelRatio_ = void 0,
                this.anchorX_ = void 0,
                this.anchorY_ = void 0,
                this.height_ = void 0,
                this.opacity_ = void 0,
                this.originX_ = void 0,
                this.originY_ = void 0,
                this.rotateWithView_ = void 0,
                this.rotation_ = void 0,
                this.scale_ = void 0,
                this.width_ = void 0,
                this.declutterMode_ = void 0,
                this.declutterImageWithText_ = void 0
            }
            drawPoint(t, e) {
                if (!this.image_)
                    return;
                this.beginGeometry(t, e);
                const i = t.getFlatCoordinates()
                  , n = t.getStride()
                  , r = this.coordinates.length
                  , o = this.appendFlatPointCoordinates(i, n);
                this.instructions.push([c.DRAW_IMAGE, r, o, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
                this.hitDetectionInstructions.push([c.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
                this.endGeometry(e)
            }
            drawMultiPoint(t, e) {
                if (!this.image_)
                    return;
                this.beginGeometry(t, e);
                const i = t.getFlatCoordinates()
                  , n = t.getStride()
                  , r = this.coordinates.length
                  , o = this.appendFlatPointCoordinates(i, n);
                this.instructions.push([c.DRAW_IMAGE, r, o, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
                this.hitDetectionInstructions.push([c.DRAW_IMAGE, r, o, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
                this.endGeometry(e)
            }
            finish() {
                return this.reverseHitDetectionInstructions(),
                this.anchorX_ = void 0,
                this.anchorY_ = void 0,
                this.hitDetectionImage_ = null,
                this.image_ = null,
                this.imagePixelRatio_ = void 0,
                this.height_ = void 0,
                this.scale_ = void 0,
                this.opacity_ = void 0,
                this.originX_ = void 0,
                this.originY_ = void 0,
                this.rotateWithView_ = void 0,
                this.rotation_ = void 0,
                this.width_ = void 0,
                super.finish()
            }
            setImageStyle(t, e) {
                const i = t.getAnchor()
                  , n = t.getSize()
                  , r = t.getOrigin();
                this.imagePixelRatio_ = t.getPixelRatio(this.pixelRatio),
                this.anchorX_ = i[0],
                this.anchorY_ = i[1],
                this.hitDetectionImage_ = t.getHitDetectionImage(),
                this.image_ = t.getImage(this.pixelRatio),
                this.height_ = n[1],
                this.opacity_ = t.getOpacity(),
                this.originX_ = r[0],
                this.originY_ = r[1],
                this.rotateWithView_ = t.getRotateWithView(),
                this.rotation_ = t.getRotation(),
                this.scale_ = t.getScaleArray(),
                this.width_ = n[0],
                this.declutterMode_ = t.getDeclutterMode(),
                this.declutterImageWithText_ = e
            }
        }
        ;
        var v = class extends _ {
            constructor(t, e, i, n) {
                super(t, e, i, n)
            }
            drawFlatCoordinates_(t, e, i, n) {
                const r = this.coordinates.length
                  , o = this.appendFlatLineCoordinates(t, e, i, n, !1, !1)
                  , s = [c.MOVE_TO_LINE_TO, r, o];
                return this.instructions.push(s),
                this.hitDetectionInstructions.push(s),
                i
            }
            drawLineString(t, e) {
                const i = this.state
                  , n = i.strokeStyle
                  , r = i.lineWidth;
                if (void 0 === n || void 0 === r)
                    return;
                this.updateStrokeStyle(i, this.applyStroke),
                this.beginGeometry(t, e),
                this.hitDetectionInstructions.push([c.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, p.X9, p.He], a);
                const o = t.getFlatCoordinates()
                  , l = t.getStride();
                this.drawFlatCoordinates_(o, 0, o.length, l),
                this.hitDetectionInstructions.push(s),
                this.endGeometry(e)
            }
            drawMultiLineString(t, e) {
                const i = this.state
                  , n = i.strokeStyle
                  , r = i.lineWidth;
                if (void 0 === n || void 0 === r)
                    return;
                this.updateStrokeStyle(i, this.applyStroke),
                this.beginGeometry(t, e),
                this.hitDetectionInstructions.push([c.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset], a);
                const o = t.getEnds()
                  , l = t.getFlatCoordinates()
                  , h = t.getStride();
                let u = 0;
                for (let t = 0, e = o.length; t < e; ++t)
                    u = this.drawFlatCoordinates_(l, u, o[t], h);
                this.hitDetectionInstructions.push(s),
                this.endGeometry(e)
            }
            finish() {
                const t = this.state;
                return null != t.lastStroke && t.lastStroke != this.coordinates.length && this.instructions.push(s),
                this.reverseHitDetectionInstructions(),
                this.state = null,
                super.finish()
            }
            applyStroke(t) {
                null != t.lastStroke && t.lastStroke != this.coordinates.length && (this.instructions.push(s),
                t.lastStroke = this.coordinates.length),
                t.lastStroke = 0,
                super.applyStroke(t),
                this.instructions.push(a)
            }
        }
          , x = i(80226);
        var b = class extends _ {
            constructor(t, e, i, n) {
                super(t, e, i, n)
            }
            drawFlatCoordinatess_(t, e, i, n) {
                const r = this.state
                  , h = void 0 !== r.fillStyle
                  , u = void 0 !== r.strokeStyle
                  , d = i.length;
                this.instructions.push(a),
                this.hitDetectionInstructions.push(a);
                for (let r = 0; r < d; ++r) {
                    const o = i[r]
                      , s = this.coordinates.length
                      , a = this.appendFlatLineCoordinates(t, e, o, n, !0, !u)
                      , h = [c.MOVE_TO_LINE_TO, s, a];
                    this.instructions.push(h),
                    this.hitDetectionInstructions.push(h),
                    u && (this.instructions.push(l),
                    this.hitDetectionInstructions.push(l)),
                    e = o
                }
                return h && (this.instructions.push(o),
                this.hitDetectionInstructions.push(o)),
                u && (this.instructions.push(s),
                this.hitDetectionInstructions.push(s)),
                e
            }
            drawCircle(t, e) {
                const i = this.state
                  , n = i.fillStyle
                  , r = i.strokeStyle;
                if (void 0 === n && void 0 === r)
                    return;
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== i.fillStyle && this.hitDetectionInstructions.push([c.SET_FILL_STYLE, p.bL]),
                void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([c.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
                const l = t.getFlatCoordinates()
                  , h = t.getStride()
                  , u = this.coordinates.length;
                this.appendFlatLineCoordinates(l, 0, l.length, h, !1, !1);
                const d = [c.CIRCLE, u];
                this.instructions.push(a, d),
                this.hitDetectionInstructions.push(a, d),
                void 0 !== i.fillStyle && (this.instructions.push(o),
                this.hitDetectionInstructions.push(o)),
                void 0 !== i.strokeStyle && (this.instructions.push(s),
                this.hitDetectionInstructions.push(s)),
                this.endGeometry(e)
            }
            drawPolygon(t, e) {
                const i = this.state
                  , n = i.fillStyle
                  , r = i.strokeStyle;
                if (void 0 === n && void 0 === r)
                    return;
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== i.fillStyle && this.hitDetectionInstructions.push([c.SET_FILL_STYLE, p.bL]),
                void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([c.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
                const o = t.getEnds()
                  , s = t.getOrientedFlatCoordinates()
                  , a = t.getStride();
                this.drawFlatCoordinatess_(s, 0, o, a),
                this.endGeometry(e)
            }
            drawMultiPolygon(t, e) {
                const i = this.state
                  , n = i.fillStyle
                  , r = i.strokeStyle;
                if (void 0 === n && void 0 === r)
                    return;
                this.setFillStrokeStyles_(),
                this.beginGeometry(t, e),
                void 0 !== i.fillStyle && this.hitDetectionInstructions.push([c.SET_FILL_STYLE, p.bL]),
                void 0 !== i.strokeStyle && this.hitDetectionInstructions.push([c.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth, i.lineCap, i.lineJoin, i.miterLimit, i.lineDash, i.lineDashOffset]);
                const o = t.getEndss()
                  , s = t.getOrientedFlatCoordinates()
                  , a = t.getStride();
                let l = 0;
                for (let t = 0, e = o.length; t < e; ++t)
                    l = this.drawFlatCoordinatess_(s, l, o[t], a);
                this.endGeometry(e)
            }
            finish() {
                this.reverseHitDetectionInstructions(),
                this.state = null;
                const t = this.tolerance;
                if (0 !== t) {
                    const e = this.coordinates;
                    for (let i = 0, n = e.length; i < n; ++i)
                        e[i] = (0,
                        x.uZ)(e[i], t)
                }
                return super.finish()
            }
            setFillStrokeStyles_() {
                const t = this.state;
                void 0 !== t.fillStyle && this.updateFillStyle(t, this.createFill),
                void 0 !== t.strokeStyle && this.updateStrokeStyle(t, this.applyStroke)
            }
        }
          , w = i(74187)
          , E = i(33983);
        function T(t, e, i, n, r) {
            const o = [];
            let s = i
              , a = 0
              , l = e.slice(i, 2);
            for (; a < t && s + r < n; ) {
                const [i,n] = l.slice(-2)
                  , c = e[s + r]
                  , h = e[s + r + 1]
                  , u = Math.sqrt((c - i) * (c - i) + (h - n) * (h - n));
                if (a += u,
                a >= t) {
                    const e = (t - a + u) / u
                      , d = (0,
                    E.t7)(i, c, e)
                      , f = (0,
                    E.t7)(n, h, e);
                    l.push(d, f),
                    o.push(l),
                    l = [d, f],
                    a == t && (s += r),
                    a = 0
                } else if (a < t)
                    l.push(e[s + r], e[s + r + 1]),
                    s += r;
                else {
                    const t = u - a
                      , e = (0,
                    E.t7)(i, c, t / u)
                      , d = (0,
                    E.t7)(n, h, t / u);
                    l.push(e, d),
                    o.push(l),
                    l = [e, d],
                    a = 0,
                    s += r
                }
            }
            return a > 0 && o.push(l),
            o
        }
        function S(t, e, i, n, r) {
            let o, s, a, l, c, h, u, d, f, p, m = i, g = i, _ = 0, y = 0, v = i;
            for (s = i; s < n; s += r) {
                const i = e[s]
                  , n = e[s + 1];
                void 0 !== c && (f = i - c,
                p = n - h,
                l = Math.sqrt(f * f + p * p),
                void 0 !== u && (y += a,
                o = Math.acos((u * f + d * p) / (a * l)),
                o > t && (y > _ && (_ = y,
                m = v,
                g = s),
                y = 0,
                v = s - r)),
                a = l,
                u = f,
                d = p),
                c = i,
                h = n
            }
            return y += l,
            y > _ ? [v, s] : [m, g]
        }
        const C = {
            left: 0,
            end: 0,
            center: .5,
            right: 1,
            start: 1,
            top: 0,
            middle: .5,
            hanging: .2,
            alphabetic: .8,
            ideographic: .8,
            bottom: 1
        };
        var A = class extends _ {
            constructor(t, e, i, n) {
                super(t, e, i, n),
                this.labels_ = null,
                this.text_ = "",
                this.textOffsetX_ = 0,
                this.textOffsetY_ = 0,
                this.textRotateWithView_ = void 0,
                this.textRotation_ = 0,
                this.textFillState_ = null,
                this.fillStates = {},
                this.textStrokeState_ = null,
                this.strokeStates = {},
                this.textState_ = {},
                this.textStates = {},
                this.textKey_ = "",
                this.fillKey_ = "",
                this.strokeKey_ = "",
                this.declutterImageWithText_ = void 0
            }
            finish() {
                const t = super.finish();
                return t.textStates = this.textStates,
                t.fillStates = this.fillStates,
                t.strokeStates = this.strokeStates,
                t
            }
            drawText(t, e) {
                const i = this.textFillState_
                  , n = this.textStrokeState_
                  , r = this.textState_;
                if ("" === this.text_ || !r || !i && !n)
                    return;
                const o = this.coordinates;
                let s = o.length;
                const a = t.getType();
                let l = null
                  , h = t.getStride();
                if ("line" !== r.placement || "LineString" != a && "MultiLineString" != a && "Polygon" != a && "MultiPolygon" != a) {
                    let i = r.overflow ? null : [];
                    switch (a) {
                    case "Point":
                    case "MultiPoint":
                        l = t.getFlatCoordinates();
                        break;
                    case "LineString":
                        l = t.getFlatMidpoint();
                        break;
                    case "Circle":
                        l = t.getCenter();
                        break;
                    case "MultiLineString":
                        l = t.getFlatMidpoints(),
                        h = 2;
                        break;
                    case "Polygon":
                        l = t.getFlatInteriorPoint(),
                        r.overflow || i.push(l[2] / this.resolution),
                        h = 3;
                        break;
                    case "MultiPolygon":
                        const e = t.getFlatInteriorPoints();
                        l = [];
                        for (let t = 0, n = e.length; t < n; t += 3)
                            r.overflow || i.push(e[t + 2] / this.resolution),
                            l.push(e[t], e[t + 1]);
                        if (0 === l.length)
                            return;
                        h = 2
                    }
                    const n = this.appendFlatPointCoordinates(l, h);
                    if (n === s)
                        return;
                    if (i && (n - s) / 2 != l.length / h) {
                        let t = s / 2;
                        i = i.filter(( (e, i) => {
                            const n = o[2 * (t + i)] === l[i * h] && o[2 * (t + i) + 1] === l[i * h + 1];
                            return n || --t,
                            n
                        }
                        ))
                    }
                    this.saveTextStates_(),
                    (r.backgroundFill || r.backgroundStroke) && (this.setFillStrokeStyle(r.backgroundFill, r.backgroundStroke),
                    r.backgroundFill && (this.updateFillStyle(this.state, this.createFill),
                    this.hitDetectionInstructions.push(this.createFill(this.state))),
                    r.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke),
                    this.hitDetectionInstructions.push(this.createStroke(this.state)))),
                    this.beginGeometry(t, e);
                    let u = r.padding;
                    if (u != p.oB && (r.scale[0] < 0 || r.scale[1] < 0)) {
                        let t = r.padding[0]
                          , e = r.padding[1]
                          , i = r.padding[2]
                          , n = r.padding[3];
                        r.scale[0] < 0 && (e = -e,
                        n = -n),
                        r.scale[1] < 0 && (t = -t,
                        i = -i),
                        u = [t, e, i, n]
                    }
                    const d = this.pixelRatio;
                    this.instructions.push([c.DRAW_IMAGE, s, n, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, void 0, this.declutterImageWithText_, u == p.oB ? p.oB : u.map((function(t) {
                        return t * d
                    }
                    )), !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i]);
                    const f = 1 / d;
                    this.hitDetectionInstructions.push([c.DRAW_IMAGE, s, n, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [f, f], NaN, void 0, this.declutterImageWithText_, u, !!r.backgroundFill, !!r.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, i]),
                    this.endGeometry(e)
                } else {
                    if (!(0,
                    f.kK)(this.getBufferedMaxExtent(), t.getExtent()))
                        return;
                    let i;
                    if (l = t.getFlatCoordinates(),
                    "LineString" == a)
                        i = [l.length];
                    else if ("MultiLineString" == a)
                        i = t.getEnds();
                    else if ("Polygon" == a)
                        i = t.getEnds().slice(0, 1);
                    else if ("MultiPolygon" == a) {
                        const e = t.getEndss();
                        i = [];
                        for (let t = 0, n = e.length; t < n; ++t)
                            i.push(e[t][0])
                    }
                    this.beginGeometry(t, e);
                    const n = r.repeat
                      , c = n ? void 0 : r.textAlign;
                    let u = 0;
                    for (let t = 0, e = i.length; t < e; ++t) {
                        let e;
                        e = n ? T(n * this.resolution, l, u, i[t], h) : [l.slice(u, i[t])];
                        for (let n = 0, a = e.length; n < a; ++n) {
                            const a = e[n];
                            let l = 0
                              , d = a.length;
                            if (null == c) {
                                const t = S(r.maxAngle, a, 0, a.length, 2);
                                l = t[0],
                                d = t[1]
                            }
                            for (let t = l; t < d; t += h)
                                o.push(a[t], a[t + 1]);
                            const f = o.length;
                            u = i[t],
                            this.drawChars_(s, f),
                            s = f
                        }
                    }
                    this.endGeometry(e)
                }
            }
            saveTextStates_() {
                const t = this.textStrokeState_
                  , e = this.textState_
                  , i = this.textFillState_
                  , n = this.strokeKey_;
                t && (n in this.strokeStates || (this.strokeStates[n] = {
                    strokeStyle: t.strokeStyle,
                    lineCap: t.lineCap,
                    lineDashOffset: t.lineDashOffset,
                    lineWidth: t.lineWidth,
                    lineJoin: t.lineJoin,
                    miterLimit: t.miterLimit,
                    lineDash: t.lineDash
                }));
                const r = this.textKey_;
                r in this.textStates || (this.textStates[r] = {
                    font: e.font,
                    textAlign: e.textAlign || p.PH,
                    justify: e.justify,
                    textBaseline: e.textBaseline || p.ru,
                    scale: e.scale
                });
                const o = this.fillKey_;
                i && (o in this.fillStates || (this.fillStates[o] = {
                    fillStyle: i.fillStyle
                }))
            }
            drawChars_(t, e) {
                const i = this.textStrokeState_
                  , n = this.textState_
                  , r = this.strokeKey_
                  , o = this.textKey_
                  , s = this.fillKey_;
                this.saveTextStates_();
                const a = this.pixelRatio
                  , l = C[n.textBaseline]
                  , h = this.textOffsetY_ * a
                  , u = this.text_
                  , d = i ? i.lineWidth * Math.abs(n.scale[0]) / 2 : 0;
                this.instructions.push([c.DRAW_CHARS, t, e, l, n.overflow, s, n.maxAngle, a, h, r, d * a, u, o, 1]),
                this.hitDetectionInstructions.push([c.DRAW_CHARS, t, e, l, n.overflow, s, n.maxAngle, 1, h, r, d, u, o, 1 / a])
            }
            setTextStyle(t, e) {
                let i, n, r;
                if (t) {
                    const e = t.getFill();
                    e ? (n = this.textFillState_,
                    n || (n = {},
                    this.textFillState_ = n),
                    n.fillStyle = (0,
                    d.y)(e.getColor() || p.bL)) : (n = null,
                    this.textFillState_ = n);
                    const o = t.getStroke();
                    if (o) {
                        r = this.textStrokeState_,
                        r || (r = {},
                        this.textStrokeState_ = r);
                        const t = o.getLineDash()
                          , e = o.getLineDashOffset()
                          , i = o.getWidth()
                          , n = o.getMiterLimit();
                        r.lineCap = o.getLineCap() || p.mb,
                        r.lineDash = t ? t.slice() : p.X9,
                        r.lineDashOffset = void 0 === e ? p.He : e,
                        r.lineJoin = o.getLineJoin() || p.rc,
                        r.lineWidth = void 0 === i ? p.yC : i,
                        r.miterLimit = void 0 === n ? p.V4 : n,
                        r.strokeStyle = (0,
                        d.y)(o.getColor() || p.Tx)
                    } else
                        r = null,
                        this.textStrokeState_ = r;
                    i = this.textState_;
                    const s = t.getFont() || p.Df;
                    (0,
                    p.Qx)(s);
                    const a = t.getScaleArray();
                    i.overflow = t.getOverflow(),
                    i.font = s,
                    i.maxAngle = t.getMaxAngle(),
                    i.placement = t.getPlacement(),
                    i.textAlign = t.getTextAlign(),
                    i.repeat = t.getRepeat(),
                    i.justify = t.getJustify(),
                    i.textBaseline = t.getTextBaseline() || p.ru,
                    i.backgroundFill = t.getBackgroundFill(),
                    i.backgroundStroke = t.getBackgroundStroke(),
                    i.padding = t.getPadding() || p.oB,
                    i.scale = void 0 === a ? [1, 1] : a;
                    const l = t.getOffsetX()
                      , c = t.getOffsetY()
                      , h = t.getRotateWithView()
                      , u = t.getRotation();
                    this.text_ = t.getText() || "",
                    this.textOffsetX_ = void 0 === l ? 0 : l,
                    this.textOffsetY_ = void 0 === c ? 0 : c,
                    this.textRotateWithView_ = void 0 !== h && h,
                    this.textRotation_ = void 0 === u ? 0 : u,
                    this.strokeKey_ = r ? ("string" == typeof r.strokeStyle ? r.strokeStyle : (0,
                    w.sq)(r.strokeStyle)) + r.lineCap + r.lineDashOffset + "|" + r.lineWidth + r.lineJoin + r.miterLimit + "[" + r.lineDash.join() + "]" : "",
                    this.textKey_ = i.font + i.scale + (i.textAlign || "?") + (i.repeat || "?") + (i.justify || "?") + (i.textBaseline || "?"),
                    this.fillKey_ = n ? "string" == typeof n.fillStyle ? n.fillStyle : "|" + (0,
                    w.sq)(n.fillStyle) : ""
                } else
                    this.text_ = "";
                this.declutterImageWithText_ = e
            }
        }
        ;
        const I = {
            Circle: b,
            Default: _,
            Image: y,
            LineString: v,
            Polygon: b,
            Text: A
        };
        var M = class {
            constructor(t, e, i, n) {
                this.tolerance_ = t,
                this.maxExtent_ = e,
                this.pixelRatio_ = n,
                this.resolution_ = i,
                this.buildersByZIndex_ = {}
            }
            finish() {
                const t = {};
                for (const e in this.buildersByZIndex_) {
                    t[e] = t[e] || {};
                    const i = this.buildersByZIndex_[e];
                    for (const n in i) {
                        const r = i[n].finish();
                        t[e][n] = r
                    }
                }
                return t
            }
            getBuilder(t, e) {
                const i = void 0 !== t ? t.toString() : "0";
                let n = this.buildersByZIndex_[i];
                void 0 === n && (n = {},
                this.buildersByZIndex_[i] = n);
                let r = n[e];
                if (void 0 === r) {
                    r = new (0,
                    I[e])(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_),
                    n[e] = r
                }
                return r
            }
        }
          , P = i(33748)
          , k = i(6101)
          , O = i(76442);
        function R(t, e, i, n, r, o, s, a, l, c, h, u) {
            let d = t[e]
              , f = t[e + 1]
              , p = 0
              , m = 0
              , g = 0
              , _ = 0;
            function y() {
                p = d,
                m = f,
                d = t[e += n],
                f = t[e + 1],
                _ += g,
                g = Math.sqrt((d - p) * (d - p) + (f - m) * (f - m))
            }
            do {
                y()
            } while (e < i - n && _ + g < o);
            let v = 0 === g ? 0 : (o - _) / g;
            const x = (0,
            E.t7)(p, d, v)
              , b = (0,
            E.t7)(m, f, v)
              , w = e - n
              , T = _
              , S = o + a * l(c, r, h);
            for (; e < i - n && _ + g < S; )
                y();
            v = 0 === g ? 0 : (S - _) / g;
            const C = (0,
            E.t7)(p, d, v)
              , A = (0,
            E.t7)(m, f, v);
            let I;
            if (u) {
                const t = [x, b, C, A];
                (0,
                O.U1)(t, 0, 4, 2, u, t, t),
                I = t[0] > t[2]
            } else
                I = x > C;
            const M = Math.PI
              , P = []
              , k = w + n === e;
            let R;
            if (g = 0,
            _ = T,
            d = t[e = w],
            f = t[e + 1],
            k) {
                y(),
                R = Math.atan2(f - m, d - p),
                I && (R += R > 0 ? -M : M);
                const t = (C + x) / 2
                  , e = (A + b) / 2;
                return P[0] = [t, e, (S - o) / 2, R, r],
                P
            }
            for (let t = 0, u = (r = r.replace(/\n/g, " ")).length; t < u; ) {
                y();
                let x = Math.atan2(f - m, d - p);
                if (I && (x += x > 0 ? -M : M),
                void 0 !== R) {
                    let t = x - R;
                    if (t += t > M ? -2 * M : t < -M ? 2 * M : 0,
                    Math.abs(t) > s)
                        return null
                }
                R = x;
                const b = t;
                let w = 0;
                for (; t < u; ++t) {
                    const s = a * l(c, r[I ? u - t - 1 : t], h);
                    if (e + n < i && _ + g < o + w + s / 2)
                        break;
                    w += s
                }
                if (t === b)
                    continue;
                const T = I ? r.substring(u - b, u - t) : r.substring(b, t);
                v = 0 === g ? 0 : (o + w / 2 - _) / g;
                const S = (0,
                E.t7)(p, d, v)
                  , C = (0,
                E.t7)(m, f, v);
                P.push([S, C, w / 2, x, T]),
                o += w
            }
            return P
        }
        var D = i(27374);
        const L = (0,
        f.lJ)()
          , B = []
          , z = []
          , F = []
          , N = [];
        function j(t) {
            return t[3].declutterBox
        }
        const U = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
        function V(t, e) {
            return "start" !== e && "end" !== e || U.test(t) || (e = "start" === e ? "left" : "right"),
            C[e]
        }
        function G(t, e, i) {
            return i > 0 && t.push("\n", ""),
            t.push(e, ""),
            t
        }
        var Z = class {
            constructor(t, e, i, n) {
                this.overlaps = i,
                this.pixelRatio = e,
                this.resolution = t,
                this.alignFill_,
                this.instructions = n.instructions,
                this.coordinates = n.coordinates,
                this.coordinateCache_ = {},
                this.renderedTransform_ = (0,
                k.Ue)(),
                this.hitDetectionInstructions = n.hitDetectionInstructions,
                this.pixelCoordinates_ = null,
                this.viewRotation_ = 0,
                this.fillStates = n.fillStates || {},
                this.strokeStates = n.strokeStates || {},
                this.textStates = n.textStates || {},
                this.widths_ = {},
                this.labels_ = {}
            }
            createLabel(t, e, i, n) {
                const r = t + e + i + n;
                if (this.labels_[r])
                    return this.labels_[r];
                const o = n ? this.strokeStates[n] : null
                  , s = i ? this.fillStates[i] : null
                  , a = this.textStates[e]
                  , l = this.pixelRatio
                  , c = [a.scale[0] * l, a.scale[1] * l]
                  , h = Array.isArray(t)
                  , u = a.justify ? C[a.justify] : V(Array.isArray(t) ? t[0] : t, a.textAlign || p.PH)
                  , d = n && o.lineWidth ? o.lineWidth : 0
                  , f = h ? t : t.split("\n").reduce(G, [])
                  , {width: m, height: g, widths: _, heights: y, lineWidths: v} = (0,
                p.Zw)(a, f)
                  , x = m + d
                  , b = []
                  , w = (x + 2) * c[0]
                  , E = (g + d) * c[1]
                  , T = {
                    width: w < 0 ? Math.floor(w) : Math.ceil(w),
                    height: E < 0 ? Math.floor(E) : Math.ceil(E),
                    contextInstructions: b
                };
                1 == c[0] && 1 == c[1] || b.push("scale", c),
                n && (b.push("strokeStyle", o.strokeStyle),
                b.push("lineWidth", d),
                b.push("lineCap", o.lineCap),
                b.push("lineJoin", o.lineJoin),
                b.push("miterLimit", o.miterLimit),
                b.push("setLineDash", [o.lineDash]),
                b.push("lineDashOffset", o.lineDashOffset)),
                i && b.push("fillStyle", s.fillStyle),
                b.push("textBaseline", "middle"),
                b.push("textAlign", "center");
                const S = .5 - u;
                let A = u * x + S * d;
                const I = []
                  , M = [];
                let P, k = 0, O = 0, R = 0, D = 0;
                for (let t = 0, e = f.length; t < e; t += 2) {
                    const e = f[t];
                    if ("\n" === e) {
                        O += k,
                        k = 0,
                        A = u * x + S * d,
                        ++D;
                        continue
                    }
                    const r = f[t + 1] || a.font;
                    r !== P && (n && I.push("font", r),
                    i && M.push("font", r),
                    P = r),
                    k = Math.max(k, y[R]);
                    const o = [e, A + S * _[R] + u * (_[R] - v[D]), .5 * (d + k) + O];
                    A += _[R],
                    n && I.push("strokeText", o),
                    i && M.push("fillText", o),
                    ++R
                }
                return Array.prototype.push.apply(b, I),
                Array.prototype.push.apply(b, M),
                this.labels_[r] = T,
                T
            }
            replayTextBackground_(t, e, i, n, r, o, s) {
                t.beginPath(),
                t.moveTo.apply(t, e),
                t.lineTo.apply(t, i),
                t.lineTo.apply(t, n),
                t.lineTo.apply(t, r),
                t.lineTo.apply(t, e),
                o && (this.alignFill_ = o[2],
                this.fill_(t)),
                s && (this.setStrokeStyle_(t, s),
                t.stroke())
            }
            calculateImageOrLabelDimensions_(t, e, i, n, r, o, s, a, l, c, h, u, d, p, m, g) {
                let _ = i - (s *= u[0])
                  , y = n - (a *= u[1]);
                const v = r + l > t ? t - l : r
                  , x = o + c > e ? e - c : o
                  , b = p[3] + v * u[0] + p[1]
                  , w = p[0] + x * u[1] + p[2]
                  , E = _ - p[3]
                  , T = y - p[0];
                let S;
                return (m || 0 !== h) && (B[0] = E,
                N[0] = E,
                B[1] = T,
                z[1] = T,
                z[0] = E + b,
                F[0] = z[0],
                F[1] = T + w,
                N[1] = F[1]),
                0 !== h ? (S = (0,
                k.qC)((0,
                k.Ue)(), i, n, 1, 1, h, -i, -n),
                (0,
                k.nn)(S, B),
                (0,
                k.nn)(S, z),
                (0,
                k.nn)(S, F),
                (0,
                k.nn)(S, N),
                (0,
                f.T9)(Math.min(B[0], z[0], F[0], N[0]), Math.min(B[1], z[1], F[1], N[1]), Math.max(B[0], z[0], F[0], N[0]), Math.max(B[1], z[1], F[1], N[1]), L)) : (0,
                f.T9)(Math.min(E, E + b), Math.min(T, T + w), Math.max(E, E + b), Math.max(T, T + w), L),
                d && (_ = Math.round(_),
                y = Math.round(y)),
                {
                    drawImageX: _,
                    drawImageY: y,
                    drawImageW: v,
                    drawImageH: x,
                    originX: l,
                    originY: c,
                    declutterBox: {
                        minX: L[0],
                        minY: L[1],
                        maxX: L[2],
                        maxY: L[3],
                        value: g
                    },
                    canvasTransform: S,
                    scale: u
                }
            }
            replayImageOrLabel_(t, e, i, n, r, o, s) {
                const a = !(!o && !s)
                  , l = n.declutterBox
                  , c = t.canvas
                  , h = s ? s[2] * n.scale[0] / 2 : 0;
                return l.minX - h <= c.width / e && l.maxX + h >= 0 && l.minY - h <= c.height / e && l.maxY + h >= 0 && (a && this.replayTextBackground_(t, B, z, F, N, o, s),
                (0,
                p._f)(t, n.canvasTransform, r, i, n.originX, n.originY, n.drawImageW, n.drawImageH, n.drawImageX, n.drawImageY, n.scale)),
                !0
            }
            fill_(t) {
                if (this.alignFill_) {
                    const e = (0,
                    k.nn)(this.renderedTransform_, [0, 0])
                      , i = 512 * this.pixelRatio;
                    t.save(),
                    t.translate(e[0] % i, e[1] % i),
                    t.rotate(this.viewRotation_)
                }
                t.fill(),
                this.alignFill_ && t.restore()
            }
            setStrokeStyle_(t, e) {
                t.strokeStyle = e[1],
                t.lineWidth = e[2],
                t.lineCap = e[3],
                t.lineJoin = e[4],
                t.miterLimit = e[5],
                t.lineDashOffset = e[7],
                t.setLineDash(e[6])
            }
            drawLabelWithPointPlacement_(t, e, i, n) {
                const r = this.textStates[e]
                  , o = this.createLabel(t, e, n, i)
                  , s = this.strokeStates[i]
                  , a = this.pixelRatio
                  , l = V(Array.isArray(t) ? t[0] : t, r.textAlign || p.PH)
                  , c = C[r.textBaseline || p.ru]
                  , h = s && s.lineWidth ? s.lineWidth : 0;
                return {
                    label: o,
                    anchorX: l * (o.width / a - 2 * r.scale[0]) + 2 * (.5 - l) * h,
                    anchorY: c * o.height / a + 2 * (.5 - c) * h
                }
            }
            execute_(t, e, i, n, r, o, s, a) {
                let l;
                this.pixelCoordinates_ && (0,
                m.fS)(i, this.renderedTransform_) ? l = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []),
                l = (0,
                O.vT)(this.coordinates, 0, this.coordinates.length, 2, i, this.pixelCoordinates_),
                (0,
                k.lk)(this.renderedTransform_, i));
                let h = 0;
                const u = n.length;
                let d, g, _, y, v, x, b, w, E, T, S, A, I = 0, M = 0, P = 0, L = null, B = null;
                const z = this.coordinateCache_
                  , F = this.viewRotation_
                  , N = Math.round(1e12 * Math.atan2(-i[1], i[0])) / 1e12
                  , U = {
                    context: t,
                    pixelRatio: this.pixelRatio,
                    resolution: this.resolution,
                    rotation: F
                }
                  , V = this.instructions != n || this.overlaps ? 0 : 200;
                let G, Z, q, W;
                for (; h < u; ) {
                    const i = n[h];
                    switch (i[0]) {
                    case c.BEGIN_GEOMETRY:
                        G = i[1],
                        W = i[3],
                        G.getGeometry() ? void 0 === s || (0,
                        f.kK)(s, W.getExtent()) ? ++h : h = i[2] + 1 : h = i[2];
                        break;
                    case c.BEGIN_PATH:
                        M > V && (this.fill_(t),
                        M = 0),
                        P > V && (t.stroke(),
                        P = 0),
                        M || P || (t.beginPath(),
                        y = NaN,
                        v = NaN),
                        ++h;
                        break;
                    case c.CIRCLE:
                        I = i[1];
                        const n = l[I]
                          , u = l[I + 1]
                          , m = l[I + 2] - n
                          , k = l[I + 3] - u
                          , O = Math.sqrt(m * m + k * k);
                        t.moveTo(n + O, u),
                        t.arc(n, u, O, 0, 2 * Math.PI, !0),
                        ++h;
                        break;
                    case c.CLOSE_PATH:
                        t.closePath(),
                        ++h;
                        break;
                    case c.CUSTOM:
                        I = i[1],
                        d = i[2];
                        const H = i[3]
                          , $ = i[4]
                          , X = 6 == i.length ? i[5] : void 0;
                        U.geometry = H,
                        U.feature = G,
                        h in z || (z[h] = []);
                        const Y = z[h];
                        X ? X(l, I, d, 2, Y) : (Y[0] = l[I],
                        Y[1] = l[I + 1],
                        Y.length = 2),
                        $(Y, U),
                        ++h;
                        break;
                    case c.DRAW_IMAGE:
                        I = i[1],
                        d = i[2],
                        w = i[3],
                        g = i[4],
                        _ = i[5];
                        let K = i[6];
                        const J = i[7]
                          , Q = i[8]
                          , tt = i[9]
                          , et = i[10];
                        let it = i[11];
                        const nt = i[12];
                        let rt = i[13];
                        const ot = i[14]
                          , st = i[15];
                        if (!w && i.length >= 20) {
                            E = i[19],
                            T = i[20],
                            S = i[21],
                            A = i[22];
                            const t = this.drawLabelWithPointPlacement_(E, T, S, A);
                            w = t.label,
                            i[3] = w;
                            const e = i[23];
                            g = (t.anchorX - e) * this.pixelRatio,
                            i[4] = g;
                            const n = i[24];
                            _ = (t.anchorY - n) * this.pixelRatio,
                            i[5] = _,
                            K = w.height,
                            i[6] = K,
                            rt = w.width,
                            i[13] = rt
                        }
                        let at, lt, ct, ht;
                        i.length > 25 && (at = i[25]),
                        i.length > 17 ? (lt = i[16],
                        ct = i[17],
                        ht = i[18]) : (lt = p.oB,
                        ct = !1,
                        ht = !1),
                        et && N ? it += F : et || N || (it -= F);
                        let ut = 0;
                        for (; I < d; I += 2) {
                            if (at && at[ut++] < rt / this.pixelRatio)
                                continue;
                            const i = this.calculateImageOrLabelDimensions_(w.width, w.height, l[I], l[I + 1], rt, K, g, _, Q, tt, it, nt, r, lt, ct || ht, G)
                              , n = [t, e, w, i, J, ct ? L : null, ht ? B : null];
                            if (a) {
                                if ("none" === ot)
                                    continue;
                                if ("obstacle" === ot) {
                                    a.insert(i.declutterBox);
                                    continue
                                }
                                {
                                    let t, e;
                                    if (st) {
                                        const i = d - I;
                                        if (!st[i]) {
                                            st[i] = n;
                                            continue
                                        }
                                        if (t = st[i],
                                        delete st[i],
                                        e = j(t),
                                        a.collides(e))
                                            continue
                                    }
                                    if (a.collides(i.declutterBox))
                                        continue;
                                    t && (a.insert(e),
                                    this.replayImageOrLabel_.apply(this, t)),
                                    a.insert(i.declutterBox)
                                }
                            }
                            this.replayImageOrLabel_.apply(this, n)
                        }
                        ++h;
                        break;
                    case c.DRAW_CHARS:
                        const dt = i[1]
                          , ft = i[2]
                          , pt = i[3]
                          , mt = i[4];
                        A = i[5];
                        const gt = i[6]
                          , _t = i[7]
                          , yt = i[8];
                        S = i[9];
                        const vt = i[10];
                        E = i[11],
                        T = i[12];
                        const xt = [i[13], i[13]]
                          , bt = this.textStates[T]
                          , wt = bt.font
                          , Et = [bt.scale[0] * _t, bt.scale[1] * _t];
                        let Tt;
                        wt in this.widths_ ? Tt = this.widths_[wt] : (Tt = {},
                        this.widths_[wt] = Tt);
                        const St = (0,
                        D.W)(l, dt, ft, 2)
                          , Ct = Math.abs(Et[0]) * (0,
                        p.Kd)(wt, E, Tt);
                        if (mt || Ct <= St) {
                            const i = this.textStates[T].textAlign
                              , n = R(l, dt, ft, 2, E, (St - Ct) * C[i], gt, Math.abs(Et[0]), p.Kd, wt, Tt, N ? 0 : this.viewRotation_);
                            t: if (n) {
                                const i = [];
                                let r, o, s, l, c;
                                if (S)
                                    for (r = 0,
                                    o = n.length; r < o; ++r) {
                                        c = n[r],
                                        s = c[4],
                                        l = this.createLabel(s, T, "", S),
                                        g = c[2] + (Et[0] < 0 ? -vt : vt),
                                        _ = pt * l.height + 2 * (.5 - pt) * vt * Et[1] / Et[0] - yt;
                                        const o = this.calculateImageOrLabelDimensions_(l.width, l.height, c[0], c[1], l.width, l.height, g, _, 0, 0, c[3], xt, !1, p.oB, !1, G);
                                        if (a && a.collides(o.declutterBox))
                                            break t;
                                        i.push([t, e, l, o, 1, null, null])
                                    }
                                if (A)
                                    for (r = 0,
                                    o = n.length; r < o; ++r) {
                                        c = n[r],
                                        s = c[4],
                                        l = this.createLabel(s, T, A, ""),
                                        g = c[2],
                                        _ = pt * l.height - yt;
                                        const o = this.calculateImageOrLabelDimensions_(l.width, l.height, c[0], c[1], l.width, l.height, g, _, 0, 0, c[3], xt, !1, p.oB, !1, G);
                                        if (a && a.collides(o.declutterBox))
                                            break t;
                                        i.push([t, e, l, o, 1, null, null])
                                    }
                                a && a.load(i.map(j));
                                for (let t = 0, e = i.length; t < e; ++t)
                                    this.replayImageOrLabel_.apply(this, i[t])
                            }
                        }
                        ++h;
                        break;
                    case c.END_GEOMETRY:
                        if (void 0 !== o) {
                            G = i[1];
                            const t = o(G, W);
                            if (t)
                                return t
                        }
                        ++h;
                        break;
                    case c.FILL:
                        V ? M++ : this.fill_(t),
                        ++h;
                        break;
                    case c.MOVE_TO_LINE_TO:
                        for (I = i[1],
                        d = i[2],
                        Z = l[I],
                        q = l[I + 1],
                        x = Z + .5 | 0,
                        b = q + .5 | 0,
                        x === y && b === v || (t.moveTo(Z, q),
                        y = x,
                        v = b),
                        I += 2; I < d; I += 2)
                            Z = l[I],
                            q = l[I + 1],
                            x = Z + .5 | 0,
                            b = q + .5 | 0,
                            I != d - 2 && x === y && b === v || (t.lineTo(Z, q),
                            y = x,
                            v = b);
                        ++h;
                        break;
                    case c.SET_FILL_STYLE:
                        L = i,
                        this.alignFill_ = i[2],
                        M && (this.fill_(t),
                        M = 0,
                        P && (t.stroke(),
                        P = 0)),
                        t.fillStyle = i[1],
                        ++h;
                        break;
                    case c.SET_STROKE_STYLE:
                        B = i,
                        P && (t.stroke(),
                        P = 0),
                        this.setStrokeStyle_(t, i),
                        ++h;
                        break;
                    case c.STROKE:
                        V ? P++ : t.stroke(),
                        ++h;
                        break;
                    default:
                        ++h
                    }
                }
                M && this.fill_(t),
                P && t.stroke()
            }
            execute(t, e, i, n, r, o) {
                this.viewRotation_ = n,
                this.execute_(t, e, i, this.instructions, r, void 0, void 0, o)
            }
            executeHitDetection(t, e, i, n, r) {
                return this.viewRotation_ = i,
                this.execute_(t, 1, e, this.hitDetectionInstructions, !0, n, r)
            }
        }
          , q = i(68326)
          , W = i(69374);
        const H = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
        const $ = {};
        var X = class {
            constructor(t, e, i, n, r, o) {
                this.maxExtent_ = t,
                this.overlaps_ = n,
                this.pixelRatio_ = i,
                this.resolution_ = e,
                this.renderBuffer_ = o,
                this.executorsByZIndex_ = {},
                this.hitDetectionContext_ = null,
                this.hitDetectionTransform_ = (0,
                k.Ue)(),
                this.createExecutors_(r)
            }
            clip(t, e) {
                const i = this.getClipCoords(e);
                t.beginPath(),
                t.moveTo(i[0], i[1]),
                t.lineTo(i[2], i[3]),
                t.lineTo(i[4], i[5]),
                t.lineTo(i[6], i[7]),
                t.clip()
            }
            createExecutors_(t) {
                for (const e in t) {
                    let i = this.executorsByZIndex_[e];
                    void 0 === i && (i = {},
                    this.executorsByZIndex_[e] = i);
                    const n = t[e];
                    for (const t in n) {
                        const e = n[t];
                        i[t] = new Z(this.resolution_,this.pixelRatio_,this.overlaps_,e)
                    }
                }
            }
            hasExecutors(t) {
                for (const e in this.executorsByZIndex_) {
                    const i = this.executorsByZIndex_[e];
                    for (let e = 0, n = t.length; e < n; ++e)
                        if (t[e]in i)
                            return !0
                }
                return !1
            }
            forEachFeatureAtCoordinate(t, e, i, n, r, o) {
                const s = 2 * (n = Math.round(n)) + 1
                  , a = (0,
                k.qC)(this.hitDetectionTransform_, n + .5, n + .5, 1 / e, -1 / e, -i, -t[0], -t[1])
                  , l = !this.hitDetectionContext_;
                l && (this.hitDetectionContext_ = (0,
                q.E4)(s, s, void 0, {
                    willReadFrequently: !0
                }));
                const c = this.hitDetectionContext_;
                let h;
                c.canvas.width !== s || c.canvas.height !== s ? (c.canvas.width = s,
                c.canvas.height = s) : l || c.clearRect(0, 0, s, s),
                void 0 !== this.renderBuffer_ && (h = (0,
                f.lJ)(),
                (0,
                f.Wj)(h, t),
                (0,
                f.f3)(h, e * (this.renderBuffer_ + n), h));
                const u = function(t) {
                    if (void 0 !== $[t])
                        return $[t];
                    const e = 2 * t + 1
                      , i = t * t
                      , n = new Array(i + 1);
                    for (let r = 0; r <= t; ++r)
                        for (let o = 0; o <= t; ++o) {
                            const s = r * r + o * o;
                            if (s > i)
                                break;
                            let a = n[s];
                            a || (a = [],
                            n[s] = a),
                            a.push(4 * ((t + r) * e + (t + o)) + 3),
                            r > 0 && a.push(4 * ((t - r) * e + (t + o)) + 3),
                            o > 0 && (a.push(4 * ((t + r) * e + (t - o)) + 3),
                            r > 0 && a.push(4 * ((t - r) * e + (t - o)) + 3))
                        }
                    const r = [];
                    for (let t = 0, e = n.length; t < e; ++t)
                        n[t] && r.push(...n[t]);
                    return $[t] = r,
                    r
                }(n);
                let d;
                function p(t, e) {
                    const i = c.getImageData(0, 0, s, s).data;
                    for (let a = 0, l = u.length; a < l; a++)
                        if (i[u[a]] > 0) {
                            if (!o || "Image" !== d && "Text" !== d || o.includes(t)) {
                                const i = (u[a] - 3) / 4
                                  , o = n - i % s
                                  , l = n - (i / s | 0)
                                  , c = r(t, e, o * o + l * l);
                                if (c)
                                    return c
                            }
                            c.clearRect(0, 0, s, s);
                            break
                        }
                }
                const g = Object.keys(this.executorsByZIndex_).map(Number);
                let _, y, v, x, b;
                for (g.sort(m.j2),
                _ = g.length - 1; _ >= 0; --_) {
                    const t = g[_].toString();
                    for (v = this.executorsByZIndex_[t],
                    y = H.length - 1; y >= 0; --y)
                        if (d = H[y],
                        x = v[d],
                        void 0 !== x && (b = x.executeHitDetection(c, a, i, p, h),
                        b))
                            return b
                }
            }
            getClipCoords(t) {
                const e = this.maxExtent_;
                if (!e)
                    return null;
                const i = e[0]
                  , n = e[1]
                  , r = e[2]
                  , o = e[3]
                  , s = [i, n, i, o, r, o, r, n];
                return (0,
                O.vT)(s, 0, 8, 2, t, s),
                s
            }
            isEmpty() {
                return (0,
                W.x)(this.executorsByZIndex_)
            }
            execute(t, e, i, n, r, o, s) {
                const a = Object.keys(this.executorsByZIndex_).map(Number);
                let l, c, h, u, d, f;
                for (a.sort(m.j2),
                this.maxExtent_ && (t.save(),
                this.clip(t, i)),
                o = o || H,
                s && a.reverse(),
                l = 0,
                c = a.length; l < c; ++l) {
                    const c = a[l].toString();
                    for (d = this.executorsByZIndex_[c],
                    h = 0,
                    u = o.length; h < u; ++h) {
                        f = d[o[h]],
                        void 0 !== f && f.execute(t, e, i, n, r, s)
                    }
                }
                this.maxExtent_ && t.restore()
            }
        }
          , Y = i(37755)
          , K = i(72967);
        var J = class extends u {
            constructor(t, e, i, n, r, o, s) {
                super(),
                this.context_ = t,
                this.pixelRatio_ = e,
                this.extent_ = i,
                this.transform_ = n,
                this.transformRotation_ = n ? (0,
                E.FH)(Math.atan2(n[1], n[0]), 10) : 0,
                this.viewRotation_ = r,
                this.squaredTolerance_ = o,
                this.userTransform_ = s,
                this.contextFillState_ = null,
                this.contextStrokeState_ = null,
                this.contextTextState_ = null,
                this.fillState_ = null,
                this.strokeState_ = null,
                this.image_ = null,
                this.imageAnchorX_ = 0,
                this.imageAnchorY_ = 0,
                this.imageHeight_ = 0,
                this.imageOpacity_ = 0,
                this.imageOriginX_ = 0,
                this.imageOriginY_ = 0,
                this.imageRotateWithView_ = !1,
                this.imageRotation_ = 0,
                this.imageScale_ = [0, 0],
                this.imageWidth_ = 0,
                this.text_ = "",
                this.textOffsetX_ = 0,
                this.textOffsetY_ = 0,
                this.textRotateWithView_ = !1,
                this.textRotation_ = 0,
                this.textScale_ = [0, 0],
                this.textFillState_ = null,
                this.textStrokeState_ = null,
                this.textState_ = null,
                this.pixelCoordinates_ = [],
                this.tmpLocalTransform_ = (0,
                k.Ue)()
            }
            drawImages_(t, e, i, n) {
                if (!this.image_)
                    return;
                const r = (0,
                O.vT)(t, e, i, n, this.transform_, this.pixelCoordinates_)
                  , o = this.context_
                  , s = this.tmpLocalTransform_
                  , a = o.globalAlpha;
                1 != this.imageOpacity_ && (o.globalAlpha = a * this.imageOpacity_);
                let l = this.imageRotation_;
                0 === this.transformRotation_ && (l -= this.viewRotation_),
                this.imageRotateWithView_ && (l += this.viewRotation_);
                for (let t = 0, e = r.length; t < e; t += 2) {
                    const e = r[t] - this.imageAnchorX_
                      , i = r[t + 1] - this.imageAnchorY_;
                    if (0 !== l || 1 != this.imageScale_[0] || 1 != this.imageScale_[1]) {
                        const t = e + this.imageAnchorX_
                          , n = i + this.imageAnchorY_;
                        (0,
                        k.qC)(s, t, n, 1, 1, l, -t, -n),
                        o.setTransform.apply(o, s),
                        o.translate(t, n),
                        o.scale(this.imageScale_[0], this.imageScale_[1]),
                        o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_),
                        o.setTransform(1, 0, 0, 1, 0, 0)
                    } else
                        o.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, e, i, this.imageWidth_, this.imageHeight_)
                }
                1 != this.imageOpacity_ && (o.globalAlpha = a)
            }
            drawText_(t, e, i, n) {
                if (!this.textState_ || "" === this.text_)
                    return;
                this.textFillState_ && this.setContextFillState_(this.textFillState_),
                this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_),
                this.setContextTextState_(this.textState_);
                const r = (0,
                O.vT)(t, e, i, n, this.transform_, this.pixelCoordinates_)
                  , o = this.context_;
                let s = this.textRotation_;
                for (0 === this.transformRotation_ && (s -= this.viewRotation_),
                this.textRotateWithView_ && (s += this.viewRotation_); e < i; e += n) {
                    const t = r[e] + this.textOffsetX_
                      , i = r[e + 1] + this.textOffsetY_;
                    0 !== s || 1 != this.textScale_[0] || 1 != this.textScale_[1] ? (o.translate(t - this.textOffsetX_, i - this.textOffsetY_),
                    o.rotate(s),
                    o.translate(this.textOffsetX_, this.textOffsetY_),
                    o.scale(this.textScale_[0], this.textScale_[1]),
                    this.textStrokeState_ && o.strokeText(this.text_, 0, 0),
                    this.textFillState_ && o.fillText(this.text_, 0, 0),
                    o.setTransform(1, 0, 0, 1, 0, 0)) : (this.textStrokeState_ && o.strokeText(this.text_, t, i),
                    this.textFillState_ && o.fillText(this.text_, t, i))
                }
            }
            moveToLineTo_(t, e, i, n, r) {
                const o = this.context_
                  , s = (0,
                O.vT)(t, e, i, n, this.transform_, this.pixelCoordinates_);
                o.moveTo(s[0], s[1]);
                let a = s.length;
                r && (a -= 2);
                for (let t = 2; t < a; t += 2)
                    o.lineTo(s[t], s[t + 1]);
                return r && o.closePath(),
                i
            }
            drawRings_(t, e, i, n) {
                for (let r = 0, o = i.length; r < o; ++r)
                    e = this.moveToLineTo_(t, e, i[r], n, !0);
                return e
            }
            drawCircle(t) {
                if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
                (0,
                f.kK)(this.extent_, t.getExtent())) {
                    if (this.fillState_ || this.strokeState_) {
                        this.fillState_ && this.setContextFillState_(this.fillState_),
                        this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                        const e = (0,
                        K.Kr)(t, this.transform_, this.pixelCoordinates_)
                          , i = e[2] - e[0]
                          , n = e[3] - e[1]
                          , r = Math.sqrt(i * i + n * n)
                          , o = this.context_;
                        o.beginPath(),
                        o.arc(e[0], e[1], r, 0, 2 * Math.PI),
                        this.fillState_ && o.fill(),
                        this.strokeState_ && o.stroke()
                    }
                    "" !== this.text_ && this.drawText_(t.getCenter(), 0, 2, 2)
                }
            }
            setStyle(t) {
                this.setFillStrokeStyle(t.getFill(), t.getStroke()),
                this.setImageStyle(t.getImage()),
                this.setTextStyle(t.getText())
            }
            setTransform(t) {
                this.transform_ = t
            }
            drawGeometry(t) {
                switch (t.getType()) {
                case "Point":
                    this.drawPoint(t);
                    break;
                case "LineString":
                    this.drawLineString(t);
                    break;
                case "Polygon":
                    this.drawPolygon(t);
                    break;
                case "MultiPoint":
                    this.drawMultiPoint(t);
                    break;
                case "MultiLineString":
                    this.drawMultiLineString(t);
                    break;
                case "MultiPolygon":
                    this.drawMultiPolygon(t);
                    break;
                case "GeometryCollection":
                    this.drawGeometryCollection(t);
                    break;
                case "Circle":
                    this.drawCircle(t)
                }
            }
            drawFeature(t, e) {
                const i = e.getGeometryFunction()(t);
                i && (this.setStyle(e),
                this.drawGeometry(i))
            }
            drawGeometryCollection(t) {
                const e = t.getGeometriesArray();
                for (let t = 0, i = e.length; t < i; ++t)
                    this.drawGeometry(e[t])
            }
            drawPoint(t) {
                this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
                const e = t.getFlatCoordinates()
                  , i = t.getStride();
                this.image_ && this.drawImages_(e, 0, e.length, i),
                "" !== this.text_ && this.drawText_(e, 0, e.length, i)
            }
            drawMultiPoint(t) {
                this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
                const e = t.getFlatCoordinates()
                  , i = t.getStride();
                this.image_ && this.drawImages_(e, 0, e.length, i),
                "" !== this.text_ && this.drawText_(e, 0, e.length, i)
            }
            drawLineString(t) {
                if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
                (0,
                f.kK)(this.extent_, t.getExtent())) {
                    if (this.strokeState_) {
                        this.setContextStrokeState_(this.strokeState_);
                        const e = this.context_
                          , i = t.getFlatCoordinates();
                        e.beginPath(),
                        this.moveToLineTo_(i, 0, i.length, t.getStride(), !1),
                        e.stroke()
                    }
                    if ("" !== this.text_) {
                        const e = t.getFlatMidpoint();
                        this.drawText_(e, 0, 2, 2)
                    }
                }
            }
            drawMultiLineString(t) {
                this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
                const e = t.getExtent();
                if ((0,
                f.kK)(this.extent_, e)) {
                    if (this.strokeState_) {
                        this.setContextStrokeState_(this.strokeState_);
                        const e = this.context_
                          , i = t.getFlatCoordinates();
                        let n = 0;
                        const r = t.getEnds()
                          , o = t.getStride();
                        e.beginPath();
                        for (let t = 0, e = r.length; t < e; ++t)
                            n = this.moveToLineTo_(i, n, r[t], o, !1);
                        e.stroke()
                    }
                    if ("" !== this.text_) {
                        const e = t.getFlatMidpoints();
                        this.drawText_(e, 0, e.length, 2)
                    }
                }
            }
            drawPolygon(t) {
                if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
                (0,
                f.kK)(this.extent_, t.getExtent())) {
                    if (this.strokeState_ || this.fillState_) {
                        this.fillState_ && this.setContextFillState_(this.fillState_),
                        this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                        const e = this.context_;
                        e.beginPath(),
                        this.drawRings_(t.getOrientedFlatCoordinates(), 0, t.getEnds(), t.getStride()),
                        this.fillState_ && e.fill(),
                        this.strokeState_ && e.stroke()
                    }
                    if ("" !== this.text_) {
                        const e = t.getFlatInteriorPoint();
                        this.drawText_(e, 0, 2, 2)
                    }
                }
            }
            drawMultiPolygon(t) {
                if (this.squaredTolerance_ && (t = t.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
                (0,
                f.kK)(this.extent_, t.getExtent())) {
                    if (this.strokeState_ || this.fillState_) {
                        this.fillState_ && this.setContextFillState_(this.fillState_),
                        this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                        const e = this.context_
                          , i = t.getOrientedFlatCoordinates();
                        let n = 0;
                        const r = t.getEndss()
                          , o = t.getStride();
                        e.beginPath();
                        for (let t = 0, e = r.length; t < e; ++t) {
                            const e = r[t];
                            n = this.drawRings_(i, n, e, o)
                        }
                        this.fillState_ && e.fill(),
                        this.strokeState_ && e.stroke()
                    }
                    if ("" !== this.text_) {
                        const e = t.getFlatInteriorPoints();
                        this.drawText_(e, 0, e.length, 2)
                    }
                }
            }
            setContextFillState_(t) {
                const e = this.context_
                  , i = this.contextFillState_;
                i ? i.fillStyle != t.fillStyle && (i.fillStyle = t.fillStyle,
                e.fillStyle = t.fillStyle) : (e.fillStyle = t.fillStyle,
                this.contextFillState_ = {
                    fillStyle: t.fillStyle
                })
            }
            setContextStrokeState_(t) {
                const e = this.context_
                  , i = this.contextStrokeState_;
                i ? (i.lineCap != t.lineCap && (i.lineCap = t.lineCap,
                e.lineCap = t.lineCap),
                (0,
                m.fS)(i.lineDash, t.lineDash) || e.setLineDash(i.lineDash = t.lineDash),
                i.lineDashOffset != t.lineDashOffset && (i.lineDashOffset = t.lineDashOffset,
                e.lineDashOffset = t.lineDashOffset),
                i.lineJoin != t.lineJoin && (i.lineJoin = t.lineJoin,
                e.lineJoin = t.lineJoin),
                i.lineWidth != t.lineWidth && (i.lineWidth = t.lineWidth,
                e.lineWidth = t.lineWidth),
                i.miterLimit != t.miterLimit && (i.miterLimit = t.miterLimit,
                e.miterLimit = t.miterLimit),
                i.strokeStyle != t.strokeStyle && (i.strokeStyle = t.strokeStyle,
                e.strokeStyle = t.strokeStyle)) : (e.lineCap = t.lineCap,
                e.setLineDash(t.lineDash),
                e.lineDashOffset = t.lineDashOffset,
                e.lineJoin = t.lineJoin,
                e.lineWidth = t.lineWidth,
                e.miterLimit = t.miterLimit,
                e.strokeStyle = t.strokeStyle,
                this.contextStrokeState_ = {
                    lineCap: t.lineCap,
                    lineDash: t.lineDash,
                    lineDashOffset: t.lineDashOffset,
                    lineJoin: t.lineJoin,
                    lineWidth: t.lineWidth,
                    miterLimit: t.miterLimit,
                    strokeStyle: t.strokeStyle
                })
            }
            setContextTextState_(t) {
                const e = this.context_
                  , i = this.contextTextState_
                  , n = t.textAlign ? t.textAlign : p.PH;
                i ? (i.font != t.font && (i.font = t.font,
                e.font = t.font),
                i.textAlign != n && (i.textAlign = n,
                e.textAlign = n),
                i.textBaseline != t.textBaseline && (i.textBaseline = t.textBaseline,
                e.textBaseline = t.textBaseline)) : (e.font = t.font,
                e.textAlign = n,
                e.textBaseline = t.textBaseline,
                this.contextTextState_ = {
                    font: t.font,
                    textAlign: n,
                    textBaseline: t.textBaseline
                })
            }
            setFillStrokeStyle(t, e) {
                if (t) {
                    const e = t.getColor();
                    this.fillState_ = {
                        fillStyle: (0,
                        d.y)(e || p.bL)
                    }
                } else
                    this.fillState_ = null;
                if (e) {
                    const t = e.getColor()
                      , i = e.getLineCap()
                      , n = e.getLineDash()
                      , r = e.getLineDashOffset()
                      , o = e.getLineJoin()
                      , s = e.getWidth()
                      , a = e.getMiterLimit()
                      , l = n || p.X9;
                    this.strokeState_ = {
                        lineCap: void 0 !== i ? i : p.mb,
                        lineDash: 1 === this.pixelRatio_ ? l : l.map((t => t * this.pixelRatio_)),
                        lineDashOffset: (r || p.He) * this.pixelRatio_,
                        lineJoin: void 0 !== o ? o : p.rc,
                        lineWidth: (void 0 !== s ? s : p.yC) * this.pixelRatio_,
                        miterLimit: void 0 !== a ? a : p.V4,
                        strokeStyle: (0,
                        d.y)(t || p.Tx)
                    }
                } else
                    this.strokeState_ = null
            }
            setImageStyle(t) {
                let e;
                if (!t || !(e = t.getSize()))
                    return void (this.image_ = null);
                const i = t.getPixelRatio(this.pixelRatio_)
                  , n = t.getAnchor()
                  , r = t.getOrigin();
                this.image_ = t.getImage(this.pixelRatio_),
                this.imageAnchorX_ = n[0] * i,
                this.imageAnchorY_ = n[1] * i,
                this.imageHeight_ = e[1] * i,
                this.imageOpacity_ = t.getOpacity(),
                this.imageOriginX_ = r[0],
                this.imageOriginY_ = r[1],
                this.imageRotateWithView_ = t.getRotateWithView(),
                this.imageRotation_ = t.getRotation();
                const o = t.getScaleArray();
                this.imageScale_ = [o[0] * this.pixelRatio_ / i, o[1] * this.pixelRatio_ / i],
                this.imageWidth_ = e[0] * i
            }
            setTextStyle(t) {
                if (t) {
                    const e = t.getFill();
                    if (e) {
                        const t = e.getColor();
                        this.textFillState_ = {
                            fillStyle: (0,
                            d.y)(t || p.bL)
                        }
                    } else
                        this.textFillState_ = null;
                    const i = t.getStroke();
                    if (i) {
                        const t = i.getColor()
                          , e = i.getLineCap()
                          , n = i.getLineDash()
                          , r = i.getLineDashOffset()
                          , o = i.getLineJoin()
                          , s = i.getWidth()
                          , a = i.getMiterLimit();
                        this.textStrokeState_ = {
                            lineCap: void 0 !== e ? e : p.mb,
                            lineDash: n || p.X9,
                            lineDashOffset: r || p.He,
                            lineJoin: void 0 !== o ? o : p.rc,
                            lineWidth: void 0 !== s ? s : p.yC,
                            miterLimit: void 0 !== a ? a : p.V4,
                            strokeStyle: (0,
                            d.y)(t || p.Tx)
                        }
                    } else
                        this.textStrokeState_ = null;
                    const n = t.getFont()
                      , r = t.getOffsetX()
                      , o = t.getOffsetY()
                      , s = t.getRotateWithView()
                      , a = t.getRotation()
                      , l = t.getScaleArray()
                      , c = t.getText()
                      , h = t.getTextAlign()
                      , u = t.getTextBaseline();
                    this.textState_ = {
                        font: void 0 !== n ? n : p.Df,
                        textAlign: void 0 !== h ? h : p.PH,
                        textBaseline: void 0 !== u ? u : p.ru
                    },
                    this.text_ = void 0 !== c ? Array.isArray(c) ? c.reduce(( (t, e, i) => t + (i % 2 ? " " : e)), "") : c : "",
                    this.textOffsetX_ = void 0 !== r ? this.pixelRatio_ * r : 0,
                    this.textOffsetY_ = void 0 !== o ? this.pixelRatio_ * o : 0,
                    this.textRotateWithView_ = void 0 !== s && s,
                    this.textRotation_ = void 0 !== a ? a : 0,
                    this.textScale_ = [this.pixelRatio_ * l[0], this.pixelRatio_ * l[1]]
                } else
                    this.text_ = ""
            }
        }
          , Q = i(81332);
        const tt = .5;
        var et = i(70553);
        const it = .5
          , nt = {
            Point: function(t, e, i, n, r) {
                const o = i.getImage()
                  , s = i.getText();
                let a;
                if (o) {
                    if (o.getImageState() != et.Z.LOADED)
                        return;
                    let l = t;
                    if (r) {
                        const c = o.getDeclutterMode();
                        if ("none" !== c)
                            if (l = r,
                            "obstacle" === c) {
                                const r = t.getBuilder(i.getZIndex(), "Image");
                                r.setImageStyle(o, a),
                                r.drawPoint(e, n)
                            } else
                                s && s.getText() && (a = {})
                    }
                    const c = l.getBuilder(i.getZIndex(), "Image");
                    c.setImageStyle(o, a),
                    c.drawPoint(e, n)
                }
                if (s && s.getText()) {
                    let o = t;
                    r && (o = r);
                    const l = o.getBuilder(i.getZIndex(), "Text");
                    l.setTextStyle(s, a),
                    l.drawText(e, n)
                }
            },
            LineString: function(t, e, i, n, r) {
                const o = i.getStroke();
                if (o) {
                    const r = t.getBuilder(i.getZIndex(), "LineString");
                    r.setFillStrokeStyle(null, o),
                    r.drawLineString(e, n)
                }
                const s = i.getText();
                if (s && s.getText()) {
                    const o = (r || t).getBuilder(i.getZIndex(), "Text");
                    o.setTextStyle(s),
                    o.drawText(e, n)
                }
            },
            Polygon: function(t, e, i, n, r) {
                const o = i.getFill()
                  , s = i.getStroke();
                if (o || s) {
                    const r = t.getBuilder(i.getZIndex(), "Polygon");
                    r.setFillStrokeStyle(o, s),
                    r.drawPolygon(e, n)
                }
                const a = i.getText();
                if (a && a.getText()) {
                    const o = (r || t).getBuilder(i.getZIndex(), "Text");
                    o.setTextStyle(a),
                    o.drawText(e, n)
                }
            },
            MultiPoint: function(t, e, i, n, r) {
                const o = i.getImage()
                  , s = i.getText();
                let a;
                if (o) {
                    if (o.getImageState() != et.Z.LOADED)
                        return;
                    let l = t;
                    if (r) {
                        const c = o.getDeclutterMode();
                        if ("none" !== c)
                            if (l = r,
                            "obstacle" === c) {
                                const r = t.getBuilder(i.getZIndex(), "Image");
                                r.setImageStyle(o, a),
                                r.drawMultiPoint(e, n)
                            } else
                                s && s.getText() && (a = {})
                    }
                    const c = l.getBuilder(i.getZIndex(), "Image");
                    c.setImageStyle(o, a),
                    c.drawMultiPoint(e, n)
                }
                if (s && s.getText()) {
                    let o = t;
                    r && (o = r);
                    const l = o.getBuilder(i.getZIndex(), "Text");
                    l.setTextStyle(s, a),
                    l.drawText(e, n)
                }
            },
            MultiLineString: function(t, e, i, n, r) {
                const o = i.getStroke();
                if (o) {
                    const r = t.getBuilder(i.getZIndex(), "LineString");
                    r.setFillStrokeStyle(null, o),
                    r.drawMultiLineString(e, n)
                }
                const s = i.getText();
                if (s && s.getText()) {
                    const o = (r || t).getBuilder(i.getZIndex(), "Text");
                    o.setTextStyle(s),
                    o.drawText(e, n)
                }
            },
            MultiPolygon: function(t, e, i, n, r) {
                const o = i.getFill()
                  , s = i.getStroke();
                if (s || o) {
                    const r = t.getBuilder(i.getZIndex(), "Polygon");
                    r.setFillStrokeStyle(o, s),
                    r.drawMultiPolygon(e, n)
                }
                const a = i.getText();
                if (a && a.getText()) {
                    const o = (r || t).getBuilder(i.getZIndex(), "Text");
                    o.setTextStyle(a),
                    o.drawText(e, n)
                }
            },
            GeometryCollection: function(t, e, i, n, r) {
                const o = e.getGeometriesArray();
                let s, a;
                for (s = 0,
                a = o.length; s < a; ++s) {
                    (0,
                    nt[o[s].getType()])(t, o[s], i, n, r)
                }
            },
            Circle: function(t, e, i, n, r) {
                const o = i.getFill()
                  , s = i.getStroke();
                if (o || s) {
                    const r = t.getBuilder(i.getZIndex(), "Circle");
                    r.setFillStrokeStyle(o, s),
                    r.drawCircle(e, n)
                }
                const a = i.getText();
                if (a && a.getText()) {
                    const o = (r || t).getBuilder(i.getZIndex(), "Text");
                    o.setTextStyle(a),
                    o.drawText(e, n)
                }
            }
        };
        function rt(t, e) {
            return parseInt((0,
            w.sq)(t), 10) - parseInt((0,
            w.sq)(e), 10)
        }
        function ot(t, e) {
            return it * t / e
        }
        function st(t, e, i, n, r, o, s) {
            let a = !1;
            const l = i.getImage();
            if (l) {
                const t = l.getImageState();
                t == et.Z.LOADED || t == et.Z.ERROR ? l.unlistenImageChange(r) : (t == et.Z.IDLE && l.load(),
                l.listenImageChange(r),
                a = !0)
            }
            return function(t, e, i, n, r, o) {
                const s = i.getGeometryFunction()(e);
                if (!s)
                    return;
                const a = s.simplifyTransformed(n, r)
                  , l = i.getRenderer();
                if (l)
                    at(t, a, i, e);
                else {
                    (0,
                    nt[a.getType()])(t, a, i, e, o)
                }
            }(t, e, i, n, o, s),
            a
        }
        function at(t, e, i, n) {
            if ("GeometryCollection" == e.getType()) {
                const r = e.getGeometries();
                for (let e = 0, o = r.length; e < o; ++e)
                    at(t, r[e], i, n);
                return
            }
            t.getBuilder(i.getZIndex(), "Default").drawCustom(e, n, i.getRenderer(), i.getHitDetectionRenderer())
        }
        var lt = i(26835)
          , ct = i(91900);
        class ht extends P.Z {
            constructor(t) {
                super(t),
                this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this),
                this.animatingOrInteracting_,
                this.hitDetectionImageData_ = null,
                this.renderedFeatures_ = null,
                this.renderedRevision_ = -1,
                this.renderedResolution_ = NaN,
                this.renderedExtent_ = (0,
                f.lJ)(),
                this.wrappedRenderedExtent_ = (0,
                f.lJ)(),
                this.renderedRotation_,
                this.renderedCenter_ = null,
                this.renderedProjection_ = null,
                this.renderedRenderOrder_ = null,
                this.replayGroup_ = null,
                this.replayGroupChanged = !0,
                this.declutterExecutorGroup = null,
                this.clipping = !0,
                this.compositionContext_ = null,
                this.opacity_ = 1
            }
            renderWorlds(t, e, i) {
                const n = e.extent
                  , r = e.viewState
                  , o = r.center
                  , s = r.resolution
                  , a = r.projection
                  , l = r.rotation
                  , c = a.getExtent()
                  , h = this.getLayer().getSource()
                  , u = e.pixelRatio
                  , d = e.viewHints
                  , p = !(d[Y.Z.ANIMATING] || d[Y.Z.INTERACTING])
                  , m = this.compositionContext_
                  , g = Math.round(e.size[0] * u)
                  , _ = Math.round(e.size[1] * u)
                  , y = h.getWrapX() && a.canWrapX()
                  , v = y ? (0,
                f.dz)(c) : null
                  , x = y ? Math.ceil((n[2] - c[2]) / v) + 1 : 1;
                let b = y ? Math.floor((n[0] - c[0]) / v) : 0;
                do {
                    const e = this.getRenderTransform(o, s, l, u, g, _, b * v);
                    t.execute(m, 1, e, l, p, void 0, i)
                } while (++b < x)
            }
            setupCompositionContext_() {
                if (1 !== this.opacity_) {
                    const t = (0,
                    q.E4)(this.context.canvas.width, this.context.canvas.height, P.r);
                    this.compositionContext_ = t
                } else
                    this.compositionContext_ = this.context
            }
            releaseCompositionContext_() {
                if (1 !== this.opacity_) {
                    const t = this.context.globalAlpha;
                    this.context.globalAlpha = this.opacity_,
                    this.context.drawImage(this.compositionContext_.canvas, 0, 0),
                    this.context.globalAlpha = t,
                    (0,
                    q.jy)(this.compositionContext_),
                    P.r.push(this.compositionContext_.canvas),
                    this.compositionContext_ = null
                }
            }
            renderDeclutter(t) {
                this.declutterExecutorGroup && (this.setupCompositionContext_(),
                this.renderWorlds(this.declutterExecutorGroup, t, t.declutterTree),
                this.releaseCompositionContext_())
            }
            renderFrame(t, e) {
                const i = t.pixelRatio
                  , n = t.layerStatesArray[t.layerIndex];
                (0,
                k.n3)(this.pixelTransform, 1 / i, 1 / i),
                (0,
                k.nb)(this.inversePixelTransform, this.pixelTransform);
                const r = (0,
                k.BB)(this.pixelTransform);
                this.useContainer(e, r, this.getBackground(t));
                const o = this.context
                  , s = o.canvas
                  , a = this.replayGroup_
                  , l = this.declutterExecutorGroup;
                if ((!a || a.isEmpty()) && (!l || l.isEmpty()))
                    return null;
                const c = Math.round(t.size[0] * i)
                  , h = Math.round(t.size[1] * i);
                s.width != c || s.height != h ? (s.width = c,
                s.height = h,
                s.style.transform !== r && (s.style.transform = r)) : this.containerReused || o.clearRect(0, 0, c, h),
                this.preRender(o, t);
                const u = t.viewState
                  , d = u.projection;
                this.opacity_ = n.opacity,
                this.setupCompositionContext_();
                let p = !1
                  , m = !0;
                if (n.extent && this.clipping) {
                    const e = (0,
                    lt.dY)(n.extent, d);
                    m = (0,
                    f.kK)(e, t.extent),
                    p = m && !(0,
                    f.r4)(e, t.extent),
                    p && this.clipUnrotated(this.compositionContext_, t, e)
                }
                return m && this.renderWorlds(a, t),
                p && this.compositionContext_.restore(),
                this.releaseCompositionContext_(),
                this.postRender(o, t),
                this.renderedRotation_ !== u.rotation && (this.renderedRotation_ = u.rotation,
                this.hitDetectionImageData_ = null),
                this.container
            }
            getFeatures(t) {
                return new Promise((e => {
                    if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                        const t = [this.context.canvas.width, this.context.canvas.height];
                        (0,
                        k.nn)(this.pixelTransform, t);
                        const e = this.renderedCenter_
                          , i = this.renderedResolution_
                          , n = this.renderedRotation_
                          , r = this.renderedProjection_
                          , o = this.wrappedRenderedExtent_
                          , s = this.getLayer()
                          , a = []
                          , l = t[0] * tt
                          , c = t[1] * tt;
                        a.push(this.getRenderTransform(e, i, n, tt, l, c, 0).slice());
                        const h = s.getSource()
                          , u = r.getExtent();
                        if (h.getWrapX() && r.canWrapX() && !(0,
                        f.r4)(u, o)) {
                            let t = o[0];
                            const r = (0,
                            f.dz)(u);
                            let s, h = 0;
                            for (; t < u[0]; )
                                --h,
                                s = r * h,
                                a.push(this.getRenderTransform(e, i, n, tt, l, c, s).slice()),
                                t += r;
                            for (h = 0,
                            t = o[2]; t > u[2]; )
                                ++h,
                                s = r * h,
                                a.push(this.getRenderTransform(e, i, n, tt, l, c, s).slice()),
                                t -= r
                        }
                        this.hitDetectionImageData_ = function(t, e, i, n, r, o, s) {
                            const a = t[0] * tt
                              , l = t[1] * tt
                              , c = (0,
                            q.E4)(a, l);
                            c.imageSmoothingEnabled = !1;
                            const h = c.canvas
                              , u = new J(c,tt,r,null,s)
                              , d = i.length
                              , p = Math.floor(16777215 / d)
                              , g = {};
                            for (let t = 1; t <= d; ++t) {
                                const e = i[t - 1]
                                  , s = e.getStyleFunction() || n;
                                if (!n)
                                    continue;
                                let a = s(e, o);
                                if (!a)
                                    continue;
                                Array.isArray(a) || (a = [a]);
                                const l = (t * p).toString(16).padStart(7, "#00000");
                                for (let t = 0, i = a.length; t < i; ++t) {
                                    const i = a[t]
                                      , n = i.getGeometryFunction()(e);
                                    if (!n || !(0,
                                    f.kK)(r, n.getExtent()))
                                        continue;
                                    const o = i.clone()
                                      , s = o.getFill();
                                    s && s.setColor(l);
                                    const c = o.getStroke();
                                    c && (c.setColor(l),
                                    c.setLineDash(null)),
                                    o.setText(void 0);
                                    const h = i.getImage();
                                    if (h && 0 !== h.getOpacity()) {
                                        const t = h.getImageSize();
                                        if (!t)
                                            continue;
                                        const e = (0,
                                        q.E4)(t[0], t[1], void 0, {
                                            alpha: !1
                                        })
                                          , i = e.canvas;
                                        e.fillStyle = l,
                                        e.fillRect(0, 0, i.width, i.height),
                                        o.setImage(new Q.Z({
                                            img: i,
                                            imgSize: t,
                                            anchor: h.getAnchor(),
                                            anchorXUnits: "pixels",
                                            anchorYUnits: "pixels",
                                            offset: h.getOrigin(),
                                            opacity: 1,
                                            size: h.getSize(),
                                            scale: h.getScale(),
                                            rotation: h.getRotation(),
                                            rotateWithView: h.getRotateWithView()
                                        }))
                                    }
                                    const u = o.getZIndex() || 0;
                                    let d = g[u];
                                    d || (d = {},
                                    g[u] = d,
                                    d.Polygon = [],
                                    d.Circle = [],
                                    d.LineString = [],
                                    d.Point = []);
                                    const p = n.getType();
                                    if ("GeometryCollection" === p) {
                                        const t = n.getGeometriesArrayRecursive();
                                        for (let e = 0, i = t.length; e < i; ++e) {
                                            const i = t[e];
                                            d[i.getType().replace("Multi", "")].push(i, o)
                                        }
                                    } else
                                        d[p.replace("Multi", "")].push(n, o)
                                }
                            }
                            const _ = Object.keys(g).map(Number).sort(m.j2);
                            for (let t = 0, i = _.length; t < i; ++t) {
                                const i = g[_[t]];
                                for (const t in i) {
                                    const n = i[t];
                                    for (let t = 0, i = n.length; t < i; t += 2) {
                                        u.setStyle(n[t + 1]);
                                        for (let i = 0, r = e.length; i < r; ++i)
                                            u.setTransform(e[i]),
                                            u.drawGeometry(n[t])
                                    }
                                }
                            }
                            return c.getImageData(0, 0, h.width, h.height)
                        }(t, a, this.renderedFeatures_, s.getStyleFunction(), o, i, n)
                    }
                    e(function(t, e, i) {
                        const n = [];
                        if (i) {
                            const r = Math.floor(Math.round(t[0]) * tt)
                              , o = Math.floor(Math.round(t[1]) * tt)
                              , s = 4 * ((0,
                            E.uZ)(r, 0, i.width - 1) + (0,
                            E.uZ)(o, 0, i.height - 1) * i.width)
                              , a = i.data[s]
                              , l = i.data[s + 1]
                              , c = i.data[s + 2] + 256 * (l + 256 * a)
                              , h = Math.floor(16777215 / e.length);
                            c && c % h == 0 && n.push(e[c / h - 1])
                        }
                        return n
                    }(t, this.renderedFeatures_, this.hitDetectionImageData_))
                }
                ))
            }
            forEachFeatureAtCoordinate(t, e, i, n, r) {
                if (!this.replayGroup_)
                    return;
                const o = e.viewState.resolution
                  , s = e.viewState.rotation
                  , a = this.getLayer()
                  , l = {}
                  , c = function(t, e, i) {
                    const o = (0,
                    w.sq)(t)
                      , s = l[o];
                    if (s) {
                        if (!0 !== s && i < s.distanceSq) {
                            if (0 === i)
                                return l[o] = !0,
                                r.splice(r.lastIndexOf(s), 1),
                                n(t, a, e);
                            s.geometry = e,
                            s.distanceSq = i
                        }
                    } else {
                        if (0 === i)
                            return l[o] = !0,
                            n(t, a, e);
                        r.push(l[o] = {
                            feature: t,
                            layer: a,
                            geometry: e,
                            distanceSq: i,
                            callback: n
                        })
                    }
                };
                let h;
                const u = [this.replayGroup_];
                return this.declutterExecutorGroup && u.push(this.declutterExecutorGroup),
                u.some((n => h = n.forEachFeatureAtCoordinate(t, o, s, i, c, n === this.declutterExecutorGroup && e.declutterTree ? e.declutterTree.all().map((t => t.value)) : null))),
                h
            }
            handleFontsChanged() {
                const t = this.getLayer();
                t.getVisible() && this.replayGroup_ && t.changed()
            }
            handleStyleImageChange_(t) {
                this.renderIfReadyAndVisible()
            }
            prepareFrame(t) {
                const e = this.getLayer()
                  , i = e.getSource();
                if (!i)
                    return !1;
                const n = t.viewHints[Y.Z.ANIMATING]
                  , r = t.viewHints[Y.Z.INTERACTING]
                  , o = e.getUpdateWhileAnimating()
                  , s = e.getUpdateWhileInteracting();
                if (this.ready && !o && n || !s && r)
                    return this.animatingOrInteracting_ = !0,
                    !0;
                this.animatingOrInteracting_ = !1;
                const a = t.extent
                  , l = t.viewState
                  , c = l.projection
                  , h = l.resolution
                  , u = t.pixelRatio
                  , d = e.getRevision()
                  , p = e.getRenderBuffer();
                let g = e.getRenderOrder();
                void 0 === g && (g = rt);
                const _ = l.center.slice()
                  , y = (0,
                f.f3)(a, p * h)
                  , v = y.slice()
                  , x = [y.slice()]
                  , b = c.getExtent();
                if (i.getWrapX() && c.canWrapX() && !(0,
                f.r4)(b, t.extent)) {
                    const t = (0,
                    f.dz)(b)
                      , e = Math.max((0,
                    f.dz)(y) / 2, t);
                    y[0] = b[0] - e,
                    y[2] = b[2] + e,
                    (0,
                    ct.Cf)(_, c);
                    const i = (0,
                    f.Cf)(x[0], c);
                    i[0] < b[0] && i[2] < b[2] ? x.push([i[0] + t, i[1], i[2] + t, i[3]]) : i[0] > b[0] && i[2] > b[2] && x.push([i[0] - t, i[1], i[2] - t, i[3]])
                }
                if (this.ready && this.renderedResolution_ == h && this.renderedRevision_ == d && this.renderedRenderOrder_ == g && (0,
                f.r4)(this.wrappedRenderedExtent_, y))
                    return (0,
                    m.fS)(this.renderedExtent_, v) || (this.hitDetectionImageData_ = null,
                    this.renderedExtent_ = v),
                    this.renderedCenter_ = _,
                    this.replayGroupChanged = !1,
                    !0;
                this.replayGroup_ = null;
                const w = new M(ot(h, u),y,h,u);
                let E;
                this.getLayer().getDeclutter() && (E = new M(ot(h, u),y,h,u));
                const T = (0,
                lt.Cs)();
                let S;
                if (T) {
                    for (let t = 0, e = x.length; t < e; ++t) {
                        const e = x[t]
                          , n = (0,
                        lt.Fj)(e, c);
                        i.loadFeatures(n, (0,
                        lt.on)(h, c), T)
                    }
                    S = (0,
                    lt.WO)(T, c)
                } else
                    for (let t = 0, e = x.length; t < e; ++t)
                        i.loadFeatures(x[t], h, c);
                const C = function(t, e) {
                    const i = ot(t, e);
                    return i * i
                }(h, u);
                let A = !0;
                const I = t => {
                    let i;
                    const n = t.getStyleFunction() || e.getStyleFunction();
                    if (n && (i = n(t, h)),
                    i) {
                        const e = this.renderFeature(t, C, i, w, S, E);
                        A = A && !e
                    }
                }
                  , P = (0,
                lt.Fj)(y, c)
                  , k = i.getFeaturesInExtent(P);
                g && k.sort(g);
                for (let t = 0, e = k.length; t < e; ++t)
                    I(k[t]);
                this.renderedFeatures_ = k,
                this.ready = A;
                const O = w.finish()
                  , R = new X(y,h,u,i.getOverlaps(),O,e.getRenderBuffer());
                return E && (this.declutterExecutorGroup = new X(y,h,u,i.getOverlaps(),E.finish(),e.getRenderBuffer())),
                this.renderedResolution_ = h,
                this.renderedRevision_ = d,
                this.renderedRenderOrder_ = g,
                this.renderedExtent_ = v,
                this.wrappedRenderedExtent_ = y,
                this.renderedCenter_ = _,
                this.renderedProjection_ = c,
                this.replayGroup_ = R,
                this.hitDetectionImageData_ = null,
                this.replayGroupChanged = !0,
                !0
            }
            renderFeature(t, e, i, n, r, o) {
                if (!i)
                    return !1;
                let s = !1;
                if (Array.isArray(i))
                    for (let a = 0, l = i.length; a < l; ++a)
                        s = st(n, t, i[a], e, this.boundHandleStyleImageChange_, r, o) || s;
                else
                    s = st(n, t, i, e, this.boundHandleStyleImageChange_, r, o);
                return s
            }
        }
        var ut = ht;
        class dt extends n.Z {
            constructor(t) {
                super(t)
            }
            createRenderer() {
                return new ut(this)
            }
        }
        var ft = dt
    },
    33983: function(t, e, i) {
        "use strict";
        function n(t, e, i) {
            return Math.min(Math.max(t, e), i)
        }
        function r(t, e, i, n, r, s) {
            const a = r - i
              , l = s - n;
            if (0 !== a || 0 !== l) {
                const o = ((t - i) * a + (e - n) * l) / (a * a + l * l);
                o > 1 ? (i = r,
                n = s) : o > 0 && (i += a * o,
                n += l * o)
            }
            return o(t, e, i, n)
        }
        function o(t, e, i, n) {
            const r = i - t
              , o = n - e;
            return r * r + o * o
        }
        function s(t) {
            const e = t.length;
            for (let i = 0; i < e; i++) {
                let n = i
                  , r = Math.abs(t[i][i]);
                for (let o = i + 1; o < e; o++) {
                    const e = Math.abs(t[o][i]);
                    e > r && (r = e,
                    n = o)
                }
                if (0 === r)
                    return null;
                const o = t[n];
                t[n] = t[i],
                t[i] = o;
                for (let n = i + 1; n < e; n++) {
                    const r = -t[n][i] / t[i][i];
                    for (let o = i; o < e + 1; o++)
                        i == o ? t[n][o] = 0 : t[n][o] += r * t[i][o]
                }
            }
            const i = new Array(e);
            for (let n = e - 1; n >= 0; n--) {
                i[n] = t[n][e] / t[n][n];
                for (let r = n - 1; r >= 0; r--)
                    t[r][e] -= t[r][n] * i[n]
            }
            return i
        }
        function a(t) {
            return t * Math.PI / 180
        }
        function l(t, e) {
            const i = t % e;
            return i * e < 0 ? i + e : i
        }
        function c(t, e, i) {
            return t + i * (e - t)
        }
        function h(t, e) {
            const i = Math.pow(10, e);
            return Math.round(t * i) / i
        }
        i.d(e, {
            $W: function() {
                return l
            },
            FH: function() {
                return h
            },
            SV: function() {
                return s
            },
            Yr: function() {
                return a
            },
            bI: function() {
                return o
            },
            rU: function() {
                return r
            },
            t7: function() {
                return c
            },
            uZ: function() {
                return n
            }
        })
    },
    69374: function(t, e, i) {
        "use strict";
        function n(t) {
            for (const e in t)
                delete t[e]
        }
        function r(t) {
            let e;
            for (e in t)
                return !1;
            return !e
        }
        i.d(e, {
            Z: function() {
                return n
            },
            x: function() {
                return r
            }
        })
    },
    26835: function(t, e, i) {
        "use strict";
        i.d(e, {
            Wm: function() {
                return n
            },
            kv: function() {
                return r
            },
            UQ: function() {
                return L
            },
            h_: function() {
                return I
            },
            OP: function() {
                return B
            },
            Vs: function() {
                return Z
            },
            dY: function() {
                return W
            },
            U2: function() {
                return O
            },
            _Q: function() {
                return R
            },
            Ck: function() {
                return F
            },
            WO: function() {
                return z
            },
            Cs: function() {
                return V
            },
            lO: function() {
                return G
            },
            Fj: function() {
                return q
            },
            on: function() {
                return H
            },
            vs: function() {
                return N
            }
        });
        const n = {
            radians: 6370997 / (2 * Math.PI),
            degrees: 2 * Math.PI * 6370997 / 360,
            ft: .3048,
            m: 1,
            "us-ft": 1200 / 3937
        };
        var r = class {
            constructor(t) {
                this.code_ = t.code,
                this.units_ = t.units,
                this.extent_ = void 0 !== t.extent ? t.extent : null,
                this.worldExtent_ = void 0 !== t.worldExtent ? t.worldExtent : null,
                this.axisOrientation_ = void 0 !== t.axisOrientation ? t.axisOrientation : "enu",
                this.global_ = void 0 !== t.global && t.global,
                this.canWrapX_ = !(!this.global_ || !this.extent_),
                this.getPointResolutionFunc_ = t.getPointResolution,
                this.defaultTileGrid_ = null,
                this.metersPerUnit_ = t.metersPerUnit
            }
            canWrapX() {
                return this.canWrapX_
            }
            getCode() {
                return this.code_
            }
            getExtent() {
                return this.extent_
            }
            getUnits() {
                return this.units_
            }
            getMetersPerUnit() {
                return this.metersPerUnit_ || n[this.units_]
            }
            getWorldExtent() {
                return this.worldExtent_
            }
            getAxisOrientation() {
                return this.axisOrientation_
            }
            isGlobal() {
                return this.global_
            }
            setGlobal(t) {
                this.global_ = t,
                this.canWrapX_ = !(!t || !this.extent_)
            }
            getDefaultTileGrid() {
                return this.defaultTileGrid_
            }
            setDefaultTileGrid(t) {
                this.defaultTileGrid_ = t
            }
            setExtent(t) {
                this.extent_ = t,
                this.canWrapX_ = !(!this.global_ || !t)
            }
            setWorldExtent(t) {
                this.worldExtent_ = t
            }
            setGetPointResolution(t) {
                this.getPointResolutionFunc_ = t
            }
            getPointResolutionFunc() {
                return this.getPointResolutionFunc_
            }
        }
        ;
        const o = 6378137
          , s = Math.PI * o
          , a = [-s, -s, s, s]
          , l = [-180, -85, 180, 85]
          , c = o * Math.log(Math.tan(Math.PI / 2));
        class h extends r {
            constructor(t) {
                super({
                    code: t,
                    units: "m",
                    extent: a,
                    global: !0,
                    worldExtent: l,
                    getPointResolution: function(t, e) {
                        return t / Math.cosh(e[1] / o)
                    }
                })
            }
        }
        const u = [new h("EPSG:3857"), new h("EPSG:102100"), new h("EPSG:102113"), new h("EPSG:900913"), new h("http://www.opengis.net/def/crs/EPSG/0/3857"), new h("http://www.opengis.net/gml/srs/epsg.xml#3857")];
        function d(t, e, i) {
            const n = t.length;
            i = i > 1 ? i : 2,
            void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
            for (let r = 0; r < n; r += i) {
                e[r] = s * t[r] / 180;
                let i = o * Math.log(Math.tan(Math.PI * (+t[r + 1] + 90) / 360));
                i > c ? i = c : i < -c && (i = -c),
                e[r + 1] = i
            }
            return e
        }
        function f(t, e, i) {
            const n = t.length;
            i = i > 1 ? i : 2,
            void 0 === e && (e = i > 2 ? t.slice() : new Array(n));
            for (let r = 0; r < n; r += i)
                e[r] = 180 * t[r] / s,
                e[r + 1] = 360 * Math.atan(Math.exp(t[r + 1] / o)) / Math.PI - 90;
            return e
        }
        const p = [-180, -90, 180, 90]
          , m = 6378137 * Math.PI / 180;
        class g extends r {
            constructor(t, e) {
                super({
                    code: t,
                    units: "degrees",
                    extent: p,
                    axisOrientation: e,
                    global: !0,
                    metersPerUnit: m,
                    worldExtent: p
                })
            }
        }
        const _ = [new g("CRS:84"), new g("EPSG:4326","neu"), new g("urn:ogc:def:crs:OGC:1.3:CRS84"), new g("urn:ogc:def:crs:OGC:2:84"), new g("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new g("http://www.opengis.net/gml/srs/epsg.xml#4326","neu"), new g("http://www.opengis.net/def/crs/EPSG/0/4326","neu")];
        let y = {};
        let v = {};
        function x(t, e, i) {
            const n = t.getCode()
              , r = e.getCode();
            n in v || (v[n] = {}),
            v[n][r] = i
        }
        var b = i(28641)
          , w = i(91900)
          , E = i(33983);
        const T = 6371008.8;
        function S(t, e, i) {
            i = i || T;
            const n = (0,
            E.Yr)(t[1])
              , r = (0,
            E.Yr)(e[1])
              , o = (r - n) / 2
              , s = (0,
            E.Yr)(e[0] - t[0]) / 2
              , a = Math.sin(o) * Math.sin(o) + Math.sin(s) * Math.sin(s) * Math.cos(n) * Math.cos(r);
            return 2 * i * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
        }
        var C = i(70044);
        let A = !0;
        function I(t) {
            A = !(void 0 === t || t)
        }
        function M(t, e) {
            if (void 0 !== e)
                for (let i = 0, n = t.length; i < n; ++i)
                    e[i] = t[i];
            else
                e = t.slice();
            return e
        }
        function P(t, e) {
            if (void 0 !== e && t !== e) {
                for (let i = 0, n = t.length; i < n; ++i)
                    e[i] = t[i];
                t = e
            }
            return t
        }
        function k(t) {
            !function(t, e) {
                y[t] = e
            }(t.getCode(), t),
            x(t, t, M)
        }
        function O(t) {
            return "string" == typeof t ? y[e = t] || y[e.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null : t || null;
            var e
        }
        function R(t, e, i, r) {
            let o;
            const s = (t = O(t)).getPointResolutionFunc();
            if (s) {
                if (o = s(e, i),
                r && r !== t.getUnits()) {
                    const e = t.getMetersPerUnit();
                    e && (o = o * e / n[r])
                }
            } else {
                const s = t.getUnits();
                if ("degrees" == s && !r || "degrees" == r)
                    o = e;
                else {
                    const a = z(t, O("EPSG:4326"));
                    if (a === P && "degrees" !== s)
                        o = e * t.getMetersPerUnit();
                    else {
                        let t = [i[0] - e / 2, i[1], i[0] + e / 2, i[1], i[0], i[1] - e / 2, i[0], i[1] + e / 2];
                        t = a(t, t, 2);
                        o = (S(t.slice(0, 2), t.slice(2, 4)) + S(t.slice(4, 6), t.slice(6, 8))) / 2
                    }
                    const l = r ? n[r] : t.getMetersPerUnit();
                    void 0 !== l && (o /= l)
                }
            }
            return o
        }
        function D(t) {
            !function(t) {
                t.forEach(k)
            }(t),
            t.forEach((function(e) {
                t.forEach((function(t) {
                    e !== t && x(e, t, M)
                }
                ))
            }
            ))
        }
        function L(t, e) {
            return t ? "string" == typeof t ? O(t) : t : O(e)
        }
        function B(t, e) {
            if (t === e)
                return !0;
            const i = t.getUnits() === e.getUnits();
            if (t.getCode() === e.getCode())
                return i;
            return z(t, e) === M && i
        }
        function z(t, e) {
            let i = function(t, e) {
                let i;
                return t in v && e in v[t] && (i = v[t][e]),
                i
            }(t.getCode(), e.getCode());
            return i || (i = P),
            i
        }
        function F(t, e) {
            return z(O(t), O(e))
        }
        function N(t, e, i) {
            return F(e, i)(t, void 0, t.length)
        }
        function j(t, e, i, n) {
            const r = F(e, i);
            return (0,
            b.Ne)(t, r, void 0, n)
        }
        let U = null;
        function V() {
            return U
        }
        function G(t, e) {
            return U ? N(t, e, U) : t
        }
        function Z(t, e) {
            return U ? N(t, U, e) : (A && !(0,
            w.fS)(t, [0, 0]) && t[0] >= -180 && t[0] <= 180 && t[1] >= -90 && t[1] <= 90 && (A = !1,
            (0,
            C.ZK)("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")),
            t)
        }
        function q(t, e) {
            return U ? j(t, e, U) : t
        }
        function W(t, e) {
            return U ? j(t, U, e) : t
        }
        function H(t, e) {
            if (!U)
                return t;
            const i = O(e).getUnits()
              , r = U.getUnits();
            return i && r ? t * n[i] / n[r] : t
        }
        var $, X, Y;
        D(u),
        D(_),
        $ = u,
        X = d,
        Y = f,
        _.forEach((function(t) {
            $.forEach((function(e) {
                x(t, e, X),
                x(e, t, Y)
            }
            ))
        }
        ))
    },
    57380: function(t, e, i) {
        "use strict";
        var n = i(291);
        class r extends n.ZP {
            constructor(t, e, i, n) {
                super(t),
                this.inversePixelTransform = e,
                this.frameState = i,
                this.context = n
            }
        }
        e.Z = r
    },
    98771: function(t, e) {
        "use strict";
        e.Z = {
            PRERENDER: "prerender",
            POSTRENDER: "postrender",
            PRECOMPOSE: "precompose",
            POSTCOMPOSE: "postcompose",
            RENDERCOMPLETE: "rendercomplete"
        }
    },
    50147: function(t, e, i) {
        "use strict";
        i.d(e, {
            Df: function() {
                return l
            },
            He: function() {
                return d
            },
            Kd: function() {
                return I
            },
            PH: function() {
                return g
            },
            Qx: function() {
                return T
            },
            Tx: function() {
                return m
            },
            V4: function() {
                return p
            },
            X9: function() {
                return u
            },
            Zw: function() {
                return M
            },
            _f: function() {
                return P
            },
            bL: function() {
                return c
            },
            mb: function() {
                return h
            },
            oB: function() {
                return y
            },
            rc: function() {
                return f
            },
            ru: function() {
                return _
            },
            sG: function() {
                return x
            },
            yC: function() {
                return v
            }
        });
        var n = i(72971)
          , r = i(40177)
          , o = i(69374)
          , s = i(68326)
          , a = i(10245);
        const l = "10px sans-serif"
          , c = "#000"
          , h = "round"
          , u = []
          , d = 0
          , f = "round"
          , p = 10
          , m = "#000"
          , g = "center"
          , _ = "middle"
          , y = [0, 0, 0, 0]
          , v = 1
          , x = new n.Z;
        let b, w = null;
        const E = {}
          , T = function() {
            const t = "32px "
              , e = ["monospace", "serif"]
              , i = e.length
              , n = "wmytzilWMYTZIL@#/&?$%10";
            let r, s;
            function l(r, o, a) {
                let l = !0;
                for (let c = 0; c < i; ++c) {
                    const i = e[c];
                    if (s = A(r + " " + o + " " + t + i, n),
                    a != i) {
                        const e = A(r + " " + o + " " + t + a + "," + i, n);
                        l = l && e != s
                    }
                }
                return !!l
            }
            function c() {
                let t = !0;
                const e = x.getKeys();
                for (let i = 0, n = e.length; i < n; ++i) {
                    const n = e[i];
                    x.get(n) < 100 && (l.apply(this, n.split("\n")) ? ((0,
                    o.Z)(E),
                    w = null,
                    b = void 0,
                    x.set(n, 100)) : (x.set(n, x.get(n) + 1, !0),
                    t = !1))
                }
                t && (clearInterval(r),
                r = void 0)
            }
            return function(t) {
                const e = (0,
                a.p)(t);
                if (!e)
                    return;
                const i = e.families;
                for (let t = 0, n = i.length; t < n; ++t) {
                    const n = i[t]
                      , o = e.style + "\n" + e.weight + "\n" + n;
                    void 0 === x.get(o) && (x.set(o, 100, !0),
                    l(e.style, e.weight, n) || (x.set(o, 0, !0),
                    void 0 === r && (r = setInterval(c, 32))))
                }
            }
        }()
          , S = function() {
            let t;
            return function(e) {
                let i = E[e];
                if (null == i) {
                    if (r.Id) {
                        const t = (0,
                        a.p)(e)
                          , n = C(e, "g");
                        i = (isNaN(Number(t.lineHeight)) ? 1.2 : Number(t.lineHeight)) * (n.actualBoundingBoxAscent + n.actualBoundingBoxDescent)
                    } else
                        t || (t = document.createElement("div"),
                        t.innerHTML = "M",
                        t.style.minHeight = "0",
                        t.style.maxHeight = "none",
                        t.style.height = "auto",
                        t.style.padding = "0",
                        t.style.border = "none",
                        t.style.position = "absolute",
                        t.style.display = "block",
                        t.style.left = "-99999px"),
                        t.style.font = e,
                        document.body.appendChild(t),
                        i = t.offsetHeight,
                        document.body.removeChild(t);
                    E[e] = i
                }
                return i
            }
        }();
        function C(t, e) {
            return w || (w = (0,
            s.E4)(1, 1)),
            t != b && (w.font = t,
            b = w.font),
            w.measureText(e)
        }
        function A(t, e) {
            return C(t, e).width
        }
        function I(t, e, i) {
            if (e in i)
                return i[e];
            const n = e.split("\n").reduce(( (e, i) => Math.max(e, A(t, i))), 0);
            return i[e] = n,
            n
        }
        function M(t, e) {
            const i = []
              , n = []
              , r = [];
            let o = 0
              , s = 0
              , a = 0
              , l = 0;
            for (let c = 0, h = e.length; c <= h; c += 2) {
                const u = e[c];
                if ("\n" === u || c === h) {
                    o = Math.max(o, s),
                    r.push(s),
                    s = 0,
                    a += l;
                    continue
                }
                const d = e[c + 1] || t.font
                  , f = A(d, u);
                i.push(f),
                s += f;
                const p = S(d);
                n.push(p),
                l = Math.max(l, p)
            }
            return {
                width: o,
                height: a,
                widths: i,
                heights: n,
                lineWidths: r
            }
        }
        function P(t, e, i, n, r, o, s, a, l, c, h) {
            t.save(),
            1 !== i && (t.globalAlpha *= i),
            e && t.setTransform.apply(t, e),
            n.contextInstructions ? (t.translate(l, c),
            t.scale(h[0], h[1]),
            function(t, e) {
                const i = t.contextInstructions;
                for (let t = 0, n = i.length; t < n; t += 2)
                    Array.isArray(i[t + 1]) ? e[i[t]].apply(e, i[t + 1]) : e[i[t]] = i[t + 1]
            }(n, t)) : h[0] < 0 || h[1] < 0 ? (t.translate(l, c),
            t.scale(h[0], h[1]),
            t.drawImage(n, r, o, s, a, 0, 0, s, a)) : t.drawImage(n, r, o, s, a, l, c, s * h[0], a * h[1]),
            t.restore()
        }
    },
    10115: function(t, e, i) {
        "use strict";
        var n = i(85487)
          , r = i(70553)
          , o = i(62706)
          , s = i(74187);
        class a extends o.Z {
            constructor(t) {
                super(),
                this.ready = !0,
                this.boundHandleImageChange_ = this.handleImageChange_.bind(this),
                this.layer_ = t,
                this.declutterExecutorGroup = null
            }
            getFeatures(t) {
                return (0,
                s.O3)()
            }
            getData(t) {
                return null
            }
            prepareFrame(t) {
                return (0,
                s.O3)()
            }
            renderFrame(t, e) {
                return (0,
                s.O3)()
            }
            loadedTileCallback(t, e, i) {
                t[e] || (t[e] = {}),
                t[e][i.tileCoord.toString()] = i
            }
            createLoadedTileFinder(t, e, i) {
                return (n, r) => {
                    const o = this.loadedTileCallback.bind(this, i, n);
                    return t.forEachLoadedTile(e, n, r, o)
                }
            }
            forEachFeatureAtCoordinate(t, e, i, n, r) {}
            getLayer() {
                return this.layer_
            }
            handleFontsChanged() {}
            handleImageChange_(t) {
                t.target.getState() === r.Z.LOADED && this.renderIfReadyAndVisible()
            }
            loadImage(t) {
                let e = t.getState();
                return e != r.Z.LOADED && e != r.Z.ERROR && t.addEventListener(n.Z.CHANGE, this.boundHandleImageChange_),
                e == r.Z.IDLE && (t.load(),
                e = t.getState()),
                e == r.Z.LOADED
            }
            renderIfReadyAndVisible() {
                const t = this.getLayer();
                t && t.getVisible() && "ready" === t.getSourceState() && t.changed()
            }
            disposeInternal() {
                delete this.layer_,
                super.disposeInternal()
            }
        }
        e.Z = a
    },
    33748: function(t, e, i) {
        "use strict";
        i.d(e, {
            r: function() {
                return u
            }
        });
        var n = i(10115)
          , r = i(57380)
          , o = i(98771)
          , s = i(6101)
          , a = i(79706)
          , l = i(68326)
          , c = i(65537)
          , h = i(28641);
        const u = [];
        let d = null;
        class f extends n.Z {
            constructor(t) {
                super(t),
                this.container = null,
                this.renderedResolution,
                this.tempTransform = (0,
                s.Ue)(),
                this.pixelTransform = (0,
                s.Ue)(),
                this.inversePixelTransform = (0,
                s.Ue)(),
                this.context = null,
                this.containerReused = !1,
                this.pixelContext_ = null,
                this.frameState = null
            }
            getImageData(t, e, i) {
                let n;
                d || (d = (0,
                l.E4)(1, 1, void 0, {
                    willReadFrequently: !0
                })),
                d.clearRect(0, 0, 1, 1);
                try {
                    d.drawImage(t, e, i, 1, 1, 0, 0, 1, 1),
                    n = d.getImageData(0, 0, 1, 1).data
                } catch (t) {
                    return d = null,
                    null
                }
                return n
            }
            getBackground(t) {
                let e = this.getLayer().getBackground();
                return "function" == typeof e && (e = e(t.viewState.resolution)),
                e || void 0
            }
            useContainer(t, e, i) {
                const n = this.getLayer().getClassName();
                let r, o;
                if (t && t.className === n && (!i || t && t.style.backgroundColor && (0,
                c.fS)((0,
                a._2)(t.style.backgroundColor), (0,
                a._2)(i)))) {
                    const e = t.firstElementChild;
                    e instanceof HTMLCanvasElement && (o = e.getContext("2d"))
                }
                if (o && o.canvas.style.transform === e ? (this.container = t,
                this.context = o,
                this.containerReused = !0) : this.containerReused && (this.container = null,
                this.context = null,
                this.containerReused = !1),
                !this.container) {
                    r = document.createElement("div"),
                    r.className = n;
                    let t = r.style;
                    t.position = "absolute",
                    t.width = "100%",
                    t.height = "100%",
                    o = (0,
                    l.E4)();
                    const e = o.canvas;
                    r.appendChild(e),
                    t = e.style,
                    t.position = "absolute",
                    t.left = "0",
                    t.transformOrigin = "top left",
                    this.container = r,
                    this.context = o
                }
                this.containerReused || !i || this.container.style.backgroundColor || (this.container.style.backgroundColor = i)
            }
            clipUnrotated(t, e, i) {
                const n = (0,
                h.rL)(i)
                  , r = (0,
                h.Xv)(i)
                  , o = (0,
                h.w$)(i)
                  , a = (0,
                h.hC)(i);
                (0,
                s.nn)(e.coordinateToPixelTransform, n),
                (0,
                s.nn)(e.coordinateToPixelTransform, r),
                (0,
                s.nn)(e.coordinateToPixelTransform, o),
                (0,
                s.nn)(e.coordinateToPixelTransform, a);
                const l = this.inversePixelTransform;
                (0,
                s.nn)(l, n),
                (0,
                s.nn)(l, r),
                (0,
                s.nn)(l, o),
                (0,
                s.nn)(l, a),
                t.save(),
                t.beginPath(),
                t.moveTo(Math.round(n[0]), Math.round(n[1])),
                t.lineTo(Math.round(r[0]), Math.round(r[1])),
                t.lineTo(Math.round(o[0]), Math.round(o[1])),
                t.lineTo(Math.round(a[0]), Math.round(a[1])),
                t.clip()
            }
            dispatchRenderEvent_(t, e, i) {
                const n = this.getLayer();
                if (n.hasListener(t)) {
                    const o = new r.Z(t,this.inversePixelTransform,i,e);
                    n.dispatchEvent(o)
                }
            }
            preRender(t, e) {
                this.frameState = e,
                this.dispatchRenderEvent_(o.Z.PRERENDER, t, e)
            }
            postRender(t, e) {
                this.dispatchRenderEvent_(o.Z.POSTRENDER, t, e)
            }
            getRenderTransform(t, e, i, n, r, o, a) {
                const l = r / 2
                  , c = o / 2
                  , h = n / e
                  , u = -h
                  , d = -t[0] + a
                  , f = -t[1];
                return (0,
                s.qC)(this.tempTransform, l, c, h, u, -i, d, f)
            }
            disposeInternal() {
                delete this.frameState,
                super.disposeInternal()
            }
        }
        e.Z = f
    },
    60828: function(t, e, i) {
        "use strict";
        i.d(e, {
            Gw: function() {
                return a
            },
            YP: function() {
                return o
            },
            gE: function() {
                return s
            },
            h$: function() {
                return r
            }
        });
        var n = i(33983);
        function r(t) {
            if (void 0 !== t)
                return 0
        }
        function o(t) {
            if (void 0 !== t)
                return t
        }
        function s(t) {
            const e = 2 * Math.PI / t;
            return function(t, i) {
                return i ? t : void 0 !== t ? t = Math.floor(t / e + .5) * e : void 0
            }
        }
        function a(t) {
            return t = t || (0,
            n.Yr)(5),
            function(e, i) {
                return i ? e : void 0 !== e ? Math.abs(e) <= t ? 0 : e : void 0
            }
        }
    },
    4307: function(t, e, i) {
        "use strict";
        function n(t) {
            return t[0] > 0 && t[1] > 0
        }
        function r(t, e) {
            return Array.isArray(t) ? t : (void 0 === e ? e = [t, t] : (e[0] = t,
            e[1] = t),
            e)
        }
        i.d(e, {
            Pq: function() {
                return r
            },
            py: function() {
                return n
            }
        })
    },
    58458: function(t, e, i) {
        "use strict";
        var n = i(72971)
          , r = i(26835);
        class o extends n.Z {
            constructor(t) {
                super(),
                this.projection = (0,
                r.U2)(t.projection),
                this.attributions_ = s(t.attributions),
                this.attributionsCollapsible_ = void 0 === t.attributionsCollapsible || t.attributionsCollapsible,
                this.loading = !1,
                this.state_ = void 0 !== t.state ? t.state : "ready",
                this.wrapX_ = void 0 !== t.wrapX && t.wrapX,
                this.interpolate_ = !!t.interpolate,
                this.viewResolver = null,
                this.viewRejector = null;
                const e = this;
                this.viewPromise_ = new Promise((function(t, i) {
                    e.viewResolver = t,
                    e.viewRejector = i
                }
                ))
            }
            getAttributions() {
                return this.attributions_
            }
            getAttributionsCollapsible() {
                return this.attributionsCollapsible_
            }
            getProjection() {
                return this.projection
            }
            getResolutions(t) {
                return null
            }
            getView() {
                return this.viewPromise_
            }
            getState() {
                return this.state_
            }
            getWrapX() {
                return this.wrapX_
            }
            getInterpolate() {
                return this.interpolate_
            }
            refresh() {
                this.changed()
            }
            setAttributions(t) {
                this.attributions_ = s(t),
                this.changed()
            }
            setState(t) {
                this.state_ = t,
                this.changed()
            }
        }
        function s(t) {
            return t ? Array.isArray(t) ? function(e) {
                return t
            }
            : "function" == typeof t ? t : function(e) {
                return [t]
            }
            : null
        }
        e.Z = o
    },
    31361: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return E
            }
        });
        var n = i(78714)
          , r = i(42071)
          , o = i(291)
          , s = i(85487)
          , a = i(35990)
          , l = i(39781)
          , c = i(58458)
          , h = i(22796)
          , u = i(36885);
        i(26835);
        function d(t, e) {
            return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]]
        }
        var f = i(99515)
          , p = i(28641)
          , m = i(65537)
          , g = i(74187)
          , _ = i(69374)
          , y = i(65818);
        let v = !1;
        function x(t, e) {
            return function(i, n, r, o, s) {
                const a = this;
                !function(t, e, i, n, r, o, s) {
                    const a = new XMLHttpRequest;
                    a.open("GET", "function" == typeof t ? t(i, n, r) : t, !0),
                    "arraybuffer" == e.getType() && (a.responseType = "arraybuffer"),
                    a.withCredentials = v,
                    a.onload = function(t) {
                        if (!a.status || a.status >= 200 && a.status < 300) {
                            const t = e.getType();
                            let n;
                            "json" == t || "text" == t ? n = a.responseText : "xml" == t ? (n = a.responseXML,
                            n || (n = (new DOMParser).parseFromString(a.responseText, "application/xml"))) : "arraybuffer" == t && (n = a.response),
                            n ? o(e.readFeatures(n, {
                                extent: i,
                                featureProjection: r
                            }), e.readProjection(n)) : s()
                        } else
                            s()
                    }
                    ,
                    a.onerror = s,
                    a.send()
                }(t, e, i, n, r, (function(t, e) {
                    a.addFeatures(t),
                    void 0 !== o && o(t)
                }
                ), s || u.Zn)
            }
        }
        class b extends o.ZP {
            constructor(t, e, i) {
                super(t),
                this.feature = e,
                this.features = i
            }
        }
        class w extends c.Z {
            constructor(t) {
                super({
                    attributions: (t = t || {}).attributions,
                    interpolate: !0,
                    projection: void 0,
                    state: "ready",
                    wrapX: void 0 === t.wrapX || t.wrapX
                }),
                this.on,
                this.once,
                this.un,
                this.loader_ = u.Zn,
                this.format_ = t.format,
                this.overlaps_ = void 0 === t.overlaps || t.overlaps,
                this.url_ = t.url,
                void 0 !== t.loader ? this.loader_ = t.loader : void 0 !== this.url_ && ((0,
                f.h)(this.format_, 7),
                this.loader_ = x(this.url_, this.format_)),
                this.strategy_ = void 0 !== t.strategy ? t.strategy : d;
                const e = void 0 === t.useSpatialIndex || t.useSpatialIndex;
                let i, r;
                this.featuresRtree_ = e ? new l.Z : null,
                this.loadedExtentsRtree_ = new l.Z,
                this.loadingExtentsCount_ = 0,
                this.nullGeometryFeatures_ = {},
                this.idIndex_ = {},
                this.uidIndex_ = {},
                this.featureChangeKeys_ = {},
                this.featuresCollection_ = null,
                Array.isArray(t.features) ? r = t.features : t.features && (i = t.features,
                r = i.getArray()),
                e || void 0 !== i || (i = new n.Z(r)),
                void 0 !== r && this.addFeaturesInternal(r),
                void 0 !== i && this.bindFeaturesCollection_(i)
            }
            addFeature(t) {
                this.addFeatureInternal(t),
                this.changed()
            }
            addFeatureInternal(t) {
                const e = (0,
                g.sq)(t);
                if (!this.addToIndex_(e, t))
                    return void (this.featuresCollection_ && this.featuresCollection_.remove(t));
                this.setupChangeEvents_(e, t);
                const i = t.getGeometry();
                if (i) {
                    const e = i.getExtent();
                    this.featuresRtree_ && this.featuresRtree_.insert(e, t)
                } else
                    this.nullGeometryFeatures_[e] = t;
                this.dispatchEvent(new b(h.Z.ADDFEATURE,t))
            }
            setupChangeEvents_(t, e) {
                this.featureChangeKeys_[t] = [(0,
                y.oL)(e, s.Z.CHANGE, this.handleFeatureChange_, this), (0,
                y.oL)(e, a.Z.PROPERTYCHANGE, this.handleFeatureChange_, this)]
            }
            addToIndex_(t, e) {
                let i = !0;
                const n = e.getId();
                return void 0 !== n && (n.toString()in this.idIndex_ ? i = !1 : this.idIndex_[n.toString()] = e),
                i && ((0,
                f.h)(!(t in this.uidIndex_), 30),
                this.uidIndex_[t] = e),
                i
            }
            addFeatures(t) {
                this.addFeaturesInternal(t),
                this.changed()
            }
            addFeaturesInternal(t) {
                const e = []
                  , i = []
                  , n = [];
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e]
                      , r = (0,
                    g.sq)(n);
                    this.addToIndex_(r, n) && i.push(n)
                }
                for (let t = 0, r = i.length; t < r; t++) {
                    const r = i[t]
                      , o = (0,
                    g.sq)(r);
                    this.setupChangeEvents_(o, r);
                    const s = r.getGeometry();
                    if (s) {
                        const t = s.getExtent();
                        e.push(t),
                        n.push(r)
                    } else
                        this.nullGeometryFeatures_[o] = r
                }
                if (this.featuresRtree_ && this.featuresRtree_.load(e, n),
                this.hasListener(h.Z.ADDFEATURE))
                    for (let t = 0, e = i.length; t < e; t++)
                        this.dispatchEvent(new b(h.Z.ADDFEATURE,i[t]))
            }
            bindFeaturesCollection_(t) {
                let e = !1;
                this.addEventListener(h.Z.ADDFEATURE, (function(i) {
                    e || (e = !0,
                    t.push(i.feature),
                    e = !1)
                }
                )),
                this.addEventListener(h.Z.REMOVEFEATURE, (function(i) {
                    e || (e = !0,
                    t.remove(i.feature),
                    e = !1)
                }
                )),
                t.addEventListener(r.Z.ADD, (t => {
                    e || (e = !0,
                    this.addFeature(t.element),
                    e = !1)
                }
                )),
                t.addEventListener(r.Z.REMOVE, (t => {
                    e || (e = !0,
                    this.removeFeature(t.element),
                    e = !1)
                }
                )),
                this.featuresCollection_ = t
            }
            clear(t) {
                if (t) {
                    for (const t in this.featureChangeKeys_) {
                        this.featureChangeKeys_[t].forEach(y.bN)
                    }
                    this.featuresCollection_ || (this.featureChangeKeys_ = {},
                    this.idIndex_ = {},
                    this.uidIndex_ = {})
                } else if (this.featuresRtree_) {
                    const t = t => {
                        this.removeFeatureInternal(t)
                    }
                    ;
                    this.featuresRtree_.forEach(t);
                    for (const t in this.nullGeometryFeatures_)
                        this.removeFeatureInternal(this.nullGeometryFeatures_[t])
                }
                this.featuresCollection_ && this.featuresCollection_.clear(),
                this.featuresRtree_ && this.featuresRtree_.clear(),
                this.nullGeometryFeatures_ = {};
                const e = new b(h.Z.CLEAR);
                this.dispatchEvent(e),
                this.changed()
            }
            forEachFeature(t) {
                if (this.featuresRtree_)
                    return this.featuresRtree_.forEach(t);
                this.featuresCollection_ && this.featuresCollection_.forEach(t)
            }
            forEachFeatureAtCoordinateDirect(t, e) {
                const i = [t[0], t[1], t[0], t[1]];
                return this.forEachFeatureInExtent(i, (function(i) {
                    if (i.getGeometry().intersectsCoordinate(t))
                        return e(i)
                }
                ))
            }
            forEachFeatureInExtent(t, e) {
                if (this.featuresRtree_)
                    return this.featuresRtree_.forEachInExtent(t, e);
                this.featuresCollection_ && this.featuresCollection_.forEach(e)
            }
            forEachFeatureIntersectingExtent(t, e) {
                return this.forEachFeatureInExtent(t, (function(i) {
                    if (i.getGeometry().intersectsExtent(t)) {
                        const t = e(i);
                        if (t)
                            return t
                    }
                }
                ))
            }
            getFeaturesCollection() {
                return this.featuresCollection_
            }
            getFeatures() {
                let t;
                return this.featuresCollection_ ? t = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (t = this.featuresRtree_.getAll(),
                (0,
                _.x)(this.nullGeometryFeatures_) || (0,
                m.l7)(t, Object.values(this.nullGeometryFeatures_))),
                t
            }
            getFeaturesAtCoordinate(t) {
                const e = [];
                return this.forEachFeatureAtCoordinateDirect(t, (function(t) {
                    e.push(t)
                }
                )),
                e
            }
            getFeaturesInExtent(t, e) {
                if (this.featuresRtree_) {
                    if (!(e && e.canWrapX() && this.getWrapX()))
                        return this.featuresRtree_.getInExtent(t);
                    const i = (0,
                    p.MV)(t, e);
                    return [].concat(...i.map((t => this.featuresRtree_.getInExtent(t))))
                }
                return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : []
            }
            getClosestFeatureToCoordinate(t, e) {
                const i = t[0]
                  , n = t[1];
                let r = null;
                const o = [NaN, NaN];
                let s = 1 / 0;
                const a = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
                return e = e || u.uX,
                this.featuresRtree_.forEachInExtent(a, (function(t) {
                    if (e(t)) {
                        const e = t.getGeometry()
                          , l = s;
                        if (s = e.closestPointXY(i, n, o, s),
                        s < l) {
                            r = t;
                            const e = Math.sqrt(s);
                            a[0] = i - e,
                            a[1] = n - e,
                            a[2] = i + e,
                            a[3] = n + e
                        }
                    }
                }
                )),
                r
            }
            getExtent(t) {
                return this.featuresRtree_.getExtent(t)
            }
            getFeatureById(t) {
                const e = this.idIndex_[t.toString()];
                return void 0 !== e ? e : null
            }
            getFeatureByUid(t) {
                const e = this.uidIndex_[t];
                return void 0 !== e ? e : null
            }
            getFormat() {
                return this.format_
            }
            getOverlaps() {
                return this.overlaps_
            }
            getUrl() {
                return this.url_
            }
            handleFeatureChange_(t) {
                const e = t.target
                  , i = (0,
                g.sq)(e)
                  , n = e.getGeometry();
                if (n) {
                    const t = n.getExtent();
                    i in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[i],
                    this.featuresRtree_ && this.featuresRtree_.insert(t, e)) : this.featuresRtree_ && this.featuresRtree_.update(t, e)
                } else
                    i in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(e),
                    this.nullGeometryFeatures_[i] = e);
                const r = e.getId();
                if (void 0 !== r) {
                    const t = r.toString();
                    this.idIndex_[t] !== e && (this.removeFromIdIndex_(e),
                    this.idIndex_[t] = e)
                } else
                    this.removeFromIdIndex_(e),
                    this.uidIndex_[i] = e;
                this.changed(),
                this.dispatchEvent(new b(h.Z.CHANGEFEATURE,e))
            }
            hasFeature(t) {
                const e = t.getId();
                return void 0 !== e ? e in this.idIndex_ : (0,
                g.sq)(t)in this.uidIndex_
            }
            isEmpty() {
                return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && (0,
                _.x)(this.nullGeometryFeatures_) : !this.featuresCollection_ || 0 === this.featuresCollection_.getLength()
            }
            loadFeatures(t, e, i) {
                const n = this.loadedExtentsRtree_
                  , r = this.strategy_(t, e, i);
                for (let t = 0, o = r.length; t < o; ++t) {
                    const o = r[t];
                    n.forEachInExtent(o, (function(t) {
                        return (0,
                        p.r4)(t.extent, o)
                    }
                    )) || (++this.loadingExtentsCount_,
                    this.dispatchEvent(new b(h.Z.FEATURESLOADSTART)),
                    this.loader_.call(this, o, e, i, (t => {
                        --this.loadingExtentsCount_,
                        this.dispatchEvent(new b(h.Z.FEATURESLOADEND,void 0,t))
                    }
                    ), ( () => {
                        --this.loadingExtentsCount_,
                        this.dispatchEvent(new b(h.Z.FEATURESLOADERROR))
                    }
                    )),
                    n.insert(o, {
                        extent: o.slice()
                    }))
                }
                this.loading = !(this.loader_.length < 4) && this.loadingExtentsCount_ > 0
            }
            refresh() {
                this.clear(!0),
                this.loadedExtentsRtree_.clear(),
                super.refresh()
            }
            removeLoadedExtent(t) {
                const e = this.loadedExtentsRtree_;
                let i;
                e.forEachInExtent(t, (function(e) {
                    if ((0,
                    p.fS)(e.extent, t))
                        return i = e,
                        !0
                }
                )),
                i && e.remove(i)
            }
            removeFeature(t) {
                if (!t)
                    return;
                const e = (0,
                g.sq)(t);
                e in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[e] : this.featuresRtree_ && this.featuresRtree_.remove(t);
                this.removeFeatureInternal(t) && this.changed()
            }
            removeFeatureInternal(t) {
                const e = (0,
                g.sq)(t)
                  , i = this.featureChangeKeys_[e];
                if (!i)
                    return;
                i.forEach(y.bN),
                delete this.featureChangeKeys_[e];
                const n = t.getId();
                return void 0 !== n && delete this.idIndex_[n.toString()],
                delete this.uidIndex_[e],
                this.dispatchEvent(new b(h.Z.REMOVEFEATURE,t)),
                t
            }
            removeFromIdIndex_(t) {
                let e = !1;
                for (const i in this.idIndex_)
                    if (this.idIndex_[i] === t) {
                        delete this.idIndex_[i],
                        e = !0;
                        break
                    }
                return e
            }
            setLoader(t) {
                this.loader_ = t
            }
            setUrl(t) {
                (0,
                f.h)(this.format_, 7),
                this.url_ = t,
                this.setLoader(x(t, this.format_))
            }
        }
        var E = w
    },
    22796: function(t, e) {
        "use strict";
        e.Z = {
            ADDFEATURE: "addfeature",
            CHANGEFEATURE: "changefeature",
            CLEAR: "clear",
            REMOVEFEATURE: "removefeature",
            FEATURESLOADSTART: "featuresloadstart",
            FEATURESLOADEND: "featuresloadend",
            FEATURESLOADERROR: "featuresloaderror"
        }
    },
    39781: function(t, e, i) {
        "use strict";
        var n = i(82582)
          , r = i(28641)
          , o = i(74187)
          , s = i(69374);
        e.Z = class {
            constructor(t) {
                this.rbush_ = new n(t),
                this.items_ = {}
            }
            insert(t, e) {
                const i = {
                    minX: t[0],
                    minY: t[1],
                    maxX: t[2],
                    maxY: t[3],
                    value: e
                };
                this.rbush_.insert(i),
                this.items_[(0,
                o.sq)(e)] = i
            }
            load(t, e) {
                const i = new Array(e.length);
                for (let n = 0, r = e.length; n < r; n++) {
                    const r = t[n]
                      , s = e[n]
                      , a = {
                        minX: r[0],
                        minY: r[1],
                        maxX: r[2],
                        maxY: r[3],
                        value: s
                    };
                    i[n] = a,
                    this.items_[(0,
                    o.sq)(s)] = a
                }
                this.rbush_.load(i)
            }
            remove(t) {
                const e = (0,
                o.sq)(t)
                  , i = this.items_[e];
                return delete this.items_[e],
                null !== this.rbush_.remove(i)
            }
            update(t, e) {
                const i = this.items_[(0,
                o.sq)(e)]
                  , n = [i.minX, i.minY, i.maxX, i.maxY];
                (0,
                r.fS)(n, t) || (this.remove(e),
                this.insert(t, e))
            }
            getAll() {
                return this.rbush_.all().map((function(t) {
                    return t.value
                }
                ))
            }
            getInExtent(t) {
                const e = {
                    minX: t[0],
                    minY: t[1],
                    maxX: t[2],
                    maxY: t[3]
                };
                return this.rbush_.search(e).map((function(t) {
                    return t.value
                }
                ))
            }
            forEach(t) {
                return this.forEach_(this.getAll(), t)
            }
            forEachInExtent(t, e) {
                return this.forEach_(this.getInExtent(t), e)
            }
            forEach_(t, e) {
                let i;
                for (let n = 0, r = t.length; n < r; n++)
                    if (i = e(t[n]),
                    i)
                        return i;
                return i
            }
            isEmpty() {
                return (0,
                s.x)(this.items_)
            }
            clear() {
                this.rbush_.clear(),
                this.items_ = {}
            }
            getExtent(t) {
                const e = this.rbush_.toJSON();
                return (0,
                r.T9)(e.minX, e.minY, e.maxX, e.maxY, t)
            }
            concat(t) {
                this.rbush_.load(t.rbush_.all());
                for (const e in t.items_)
                    this.items_[e] = t.items_[e]
            }
        }
    },
    30283: function(t, e, i) {
        "use strict";
        var n = i(35393);
        class r extends n.Z {
            constructor(t) {
                super({
                    points: 1 / 0,
                    fill: (t = t || {
                        radius: 5
                    }).fill,
                    radius: t.radius,
                    stroke: t.stroke,
                    scale: void 0 !== t.scale ? t.scale : 1,
                    rotation: void 0 !== t.rotation ? t.rotation : 0,
                    rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
                    displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
                    declutterMode: t.declutterMode
                })
            }
            clone() {
                const t = this.getScale()
                  , e = new r({
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    radius: this.getRadius(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                });
                return e.setOpacity(this.getOpacity()),
                e
            }
            setRadius(t) {
                this.radius_ = t,
                this.render()
            }
        }
        e.Z = r
    },
    51345: function(t, e) {
        "use strict";
        class i {
            constructor(t) {
                t = t || {},
                this.color_ = void 0 !== t.color ? t.color : null
            }
            clone() {
                const t = this.getColor();
                return new i({
                    color: Array.isArray(t) ? t.slice() : t || void 0
                })
            }
            getColor() {
                return this.color_
            }
            setColor(t) {
                this.color_ = t
            }
        }
        e.Z = i
    },
    81332: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return _
            }
        });
        var n = i(85487)
          , r = i(70553)
          , o = i(28443)
          , s = i(79706)
          , a = i(99515)
          , l = i(208)
          , c = i(68326)
          , h = i(92710)
          , u = i(18096);
        let d = null;
        class f extends l.Z {
            constructor(t, e, i, n, r, o) {
                super(),
                this.hitDetectionImage_ = null,
                this.image_ = t,
                this.crossOrigin_ = n,
                this.canvas_ = {},
                this.color_ = o,
                this.unlisten_ = null,
                this.imageState_ = r,
                this.size_ = i,
                this.src_ = e,
                this.tainted_
            }
            initializeImage_() {
                this.image_ = new Image,
                null !== this.crossOrigin_ && (this.image_.crossOrigin = this.crossOrigin_)
            }
            isTainted_() {
                if (void 0 === this.tainted_ && this.imageState_ === r.Z.LOADED) {
                    d || (d = (0,
                    c.E4)(1, 1, void 0, {
                        willReadFrequently: !0
                    })),
                    d.drawImage(this.image_, 0, 0);
                    try {
                        d.getImageData(0, 0, 1, 1),
                        this.tainted_ = !1
                    } catch (t) {
                        d = null,
                        this.tainted_ = !0
                    }
                }
                return !0 === this.tainted_
            }
            dispatchChangeEvent_() {
                this.dispatchEvent(n.Z.CHANGE)
            }
            handleImageError_() {
                this.imageState_ = r.Z.ERROR,
                this.unlistenImage_(),
                this.dispatchChangeEvent_()
            }
            handleImageLoad_() {
                this.imageState_ = r.Z.LOADED,
                this.size_ ? (this.image_.width = this.size_[0],
                this.image_.height = this.size_[1]) : this.size_ = [this.image_.width, this.image_.height],
                this.unlistenImage_(),
                this.dispatchChangeEvent_()
            }
            getImage(t) {
                return this.image_ || this.initializeImage_(),
                this.replaceColor_(t),
                this.canvas_[t] ? this.canvas_[t] : this.image_
            }
            getPixelRatio(t) {
                return this.replaceColor_(t),
                this.canvas_[t] ? t : 1
            }
            getImageState() {
                return this.imageState_
            }
            getHitDetectionImage() {
                if (this.image_ || this.initializeImage_(),
                !this.hitDetectionImage_)
                    if (this.isTainted_()) {
                        const t = this.size_[0]
                          , e = this.size_[1]
                          , i = (0,
                        c.E4)(t, e);
                        i.fillRect(0, 0, t, e),
                        this.hitDetectionImage_ = i.canvas
                    } else
                        this.hitDetectionImage_ = this.image_;
                return this.hitDetectionImage_
            }
            getSize() {
                return this.size_
            }
            getSrc() {
                return this.src_
            }
            load() {
                if (this.imageState_ === r.Z.IDLE) {
                    this.image_ || this.initializeImage_(),
                    this.imageState_ = r.Z.LOADING;
                    try {
                        this.image_.src = this.src_
                    } catch (t) {
                        this.handleImageError_()
                    }
                    this.unlisten_ = (0,
                    u.K)(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this))
                }
            }
            replaceColor_(t) {
                if (!this.color_ || this.canvas_[t] || this.imageState_ !== r.Z.LOADED)
                    return;
                const e = this.image_
                  , i = document.createElement("canvas");
                i.width = Math.ceil(e.width * t),
                i.height = Math.ceil(e.height * t);
                const n = i.getContext("2d");
                n.scale(t, t),
                n.drawImage(e, 0, 0),
                n.globalCompositeOperation = "multiply",
                n.fillStyle = (0,
                s.XC)(this.color_),
                n.fillRect(0, 0, i.width / t, i.height / t),
                n.globalCompositeOperation = "destination-in",
                n.drawImage(e, 0, 0),
                this.canvas_[t] = i
            }
            unlistenImage_() {
                this.unlisten_ && (this.unlisten_(),
                this.unlisten_ = null)
            }
        }
        var p = i(74187);
        function m(t, e, i, n) {
            return void 0 !== i && void 0 !== n ? [i / t, n / e] : void 0 !== i ? i / t : void 0 !== n ? n / e : 1
        }
        class g extends o.Z {
            constructor(t) {
                const e = void 0 !== (t = t || {}).opacity ? t.opacity : 1
                  , i = void 0 !== t.rotation ? t.rotation : 0
                  , n = void 0 !== t.scale ? t.scale : 1
                  , o = void 0 !== t.rotateWithView && t.rotateWithView;
                super({
                    opacity: e,
                    rotation: i,
                    scale: n,
                    displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
                    rotateWithView: o,
                    declutterMode: t.declutterMode
                }),
                this.anchor_ = void 0 !== t.anchor ? t.anchor : [.5, .5],
                this.normalizedAnchor_ = null,
                this.anchorOrigin_ = void 0 !== t.anchorOrigin ? t.anchorOrigin : "top-left",
                this.anchorXUnits_ = void 0 !== t.anchorXUnits ? t.anchorXUnits : "fraction",
                this.anchorYUnits_ = void 0 !== t.anchorYUnits ? t.anchorYUnits : "fraction",
                this.crossOrigin_ = void 0 !== t.crossOrigin ? t.crossOrigin : null;
                const l = void 0 !== t.img ? t.img : null;
                this.imgSize_ = t.imgSize;
                let c = t.src;
                (0,
                a.h)(!(void 0 !== c && l), 4),
                (0,
                a.h)(!l || l && this.imgSize_, 5),
                void 0 !== c && 0 !== c.length || !l || (c = l.src || (0,
                p.sq)(l)),
                (0,
                a.h)(void 0 !== c && c.length > 0, 6),
                (0,
                a.h)(!((void 0 !== t.width || void 0 !== t.height) && void 0 !== t.scale), 69);
                const u = void 0 !== t.src ? r.Z.IDLE : r.Z.LOADED;
                if (this.color_ = void 0 !== t.color ? (0,
                s._2)(t.color) : null,
                this.iconImage_ = function(t, e, i, n, r, o) {
                    let s = h.c.get(e, n, o);
                    return s || (s = new f(t,e,i,n,r,o),
                    h.c.set(e, n, o, s)),
                    s
                }(l, c, void 0 !== this.imgSize_ ? this.imgSize_ : null, this.crossOrigin_, u, this.color_),
                this.offset_ = void 0 !== t.offset ? t.offset : [0, 0],
                this.offsetOrigin_ = void 0 !== t.offsetOrigin ? t.offsetOrigin : "top-left",
                this.origin_ = null,
                this.size_ = void 0 !== t.size ? t.size : null,
                void 0 !== t.width || void 0 !== t.height) {
                    let e, i;
                    if (t.size)
                        [e,i] = t.size;
                    else {
                        const n = this.getImage(1);
                        if (!(n instanceof HTMLCanvasElement || n.src && n.complete)) {
                            this.initialOptions_ = t;
                            const e = () => {
                                if (this.unlistenImageChange(e),
                                !this.initialOptions_)
                                    return;
                                const i = this.iconImage_.getSize();
                                this.setScale(m(i[0], i[1], t.width, t.height))
                            }
                            ;
                            return void this.listenImageChange(e)
                        }
                        e = n.width,
                        i = n.height
                    }
                    void 0 !== e && this.setScale(m(e, i, t.width, t.height))
                }
            }
            clone() {
                let t, e, i;
                this.initialOptions_ ? (e = this.initialOptions_.width,
                i = this.initialOptions_.height) : (t = this.getScale(),
                t = Array.isArray(t) ? t.slice() : t);
                return new g({
                    anchor: this.anchor_.slice(),
                    anchorOrigin: this.anchorOrigin_,
                    anchorXUnits: this.anchorXUnits_,
                    anchorYUnits: this.anchorYUnits_,
                    color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
                    crossOrigin: this.crossOrigin_,
                    imgSize: this.imgSize_,
                    offset: this.offset_.slice(),
                    offsetOrigin: this.offsetOrigin_,
                    opacity: this.getOpacity(),
                    rotateWithView: this.getRotateWithView(),
                    rotation: this.getRotation(),
                    scale: t,
                    width: e,
                    height: i,
                    size: null !== this.size_ ? this.size_.slice() : void 0,
                    src: this.getSrc(),
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                })
            }
            getAnchor() {
                let t = this.normalizedAnchor_;
                if (!t) {
                    t = this.anchor_;
                    const e = this.getSize();
                    if ("fraction" == this.anchorXUnits_ || "fraction" == this.anchorYUnits_) {
                        if (!e)
                            return null;
                        t = this.anchor_.slice(),
                        "fraction" == this.anchorXUnits_ && (t[0] *= e[0]),
                        "fraction" == this.anchorYUnits_ && (t[1] *= e[1])
                    }
                    if ("top-left" != this.anchorOrigin_) {
                        if (!e)
                            return null;
                        t === this.anchor_ && (t = this.anchor_.slice()),
                        "top-right" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t[0] = -t[0] + e[0]),
                        "bottom-left" != this.anchorOrigin_ && "bottom-right" != this.anchorOrigin_ || (t[1] = -t[1] + e[1])
                    }
                    this.normalizedAnchor_ = t
                }
                const e = this.getDisplacement()
                  , i = this.getScaleArray();
                return [t[0] - e[0] / i[0], t[1] + e[1] / i[1]]
            }
            setAnchor(t) {
                this.anchor_ = t,
                this.normalizedAnchor_ = null
            }
            getColor() {
                return this.color_
            }
            getImage(t) {
                return this.iconImage_.getImage(t)
            }
            getPixelRatio(t) {
                return this.iconImage_.getPixelRatio(t)
            }
            getImageSize() {
                return this.iconImage_.getSize()
            }
            getImageState() {
                return this.iconImage_.getImageState()
            }
            getHitDetectionImage() {
                return this.iconImage_.getHitDetectionImage()
            }
            getOrigin() {
                if (this.origin_)
                    return this.origin_;
                let t = this.offset_;
                if ("top-left" != this.offsetOrigin_) {
                    const e = this.getSize()
                      , i = this.iconImage_.getSize();
                    if (!e || !i)
                        return null;
                    t = t.slice(),
                    "top-right" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t[0] = i[0] - e[0] - t[0]),
                    "bottom-left" != this.offsetOrigin_ && "bottom-right" != this.offsetOrigin_ || (t[1] = i[1] - e[1] - t[1])
                }
                return this.origin_ = t,
                this.origin_
            }
            getSrc() {
                return this.iconImage_.getSrc()
            }
            getSize() {
                return this.size_ ? this.size_ : this.iconImage_.getSize()
            }
            getWidth() {
                const t = this.getScaleArray();
                return this.size_ ? this.size_[0] * t[0] : this.iconImage_.getImageState() == r.Z.LOADED ? this.iconImage_.getSize()[0] * t[0] : void 0
            }
            getHeight() {
                const t = this.getScaleArray();
                return this.size_ ? this.size_[1] * t[1] : this.iconImage_.getImageState() == r.Z.LOADED ? this.iconImage_.getSize()[1] * t[1] : void 0
            }
            setScale(t) {
                delete this.initialOptions_,
                super.setScale(t)
            }
            listenImageChange(t) {
                this.iconImage_.addEventListener(n.Z.CHANGE, t)
            }
            load() {
                this.iconImage_.load()
            }
            unlistenImageChange(t) {
                this.iconImage_.removeEventListener(n.Z.CHANGE, t)
            }
        }
        var _ = g
    },
    92710: function(t, e, i) {
        "use strict";
        i.d(e, {
            c: function() {
                return s
            }
        });
        var n = i(79706);
        class r {
            constructor() {
                this.cache_ = {},
                this.cacheSize_ = 0,
                this.maxCacheSize_ = 32
            }
            clear() {
                this.cache_ = {},
                this.cacheSize_ = 0
            }
            canExpireCache() {
                return this.cacheSize_ > this.maxCacheSize_
            }
            expire() {
                if (this.canExpireCache()) {
                    let t = 0;
                    for (const e in this.cache_) {
                        const i = this.cache_[e];
                        0 != (3 & t++) || i.hasListener() || (delete this.cache_[e],
                        --this.cacheSize_)
                    }
                }
            }
            get(t, e, i) {
                const n = o(t, e, i);
                return n in this.cache_ ? this.cache_[n] : null
            }
            set(t, e, i, n) {
                const r = o(t, e, i);
                this.cache_[r] = n,
                ++this.cacheSize_
            }
            setSize(t) {
                this.maxCacheSize_ = t,
                this.expire()
            }
        }
        function o(t, e, i) {
            return e + ":" + t + ":" + (i ? (0,
            n.XC)(i) : "null")
        }
        const s = new r
    },
    28443: function(t, e, i) {
        "use strict";
        var n = i(74187)
          , r = i(4307);
        class o {
            constructor(t) {
                this.opacity_ = t.opacity,
                this.rotateWithView_ = t.rotateWithView,
                this.rotation_ = t.rotation,
                this.scale_ = t.scale,
                this.scaleArray_ = (0,
                r.Pq)(t.scale),
                this.displacement_ = t.displacement,
                this.declutterMode_ = t.declutterMode
            }
            clone() {
                const t = this.getScale();
                return new o({
                    opacity: this.getOpacity(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                })
            }
            getOpacity() {
                return this.opacity_
            }
            getRotateWithView() {
                return this.rotateWithView_
            }
            getRotation() {
                return this.rotation_
            }
            getScale() {
                return this.scale_
            }
            getScaleArray() {
                return this.scaleArray_
            }
            getDisplacement() {
                return this.displacement_
            }
            getDeclutterMode() {
                return this.declutterMode_
            }
            getAnchor() {
                return (0,
                n.O3)()
            }
            getImage(t) {
                return (0,
                n.O3)()
            }
            getHitDetectionImage() {
                return (0,
                n.O3)()
            }
            getPixelRatio(t) {
                return 1
            }
            getImageState() {
                return (0,
                n.O3)()
            }
            getImageSize() {
                return (0,
                n.O3)()
            }
            getOrigin() {
                return (0,
                n.O3)()
            }
            getSize() {
                return (0,
                n.O3)()
            }
            setDisplacement(t) {
                this.displacement_ = t
            }
            setOpacity(t) {
                this.opacity_ = t
            }
            setRotateWithView(t) {
                this.rotateWithView_ = t
            }
            setRotation(t) {
                this.rotation_ = t
            }
            setScale(t) {
                this.scale_ = t,
                this.scaleArray_ = (0,
                r.Pq)(t)
            }
            listenImageChange(t) {
                (0,
                n.O3)()
            }
            load() {
                (0,
                n.O3)()
            }
            unlistenImageChange(t) {
                (0,
                n.O3)()
            }
        }
        e.Z = o
    },
    35393: function(t, e, i) {
        "use strict";
        var n = i(70553)
          , r = i(28443)
          , o = i(79706)
          , s = i(96620)
          , a = i(68326)
          , l = i(50147);
        class c extends r.Z {
            constructor(t) {
                super({
                    opacity: 1,
                    rotateWithView: void 0 !== t.rotateWithView && t.rotateWithView,
                    rotation: void 0 !== t.rotation ? t.rotation : 0,
                    scale: void 0 !== t.scale ? t.scale : 1,
                    displacement: void 0 !== t.displacement ? t.displacement : [0, 0],
                    declutterMode: t.declutterMode
                }),
                this.canvas_ = void 0,
                this.hitDetectionCanvas_ = null,
                this.fill_ = void 0 !== t.fill ? t.fill : null,
                this.origin_ = [0, 0],
                this.points_ = t.points,
                this.radius_ = void 0 !== t.radius ? t.radius : t.radius1,
                this.radius2_ = t.radius2,
                this.angle_ = void 0 !== t.angle ? t.angle : 0,
                this.stroke_ = void 0 !== t.stroke ? t.stroke : null,
                this.size_ = null,
                this.renderOptions_ = null,
                this.render()
            }
            clone() {
                const t = this.getScale()
                  , e = new c({
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    points: this.getPoints(),
                    radius: this.getRadius(),
                    radius2: this.getRadius2(),
                    angle: this.getAngle(),
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    displacement: this.getDisplacement().slice(),
                    declutterMode: this.getDeclutterMode()
                });
                return e.setOpacity(this.getOpacity()),
                e
            }
            getAnchor() {
                const t = this.size_;
                if (!t)
                    return null;
                const e = this.getDisplacement()
                  , i = this.getScaleArray();
                return [t[0] / 2 - e[0] / i[0], t[1] / 2 + e[1] / i[1]]
            }
            getAngle() {
                return this.angle_
            }
            getFill() {
                return this.fill_
            }
            setFill(t) {
                this.fill_ = t,
                this.render()
            }
            getHitDetectionImage() {
                return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_),
                this.hitDetectionCanvas_
            }
            getImage(t) {
                let e = this.canvas_[t];
                if (!e) {
                    const i = this.renderOptions_
                      , n = (0,
                    a.E4)(i.size * t, i.size * t);
                    this.draw_(i, n, t),
                    e = n.canvas,
                    this.canvas_[t] = e
                }
                return e
            }
            getPixelRatio(t) {
                return t
            }
            getImageSize() {
                return this.size_
            }
            getImageState() {
                return n.Z.LOADED
            }
            getOrigin() {
                return this.origin_
            }
            getPoints() {
                return this.points_
            }
            getRadius() {
                return this.radius_
            }
            getRadius2() {
                return this.radius2_
            }
            getSize() {
                return this.size_
            }
            getStroke() {
                return this.stroke_
            }
            setStroke(t) {
                this.stroke_ = t,
                this.render()
            }
            listenImageChange(t) {}
            load() {}
            unlistenImageChange(t) {}
            calculateLineJoinSize_(t, e, i) {
                if (0 === e || this.points_ === 1 / 0 || "bevel" !== t && "miter" !== t)
                    return e;
                let n = this.radius_
                  , r = void 0 === this.radius2_ ? n : this.radius2_;
                if (n < r) {
                    const t = n;
                    n = r,
                    r = t
                }
                const o = void 0 === this.radius2_ ? this.points_ : 2 * this.points_
                  , s = 2 * Math.PI / o
                  , a = r * Math.sin(s)
                  , l = n - Math.sqrt(r * r - a * a)
                  , c = Math.sqrt(a * a + l * l)
                  , h = c / a;
                if ("miter" === t && h <= i)
                    return h * e;
                const u = e / 2 / h
                  , d = e / 2 * (l / c)
                  , f = Math.sqrt((n + u) * (n + u) + d * d) - n;
                if (void 0 === this.radius2_ || "bevel" === t)
                    return 2 * f;
                const p = n * Math.sin(s)
                  , m = r - Math.sqrt(n * n - p * p)
                  , g = Math.sqrt(p * p + m * m) / p;
                if (g <= i) {
                    const t = g * e / 2 - r - n;
                    return 2 * Math.max(f, t)
                }
                return 2 * f
            }
            createRenderOptions() {
                let t, e = l.rc, i = 0, n = null, r = 0, o = 0;
                this.stroke_ && (t = this.stroke_.getColor(),
                null === t && (t = l.Tx),
                t = (0,
                s.y)(t),
                o = this.stroke_.getWidth(),
                void 0 === o && (o = l.yC),
                n = this.stroke_.getLineDash(),
                r = this.stroke_.getLineDashOffset(),
                e = this.stroke_.getLineJoin(),
                void 0 === e && (e = l.rc),
                i = this.stroke_.getMiterLimit(),
                void 0 === i && (i = l.V4));
                const a = this.calculateLineJoinSize_(e, o, i)
                  , c = Math.max(this.radius_, this.radius2_ || 0);
                return {
                    strokeStyle: t,
                    strokeWidth: o,
                    size: Math.ceil(2 * c + a),
                    lineDash: n,
                    lineDashOffset: r,
                    lineJoin: e,
                    miterLimit: i
                }
            }
            render() {
                this.renderOptions_ = this.createRenderOptions();
                const t = this.renderOptions_.size;
                this.canvas_ = {},
                this.size_ = [t, t]
            }
            draw_(t, e, i) {
                if (e.scale(i, i),
                e.translate(t.size / 2, t.size / 2),
                this.createPath_(e),
                this.fill_) {
                    let t = this.fill_.getColor();
                    null === t && (t = l.bL),
                    e.fillStyle = (0,
                    s.y)(t),
                    e.fill()
                }
                this.stroke_ && (e.strokeStyle = t.strokeStyle,
                e.lineWidth = t.strokeWidth,
                t.lineDash && (e.setLineDash(t.lineDash),
                e.lineDashOffset = t.lineDashOffset),
                e.lineJoin = t.lineJoin,
                e.miterLimit = t.miterLimit,
                e.stroke())
            }
            createHitDetectionCanvas_(t) {
                if (this.fill_) {
                    let e = this.fill_.getColor()
                      , i = 0;
                    if ("string" == typeof e && (e = (0,
                    o._2)(e)),
                    null === e ? i = 1 : Array.isArray(e) && (i = 4 === e.length ? e[3] : 1),
                    0 === i) {
                        const e = (0,
                        a.E4)(t.size, t.size);
                        this.hitDetectionCanvas_ = e.canvas,
                        this.drawHitDetectionCanvas_(t, e)
                    }
                }
                this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1))
            }
            createPath_(t) {
                let e = this.points_;
                const i = this.radius_;
                if (e === 1 / 0)
                    t.arc(0, 0, i, 0, 2 * Math.PI);
                else {
                    const n = void 0 === this.radius2_ ? i : this.radius2_;
                    void 0 !== this.radius2_ && (e *= 2);
                    const r = this.angle_ - Math.PI / 2
                      , o = 2 * Math.PI / e;
                    for (let s = 0; s < e; s++) {
                        const e = r + s * o
                          , a = s % 2 == 0 ? i : n;
                        t.lineTo(a * Math.cos(e), a * Math.sin(e))
                    }
                    t.closePath()
                }
            }
            drawHitDetectionCanvas_(t, e) {
                e.translate(t.size / 2, t.size / 2),
                this.createPath_(e),
                e.fillStyle = l.bL,
                e.fill(),
                this.stroke_ && (e.strokeStyle = t.strokeStyle,
                e.lineWidth = t.strokeWidth,
                t.lineDash && (e.setLineDash(t.lineDash),
                e.lineDashOffset = t.lineDashOffset),
                e.lineJoin = t.lineJoin,
                e.miterLimit = t.miterLimit,
                e.stroke())
            }
        }
        e.Z = c
    },
    58958: function(t, e) {
        "use strict";
        class i {
            constructor(t) {
                t = t || {},
                this.color_ = void 0 !== t.color ? t.color : null,
                this.lineCap_ = t.lineCap,
                this.lineDash_ = void 0 !== t.lineDash ? t.lineDash : null,
                this.lineDashOffset_ = t.lineDashOffset,
                this.lineJoin_ = t.lineJoin,
                this.miterLimit_ = t.miterLimit,
                this.width_ = t.width
            }
            clone() {
                const t = this.getColor();
                return new i({
                    color: Array.isArray(t) ? t.slice() : t || void 0,
                    lineCap: this.getLineCap(),
                    lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
                    lineDashOffset: this.getLineDashOffset(),
                    lineJoin: this.getLineJoin(),
                    miterLimit: this.getMiterLimit(),
                    width: this.getWidth()
                })
            }
            getColor() {
                return this.color_
            }
            getLineCap() {
                return this.lineCap_
            }
            getLineDash() {
                return this.lineDash_
            }
            getLineDashOffset() {
                return this.lineDashOffset_
            }
            getLineJoin() {
                return this.lineJoin_
            }
            getMiterLimit() {
                return this.miterLimit_
            }
            getWidth() {
                return this.width_
            }
            setColor(t) {
                this.color_ = t
            }
            setLineCap(t) {
                this.lineCap_ = t
            }
            setLineDash(t) {
                this.lineDash_ = t
            }
            setLineDashOffset(t) {
                this.lineDashOffset_ = t
            }
            setLineJoin(t) {
                this.lineJoin_ = t
            }
            setMiterLimit(t) {
                this.miterLimit_ = t
            }
            setWidth(t) {
                this.width_ = t
            }
        }
        e.Z = i
    },
    47539: function(t, e, i) {
        "use strict";
        i.d(e, {
            J$: function() {
                return l
            },
            Ly: function() {
                return u
            },
            yF: function() {
                return h
            }
        });
        var n = i(30283)
          , r = i(51345)
          , o = i(58958)
          , s = i(99515);
        class a {
            constructor(t) {
                t = t || {},
                this.geometry_ = null,
                this.geometryFunction_ = d,
                void 0 !== t.geometry && this.setGeometry(t.geometry),
                this.fill_ = void 0 !== t.fill ? t.fill : null,
                this.image_ = void 0 !== t.image ? t.image : null,
                this.renderer_ = void 0 !== t.renderer ? t.renderer : null,
                this.hitDetectionRenderer_ = void 0 !== t.hitDetectionRenderer ? t.hitDetectionRenderer : null,
                this.stroke_ = void 0 !== t.stroke ? t.stroke : null,
                this.text_ = void 0 !== t.text ? t.text : null,
                this.zIndex_ = t.zIndex
            }
            clone() {
                let t = this.getGeometry();
                return t && "object" == typeof t && (t = t.clone()),
                new a({
                    geometry: t,
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    image: this.getImage() ? this.getImage().clone() : void 0,
                    renderer: this.getRenderer(),
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    text: this.getText() ? this.getText().clone() : void 0,
                    zIndex: this.getZIndex()
                })
            }
            getRenderer() {
                return this.renderer_
            }
            setRenderer(t) {
                this.renderer_ = t
            }
            setHitDetectionRenderer(t) {
                this.hitDetectionRenderer_ = t
            }
            getHitDetectionRenderer() {
                return this.hitDetectionRenderer_
            }
            getGeometry() {
                return this.geometry_
            }
            getGeometryFunction() {
                return this.geometryFunction_
            }
            getFill() {
                return this.fill_
            }
            setFill(t) {
                this.fill_ = t
            }
            getImage() {
                return this.image_
            }
            setImage(t) {
                this.image_ = t
            }
            getStroke() {
                return this.stroke_
            }
            setStroke(t) {
                this.stroke_ = t
            }
            getText() {
                return this.text_
            }
            setText(t) {
                this.text_ = t
            }
            getZIndex() {
                return this.zIndex_
            }
            setGeometry(t) {
                "function" == typeof t ? this.geometryFunction_ = t : "string" == typeof t ? this.geometryFunction_ = function(e) {
                    return e.get(t)
                }
                : t ? void 0 !== t && (this.geometryFunction_ = function() {
                    return t
                }
                ) : this.geometryFunction_ = d,
                this.geometry_ = t
            }
            setZIndex(t) {
                this.zIndex_ = t
            }
        }
        function l(t) {
            let e;
            if ("function" == typeof t)
                e = t;
            else {
                let i;
                if (Array.isArray(t))
                    i = t;
                else {
                    (0,
                    s.h)("function" == typeof t.getZIndex, 41);
                    i = [t]
                }
                e = function() {
                    return i
                }
            }
            return e
        }
        let c = null;
        function h(t, e) {
            if (!c) {
                const t = new r.Z({
                    color: "rgba(255,255,255,0.4)"
                })
                  , e = new o.Z({
                    color: "#3399CC",
                    width: 1.25
                });
                c = [new a({
                    image: new n.Z({
                        fill: t,
                        stroke: e,
                        radius: 5
                    }),
                    fill: t,
                    stroke: e
                })]
            }
            return c
        }
        function u() {
            const t = {}
              , e = [255, 255, 255, 1]
              , i = [0, 153, 255, 1];
            return t.Polygon = [new a({
                fill: new r.Z({
                    color: [255, 255, 255, .5]
                })
            })],
            t.MultiPolygon = t.Polygon,
            t.LineString = [new a({
                stroke: new o.Z({
                    color: e,
                    width: 5
                })
            }), new a({
                stroke: new o.Z({
                    color: i,
                    width: 3
                })
            })],
            t.MultiLineString = t.LineString,
            t.Circle = t.Polygon.concat(t.LineString),
            t.Point = [new a({
                image: new n.Z({
                    radius: 6,
                    fill: new r.Z({
                        color: i
                    }),
                    stroke: new o.Z({
                        color: e,
                        width: 1.5
                    })
                }),
                zIndex: 1 / 0
            })],
            t.MultiPoint = t.Point,
            t.GeometryCollection = t.Polygon.concat(t.LineString, t.Point),
            t
        }
        function d(t) {
            return t.getGeometry()
        }
        e.ZP = a
    },
    21280: function(t, e, i) {
        "use strict";
        var n = i(51345)
          , r = i(4307);
        class o {
            constructor(t) {
                t = t || {},
                this.font_ = t.font,
                this.rotation_ = t.rotation,
                this.rotateWithView_ = t.rotateWithView,
                this.scale_ = t.scale,
                this.scaleArray_ = (0,
                r.Pq)(void 0 !== t.scale ? t.scale : 1),
                this.text_ = t.text,
                this.textAlign_ = t.textAlign,
                this.justify_ = t.justify,
                this.repeat_ = t.repeat,
                this.textBaseline_ = t.textBaseline,
                this.fill_ = void 0 !== t.fill ? t.fill : new n.Z({
                    color: "#333"
                }),
                this.maxAngle_ = void 0 !== t.maxAngle ? t.maxAngle : Math.PI / 4,
                this.placement_ = void 0 !== t.placement ? t.placement : "point",
                this.overflow_ = !!t.overflow,
                this.stroke_ = void 0 !== t.stroke ? t.stroke : null,
                this.offsetX_ = void 0 !== t.offsetX ? t.offsetX : 0,
                this.offsetY_ = void 0 !== t.offsetY ? t.offsetY : 0,
                this.backgroundFill_ = t.backgroundFill ? t.backgroundFill : null,
                this.backgroundStroke_ = t.backgroundStroke ? t.backgroundStroke : null,
                this.padding_ = void 0 === t.padding ? null : t.padding
            }
            clone() {
                const t = this.getScale();
                return new o({
                    font: this.getFont(),
                    placement: this.getPlacement(),
                    repeat: this.getRepeat(),
                    maxAngle: this.getMaxAngle(),
                    overflow: this.getOverflow(),
                    rotation: this.getRotation(),
                    rotateWithView: this.getRotateWithView(),
                    scale: Array.isArray(t) ? t.slice() : t,
                    text: this.getText(),
                    textAlign: this.getTextAlign(),
                    justify: this.getJustify(),
                    textBaseline: this.getTextBaseline(),
                    fill: this.getFill() ? this.getFill().clone() : void 0,
                    stroke: this.getStroke() ? this.getStroke().clone() : void 0,
                    offsetX: this.getOffsetX(),
                    offsetY: this.getOffsetY(),
                    backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
                    backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
                    padding: this.getPadding() || void 0
                })
            }
            getOverflow() {
                return this.overflow_
            }
            getFont() {
                return this.font_
            }
            getMaxAngle() {
                return this.maxAngle_
            }
            getPlacement() {
                return this.placement_
            }
            getRepeat() {
                return this.repeat_
            }
            getOffsetX() {
                return this.offsetX_
            }
            getOffsetY() {
                return this.offsetY_
            }
            getFill() {
                return this.fill_
            }
            getRotateWithView() {
                return this.rotateWithView_
            }
            getRotation() {
                return this.rotation_
            }
            getScale() {
                return this.scale_
            }
            getScaleArray() {
                return this.scaleArray_
            }
            getStroke() {
                return this.stroke_
            }
            getText() {
                return this.text_
            }
            getTextAlign() {
                return this.textAlign_
            }
            getJustify() {
                return this.justify_
            }
            getTextBaseline() {
                return this.textBaseline_
            }
            getBackgroundFill() {
                return this.backgroundFill_
            }
            getBackgroundStroke() {
                return this.backgroundStroke_
            }
            getPadding() {
                return this.padding_
            }
            setOverflow(t) {
                this.overflow_ = t
            }
            setFont(t) {
                this.font_ = t
            }
            setMaxAngle(t) {
                this.maxAngle_ = t
            }
            setOffsetX(t) {
                this.offsetX_ = t
            }
            setOffsetY(t) {
                this.offsetY_ = t
            }
            setPlacement(t) {
                this.placement_ = t
            }
            setRepeat(t) {
                this.repeat_ = t
            }
            setRotateWithView(t) {
                this.rotateWithView_ = t
            }
            setFill(t) {
                this.fill_ = t
            }
            setRotation(t) {
                this.rotation_ = t
            }
            setScale(t) {
                this.scale_ = t,
                this.scaleArray_ = (0,
                r.Pq)(void 0 !== t ? t : 1)
            }
            setStroke(t) {
                this.stroke_ = t
            }
            setText(t) {
                this.text_ = t
            }
            setTextAlign(t) {
                this.textAlign_ = t
            }
            setJustify(t) {
                this.justify_ = t
            }
            setTextBaseline(t) {
                this.textBaseline_ = t
            }
            setBackgroundFill(t) {
                this.backgroundFill_ = t
            }
            setBackgroundStroke(t) {
                this.backgroundStroke_ = t
            }
            setPadding(t) {
                this.padding_ = t
            }
        }
        e.Z = o
    },
    6101: function(t, e, i) {
        "use strict";
        i.d(e, {
            BB: function() {
                return v
            },
            Iu: function() {
                return m
            },
            Jp: function() {
                return l
            },
            U1: function() {
                return d
            },
            Ue: function() {
                return s
            },
            bA: function() {
                return f
            },
            lk: function() {
                return h
            },
            mc: function() {
                return a
            },
            n3: function() {
                return p
            },
            nb: function() {
                return _
            },
            nn: function() {
                return u
            },
            qC: function() {
                return g
            }
        });
        var n = i(40177)
          , r = i(99515);
        const o = new Array(6);
        function s() {
            return [1, 0, 0, 1, 0, 0]
        }
        function a(t) {
            return c(t, 1, 0, 0, 1, 0, 0)
        }
        function l(t, e) {
            const i = t[0]
              , n = t[1]
              , r = t[2]
              , o = t[3]
              , s = t[4]
              , a = t[5]
              , l = e[0]
              , c = e[1]
              , h = e[2]
              , u = e[3]
              , d = e[4]
              , f = e[5];
            return t[0] = i * l + r * c,
            t[1] = n * l + o * c,
            t[2] = i * h + r * u,
            t[3] = n * h + o * u,
            t[4] = i * d + r * f + s,
            t[5] = n * d + o * f + a,
            t
        }
        function c(t, e, i, n, r, o, s) {
            return t[0] = e,
            t[1] = i,
            t[2] = n,
            t[3] = r,
            t[4] = o,
            t[5] = s,
            t
        }
        function h(t, e) {
            return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t
        }
        function u(t, e) {
            const i = e[0]
              , n = e[1];
            return e[0] = t[0] * i + t[2] * n + t[4],
            e[1] = t[1] * i + t[3] * n + t[5],
            e
        }
        function d(t, e) {
            const i = Math.cos(e)
              , n = Math.sin(e);
            return l(t, c(o, i, n, -n, i, 0, 0))
        }
        function f(t, e, i) {
            return l(t, c(o, e, 0, 0, i, 0, 0))
        }
        function p(t, e, i) {
            return c(t, e, 0, 0, i, 0, 0)
        }
        function m(t, e, i) {
            return l(t, c(o, 1, 0, 0, 1, e, i))
        }
        function g(t, e, i, n, r, o, s, a) {
            const l = Math.sin(o)
              , c = Math.cos(o);
            return t[0] = n * c,
            t[1] = r * l,
            t[2] = -n * l,
            t[3] = r * c,
            t[4] = s * n * c - a * n * l + e,
            t[5] = s * r * l + a * r * c + i,
            t
        }
        function _(t, e) {
            const i = (n = e)[0] * n[3] - n[1] * n[2];
            var n;
            (0,
            r.h)(0 !== i, 32);
            const o = e[0]
              , s = e[1]
              , a = e[2]
              , l = e[3]
              , c = e[4]
              , h = e[5];
            return t[0] = l / i,
            t[1] = -s / i,
            t[2] = -a / i,
            t[3] = o / i,
            t[4] = (a * h - l * c) / i,
            t[5] = -(o * h - s * c) / i,
            t
        }
        let y;
        function v(t) {
            const e = "matrix(" + t.join(", ") + ")";
            if (n.Id)
                return e;
            const i = y || (y = document.createElement("div"));
            return i.style.transform = e,
            i.style.transform
        }
    },
    74187: function(t, e, i) {
        "use strict";
        function n() {
            throw new Error("Unimplemented abstract method.")
        }
        i.d(e, {
            O3: function() {
                return n
            },
            sq: function() {
                return o
            }
        });
        let r = 0;
        function o(t) {
            return t.ol_uid || (t.ol_uid = String(++r))
        }
    },
    26089: function(t, e, i) {
        "use strict";
        i.d(e, {
            WB: function() {
                return H
            },
            Q_: function() {
                return nt
            },
            Jk: function() {
                return rt
            }
        });
        var n = i(2262)
          , r = i(66252)
          , o = !1;
        function s(t, e, i) {
            return Array.isArray(t) ? (t.length = Math.max(t.length, e),
            t.splice(e, 1, i),
            i) : (t[e] = i,
            i)
        }
        var a = i(45689)
          , l = i(25108);
        let c;
        const h = t => c = t
          , u = Symbol();
        function d(t) {
            return t && "object" == typeof t && "[object Object]" === Object.prototype.toString.call(t) && "function" != typeof t.toJSON
        }
        var f;
        !function(t) {
            t.direct = "direct",
            t.patchObject = "patch object",
            t.patchFunction = "patch function"
        }(f || (f = {}));
        const p = "undefined" != typeof window
          , m = !1
          , g = ( () => "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : "object" == typeof globalThis ? globalThis : {
            HTMLElement: null
        })();
        function _(t, e, i) {
            const n = new XMLHttpRequest;
            n.open("GET", t),
            n.responseType = "blob",
            n.onload = function() {
                w(n.response, e, i)
            }
            ,
            n.onerror = function() {
                l.error("could not download file")
            }
            ,
            n.send()
        }
        function y(t) {
            const e = new XMLHttpRequest;
            e.open("HEAD", t, !1);
            try {
                e.send()
            } catch (t) {}
            return e.status >= 200 && e.status <= 299
        }
        function v(t) {
            try {
                t.dispatchEvent(new MouseEvent("click"))
            } catch (e) {
                const i = document.createEvent("MouseEvents");
                i.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null),
                t.dispatchEvent(i)
            }
        }
        const x = "object" == typeof navigator ? navigator : {
            userAgent: ""
        }
          , b = ( () => /Macintosh/.test(x.userAgent) && /AppleWebKit/.test(x.userAgent) && !/Safari/.test(x.userAgent))()
          , w = p ? "undefined" != typeof HTMLAnchorElement && "download"in HTMLAnchorElement.prototype && !b ? function(t, e="download", i) {
            const n = document.createElement("a");
            n.download = e,
            n.rel = "noopener",
            "string" == typeof t ? (n.href = t,
            n.origin !== location.origin ? y(n.href) ? _(t, e, i) : (n.target = "_blank",
            v(n)) : v(n)) : (n.href = URL.createObjectURL(t),
            setTimeout((function() {
                URL.revokeObjectURL(n.href)
            }
            ), 4e4),
            setTimeout((function() {
                v(n)
            }
            ), 0))
        }
        : "msSaveOrOpenBlob"in x ? function(t, e="download", i) {
            if ("string" == typeof t)
                if (y(t))
                    _(t, e, i);
                else {
                    const e = document.createElement("a");
                    e.href = t,
                    e.target = "_blank",
                    setTimeout((function() {
                        v(e)
                    }
                    ))
                }
            else
                navigator.msSaveOrOpenBlob(function(t, {autoBom: e=!1}={}) {
                    return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t],{
                        type: t.type
                    }) : t
                }(t, i), e)
        }
        : function(t, e, i, n) {
            (n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading...");
            if ("string" == typeof t)
                return _(t, e, i);
            const r = "application/octet-stream" === t.type
              , o = /constructor/i.test(String(g.HTMLElement)) || "safari"in g
              , s = /CriOS\/[\d]+/.test(navigator.userAgent);
            if ((s || r && o || b) && "undefined" != typeof FileReader) {
                const e = new FileReader;
                e.onloadend = function() {
                    let t = e.result;
                    if ("string" != typeof t)
                        throw n = null,
                        new Error("Wrong reader.result type");
                    t = s ? t : t.replace(/^data:[^;]*;/, "data:attachment/file;"),
                    n ? n.location.href = t : location.assign(t),
                    n = null
                }
                ,
                e.readAsDataURL(t)
            } else {
                const e = URL.createObjectURL(t);
                n ? n.location.assign(e) : location.href = e,
                n = null,
                setTimeout((function() {
                    URL.revokeObjectURL(e)
                }
                ), 4e4)
            }
        }
        : () => {}
        ;
        function E(t, e) {
            const i = " " + t;
            "function" == typeof __VUE_DEVTOOLS_TOAST__ ? __VUE_DEVTOOLS_TOAST__(i, e) : "error" === e ? l.error(i) : "warn" === e && l.warn(i)
        }
        function T(t) {
            return "_a"in t && "install"in t
        }
        function S() {
            if (!("clipboard"in navigator))
                return E("Your browser doesn't support the Clipboard API", "error"),
                !0
        }
        function C(t) {
            return !!(t instanceof Error && t.message.toLowerCase().includes("document is not focused")) && (E('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"),
            !0)
        }
        let A;
        async function I(t) {
            try {
                const e = (A || (A = document.createElement("input"),
                A.type = "file",
                A.accept = ".json"),
                function() {
                    return new Promise(( (t, e) => {
                        A.onchange = async () => {
                            const e = A.files;
                            if (!e)
                                return t(null);
                            const i = e.item(0);
                            return t(i ? {
                                text: await i.text(),
                                file: i
                            } : null)
                        }
                        ,
                        A.oncancel = () => t(null),
                        A.onerror = e,
                        A.click()
                    }
                    ))
                }
                )
                  , i = await e();
                if (!i)
                    return;
                const {text: n, file: r} = i;
                M(t, JSON.parse(n)),
                E(`Global state imported from "${r.name}".`)
            } catch (t) {
                E("Failed to import the state from JSON. Check the console for more details.", "error"),
                l.error(t)
            }
        }
        function M(t, e) {
            for (const i in e) {
                const n = t.state.value[i];
                n && Object.assign(n, e[i])
            }
        }
        function P(t) {
            return {
                _custom: {
                    display: t
                }
            }
        }
        const k = " Pinia (root)"
          , O = "_root";
        function R(t) {
            return T(t) ? {
                id: O,
                label: k
            } : {
                id: t.$id,
                label: t.$id
            }
        }
        function D(t) {
            return t ? Array.isArray(t) ? t.reduce(( (t, e) => (t.keys.push(e.key),
            t.operations.push(e.type),
            t.oldValue[e.key] = e.oldValue,
            t.newValue[e.key] = e.newValue,
            t)), {
                oldValue: {},
                keys: [],
                operations: [],
                newValue: {}
            }) : {
                operation: P(t.type),
                key: P(t.key),
                oldValue: t.oldValue,
                newValue: t.newValue
            } : {}
        }
        function L(t) {
            switch (t) {
            case f.direct:
                return "mutation";
            case f.patchFunction:
            case f.patchObject:
                return "$patch";
            default:
                return "unknown"
            }
        }
        let B = !0;
        const z = []
          , F = "pinia:mutations"
          , N = "pinia"
          , {assign: j} = Object
          , U = t => " " + t;
        function V(t, e) {
            (0,
            a.F1)({
                id: "dev.esm.pinia",
                label: "Pinia ",
                logo: "https://pinia.vuejs.org/logo.svg",
                packageName: "pinia",
                homepage: "https://pinia.vuejs.org",
                componentStateTypes: z,
                app: t
            }, (i => {
                "function" != typeof i.now && E("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."),
                i.addTimelineLayer({
                    id: F,
                    label: "Pinia ",
                    color: 15064968
                }),
                i.addInspector({
                    id: N,
                    label: "Pinia ",
                    icon: "storage",
                    treeFilterPlaceholder: "Search stores",
                    actions: [{
                        icon: "content_copy",
                        action: () => {
                            !async function(t) {
                                if (!S())
                                    try {
                                        await navigator.clipboard.writeText(JSON.stringify(t.state.value)),
                                        E("Global state copied to clipboard.")
                                    } catch (t) {
                                        if (C(t))
                                            return;
                                        E("Failed to serialize the state. Check the console for more details.", "error"),
                                        l.error(t)
                                    }
                            }(e)
                        }
                        ,
                        tooltip: "Serialize and copy the state"
                    }, {
                        icon: "content_paste",
                        action: async () => {
                            await async function(t) {
                                if (!S())
                                    try {
                                        M(t, JSON.parse(await navigator.clipboard.readText())),
                                        E("Global state pasted from clipboard.")
                                    } catch (t) {
                                        if (C(t))
                                            return;
                                        E("Failed to deserialize the state from clipboard. Check the console for more details.", "error"),
                                        l.error(t)
                                    }
                            }(e),
                            i.sendInspectorTree(N),
                            i.sendInspectorState(N)
                        }
                        ,
                        tooltip: "Replace the state with the content of your clipboard"
                    }, {
                        icon: "save",
                        action: () => {
                            !async function(t) {
                                try {
                                    w(new Blob([JSON.stringify(t.state.value)],{
                                        type: "text/plain;charset=utf-8"
                                    }), "pinia-state.json")
                                } catch (t) {
                                    E("Failed to export the state as JSON. Check the console for more details.", "error"),
                                    l.error(t)
                                }
                            }(e)
                        }
                        ,
                        tooltip: "Save the state as a JSON file"
                    }, {
                        icon: "folder_open",
                        action: async () => {
                            await I(e),
                            i.sendInspectorTree(N),
                            i.sendInspectorState(N)
                        }
                        ,
                        tooltip: "Import the state from a JSON file"
                    }],
                    nodeActions: [{
                        icon: "restore",
                        tooltip: 'Reset the state (with "$reset")',
                        action: t => {
                            const i = e._s.get(t);
                            i ? "function" != typeof i.$reset ? E(`Cannot reset "${t}" store because it doesn't have a "$reset" method implemented.`, "warn") : (i.$reset(),
                            E(`Store "${t}" reset.`)) : E(`Cannot reset "${t}" store because it wasn't found.`, "warn")
                        }
                    }]
                }),
                i.on.inspectComponent(( (t, e) => {
                    const i = t.componentInstance && t.componentInstance.proxy;
                    if (i && i._pStores) {
                        const e = t.componentInstance.proxy._pStores;
                        Object.values(e).forEach((e => {
                            t.instanceData.state.push({
                                type: U(e.$id),
                                key: "state",
                                editable: !0,
                                value: e._isOptionsAPI ? {
                                    _custom: {
                                        value: (0,
                                        n.IU)(e.$state),
                                        actions: [{
                                            icon: "restore",
                                            tooltip: "Reset the state of this store",
                                            action: () => e.$reset()
                                        }]
                                    }
                                } : Object.keys(e.$state).reduce(( (t, i) => (t[i] = e.$state[i],
                                t)), {})
                            }),
                            e._getters && e._getters.length && t.instanceData.state.push({
                                type: U(e.$id),
                                key: "getters",
                                editable: !1,
                                value: e._getters.reduce(( (t, i) => {
                                    try {
                                        t[i] = e[i]
                                    } catch (e) {
                                        t[i] = e
                                    }
                                    return t
                                }
                                ), {})
                            })
                        }
                        ))
                    }
                }
                )),
                i.on.getInspectorTree((i => {
                    if (i.app === t && i.inspectorId === N) {
                        let t = [e];
                        t = t.concat(Array.from(e._s.values())),
                        i.rootNodes = (i.filter ? t.filter((t => "$id"in t ? t.$id.toLowerCase().includes(i.filter.toLowerCase()) : k.toLowerCase().includes(i.filter.toLowerCase()))) : t).map(R)
                    }
                }
                )),
                i.on.getInspectorState((i => {
                    if (i.app === t && i.inspectorId === N) {
                        const t = i.nodeId === O ? e : e._s.get(i.nodeId);
                        if (!t)
                            return;
                        t && (i.state = function(t) {
                            if (T(t)) {
                                const e = Array.from(t._s.keys())
                                  , i = t._s
                                  , n = {
                                    state: e.map((e => ({
                                        editable: !0,
                                        key: e,
                                        value: t.state.value[e]
                                    }))),
                                    getters: e.filter((t => i.get(t)._getters)).map((t => {
                                        const e = i.get(t);
                                        return {
                                            editable: !1,
                                            key: t,
                                            value: e._getters.reduce(( (t, i) => (t[i] = e[i],
                                            t)), {})
                                        }
                                    }
                                    ))
                                };
                                return n
                            }
                            const e = {
                                state: Object.keys(t.$state).map((e => ({
                                    editable: !0,
                                    key: e,
                                    value: t.$state[e]
                                })))
                            };
                            return t._getters && t._getters.length && (e.getters = t._getters.map((e => ({
                                editable: !1,
                                key: e,
                                value: t[e]
                            })))),
                            t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map((e => ({
                                editable: !0,
                                key: e,
                                value: t[e]
                            })))),
                            e
                        }(t))
                    }
                }
                )),
                i.on.editInspectorState(( (i, n) => {
                    if (i.app === t && i.inspectorId === N) {
                        const t = i.nodeId === O ? e : e._s.get(i.nodeId);
                        if (!t)
                            return E(`store "${i.nodeId}" not found`, "error");
                        const {path: n} = i;
                        T(t) ? n.unshift("state") : 1 === n.length && t._customProperties.has(n[0]) && !(n[0]in t.$state) || n.unshift("$state"),
                        B = !1,
                        i.set(t, n, i.state.value),
                        B = !0
                    }
                }
                )),
                i.on.editComponentState((t => {
                    if (t.type.startsWith("")) {
                        const i = t.type.replace(/^\s*/, "")
                          , n = e._s.get(i);
                        if (!n)
                            return E(`store "${i}" not found`, "error");
                        const {path: r} = t;
                        if ("state" !== r[0])
                            return E(`Invalid path for store "${i}":\n${r}\nOnly state can be modified.`);
                        r[0] = "$state",
                        B = !1,
                        t.set(n, r, t.state.value),
                        B = !0
                    }
                }
                ))
            }
            ))
        }
        let G, Z = 0;
        function q(t, e, i) {
            const r = e.reduce(( (e, i) => (e[i] = (0,
            n.IU)(t)[i],
            e)), {});
            for (const e in r)
                t[e] = function() {
                    const n = Z
                      , o = i ? new Proxy(t,{
                        get(...t) {
                            return G = n,
                            Reflect.get(...t)
                        },
                        set(...t) {
                            return G = n,
                            Reflect.set(...t)
                        }
                    }) : t;
                    G = n;
                    const s = r[e].apply(o, arguments);
                    return G = void 0,
                    s
                }
        }
        function W({app: t, store: e, options: i}) {
            if (e.$id.startsWith("__hot:"))
                return;
            e._isOptionsAPI = !!i.state,
            q(e, Object.keys(i.actions), e._isOptionsAPI);
            const o = e._hotUpdate;
            (0,
            n.IU)(e)._hotUpdate = function(t) {
                o.apply(this, arguments),
                q(e, Object.keys(t._hmrPayload.actions), !!e._isOptionsAPI)
            }
            ,
            function(t, e) {
                z.includes(U(e.$id)) || z.push(U(e.$id)),
                (0,
                a.F1)({
                    id: "dev.esm.pinia",
                    label: "Pinia ",
                    logo: "https://pinia.vuejs.org/logo.svg",
                    packageName: "pinia",
                    homepage: "https://pinia.vuejs.org",
                    componentStateTypes: z,
                    app: t,
                    settings: {
                        logStoreChanges: {
                            label: "Notify about new/deleted stores",
                            type: "boolean",
                            defaultValue: !0
                        }
                    }
                }, (t => {
                    const i = "function" == typeof t.now ? t.now.bind(t) : Date.now;
                    e.$onAction(( ({after: n, onError: r, name: o, args: s}) => {
                        const a = Z++;
                        t.addTimelineEvent({
                            layerId: F,
                            event: {
                                time: i(),
                                title: " " + o,
                                subtitle: "start",
                                data: {
                                    store: P(e.$id),
                                    action: P(o),
                                    args: s
                                },
                                groupId: a
                            }
                        }),
                        n((n => {
                            G = void 0,
                            t.addTimelineEvent({
                                layerId: F,
                                event: {
                                    time: i(),
                                    title: " " + o,
                                    subtitle: "end",
                                    data: {
                                        store: P(e.$id),
                                        action: P(o),
                                        args: s,
                                        result: n
                                    },
                                    groupId: a
                                }
                            })
                        }
                        )),
                        r((n => {
                            G = void 0,
                            t.addTimelineEvent({
                                layerId: F,
                                event: {
                                    time: i(),
                                    logType: "error",
                                    title: " " + o,
                                    subtitle: "end",
                                    data: {
                                        store: P(e.$id),
                                        action: P(o),
                                        args: s,
                                        error: n
                                    },
                                    groupId: a
                                }
                            })
                        }
                        ))
                    }
                    ), !0),
                    e._customProperties.forEach((o => {
                        (0,
                        r.YP)(( () => (0,
                        n.SU)(e[o])), ( (e, n) => {
                            t.notifyComponentUpdate(),
                            t.sendInspectorState(N),
                            B && t.addTimelineEvent({
                                layerId: F,
                                event: {
                                    time: i(),
                                    title: "Change",
                                    subtitle: o,
                                    data: {
                                        newValue: e,
                                        oldValue: n
                                    },
                                    groupId: G
                                }
                            })
                        }
                        ), {
                            deep: !0
                        })
                    }
                    )),
                    e.$subscribe(( ({events: n, type: r}, o) => {
                        if (t.notifyComponentUpdate(),
                        t.sendInspectorState(N),
                        !B)
                            return;
                        const s = {
                            time: i(),
                            title: L(r),
                            data: j({
                                store: P(e.$id)
                            }, D(n)),
                            groupId: G
                        };
                        r === f.patchFunction ? s.subtitle = "" : r === f.patchObject ? s.subtitle = "" : n && !Array.isArray(n) && (s.subtitle = n.type),
                        n && (s.data["rawEvent(s)"] = {
                            _custom: {
                                display: "DebuggerEvent",
                                type: "object",
                                tooltip: "raw DebuggerEvent[]",
                                value: n
                            }
                        }),
                        t.addTimelineEvent({
                            layerId: F,
                            event: s
                        })
                    }
                    ), {
                        detached: !0,
                        flush: "sync"
                    });
                    const o = e._hotUpdate;
                    e._hotUpdate = (0,
                    n.Xl)((n => {
                        o(n),
                        t.addTimelineEvent({
                            layerId: F,
                            event: {
                                time: i(),
                                title: " " + e.$id,
                                subtitle: "HMR update",
                                data: {
                                    store: P(e.$id),
                                    info: P("HMR update")
                                }
                            }
                        }),
                        t.notifyComponentUpdate(),
                        t.sendInspectorTree(N),
                        t.sendInspectorState(N)
                    }
                    ));
                    const {$dispose: s} = e;
                    e.$dispose = () => {
                        s(),
                        t.notifyComponentUpdate(),
                        t.sendInspectorTree(N),
                        t.sendInspectorState(N),
                        t.getSettings().logStoreChanges && E(`Disposed "${e.$id}" store `)
                    }
                    ,
                    t.notifyComponentUpdate(),
                    t.sendInspectorTree(N),
                    t.sendInspectorState(N),
                    t.getSettings().logStoreChanges && E(`"${e.$id}" store installed `)
                }
                ))
            }(t, e)
        }
        function H() {
            const t = (0,
            n.B)(!0)
              , e = t.run(( () => (0,
            n.iH)({})));
            let i = []
              , r = [];
            const s = (0,
            n.Xl)({
                install(t) {
                    h(s),
                    o || (s._a = t,
                    t.provide(u, s),
                    t.config.globalProperties.$pinia = s,
                    m && V(t, s),
                    r.forEach((t => i.push(t))),
                    r = [])
                },
                use(t) {
                    return this._a || o ? i.push(t) : r.push(t),
                    this
                },
                _p: i,
                _a: null,
                _e: t,
                _s: new Map,
                state: e
            });
            return m && "undefined" != typeof Proxy && s.use(W),
            s
        }
        const $ = () => {}
        ;
        function X(t, e, i, r=$) {
            t.push(e);
            const o = () => {
                const i = t.indexOf(e);
                i > -1 && (t.splice(i, 1),
                r())
            }
            ;
            return !i && (0,
            n.nZ)() && (0,
            n.EB)(o),
            o
        }
        function Y(t, ...e) {
            t.slice().forEach((t => {
                t(...e)
            }
            ))
        }
        const K = t => t();
        function J(t, e) {
            t instanceof Map && e instanceof Map && e.forEach(( (e, i) => t.set(i, e))),
            t instanceof Set && e instanceof Set && e.forEach(t.add, t);
            for (const i in e) {
                if (!e.hasOwnProperty(i))
                    continue;
                const r = e[i]
                  , o = t[i];
                d(o) && d(r) && t.hasOwnProperty(i) && !(0,
                n.dq)(r) && !(0,
                n.PG)(r) ? t[i] = J(o, r) : t[i] = r
            }
            return t
        }
        const Q = Symbol()
          , tt = new WeakMap;
        const {assign: et} = Object;
        function it(t, e, i={}, a, l, c) {
            let u;
            const p = et({
                actions: {}
            }, i);
            const g = {
                deep: !0
            };
            let _, y;
            let v, x = [], b = [];
            const w = a.state.value[t];
            c || w || (o ? s(a.state.value, t, {}) : a.state.value[t] = {});
            const E = (0,
            n.iH)({});
            let T;
            function S(e) {
                let i;
                _ = y = !1,
                "function" == typeof e ? (e(a.state.value[t]),
                i = {
                    type: f.patchFunction,
                    storeId: t,
                    events: v
                }) : (J(a.state.value[t], e),
                i = {
                    type: f.patchObject,
                    payload: e,
                    storeId: t,
                    events: v
                });
                const n = T = Symbol();
                (0,
                r.Y3)().then(( () => {
                    T === n && (_ = !0)
                }
                )),
                y = !0,
                Y(x, i, a.state.value[t])
            }
            const C = c ? function() {
                const {state: t} = i
                  , e = t ? t() : {};
                this.$patch((t => {
                    et(t, e)
                }
                ))
            }
            : $;
            function A(e, i) {
                return function() {
                    h(a);
                    const n = Array.from(arguments)
                      , r = []
                      , o = [];
                    let s;
                    Y(b, {
                        args: n,
                        name: e,
                        store: P,
                        after: function(t) {
                            r.push(t)
                        },
                        onError: function(t) {
                            o.push(t)
                        }
                    });
                    try {
                        s = i.apply(this && this.$id === t ? this : P, n)
                    } catch (t) {
                        throw Y(o, t),
                        t
                    }
                    return s instanceof Promise ? s.then((t => (Y(r, t),
                    t))).catch((t => (Y(o, t),
                    Promise.reject(t)))) : (Y(r, s),
                    s)
                }
            }
            const I = (0,
            n.Xl)({
                actions: {},
                getters: {},
                state: [],
                hotState: E
            })
              , M = {
                _p: a,
                $id: t,
                $onAction: X.bind(null, b),
                $patch: S,
                $reset: C,
                $subscribe(e, i={}) {
                    const n = X(x, e, i.detached, ( () => o()))
                      , o = u.run(( () => (0,
                    r.YP)(( () => a.state.value[t]), (n => {
                        ("sync" === i.flush ? y : _) && e({
                            storeId: t,
                            type: f.direct,
                            events: v
                        }, n)
                    }
                    ), et({}, g, i))));
                    return n
                },
                $dispose: function() {
                    u.stop(),
                    x = [],
                    b = [],
                    a._s.delete(t)
                }
            };
            o && (M._r = !1);
            const P = (0,
            n.qj)(m ? et({
                _hmrPayload: I,
                _customProperties: (0,
                n.Xl)(new Set)
            }, M) : M);
            a._s.set(t, P);
            const k = a._a && a._a.runWithContext || K
              , O = a._e.run(( () => (u = (0,
            n.B)(),
            k(( () => u.run(e))))));
            for (const e in O) {
                const i = O[e];
                if ((0,
                n.dq)(i) && (D = i,
                !(0,
                n.dq)(D) || !D.effect) || (0,
                n.PG)(i))
                    c || (!w || (R = i,
                    o ? tt.has(R) : d(R) && R.hasOwnProperty(Q)) || ((0,
                    n.dq)(i) ? i.value = w[e] : J(i, w[e])),
                    o ? s(a.state.value[t], e, i) : a.state.value[t][e] = i);
                else if ("function" == typeof i) {
                    const t = A(e, i);
                    o ? s(O, e, t) : O[e] = t,
                    p.actions[e] = i
                } else
                    0
            }
            var R, D;
            if (o ? Object.keys(O).forEach((t => {
                s(P, t, O[t])
            }
            )) : (et(P, O),
            et((0,
            n.IU)(P), O)),
            Object.defineProperty(P, "$state", {
                get: () => a.state.value[t],
                set: t => {
                    S((e => {
                        et(e, t)
                    }
                    ))
                }
            }),
            m) {
                const t = {
                    writable: !0,
                    configurable: !0,
                    enumerable: !1
                };
                ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach((e => {
                    Object.defineProperty(P, e, et({
                        value: P[e]
                    }, t))
                }
                ))
            }
            return o && (P._r = !0),
            a._p.forEach((t => {
                if (m) {
                    const e = u.run(( () => t({
                        store: P,
                        app: a._a,
                        pinia: a,
                        options: p
                    })));
                    Object.keys(e || {}).forEach((t => P._customProperties.add(t))),
                    et(P, e)
                } else
                    et(P, u.run(( () => t({
                        store: P,
                        app: a._a,
                        pinia: a,
                        options: p
                    }))))
            }
            )),
            w && c && i.hydrate && i.hydrate(P.$state, w),
            _ = !0,
            y = !0,
            P
        }
        function nt(t, e, i) {
            let a, l;
            const d = "function" == typeof e;
            function f(t, i) {
                const f = (0,
                r.EM)();
                (t = t || (f ? (0,
                r.f3)(u, null) : null)) && h(t),
                (t = c)._s.has(a) || (d ? it(a, e, l, t) : function(t, e, i, a) {
                    const {state: l, actions: c, getters: u} = e
                      , d = i.state.value[t];
                    let f;
                    f = it(t, (function() {
                        d || (o ? s(i.state.value, t, l ? l() : {}) : i.state.value[t] = l ? l() : {});
                        const e = (0,
                        n.BK)(i.state.value[t]);
                        return et(e, c, Object.keys(u || {}).reduce(( (e, s) => (e[s] = (0,
                        n.Xl)((0,
                        r.Fl)(( () => {
                            h(i);
                            const e = i._s.get(t);
                            if (!o || e._r)
                                return u[s].call(e, e)
                        }
                        ))),
                        e)), {}))
                    }
                    ), e, i, 0, !0)
                }(a, l, t));
                return t._s.get(a)
            }
            return "string" == typeof t ? (a = t,
            l = d ? i : e) : (l = t,
            a = t.id),
            f.$id = a,
            f
        }
        function rt(t) {
            if (o)
                return (0,
                n.BK)(t);
            {
                t = (0,
                n.IU)(t);
                const e = {};
                for (const i in t) {
                    const r = t[i];
                    ((0,
                    n.dq)(r) || (0,
                    n.PG)(r)) && (e[i] = (0,
                    n.Vh)(t, i))
                }
                return e
            }
        }
    },
    49227: function(t, e, i) {
        "use strict";
        function n(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, n = Array(e); i < e; i++)
                n[i] = t[i];
            return n
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    60778: function(t, e, i) {
        "use strict";
        function n(t) {
            if (Array.isArray(t))
                return t
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    48534: function(t, e, i) {
        "use strict";
        function n(t, e, i, n, r, o, s) {
            try {
                var a = t[o](s)
                  , l = a.value
            } catch (t) {
                return void i(t)
            }
            a.done ? e(l) : Promise.resolve(l).then(n, r)
        }
        function r(t) {
            return function() {
                var e = this
                  , i = arguments;
                return new Promise((function(r, o) {
                    var s = t.apply(e, i);
                    function a(t) {
                        n(s, r, o, a, l, "next", t)
                    }
                    function l(t) {
                        n(s, r, o, a, l, "throw", t)
                    }
                    a(void 0)
                }
                ))
            }
        }
        i.d(e, {
            Z: function() {
                return r
            }
        })
    },
    13087: function(t, e, i) {
        "use strict";
        function n(t, e) {
            if (!(t instanceof e))
                throw new TypeError("Cannot call a class as a function")
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    38829: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(55702);
        function r(t, e) {
            return function(t, e) {
                return e.get ? e.get.call(t) : e.value
            }(t, (0,
            n.Z)(e, t))
        }
    },
    55702: function(t, e, i) {
        "use strict";
        function n(t, e) {
            return t.get(function(t, e, i) {
                if ("function" == typeof t ? t === e : t.has(e))
                    return arguments.length < 3 ? e : i;
                throw new TypeError("Private element is not present on this object")
            }(t, e))
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    60878: function(t, e, i) {
        "use strict";
        function n(t, e, i) {
            (function(t, e) {
                if (e.has(t))
                    throw new TypeError("Cannot initialize the same private elements twice on an object")
            }
            )(t, e),
            e.set(t, i)
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    42575: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(55702);
        function r(t, e, i) {
            return function(t, e, i) {
                if (e.set)
                    e.set.call(t, i);
                else {
                    if (!e.writable)
                        throw new TypeError("attempted to set read only private field");
                    e.value = i
                }
            }(t, (0,
            n.Z)(e, t), i),
            i
        }
    },
    72968: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return o
            }
        });
        var n = i(68521);
        function r(t, e) {
            for (var i = 0; i < e.length; i++) {
                var r = e[i];
                r.enumerable = r.enumerable || !1,
                r.configurable = !0,
                "value"in r && (r.writable = !0),
                Object.defineProperty(t, (0,
                n.Z)(r.key), r)
            }
        }
        function o(t, e, i) {
            return e && r(t.prototype, e),
            i && r(t, i),
            Object.defineProperty(t, "prototype", {
                writable: !1
            }),
            t
        }
    },
    66347: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(12780);
        function r(t, e) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (!i) {
                if (Array.isArray(t) || (i = (0,
                n.Z)(t)) || e && t && "number" == typeof t.length) {
                    i && (t = i);
                    var r = 0
                      , o = function() {};
                    return {
                        s: o,
                        n: function() {
                            return r >= t.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: t[r++]
                            }
                        },
                        e: function(t) {
                            throw t
                        },
                        f: o
                    }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }
            var s, a = !0, l = !1;
            return {
                s: function() {
                    i = i.call(t)
                },
                n: function() {
                    var t = i.next();
                    return a = t.done,
                    t
                },
                e: function(t) {
                    l = !0,
                    s = t
                },
                f: function() {
                    try {
                        a || null == i.return || i.return()
                    } finally {
                        if (l)
                            throw s
                    }
                }
            }
        }
    },
    82482: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(68521);
        function r(t, e, i) {
            return (e = (0,
            n.Z)(e))in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i,
            t
        }
    },
    39299: function(t, e, i) {
        "use strict";
        function n() {
            return n = Object.assign ? Object.assign.bind() : function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var n in i)
                        ({}).hasOwnProperty.call(i, n) && (t[n] = i[n])
                }
                return t
            }
            ,
            n.apply(null, arguments)
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    72285: function(t, e, i) {
        "use strict";
        function n(t) {
            if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"])
                return Array.from(t)
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    16786: function(t, e, i) {
        "use strict";
        function n() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    22881: function(t, e, i) {
        "use strict";
        function n(t) {
            if (null == t)
                throw new TypeError("Cannot destructure " + t)
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    95082: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return o
            }
        });
        i(57658);
        var n = i(82482);
        function r(t, e) {
            var i = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                e && (n = n.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }
                ))),
                i.push.apply(i, n)
            }
            return i
        }
        function o(t) {
            for (var e = 1; e < arguments.length; e++) {
                var i = null != arguments[e] ? arguments[e] : {};
                e % 2 ? r(Object(i), !0).forEach((function(e) {
                    (0,
                    n.Z)(t, e, i[e])
                }
                )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : r(Object(i)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }
                ))
            }
            return t
        }
    },
    62078: function(t, e, i) {
        "use strict";
        function n(t, e) {
            if (null == t)
                return {};
            var i, n, r = function(t, e) {
                if (null == t)
                    return {};
                var i = {};
                for (var n in t)
                    if ({}.hasOwnProperty.call(t, n)) {
                        if (e.includes(n))
                            continue;
                        i[n] = t[n]
                    }
                return i
            }(t, e);
            if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                for (n = 0; n < o.length; n++)
                    i = o[n],
                    e.includes(i) || {}.propertyIsEnumerable.call(t, i) && (r[i] = t[i])
            }
            return r
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    54621: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return s
            }
        });
        var n = i(60778);
        i(57658);
        var r = i(12780)
          , o = i(16786);
        function s(t, e) {
            return (0,
            n.Z)(t) || function(t, e) {
                var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                if (null != i) {
                    var n, r, o, s, a = [], l = !0, c = !1;
                    try {
                        if (o = (i = i.call(t)).next,
                        0 === e) {
                            if (Object(i) !== i)
                                return;
                            l = !1
                        } else
                            for (; !(l = (n = o.call(i)).done) && (a.push(n.value),
                            a.length !== e); l = !0)
                                ;
                    } catch (t) {
                        c = !0,
                        r = t
                    } finally {
                        try {
                            if (!l && null != i.return && (s = i.return(),
                            Object(s) !== s))
                                return
                        } finally {
                            if (c)
                                throw r
                        }
                    }
                    return a
                }
            }(t, e) || (0,
            r.Z)(t, e) || (0,
            o.Z)()
        }
    },
    55167: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return a
            }
        });
        var n = i(60778)
          , r = i(72285)
          , o = i(12780)
          , s = i(16786);
        function a(t) {
            return (0,
            n.Z)(t) || (0,
            r.Z)(t) || (0,
            o.Z)(t) || (0,
            s.Z)()
        }
    },
    88478: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return s
            }
        });
        var n = i(49227);
        var r = i(72285)
          , o = i(12780);
        function s(t) {
            return function(t) {
                if (Array.isArray(t))
                    return (0,
                    n.Z)(t)
            }(t) || (0,
            r.Z)(t) || (0,
            o.Z)(t) || function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
        }
    },
    68521: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(3336);
        function r(t) {
            var e = function(t, e) {
                if ("object" != (0,
                n.Z)(t) || !t)
                    return t;
                var i = t[Symbol.toPrimitive];
                if (void 0 !== i) {
                    var r = i.call(t, e || "default");
                    if ("object" != (0,
                    n.Z)(r))
                        return r;
                    throw new TypeError("@@toPrimitive must return a primitive value.")
                }
                return ("string" === e ? String : Number)(t)
            }(t, "string");
            return "symbol" == (0,
            n.Z)(e) ? e : e + ""
        }
    },
    3336: function(t, e, i) {
        "use strict";
        function n(t) {
            return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            }
            : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }
            ,
            n(t)
        }
        i.d(e, {
            Z: function() {
                return n
            }
        })
    },
    12780: function(t, e, i) {
        "use strict";
        i.d(e, {
            Z: function() {
                return r
            }
        });
        var n = i(49227);
        function r(t, e) {
            if (t) {
                if ("string" == typeof t)
                    return (0,
                    n.Z)(t, e);
                var i = {}.toString.call(t).slice(8, -1);
                return "Object" === i && t.constructor && (i = t.constructor.name),
                "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? (0,
                n.Z)(t, e) : void 0
            }
        }
    }
}]);
